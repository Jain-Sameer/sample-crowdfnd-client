const __vite__mapDeps = (
  i,
  m = __vite__mapDeps,
  d = m.f ||
    (m.f = [
      "assets/edition-drop-24708d00.browser.esm-BALu-ei5.js",
      "assets/erc-1155-standard-c4641fc4.browser.esm-BxD1cako.js",
      "assets/thirdweb-checkout-49195812.browser.esm-DHd89nnb.js",
      "assets/edition-b3122b64.browser.esm-BsAXhO03.js",
      "assets/multiwrap-18fab528.browser.esm-CuLM__Iq.js",
      "assets/hasERC20Allowance-1499f181.browser.esm-DtQg24uO.js",
      "assets/erc-721-standard-c858f30e.browser.esm-D6uPbU5q.js",
      "assets/nft-collection-0cf43f4d.browser.esm-gNMFqgQJ.js",
      "assets/nft-drop-399edfe0.browser.esm-j1yx62mK.js",
      "assets/pack-bd61f578.browser.esm-BQH3tqr9.js",
      "assets/signature-drop-224b723c.browser.esm-D6WJ2a4H.js",
      "assets/token-drop-90cb00e6.browser.esm-DBXTQt3l.js",
      "assets/erc-20-standard-10861ed4.browser.esm-DnnjDnr4.js",
      "assets/token-1023bf9c.browser.esm-Bl5opv9y.js",
    ])
) => i.map((i) => d[i]);
var Oz = Object.defineProperty;
var AC = (t) => {
  throw TypeError(t);
};
var Fz = (t, e, r) =>
  e in t
    ? Oz(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r,
      })
    : (t[e] = r);
var oe = (t, e, r) => Fz(t, typeof e != "symbol" ? e + "" : e, r),
  kC = (t, e, r) => e.has(t) || AC("Cannot " + r);
var A1 = (t, e, r) => (
    kC(t, e, "read from private field"), r ? r.call(t) : e.get(t)
  ),
  k1 = (t, e, r) =>
    e.has(t)
      ? AC("Cannot add the same private member more than once")
      : e instanceof WeakSet
      ? e.add(t)
      : e.set(t, r),
  S1 = (t, e, r, n) => (
    kC(t, e, "write to private field"), n ? n.call(t, r) : e.set(t, r), r
  );
function Lz(t, e) {
  for (var r = 0; r < e.length; r++) {
    const n = e[r];
    if (typeof n != "string" && !Array.isArray(n)) {
      for (const i in n)
        if (i !== "default" && !(i in t)) {
          const a = Object.getOwnPropertyDescriptor(n, i);
          a &&
            Object.defineProperty(
              t,
              i,
              a.get
                ? a
                : {
                    enumerable: !0,
                    get: () => n[i],
                  }
            );
        }
    }
  }
  return Object.freeze(
    Object.defineProperty(t, Symbol.toStringTag, {
      value: "Module",
    })
  );
}
(function () {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const i of document.querySelectorAll('link[rel="modulepreload"]')) n(i);
  new MutationObserver((i) => {
    for (const a of i)
      if (a.type === "childList")
        for (const s of a.addedNodes)
          s.tagName === "LINK" && s.rel === "modulepreload" && n(s);
  }).observe(document, {
    childList: !0,
    subtree: !0,
  });
  function r(i) {
    const a = {};
    return (
      i.integrity && (a.integrity = i.integrity),
      i.referrerPolicy && (a.referrerPolicy = i.referrerPolicy),
      i.crossOrigin === "use-credentials"
        ? (a.credentials = "include")
        : i.crossOrigin === "anonymous"
        ? (a.credentials = "omit")
        : (a.credentials = "same-origin"),
      a
    );
  }
  function n(i) {
    if (i.ep) return;
    i.ep = !0;
    const a = r(i);
    fetch(i.href, a);
  }
})();
var ke =
  typeof globalThis < "u"
    ? globalThis
    : typeof window < "u"
    ? window
    : typeof global < "u"
    ? global
    : typeof self < "u"
    ? self
    : {};
function mn(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default")
    ? t.default
    : t;
}
function Pt(t) {
  if (t.__esModule) return t;
  var e = t.default;
  if (typeof e == "function") {
    var r = function n() {
      return this instanceof n
        ? Reflect.construct(e, arguments, this.constructor)
        : e.apply(this, arguments);
    };
    r.prototype = e.prototype;
  } else r = {};
  return (
    Object.defineProperty(r, "__esModule", {
      value: !0,
    }),
    Object.keys(t).forEach(function (n) {
      var i = Object.getOwnPropertyDescriptor(t, n);
      Object.defineProperty(
        r,
        n,
        i.get
          ? i
          : {
              enumerable: !0,
              get: function () {
                return t[n];
              },
            }
      );
    }),
    r
  );
}
var fR = {
    exports: {},
  },
  Ab = {},
  dR = {
    exports: {},
  },
  kt = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Tm = Symbol.for("react.element"),
  $z = Symbol.for("react.portal"),
  Uz = Symbol.for("react.fragment"),
  Wz = Symbol.for("react.strict_mode"),
  jz = Symbol.for("react.profiler"),
  Hz = Symbol.for("react.provider"),
  zz = Symbol.for("react.context"),
  qz = Symbol.for("react.forward_ref"),
  Vz = Symbol.for("react.suspense"),
  Kz = Symbol.for("react.memo"),
  Gz = Symbol.for("react.lazy"),
  SC = Symbol.iterator;
function Zz(t) {
  return t === null || typeof t != "object"
    ? null
    : ((t = (SC && t[SC]) || t["@@iterator"]),
      typeof t == "function" ? t : null);
}
var hR = {
    isMounted: function () {
      return !1;
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {},
  },
  pR = Object.assign,
  mR = {};
function ad(t, e, r) {
  (this.props = t),
    (this.context = e),
    (this.refs = mR),
    (this.updater = r || hR);
}
ad.prototype.isReactComponent = {};
ad.prototype.setState = function (t, e) {
  if (typeof t != "object" && typeof t != "function" && t != null)
    throw Error(
      "setState(...): takes an object of state variables to update or a function which returns an object of state variables."
    );
  this.updater.enqueueSetState(this, t, e, "setState");
};
ad.prototype.forceUpdate = function (t) {
  this.updater.enqueueForceUpdate(this, t, "forceUpdate");
};
function yR() {}
yR.prototype = ad.prototype;
function W4(t, e, r) {
  (this.props = t),
    (this.context = e),
    (this.refs = mR),
    (this.updater = r || hR);
}
var j4 = (W4.prototype = new yR());
j4.constructor = W4;
pR(j4, ad.prototype);
j4.isPureReactComponent = !0;
var MC = Array.isArray,
  gR = Object.prototype.hasOwnProperty,
  H4 = {
    current: null,
  },
  bR = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0,
  };
function vR(t, e, r) {
  var n,
    i = {},
    a = null,
    s = null;
  if (e != null)
    for (n in (e.ref !== void 0 && (s = e.ref),
    e.key !== void 0 && (a = "" + e.key),
    e))
      gR.call(e, n) && !bR.hasOwnProperty(n) && (i[n] = e[n]);
  var o = arguments.length - 2;
  if (o === 1) i.children = r;
  else if (1 < o) {
    for (var c = Array(o), u = 0; u < o; u++) c[u] = arguments[u + 2];
    i.children = c;
  }
  if (t && t.defaultProps)
    for (n in ((o = t.defaultProps), o)) i[n] === void 0 && (i[n] = o[n]);
  return {
    $$typeof: Tm,
    type: t,
    key: a,
    ref: s,
    props: i,
    _owner: H4.current,
  };
}
function Jz(t, e) {
  return {
    $$typeof: Tm,
    type: t.type,
    key: e,
    ref: t.ref,
    props: t.props,
    _owner: t._owner,
  };
}
function z4(t) {
  return typeof t == "object" && t !== null && t.$$typeof === Tm;
}
function Qz(t) {
  var e = {
    "=": "=0",
    ":": "=2",
  };
  return (
    "$" +
    t.replace(/[=:]/g, function (r) {
      return e[r];
    })
  );
}
var IC = /\/+/g;
function uw(t, e) {
  return typeof t == "object" && t !== null && t.key != null
    ? Qz("" + t.key)
    : e.toString(36);
}
function Ry(t, e, r, n, i) {
  var a = typeof t;
  (a === "undefined" || a === "boolean") && (t = null);
  var s = !1;
  if (t === null) s = !0;
  else
    switch (a) {
      case "string":
      case "number":
        s = !0;
        break;
      case "object":
        switch (t.$$typeof) {
          case Tm:
          case $z:
            s = !0;
        }
    }
  if (s)
    return (
      (s = t),
      (i = i(s)),
      (t = n === "" ? "." + uw(s, 0) : n),
      MC(i)
        ? ((r = ""),
          t != null && (r = t.replace(IC, "$&/") + "/"),
          Ry(i, e, r, "", function (u) {
            return u;
          }))
        : i != null &&
          (z4(i) &&
            (i = Jz(
              i,
              r +
                (!i.key || (s && s.key === i.key)
                  ? ""
                  : ("" + i.key).replace(IC, "$&/") + "/") +
                t
            )),
          e.push(i)),
      1
    );
  if (((s = 0), (n = n === "" ? "." : n + ":"), MC(t)))
    for (var o = 0; o < t.length; o++) {
      a = t[o];
      var c = n + uw(a, o);
      s += Ry(a, e, r, c, i);
    }
  else if (((c = Zz(t)), typeof c == "function"))
    for (t = c.call(t), o = 0; !(a = t.next()).done; )
      (a = a.value), (c = n + uw(a, o++)), (s += Ry(a, e, r, c, i));
  else if (a === "object")
    throw (
      ((e = String(t)),
      Error(
        "Objects are not valid as a React child (found: " +
          (e === "[object Object]"
            ? "object with keys {" + Object.keys(t).join(", ") + "}"
            : e) +
          "). If you meant to render a collection of children, use an array instead."
      ))
    );
  return s;
}
function M1(t, e, r) {
  if (t == null) return t;
  var n = [],
    i = 0;
  return (
    Ry(t, n, "", "", function (a) {
      return e.call(r, a, i++);
    }),
    n
  );
}
function Yz(t) {
  if (t._status === -1) {
    var e = t._result;
    (e = e()),
      e.then(
        function (r) {
          (t._status === 0 || t._status === -1) &&
            ((t._status = 1), (t._result = r));
        },
        function (r) {
          (t._status === 0 || t._status === -1) &&
            ((t._status = 2), (t._result = r));
        }
      ),
      t._status === -1 && ((t._status = 0), (t._result = e));
  }
  if (t._status === 1) return t._result.default;
  throw t._result;
}
var Mi = {
    current: null,
  },
  Py = {
    transition: null,
  },
  Xz = {
    ReactCurrentDispatcher: Mi,
    ReactCurrentBatchConfig: Py,
    ReactCurrentOwner: H4,
  };
function xR() {
  throw Error("act(...) is not supported in production builds of React.");
}
kt.Children = {
  map: M1,
  forEach: function (t, e, r) {
    M1(
      t,
      function () {
        e.apply(this, arguments);
      },
      r
    );
  },
  count: function (t) {
    var e = 0;
    return (
      M1(t, function () {
        e++;
      }),
      e
    );
  },
  toArray: function (t) {
    return (
      M1(t, function (e) {
        return e;
      }) || []
    );
  },
  only: function (t) {
    if (!z4(t))
      throw Error(
        "React.Children.only expected to receive a single React element child."
      );
    return t;
  },
};
kt.Component = ad;
kt.Fragment = Uz;
kt.Profiler = jz;
kt.PureComponent = W4;
kt.StrictMode = Wz;
kt.Suspense = Vz;
kt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Xz;
kt.act = xR;
kt.cloneElement = function (t, e, r) {
  if (t == null)
    throw Error(
      "React.cloneElement(...): The argument must be a React element, but you passed " +
        t +
        "."
    );
  var n = pR({}, t.props),
    i = t.key,
    a = t.ref,
    s = t._owner;
  if (e != null) {
    if (
      (e.ref !== void 0 && ((a = e.ref), (s = H4.current)),
      e.key !== void 0 && (i = "" + e.key),
      t.type && t.type.defaultProps)
    )
      var o = t.type.defaultProps;
    for (c in e)
      gR.call(e, c) &&
        !bR.hasOwnProperty(c) &&
        (n[c] = e[c] === void 0 && o !== void 0 ? o[c] : e[c]);
  }
  var c = arguments.length - 2;
  if (c === 1) n.children = r;
  else if (1 < c) {
    o = Array(c);
    for (var u = 0; u < c; u++) o[u] = arguments[u + 2];
    n.children = o;
  }
  return {
    $$typeof: Tm,
    type: t.type,
    key: i,
    ref: a,
    props: n,
    _owner: s,
  };
};
kt.createContext = function (t) {
  return (
    (t = {
      $$typeof: zz,
      _currentValue: t,
      _currentValue2: t,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null,
    }),
    (t.Provider = {
      $$typeof: Hz,
      _context: t,
    }),
    (t.Consumer = t)
  );
};
kt.createElement = vR;
kt.createFactory = function (t) {
  var e = vR.bind(null, t);
  return (e.type = t), e;
};
kt.createRef = function () {
  return {
    current: null,
  };
};
kt.forwardRef = function (t) {
  return {
    $$typeof: qz,
    render: t,
  };
};
kt.isValidElement = z4;
kt.lazy = function (t) {
  return {
    $$typeof: Gz,
    _payload: {
      _status: -1,
      _result: t,
    },
    _init: Yz,
  };
};
kt.memo = function (t, e) {
  return {
    $$typeof: Kz,
    type: t,
    compare: e === void 0 ? null : e,
  };
};
kt.startTransition = function (t) {
  var e = Py.transition;
  Py.transition = {};
  try {
    t();
  } finally {
    Py.transition = e;
  }
};
kt.unstable_act = xR;
kt.useCallback = function (t, e) {
  return Mi.current.useCallback(t, e);
};
kt.useContext = function (t) {
  return Mi.current.useContext(t);
};
kt.useDebugValue = function () {};
kt.useDeferredValue = function (t) {
  return Mi.current.useDeferredValue(t);
};
kt.useEffect = function (t, e) {
  return Mi.current.useEffect(t, e);
};
kt.useId = function () {
  return Mi.current.useId();
};
kt.useImperativeHandle = function (t, e, r) {
  return Mi.current.useImperativeHandle(t, e, r);
};
kt.useInsertionEffect = function (t, e) {
  return Mi.current.useInsertionEffect(t, e);
};
kt.useLayoutEffect = function (t, e) {
  return Mi.current.useLayoutEffect(t, e);
};
kt.useMemo = function (t, e) {
  return Mi.current.useMemo(t, e);
};
kt.useReducer = function (t, e, r) {
  return Mi.current.useReducer(t, e, r);
};
kt.useRef = function (t) {
  return Mi.current.useRef(t);
};
kt.useState = function (t) {
  return Mi.current.useState(t);
};
kt.useSyncExternalStore = function (t, e, r) {
  return Mi.current.useSyncExternalStore(t, e, r);
};
kt.useTransition = function () {
  return Mi.current.useTransition();
};
kt.version = "18.3.1";
dR.exports = kt;
var ye = dR.exports;
const ku = mn(ye),
  J5 = Lz(
    {
      __proto__: null,
      default: ku,
    },
    [ye]
  );
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var eq = ye,
  tq = Symbol.for("react.element"),
  rq = Symbol.for("react.fragment"),
  nq = Object.prototype.hasOwnProperty,
  iq = eq.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
  aq = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0,
  };
function wR(t, e, r) {
  var n,
    i = {},
    a = null,
    s = null;
  r !== void 0 && (a = "" + r),
    e.key !== void 0 && (a = "" + e.key),
    e.ref !== void 0 && (s = e.ref);
  for (n in e) nq.call(e, n) && !aq.hasOwnProperty(n) && (i[n] = e[n]);
  if (t && t.defaultProps)
    for (n in ((e = t.defaultProps), e)) i[n] === void 0 && (i[n] = e[n]);
  return {
    $$typeof: tq,
    type: t,
    key: a,
    ref: s,
    props: i,
    _owner: iq.current,
  };
}
Ab.Fragment = rq;
Ab.jsx = wR;
Ab.jsxs = wR;
fR.exports = Ab;
var de = fR.exports,
  _R = {
    exports: {},
  },
  ga = {},
  ER = {
    exports: {},
  },
  TR = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function (t) {
  function e(x, f) {
    var _ = x.length;
    x.push(f);
    e: for (; 0 < _; ) {
      var P = (_ - 1) >>> 1,
        M = x[P];
      if (0 < i(M, f)) (x[P] = f), (x[_] = M), (_ = P);
      else break e;
    }
  }
  function r(x) {
    return x.length === 0 ? null : x[0];
  }
  function n(x) {
    if (x.length === 0) return null;
    var f = x[0],
      _ = x.pop();
    if (_ !== f) {
      x[0] = _;
      e: for (var P = 0, M = x.length, D = M >>> 1; P < D; ) {
        var q = 2 * (P + 1) - 1,
          B = x[q],
          H = q + 1,
          Q = x[H];
        if (0 > i(B, _))
          H < M && 0 > i(Q, B)
            ? ((x[P] = Q), (x[H] = _), (P = H))
            : ((x[P] = B), (x[q] = _), (P = q));
        else if (H < M && 0 > i(Q, _)) (x[P] = Q), (x[H] = _), (P = H);
        else break e;
      }
    }
    return f;
  }
  function i(x, f) {
    var _ = x.sortIndex - f.sortIndex;
    return _ !== 0 ? _ : x.id - f.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var a = performance;
    t.unstable_now = function () {
      return a.now();
    };
  } else {
    var s = Date,
      o = s.now();
    t.unstable_now = function () {
      return s.now() - o;
    };
  }
  var c = [],
    u = [],
    d = 1,
    m = null,
    v = 3,
    E = !1,
    A = !1,
    I = !1,
    b = typeof setTimeout == "function" ? setTimeout : null,
    w = typeof clearTimeout == "function" ? clearTimeout : null,
    S = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function k(x) {
    for (var f = r(u); f !== null; ) {
      if (f.callback === null) n(u);
      else if (f.startTime <= x)
        n(u), (f.sortIndex = f.expirationTime), e(c, f);
      else break;
      f = r(u);
    }
  }
  function N(x) {
    if (((I = !1), k(x), !A))
      if (r(c) !== null) (A = !0), T(O);
      else {
        var f = r(u);
        f !== null && R(N, f.startTime - x);
      }
  }
  function O(x, f) {
    (A = !1), I && ((I = !1), w(j), (j = -1)), (E = !0);
    var _ = v;
    try {
      for (
        k(f), m = r(c);
        m !== null && (!(m.expirationTime > f) || (x && !l()));

      ) {
        var P = m.callback;
        if (typeof P == "function") {
          (m.callback = null), (v = m.priorityLevel);
          var M = P(m.expirationTime <= f);
          (f = t.unstable_now()),
            typeof M == "function" ? (m.callback = M) : m === r(c) && n(c),
            k(f);
        } else n(c);
        m = r(c);
      }
      if (m !== null) var D = !0;
      else {
        var q = r(u);
        q !== null && R(N, q.startTime - f), (D = !1);
      }
      return D;
    } finally {
      (m = null), (v = _), (E = !1);
    }
  }
  var F = !1,
    V = null,
    j = -1,
    X = 5,
    C = -1;
  function l() {
    return !(t.unstable_now() - C < X);
  }
  function p() {
    if (V !== null) {
      var x = t.unstable_now();
      C = x;
      var f = !0;
      try {
        f = V(!0, x);
      } finally {
        f ? y() : ((F = !1), (V = null));
      }
    } else F = !1;
  }
  var y;
  if (typeof S == "function")
    y = function () {
      S(p);
    };
  else if (typeof MessageChannel < "u") {
    var h = new MessageChannel(),
      g = h.port2;
    (h.port1.onmessage = p),
      (y = function () {
        g.postMessage(null);
      });
  } else
    y = function () {
      b(p, 0);
    };
  function T(x) {
    (V = x), F || ((F = !0), y());
  }
  function R(x, f) {
    j = b(function () {
      x(t.unstable_now());
    }, f);
  }
  (t.unstable_IdlePriority = 5),
    (t.unstable_ImmediatePriority = 1),
    (t.unstable_LowPriority = 4),
    (t.unstable_NormalPriority = 3),
    (t.unstable_Profiling = null),
    (t.unstable_UserBlockingPriority = 2),
    (t.unstable_cancelCallback = function (x) {
      x.callback = null;
    }),
    (t.unstable_continueExecution = function () {
      A || E || ((A = !0), T(O));
    }),
    (t.unstable_forceFrameRate = function (x) {
      0 > x || 125 < x
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (X = 0 < x ? Math.floor(1e3 / x) : 5);
    }),
    (t.unstable_getCurrentPriorityLevel = function () {
      return v;
    }),
    (t.unstable_getFirstCallbackNode = function () {
      return r(c);
    }),
    (t.unstable_next = function (x) {
      switch (v) {
        case 1:
        case 2:
        case 3:
          var f = 3;
          break;
        default:
          f = v;
      }
      var _ = v;
      v = f;
      try {
        return x();
      } finally {
        v = _;
      }
    }),
    (t.unstable_pauseExecution = function () {}),
    (t.unstable_requestPaint = function () {}),
    (t.unstable_runWithPriority = function (x, f) {
      switch (x) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          x = 3;
      }
      var _ = v;
      v = x;
      try {
        return f();
      } finally {
        v = _;
      }
    }),
    (t.unstable_scheduleCallback = function (x, f, _) {
      var P = t.unstable_now();
      switch (
        (typeof _ == "object" && _ !== null
          ? ((_ = _.delay), (_ = typeof _ == "number" && 0 < _ ? P + _ : P))
          : (_ = P),
        x)
      ) {
        case 1:
          var M = -1;
          break;
        case 2:
          M = 250;
          break;
        case 5:
          M = 1073741823;
          break;
        case 4:
          M = 1e4;
          break;
        default:
          M = 5e3;
      }
      return (
        (M = _ + M),
        (x = {
          id: d++,
          callback: f,
          priorityLevel: x,
          startTime: _,
          expirationTime: M,
          sortIndex: -1,
        }),
        _ > P
          ? ((x.sortIndex = _),
            e(u, x),
            r(c) === null &&
              x === r(u) &&
              (I ? (w(j), (j = -1)) : (I = !0), R(N, _ - P)))
          : ((x.sortIndex = M), e(c, x), A || E || ((A = !0), T(O))),
        x
      );
    }),
    (t.unstable_shouldYield = l),
    (t.unstable_wrapCallback = function (x) {
      var f = v;
      return function () {
        var _ = v;
        v = f;
        try {
          return x.apply(this, arguments);
        } finally {
          v = _;
        }
      };
    });
})(TR);
ER.exports = TR;
var sq = ER.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var oq = ye,
  ma = sq;
function Ge(t) {
  for (
    var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, r = 1;
    r < arguments.length;
    r++
  )
    e += "&args[]=" + encodeURIComponent(arguments[r]);
  return (
    "Minified React error #" +
    t +
    "; visit " +
    e +
    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
  );
}
var CR = new Set(),
  ep = {};
function Su(t, e) {
  lf(t, e), lf(t + "Capture", e);
}
function lf(t, e) {
  for (ep[t] = e, t = 0; t < e.length; t++) CR.add(e[t]);
}
var jo = !(
    typeof window > "u" ||
    typeof window.document > "u" ||
    typeof window.document.createElement > "u"
  ),
  Q5 = Object.prototype.hasOwnProperty,
  cq =
    /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
  RC = {},
  PC = {};
function lq(t) {
  return Q5.call(PC, t)
    ? !0
    : Q5.call(RC, t)
    ? !1
    : cq.test(t)
    ? (PC[t] = !0)
    : ((RC[t] = !0), !1);
}
function uq(t, e, r, n) {
  if (r !== null && r.type === 0) return !1;
  switch (typeof e) {
    case "function":
    case "symbol":
      return !0;
    case "boolean":
      return n
        ? !1
        : r !== null
        ? !r.acceptsBooleans
        : ((t = t.toLowerCase().slice(0, 5)), t !== "data-" && t !== "aria-");
    default:
      return !1;
  }
}
function fq(t, e, r, n) {
  if (e === null || typeof e > "u" || uq(t, e, r, n)) return !0;
  if (n) return !1;
  if (r !== null)
    switch (r.type) {
      case 3:
        return !e;
      case 4:
        return e === !1;
      case 5:
        return isNaN(e);
      case 6:
        return isNaN(e) || 1 > e;
    }
  return !1;
}
function Ii(t, e, r, n, i, a, s) {
  (this.acceptsBooleans = e === 2 || e === 3 || e === 4),
    (this.attributeName = n),
    (this.attributeNamespace = i),
    (this.mustUseProperty = r),
    (this.propertyName = t),
    (this.type = e),
    (this.sanitizeURL = a),
    (this.removeEmptyString = s);
}
var Zn = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
  .split(" ")
  .forEach(function (t) {
    Zn[t] = new Ii(t, 0, !1, t, null, !1, !1);
  });
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"],
].forEach(function (t) {
  var e = t[0];
  Zn[e] = new Ii(e, 1, !1, t[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function (t) {
  Zn[t] = new Ii(t, 2, !1, t.toLowerCase(), null, !1, !1);
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha",
].forEach(function (t) {
  Zn[t] = new Ii(t, 2, !1, t, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
  .split(" ")
  .forEach(function (t) {
    Zn[t] = new Ii(t, 3, !1, t.toLowerCase(), null, !1, !1);
  });
["checked", "multiple", "muted", "selected"].forEach(function (t) {
  Zn[t] = new Ii(t, 3, !0, t, null, !1, !1);
});
["capture", "download"].forEach(function (t) {
  Zn[t] = new Ii(t, 4, !1, t, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function (t) {
  Zn[t] = new Ii(t, 6, !1, t, null, !1, !1);
});
["rowSpan", "start"].forEach(function (t) {
  Zn[t] = new Ii(t, 5, !1, t.toLowerCase(), null, !1, !1);
});
var q4 = /[\-:]([a-z])/g;
function V4(t) {
  return t[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
  .split(" ")
  .forEach(function (t) {
    var e = t.replace(q4, V4);
    Zn[e] = new Ii(e, 1, !1, t, null, !1, !1);
  });
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
  .split(" ")
  .forEach(function (t) {
    var e = t.replace(q4, V4);
    Zn[e] = new Ii(e, 1, !1, t, "http://www.w3.org/1999/xlink", !1, !1);
  });
["xml:base", "xml:lang", "xml:space"].forEach(function (t) {
  var e = t.replace(q4, V4);
  Zn[e] = new Ii(e, 1, !1, t, "http://www.w3.org/XML/1998/namespace", !1, !1);
});
["tabIndex", "crossOrigin"].forEach(function (t) {
  Zn[t] = new Ii(t, 1, !1, t.toLowerCase(), null, !1, !1);
});
Zn.xlinkHref = new Ii(
  "xlinkHref",
  1,
  !1,
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  !1
);
["src", "href", "action", "formAction"].forEach(function (t) {
  Zn[t] = new Ii(t, 1, !1, t.toLowerCase(), null, !0, !0);
});
function K4(t, e, r, n) {
  var i = Zn.hasOwnProperty(e) ? Zn[e] : null;
  (i !== null
    ? i.type !== 0
    : n ||
      !(2 < e.length) ||
      (e[0] !== "o" && e[0] !== "O") ||
      (e[1] !== "n" && e[1] !== "N")) &&
    (fq(e, r, i, n) && (r = null),
    n || i === null
      ? lq(e) && (r === null ? t.removeAttribute(e) : t.setAttribute(e, "" + r))
      : i.mustUseProperty
      ? (t[i.propertyName] = r === null ? (i.type === 3 ? !1 : "") : r)
      : ((e = i.attributeName),
        (n = i.attributeNamespace),
        r === null
          ? t.removeAttribute(e)
          : ((i = i.type),
            (r = i === 3 || (i === 4 && r === !0) ? "" : "" + r),
            n ? t.setAttributeNS(n, e, r) : t.setAttribute(e, r))));
}
var Xo = oq.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  I1 = Symbol.for("react.element"),
  b0 = Symbol.for("react.portal"),
  v0 = Symbol.for("react.fragment"),
  G4 = Symbol.for("react.strict_mode"),
  Y5 = Symbol.for("react.profiler"),
  AR = Symbol.for("react.provider"),
  kR = Symbol.for("react.context"),
  Z4 = Symbol.for("react.forward_ref"),
  X5 = Symbol.for("react.suspense"),
  e6 = Symbol.for("react.suspense_list"),
  J4 = Symbol.for("react.memo"),
  dc = Symbol.for("react.lazy"),
  SR = Symbol.for("react.offscreen"),
  NC = Symbol.iterator;
function Ud(t) {
  return t === null || typeof t != "object"
    ? null
    : ((t = (NC && t[NC]) || t["@@iterator"]),
      typeof t == "function" ? t : null);
}
var Jr = Object.assign,
  fw;
function dh(t) {
  if (fw === void 0)
    try {
      throw Error();
    } catch (r) {
      var e = r.stack.trim().match(/\n( *(at )?)/);
      fw = (e && e[1]) || "";
    }
  return (
    `
` +
    fw +
    t
  );
}
var dw = !1;
function hw(t, e) {
  if (!t || dw) return "";
  dw = !0;
  var r = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (e)
      if (
        ((e = function () {
          throw Error();
        }),
        Object.defineProperty(e.prototype, "props", {
          set: function () {
            throw Error();
          },
        }),
        typeof Reflect == "object" && Reflect.construct)
      ) {
        try {
          Reflect.construct(e, []);
        } catch (u) {
          var n = u;
        }
        Reflect.construct(t, [], e);
      } else {
        try {
          e.call();
        } catch (u) {
          n = u;
        }
        t.call(e.prototype);
      }
    else {
      try {
        throw Error();
      } catch (u) {
        n = u;
      }
      t();
    }
  } catch (u) {
    if (u && n && typeof u.stack == "string") {
      for (
        var i = u.stack.split(`
`),
          a = n.stack.split(`
`),
          s = i.length - 1,
          o = a.length - 1;
        1 <= s && 0 <= o && i[s] !== a[o];

      )
        o--;
      for (; 1 <= s && 0 <= o; s--, o--)
        if (i[s] !== a[o]) {
          if (s !== 1 || o !== 1)
            do
              if ((s--, o--, 0 > o || i[s] !== a[o])) {
                var c =
                  `
` + i[s].replace(" at new ", " at ");
                return (
                  t.displayName &&
                    c.includes("<anonymous>") &&
                    (c = c.replace("<anonymous>", t.displayName)),
                  c
                );
              }
            while (1 <= s && 0 <= o);
          break;
        }
    }
  } finally {
    (dw = !1), (Error.prepareStackTrace = r);
  }
  return (t = t ? t.displayName || t.name : "") ? dh(t) : "";
}
function dq(t) {
  switch (t.tag) {
    case 5:
      return dh(t.type);
    case 16:
      return dh("Lazy");
    case 13:
      return dh("Suspense");
    case 19:
      return dh("SuspenseList");
    case 0:
    case 2:
    case 15:
      return (t = hw(t.type, !1)), t;
    case 11:
      return (t = hw(t.type.render, !1)), t;
    case 1:
      return (t = hw(t.type, !0)), t;
    default:
      return "";
  }
}
function t6(t) {
  if (t == null) return null;
  if (typeof t == "function") return t.displayName || t.name || null;
  if (typeof t == "string") return t;
  switch (t) {
    case v0:
      return "Fragment";
    case b0:
      return "Portal";
    case Y5:
      return "Profiler";
    case G4:
      return "StrictMode";
    case X5:
      return "Suspense";
    case e6:
      return "SuspenseList";
  }
  if (typeof t == "object")
    switch (t.$$typeof) {
      case kR:
        return (t.displayName || "Context") + ".Consumer";
      case AR:
        return (t._context.displayName || "Context") + ".Provider";
      case Z4:
        var e = t.render;
        return (
          (t = t.displayName),
          t ||
            ((t = e.displayName || e.name || ""),
            (t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef")),
          t
        );
      case J4:
        return (
          (e = t.displayName || null), e !== null ? e : t6(t.type) || "Memo"
        );
      case dc:
        (e = t._payload), (t = t._init);
        try {
          return t6(t(e));
        } catch {}
    }
  return null;
}
function hq(t) {
  var e = t.type;
  switch (t.tag) {
    case 24:
      return "Cache";
    case 9:
      return (e.displayName || "Context") + ".Consumer";
    case 10:
      return (e._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return (
        (t = e.render),
        (t = t.displayName || t.name || ""),
        e.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef")
      );
    case 7:
      return "Fragment";
    case 5:
      return e;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return t6(e);
    case 8:
      return e === G4 ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof e == "function") return e.displayName || e.name || null;
      if (typeof e == "string") return e;
  }
  return null;
}
function Gc(t) {
  switch (typeof t) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return t;
    case "object":
      return t;
    default:
      return "";
  }
}
function MR(t) {
  var e = t.type;
  return (
    (t = t.nodeName) &&
    t.toLowerCase() === "input" &&
    (e === "checkbox" || e === "radio")
  );
}
function pq(t) {
  var e = MR(t) ? "checked" : "value",
    r = Object.getOwnPropertyDescriptor(t.constructor.prototype, e),
    n = "" + t[e];
  if (
    !t.hasOwnProperty(e) &&
    typeof r < "u" &&
    typeof r.get == "function" &&
    typeof r.set == "function"
  ) {
    var i = r.get,
      a = r.set;
    return (
      Object.defineProperty(t, e, {
        configurable: !0,
        get: function () {
          return i.call(this);
        },
        set: function (s) {
          (n = "" + s), a.call(this, s);
        },
      }),
      Object.defineProperty(t, e, {
        enumerable: r.enumerable,
      }),
      {
        getValue: function () {
          return n;
        },
        setValue: function (s) {
          n = "" + s;
        },
        stopTracking: function () {
          (t._valueTracker = null), delete t[e];
        },
      }
    );
  }
}
function R1(t) {
  t._valueTracker || (t._valueTracker = pq(t));
}
function IR(t) {
  if (!t) return !1;
  var e = t._valueTracker;
  if (!e) return !0;
  var r = e.getValue(),
    n = "";
  return (
    t && (n = MR(t) ? (t.checked ? "true" : "false") : t.value),
    (t = n),
    t !== r ? (e.setValue(t), !0) : !1
  );
}
function cg(t) {
  if (((t = t || (typeof document < "u" ? document : void 0)), typeof t > "u"))
    return null;
  try {
    return t.activeElement || t.body;
  } catch {
    return t.body;
  }
}
function r6(t, e) {
  var r = e.checked;
  return Jr({}, e, {
    defaultChecked: void 0,
    defaultValue: void 0,
    value: void 0,
    checked: r ?? t._wrapperState.initialChecked,
  });
}
function BC(t, e) {
  var r = e.defaultValue == null ? "" : e.defaultValue,
    n = e.checked != null ? e.checked : e.defaultChecked;
  (r = Gc(e.value != null ? e.value : r)),
    (t._wrapperState = {
      initialChecked: n,
      initialValue: r,
      controlled:
        e.type === "checkbox" || e.type === "radio"
          ? e.checked != null
          : e.value != null,
    });
}
function RR(t, e) {
  (e = e.checked), e != null && K4(t, "checked", e, !1);
}
function n6(t, e) {
  RR(t, e);
  var r = Gc(e.value),
    n = e.type;
  if (r != null)
    n === "number"
      ? ((r === 0 && t.value === "") || t.value != r) && (t.value = "" + r)
      : t.value !== "" + r && (t.value = "" + r);
  else if (n === "submit" || n === "reset") {
    t.removeAttribute("value");
    return;
  }
  e.hasOwnProperty("value")
    ? i6(t, e.type, r)
    : e.hasOwnProperty("defaultValue") && i6(t, e.type, Gc(e.defaultValue)),
    e.checked == null &&
      e.defaultChecked != null &&
      (t.defaultChecked = !!e.defaultChecked);
}
function DC(t, e, r) {
  if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
    var n = e.type;
    if (
      !(
        (n !== "submit" && n !== "reset") ||
        (e.value !== void 0 && e.value !== null)
      )
    )
      return;
    (e = "" + t._wrapperState.initialValue),
      r || e === t.value || (t.value = e),
      (t.defaultValue = e);
  }
  (r = t.name),
    r !== "" && (t.name = ""),
    (t.defaultChecked = !!t._wrapperState.initialChecked),
    r !== "" && (t.name = r);
}
function i6(t, e, r) {
  (e !== "number" || cg(t.ownerDocument) !== t) &&
    (r == null
      ? (t.defaultValue = "" + t._wrapperState.initialValue)
      : t.defaultValue !== "" + r && (t.defaultValue = "" + r));
}
var hh = Array.isArray;
function $0(t, e, r, n) {
  if (((t = t.options), e)) {
    e = {};
    for (var i = 0; i < r.length; i++) e["$" + r[i]] = !0;
    for (r = 0; r < t.length; r++)
      (i = e.hasOwnProperty("$" + t[r].value)),
        t[r].selected !== i && (t[r].selected = i),
        i && n && (t[r].defaultSelected = !0);
  } else {
    for (r = "" + Gc(r), e = null, i = 0; i < t.length; i++) {
      if (t[i].value === r) {
        (t[i].selected = !0), n && (t[i].defaultSelected = !0);
        return;
      }
      e !== null || t[i].disabled || (e = t[i]);
    }
    e !== null && (e.selected = !0);
  }
}
function a6(t, e) {
  if (e.dangerouslySetInnerHTML != null) throw Error(Ge(91));
  return Jr({}, e, {
    value: void 0,
    defaultValue: void 0,
    children: "" + t._wrapperState.initialValue,
  });
}
function OC(t, e) {
  var r = e.value;
  if (r == null) {
    if (((r = e.children), (e = e.defaultValue), r != null)) {
      if (e != null) throw Error(Ge(92));
      if (hh(r)) {
        if (1 < r.length) throw Error(Ge(93));
        r = r[0];
      }
      e = r;
    }
    e == null && (e = ""), (r = e);
  }
  t._wrapperState = {
    initialValue: Gc(r),
  };
}
function PR(t, e) {
  var r = Gc(e.value),
    n = Gc(e.defaultValue);
  r != null &&
    ((r = "" + r),
    r !== t.value && (t.value = r),
    e.defaultValue == null && t.defaultValue !== r && (t.defaultValue = r)),
    n != null && (t.defaultValue = "" + n);
}
function FC(t) {
  var e = t.textContent;
  e === t._wrapperState.initialValue && e !== "" && e !== null && (t.value = e);
}
function NR(t) {
  switch (t) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function s6(t, e) {
  return t == null || t === "http://www.w3.org/1999/xhtml"
    ? NR(e)
    : t === "http://www.w3.org/2000/svg" && e === "foreignObject"
    ? "http://www.w3.org/1999/xhtml"
    : t;
}
var P1,
  BR = (function (t) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction
      ? function (e, r, n, i) {
          MSApp.execUnsafeLocalFunction(function () {
            return t(e, r, n, i);
          });
        }
      : t;
  })(function (t, e) {
    if (t.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in t)
      t.innerHTML = e;
    else {
      for (
        P1 = P1 || document.createElement("div"),
          P1.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>",
          e = P1.firstChild;
        t.firstChild;

      )
        t.removeChild(t.firstChild);
      for (; e.firstChild; ) t.appendChild(e.firstChild);
    }
  });
function tp(t, e) {
  if (e) {
    var r = t.firstChild;
    if (r && r === t.lastChild && r.nodeType === 3) {
      r.nodeValue = e;
      return;
    }
  }
  t.textContent = e;
}
var Ah = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0,
  },
  mq = ["Webkit", "ms", "Moz", "O"];
Object.keys(Ah).forEach(function (t) {
  mq.forEach(function (e) {
    (e = e + t.charAt(0).toUpperCase() + t.substring(1)), (Ah[e] = Ah[t]);
  });
});
function DR(t, e, r) {
  return e == null || typeof e == "boolean" || e === ""
    ? ""
    : r || typeof e != "number" || e === 0 || (Ah.hasOwnProperty(t) && Ah[t])
    ? ("" + e).trim()
    : e + "px";
}
function OR(t, e) {
  t = t.style;
  for (var r in e)
    if (e.hasOwnProperty(r)) {
      var n = r.indexOf("--") === 0,
        i = DR(r, e[r], n);
      r === "float" && (r = "cssFloat"), n ? t.setProperty(r, i) : (t[r] = i);
    }
}
var yq = Jr(
  {
    menuitem: !0,
  },
  {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0,
  }
);
function o6(t, e) {
  if (e) {
    if (yq[t] && (e.children != null || e.dangerouslySetInnerHTML != null))
      throw Error(Ge(137, t));
    if (e.dangerouslySetInnerHTML != null) {
      if (e.children != null) throw Error(Ge(60));
      if (
        typeof e.dangerouslySetInnerHTML != "object" ||
        !("__html" in e.dangerouslySetInnerHTML)
      )
        throw Error(Ge(61));
    }
    if (e.style != null && typeof e.style != "object") throw Error(Ge(62));
  }
}
function c6(t, e) {
  if (t.indexOf("-") === -1) return typeof e.is == "string";
  switch (t) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var l6 = null;
function Q4(t) {
  return (
    (t = t.target || t.srcElement || window),
    t.correspondingUseElement && (t = t.correspondingUseElement),
    t.nodeType === 3 ? t.parentNode : t
  );
}
var u6 = null,
  U0 = null,
  W0 = null;
function LC(t) {
  if ((t = km(t))) {
    if (typeof u6 != "function") throw Error(Ge(280));
    var e = t.stateNode;
    e && ((e = Rb(e)), u6(t.stateNode, t.type, e));
  }
}
function FR(t) {
  U0 ? (W0 ? W0.push(t) : (W0 = [t])) : (U0 = t);
}
function LR() {
  if (U0) {
    var t = U0,
      e = W0;
    if (((W0 = U0 = null), LC(t), e)) for (t = 0; t < e.length; t++) LC(e[t]);
  }
}
function $R(t, e) {
  return t(e);
}
function UR() {}
var pw = !1;
function WR(t, e, r) {
  if (pw) return t(e, r);
  pw = !0;
  try {
    return $R(t, e, r);
  } finally {
    (pw = !1), (U0 !== null || W0 !== null) && (UR(), LR());
  }
}
function rp(t, e) {
  var r = t.stateNode;
  if (r === null) return null;
  var n = Rb(r);
  if (n === null) return null;
  r = n[e];
  e: switch (e) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (n = !n.disabled) ||
        ((t = t.type),
        (n = !(
          t === "button" ||
          t === "input" ||
          t === "select" ||
          t === "textarea"
        ))),
        (t = !n);
      break e;
    default:
      t = !1;
  }
  if (t) return null;
  if (r && typeof r != "function") throw Error(Ge(231, e, typeof r));
  return r;
}
var f6 = !1;
if (jo)
  try {
    var Wd = {};
    Object.defineProperty(Wd, "passive", {
      get: function () {
        f6 = !0;
      },
    }),
      window.addEventListener("test", Wd, Wd),
      window.removeEventListener("test", Wd, Wd);
  } catch {
    f6 = !1;
  }
function gq(t, e, r, n, i, a, s, o, c) {
  var u = Array.prototype.slice.call(arguments, 3);
  try {
    e.apply(r, u);
  } catch (d) {
    this.onError(d);
  }
}
var kh = !1,
  lg = null,
  ug = !1,
  d6 = null,
  bq = {
    onError: function (t) {
      (kh = !0), (lg = t);
    },
  };
function vq(t, e, r, n, i, a, s, o, c) {
  (kh = !1), (lg = null), gq.apply(bq, arguments);
}
function xq(t, e, r, n, i, a, s, o, c) {
  if ((vq.apply(this, arguments), kh)) {
    if (kh) {
      var u = lg;
      (kh = !1), (lg = null);
    } else throw Error(Ge(198));
    ug || ((ug = !0), (d6 = u));
  }
}
function Mu(t) {
  var e = t,
    r = t;
  if (t.alternate) for (; e.return; ) e = e.return;
  else {
    t = e;
    do (e = t), e.flags & 4098 && (r = e.return), (t = e.return);
    while (t);
  }
  return e.tag === 3 ? r : null;
}
function jR(t) {
  if (t.tag === 13) {
    var e = t.memoizedState;
    if (
      (e === null && ((t = t.alternate), t !== null && (e = t.memoizedState)),
      e !== null)
    )
      return e.dehydrated;
  }
  return null;
}
function $C(t) {
  if (Mu(t) !== t) throw Error(Ge(188));
}
function wq(t) {
  var e = t.alternate;
  if (!e) {
    if (((e = Mu(t)), e === null)) throw Error(Ge(188));
    return e !== t ? null : t;
  }
  for (var r = t, n = e; ; ) {
    var i = r.return;
    if (i === null) break;
    var a = i.alternate;
    if (a === null) {
      if (((n = i.return), n !== null)) {
        r = n;
        continue;
      }
      break;
    }
    if (i.child === a.child) {
      for (a = i.child; a; ) {
        if (a === r) return $C(i), t;
        if (a === n) return $C(i), e;
        a = a.sibling;
      }
      throw Error(Ge(188));
    }
    if (r.return !== n.return) (r = i), (n = a);
    else {
      for (var s = !1, o = i.child; o; ) {
        if (o === r) {
          (s = !0), (r = i), (n = a);
          break;
        }
        if (o === n) {
          (s = !0), (n = i), (r = a);
          break;
        }
        o = o.sibling;
      }
      if (!s) {
        for (o = a.child; o; ) {
          if (o === r) {
            (s = !0), (r = a), (n = i);
            break;
          }
          if (o === n) {
            (s = !0), (n = a), (r = i);
            break;
          }
          o = o.sibling;
        }
        if (!s) throw Error(Ge(189));
      }
    }
    if (r.alternate !== n) throw Error(Ge(190));
  }
  if (r.tag !== 3) throw Error(Ge(188));
  return r.stateNode.current === r ? t : e;
}
function HR(t) {
  return (t = wq(t)), t !== null ? zR(t) : null;
}
function zR(t) {
  if (t.tag === 5 || t.tag === 6) return t;
  for (t = t.child; t !== null; ) {
    var e = zR(t);
    if (e !== null) return e;
    t = t.sibling;
  }
  return null;
}
var qR = ma.unstable_scheduleCallback,
  UC = ma.unstable_cancelCallback,
  _q = ma.unstable_shouldYield,
  Eq = ma.unstable_requestPaint,
  on = ma.unstable_now,
  Tq = ma.unstable_getCurrentPriorityLevel,
  Y4 = ma.unstable_ImmediatePriority,
  VR = ma.unstable_UserBlockingPriority,
  fg = ma.unstable_NormalPriority,
  Cq = ma.unstable_LowPriority,
  KR = ma.unstable_IdlePriority,
  kb = null,
  Ys = null;
function Aq(t) {
  if (Ys && typeof Ys.onCommitFiberRoot == "function")
    try {
      Ys.onCommitFiberRoot(kb, t, void 0, (t.current.flags & 128) === 128);
    } catch {}
}
var ps = Math.clz32 ? Math.clz32 : Mq,
  kq = Math.log,
  Sq = Math.LN2;
function Mq(t) {
  return (t >>>= 0), t === 0 ? 32 : (31 - ((kq(t) / Sq) | 0)) | 0;
}
var N1 = 64,
  B1 = 4194304;
function ph(t) {
  switch (t & -t) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return t & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return t & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return t;
  }
}
function dg(t, e) {
  var r = t.pendingLanes;
  if (r === 0) return 0;
  var n = 0,
    i = t.suspendedLanes,
    a = t.pingedLanes,
    s = r & 268435455;
  if (s !== 0) {
    var o = s & ~i;
    o !== 0 ? (n = ph(o)) : ((a &= s), a !== 0 && (n = ph(a)));
  } else (s = r & ~i), s !== 0 ? (n = ph(s)) : a !== 0 && (n = ph(a));
  if (n === 0) return 0;
  if (
    e !== 0 &&
    e !== n &&
    !(e & i) &&
    ((i = n & -n), (a = e & -e), i >= a || (i === 16 && (a & 4194240) !== 0))
  )
    return e;
  if ((n & 4 && (n |= r & 16), (e = t.entangledLanes), e !== 0))
    for (t = t.entanglements, e &= n; 0 < e; )
      (r = 31 - ps(e)), (i = 1 << r), (n |= t[r]), (e &= ~i);
  return n;
}
function Iq(t, e) {
  switch (t) {
    case 1:
    case 2:
    case 4:
      return e + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return e + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function Rq(t, e) {
  for (
    var r = t.suspendedLanes,
      n = t.pingedLanes,
      i = t.expirationTimes,
      a = t.pendingLanes;
    0 < a;

  ) {
    var s = 31 - ps(a),
      o = 1 << s,
      c = i[s];
    c === -1
      ? (!(o & r) || o & n) && (i[s] = Iq(o, e))
      : c <= e && (t.expiredLanes |= o),
      (a &= ~o);
  }
}
function h6(t) {
  return (
    (t = t.pendingLanes & -1073741825),
    t !== 0 ? t : t & 1073741824 ? 1073741824 : 0
  );
}
function GR() {
  var t = N1;
  return (N1 <<= 1), !(N1 & 4194240) && (N1 = 64), t;
}
function mw(t) {
  for (var e = [], r = 0; 31 > r; r++) e.push(t);
  return e;
}
function Cm(t, e, r) {
  (t.pendingLanes |= e),
    e !== 536870912 && ((t.suspendedLanes = 0), (t.pingedLanes = 0)),
    (t = t.eventTimes),
    (e = 31 - ps(e)),
    (t[e] = r);
}
function Pq(t, e) {
  var r = t.pendingLanes & ~e;
  (t.pendingLanes = e),
    (t.suspendedLanes = 0),
    (t.pingedLanes = 0),
    (t.expiredLanes &= e),
    (t.mutableReadLanes &= e),
    (t.entangledLanes &= e),
    (e = t.entanglements);
  var n = t.eventTimes;
  for (t = t.expirationTimes; 0 < r; ) {
    var i = 31 - ps(r),
      a = 1 << i;
    (e[i] = 0), (n[i] = -1), (t[i] = -1), (r &= ~a);
  }
}
function X4(t, e) {
  var r = (t.entangledLanes |= e);
  for (t = t.entanglements; r; ) {
    var n = 31 - ps(r),
      i = 1 << n;
    (i & e) | (t[n] & e) && (t[n] |= e), (r &= ~i);
  }
}
var er = 0;
function ZR(t) {
  return (t &= -t), 1 < t ? (4 < t ? (t & 268435455 ? 16 : 536870912) : 4) : 1;
}
var JR,
  e8,
  QR,
  YR,
  XR,
  p6 = !1,
  D1 = [],
  Sc = null,
  Mc = null,
  Ic = null,
  np = new Map(),
  ip = new Map(),
  mc = [],
  Nq =
    "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
      " "
    );
function WC(t, e) {
  switch (t) {
    case "focusin":
    case "focusout":
      Sc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Ic = null;
      break;
    case "pointerover":
    case "pointerout":
      np.delete(e.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      ip.delete(e.pointerId);
  }
}
function jd(t, e, r, n, i, a) {
  return t === null || t.nativeEvent !== a
    ? ((t = {
        blockedOn: e,
        domEventName: r,
        eventSystemFlags: n,
        nativeEvent: a,
        targetContainers: [i],
      }),
      e !== null && ((e = km(e)), e !== null && e8(e)),
      t)
    : ((t.eventSystemFlags |= n),
      (e = t.targetContainers),
      i !== null && e.indexOf(i) === -1 && e.push(i),
      t);
}
function Bq(t, e, r, n, i) {
  switch (e) {
    case "focusin":
      return (Sc = jd(Sc, t, e, r, n, i)), !0;
    case "dragenter":
      return (Mc = jd(Mc, t, e, r, n, i)), !0;
    case "mouseover":
      return (Ic = jd(Ic, t, e, r, n, i)), !0;
    case "pointerover":
      var a = i.pointerId;
      return np.set(a, jd(np.get(a) || null, t, e, r, n, i)), !0;
    case "gotpointercapture":
      return (
        (a = i.pointerId), ip.set(a, jd(ip.get(a) || null, t, e, r, n, i)), !0
      );
  }
  return !1;
}
function eP(t) {
  var e = Wl(t.target);
  if (e !== null) {
    var r = Mu(e);
    if (r !== null) {
      if (((e = r.tag), e === 13)) {
        if (((e = jR(r)), e !== null)) {
          (t.blockedOn = e),
            XR(t.priority, function () {
              QR(r);
            });
          return;
        }
      } else if (e === 3 && r.stateNode.current.memoizedState.isDehydrated) {
        t.blockedOn = r.tag === 3 ? r.stateNode.containerInfo : null;
        return;
      }
    }
  }
  t.blockedOn = null;
}
function Ny(t) {
  if (t.blockedOn !== null) return !1;
  for (var e = t.targetContainers; 0 < e.length; ) {
    var r = m6(t.domEventName, t.eventSystemFlags, e[0], t.nativeEvent);
    if (r === null) {
      r = t.nativeEvent;
      var n = new r.constructor(r.type, r);
      (l6 = n), r.target.dispatchEvent(n), (l6 = null);
    } else return (e = km(r)), e !== null && e8(e), (t.blockedOn = r), !1;
    e.shift();
  }
  return !0;
}
function jC(t, e, r) {
  Ny(t) && r.delete(e);
}
function Dq() {
  (p6 = !1),
    Sc !== null && Ny(Sc) && (Sc = null),
    Mc !== null && Ny(Mc) && (Mc = null),
    Ic !== null && Ny(Ic) && (Ic = null),
    np.forEach(jC),
    ip.forEach(jC);
}
function Hd(t, e) {
  t.blockedOn === e &&
    ((t.blockedOn = null),
    p6 ||
      ((p6 = !0),
      ma.unstable_scheduleCallback(ma.unstable_NormalPriority, Dq)));
}
function ap(t) {
  function e(i) {
    return Hd(i, t);
  }
  if (0 < D1.length) {
    Hd(D1[0], t);
    for (var r = 1; r < D1.length; r++) {
      var n = D1[r];
      n.blockedOn === t && (n.blockedOn = null);
    }
  }
  for (
    Sc !== null && Hd(Sc, t),
      Mc !== null && Hd(Mc, t),
      Ic !== null && Hd(Ic, t),
      np.forEach(e),
      ip.forEach(e),
      r = 0;
    r < mc.length;
    r++
  )
    (n = mc[r]), n.blockedOn === t && (n.blockedOn = null);
  for (; 0 < mc.length && ((r = mc[0]), r.blockedOn === null); )
    eP(r), r.blockedOn === null && mc.shift();
}
var j0 = Xo.ReactCurrentBatchConfig,
  hg = !0;
function Oq(t, e, r, n) {
  var i = er,
    a = j0.transition;
  j0.transition = null;
  try {
    (er = 1), t8(t, e, r, n);
  } finally {
    (er = i), (j0.transition = a);
  }
}
function Fq(t, e, r, n) {
  var i = er,
    a = j0.transition;
  j0.transition = null;
  try {
    (er = 4), t8(t, e, r, n);
  } finally {
    (er = i), (j0.transition = a);
  }
}
function t8(t, e, r, n) {
  if (hg) {
    var i = m6(t, e, r, n);
    if (i === null) Cw(t, e, n, pg, r), WC(t, n);
    else if (Bq(i, t, e, r, n)) n.stopPropagation();
    else if ((WC(t, n), e & 4 && -1 < Nq.indexOf(t))) {
      for (; i !== null; ) {
        var a = km(i);
        if (
          (a !== null && JR(a),
          (a = m6(t, e, r, n)),
          a === null && Cw(t, e, n, pg, r),
          a === i)
        )
          break;
        i = a;
      }
      i !== null && n.stopPropagation();
    } else Cw(t, e, n, null, r);
  }
}
var pg = null;
function m6(t, e, r, n) {
  if (((pg = null), (t = Q4(n)), (t = Wl(t)), t !== null))
    if (((e = Mu(t)), e === null)) t = null;
    else if (((r = e.tag), r === 13)) {
      if (((t = jR(e)), t !== null)) return t;
      t = null;
    } else if (r === 3) {
      if (e.stateNode.current.memoizedState.isDehydrated)
        return e.tag === 3 ? e.stateNode.containerInfo : null;
      t = null;
    } else e !== t && (t = null);
  return (pg = t), null;
}
function tP(t) {
  switch (t) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (Tq()) {
        case Y4:
          return 1;
        case VR:
          return 4;
        case fg:
        case Cq:
          return 16;
        case KR:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var wc = null,
  r8 = null,
  By = null;
function rP() {
  if (By) return By;
  var t,
    e = r8,
    r = e.length,
    n,
    i = "value" in wc ? wc.value : wc.textContent,
    a = i.length;
  for (t = 0; t < r && e[t] === i[t]; t++);
  var s = r - t;
  for (n = 1; n <= s && e[r - n] === i[a - n]; n++);
  return (By = i.slice(t, 1 < n ? 1 - n : void 0));
}
function Dy(t) {
  var e = t.keyCode;
  return (
    "charCode" in t
      ? ((t = t.charCode), t === 0 && e === 13 && (t = 13))
      : (t = e),
    t === 10 && (t = 13),
    32 <= t || t === 13 ? t : 0
  );
}
function O1() {
  return !0;
}
function HC() {
  return !1;
}
function ba(t) {
  function e(r, n, i, a, s) {
    (this._reactName = r),
      (this._targetInst = i),
      (this.type = n),
      (this.nativeEvent = a),
      (this.target = s),
      (this.currentTarget = null);
    for (var o in t)
      t.hasOwnProperty(o) && ((r = t[o]), (this[o] = r ? r(a) : a[o]));
    return (
      (this.isDefaultPrevented = (
        a.defaultPrevented != null ? a.defaultPrevented : a.returnValue === !1
      )
        ? O1
        : HC),
      (this.isPropagationStopped = HC),
      this
    );
  }
  return (
    Jr(e.prototype, {
      preventDefault: function () {
        this.defaultPrevented = !0;
        var r = this.nativeEvent;
        r &&
          (r.preventDefault
            ? r.preventDefault()
            : typeof r.returnValue != "unknown" && (r.returnValue = !1),
          (this.isDefaultPrevented = O1));
      },
      stopPropagation: function () {
        var r = this.nativeEvent;
        r &&
          (r.stopPropagation
            ? r.stopPropagation()
            : typeof r.cancelBubble != "unknown" && (r.cancelBubble = !0),
          (this.isPropagationStopped = O1));
      },
      persist: function () {},
      isPersistent: O1,
    }),
    e
  );
}
var sd = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (t) {
      return t.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0,
  },
  n8 = ba(sd),
  Am = Jr({}, sd, {
    view: 0,
    detail: 0,
  }),
  Lq = ba(Am),
  yw,
  gw,
  zd,
  Sb = Jr({}, Am, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: i8,
    button: 0,
    buttons: 0,
    relatedTarget: function (t) {
      return t.relatedTarget === void 0
        ? t.fromElement === t.srcElement
          ? t.toElement
          : t.fromElement
        : t.relatedTarget;
    },
    movementX: function (t) {
      return "movementX" in t
        ? t.movementX
        : (t !== zd &&
            (zd && t.type === "mousemove"
              ? ((yw = t.screenX - zd.screenX), (gw = t.screenY - zd.screenY))
              : (gw = yw = 0),
            (zd = t)),
          yw);
    },
    movementY: function (t) {
      return "movementY" in t ? t.movementY : gw;
    },
  }),
  zC = ba(Sb),
  $q = Jr({}, Sb, {
    dataTransfer: 0,
  }),
  Uq = ba($q),
  Wq = Jr({}, Am, {
    relatedTarget: 0,
  }),
  bw = ba(Wq),
  jq = Jr({}, sd, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0,
  }),
  Hq = ba(jq),
  zq = Jr({}, sd, {
    clipboardData: function (t) {
      return "clipboardData" in t ? t.clipboardData : window.clipboardData;
    },
  }),
  qq = ba(zq),
  Vq = Jr({}, sd, {
    data: 0,
  }),
  qC = ba(Vq),
  Kq = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified",
  },
  Gq = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta",
  },
  Zq = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey",
  };
function Jq(t) {
  var e = this.nativeEvent;
  return e.getModifierState ? e.getModifierState(t) : (t = Zq[t]) ? !!e[t] : !1;
}
function i8() {
  return Jq;
}
var Qq = Jr({}, Am, {
    key: function (t) {
      if (t.key) {
        var e = Kq[t.key] || t.key;
        if (e !== "Unidentified") return e;
      }
      return t.type === "keypress"
        ? ((t = Dy(t)), t === 13 ? "Enter" : String.fromCharCode(t))
        : t.type === "keydown" || t.type === "keyup"
        ? Gq[t.keyCode] || "Unidentified"
        : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: i8,
    charCode: function (t) {
      return t.type === "keypress" ? Dy(t) : 0;
    },
    keyCode: function (t) {
      return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0;
    },
    which: function (t) {
      return t.type === "keypress"
        ? Dy(t)
        : t.type === "keydown" || t.type === "keyup"
        ? t.keyCode
        : 0;
    },
  }),
  Yq = ba(Qq),
  Xq = Jr({}, Sb, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0,
  }),
  VC = ba(Xq),
  eV = Jr({}, Am, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: i8,
  }),
  tV = ba(eV),
  rV = Jr({}, sd, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0,
  }),
  nV = ba(rV),
  iV = Jr({}, Sb, {
    deltaX: function (t) {
      return "deltaX" in t ? t.deltaX : "wheelDeltaX" in t ? -t.wheelDeltaX : 0;
    },
    deltaY: function (t) {
      return "deltaY" in t
        ? t.deltaY
        : "wheelDeltaY" in t
        ? -t.wheelDeltaY
        : "wheelDelta" in t
        ? -t.wheelDelta
        : 0;
    },
    deltaZ: 0,
    deltaMode: 0,
  }),
  aV = ba(iV),
  sV = [9, 13, 27, 32],
  a8 = jo && "CompositionEvent" in window,
  Sh = null;
jo && "documentMode" in document && (Sh = document.documentMode);
var oV = jo && "TextEvent" in window && !Sh,
  nP = jo && (!a8 || (Sh && 8 < Sh && 11 >= Sh)),
  KC = " ",
  GC = !1;
function iP(t, e) {
  switch (t) {
    case "keyup":
      return sV.indexOf(e.keyCode) !== -1;
    case "keydown":
      return e.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
function aP(t) {
  return (t = t.detail), typeof t == "object" && "data" in t ? t.data : null;
}
var x0 = !1;
function cV(t, e) {
  switch (t) {
    case "compositionend":
      return aP(e);
    case "keypress":
      return e.which !== 32 ? null : ((GC = !0), KC);
    case "textInput":
      return (t = e.data), t === KC && GC ? null : t;
    default:
      return null;
  }
}
function lV(t, e) {
  if (x0)
    return t === "compositionend" || (!a8 && iP(t, e))
      ? ((t = rP()), (By = r8 = wc = null), (x0 = !1), t)
      : null;
  switch (t) {
    case "paste":
      return null;
    case "keypress":
      if (!(e.ctrlKey || e.altKey || e.metaKey) || (e.ctrlKey && e.altKey)) {
        if (e.char && 1 < e.char.length) return e.char;
        if (e.which) return String.fromCharCode(e.which);
      }
      return null;
    case "compositionend":
      return nP && e.locale !== "ko" ? null : e.data;
    default:
      return null;
  }
}
var uV = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0,
};
function ZC(t) {
  var e = t && t.nodeName && t.nodeName.toLowerCase();
  return e === "input" ? !!uV[t.type] : e === "textarea";
}
function sP(t, e, r, n) {
  FR(n),
    (e = mg(e, "onChange")),
    0 < e.length &&
      ((r = new n8("onChange", "change", null, r, n)),
      t.push({
        event: r,
        listeners: e,
      }));
}
var Mh = null,
  sp = null;
function fV(t) {
  gP(t, 0);
}
function Mb(t) {
  var e = E0(t);
  if (IR(e)) return t;
}
function dV(t, e) {
  if (t === "change") return e;
}
var oP = !1;
if (jo) {
  var vw;
  if (jo) {
    var xw = "oninput" in document;
    if (!xw) {
      var JC = document.createElement("div");
      JC.setAttribute("oninput", "return;"),
        (xw = typeof JC.oninput == "function");
    }
    vw = xw;
  } else vw = !1;
  oP = vw && (!document.documentMode || 9 < document.documentMode);
}
function QC() {
  Mh && (Mh.detachEvent("onpropertychange", cP), (sp = Mh = null));
}
function cP(t) {
  if (t.propertyName === "value" && Mb(sp)) {
    var e = [];
    sP(e, sp, t, Q4(t)), WR(fV, e);
  }
}
function hV(t, e, r) {
  t === "focusin"
    ? (QC(), (Mh = e), (sp = r), Mh.attachEvent("onpropertychange", cP))
    : t === "focusout" && QC();
}
function pV(t) {
  if (t === "selectionchange" || t === "keyup" || t === "keydown")
    return Mb(sp);
}
function mV(t, e) {
  if (t === "click") return Mb(e);
}
function yV(t, e) {
  if (t === "input" || t === "change") return Mb(e);
}
function gV(t, e) {
  return (t === e && (t !== 0 || 1 / t === 1 / e)) || (t !== t && e !== e);
}
var bs = typeof Object.is == "function" ? Object.is : gV;
function op(t, e) {
  if (bs(t, e)) return !0;
  if (typeof t != "object" || t === null || typeof e != "object" || e === null)
    return !1;
  var r = Object.keys(t),
    n = Object.keys(e);
  if (r.length !== n.length) return !1;
  for (n = 0; n < r.length; n++) {
    var i = r[n];
    if (!Q5.call(e, i) || !bs(t[i], e[i])) return !1;
  }
  return !0;
}
function YC(t) {
  for (; t && t.firstChild; ) t = t.firstChild;
  return t;
}
function XC(t, e) {
  var r = YC(t);
  t = 0;
  for (var n; r; ) {
    if (r.nodeType === 3) {
      if (((n = t + r.textContent.length), t <= e && n >= e))
        return {
          node: r,
          offset: e - t,
        };
      t = n;
    }
    e: {
      for (; r; ) {
        if (r.nextSibling) {
          r = r.nextSibling;
          break e;
        }
        r = r.parentNode;
      }
      r = void 0;
    }
    r = YC(r);
  }
}
function lP(t, e) {
  return t && e
    ? t === e
      ? !0
      : t && t.nodeType === 3
      ? !1
      : e && e.nodeType === 3
      ? lP(t, e.parentNode)
      : "contains" in t
      ? t.contains(e)
      : t.compareDocumentPosition
      ? !!(t.compareDocumentPosition(e) & 16)
      : !1
    : !1;
}
function uP() {
  for (var t = window, e = cg(); e instanceof t.HTMLIFrameElement; ) {
    try {
      var r = typeof e.contentWindow.location.href == "string";
    } catch {
      r = !1;
    }
    if (r) t = e.contentWindow;
    else break;
    e = cg(t.document);
  }
  return e;
}
function s8(t) {
  var e = t && t.nodeName && t.nodeName.toLowerCase();
  return (
    e &&
    ((e === "input" &&
      (t.type === "text" ||
        t.type === "search" ||
        t.type === "tel" ||
        t.type === "url" ||
        t.type === "password")) ||
      e === "textarea" ||
      t.contentEditable === "true")
  );
}
function bV(t) {
  var e = uP(),
    r = t.focusedElem,
    n = t.selectionRange;
  if (
    e !== r &&
    r &&
    r.ownerDocument &&
    lP(r.ownerDocument.documentElement, r)
  ) {
    if (n !== null && s8(r)) {
      if (
        ((e = n.start),
        (t = n.end),
        t === void 0 && (t = e),
        "selectionStart" in r)
      )
        (r.selectionStart = e), (r.selectionEnd = Math.min(t, r.value.length));
      else if (
        ((t = ((e = r.ownerDocument || document) && e.defaultView) || window),
        t.getSelection)
      ) {
        t = t.getSelection();
        var i = r.textContent.length,
          a = Math.min(n.start, i);
        (n = n.end === void 0 ? a : Math.min(n.end, i)),
          !t.extend && a > n && ((i = n), (n = a), (a = i)),
          (i = XC(r, a));
        var s = XC(r, n);
        i &&
          s &&
          (t.rangeCount !== 1 ||
            t.anchorNode !== i.node ||
            t.anchorOffset !== i.offset ||
            t.focusNode !== s.node ||
            t.focusOffset !== s.offset) &&
          ((e = e.createRange()),
          e.setStart(i.node, i.offset),
          t.removeAllRanges(),
          a > n
            ? (t.addRange(e), t.extend(s.node, s.offset))
            : (e.setEnd(s.node, s.offset), t.addRange(e)));
      }
    }
    for (e = [], t = r; (t = t.parentNode); )
      t.nodeType === 1 &&
        e.push({
          element: t,
          left: t.scrollLeft,
          top: t.scrollTop,
        });
    for (typeof r.focus == "function" && r.focus(), r = 0; r < e.length; r++)
      (t = e[r]),
        (t.element.scrollLeft = t.left),
        (t.element.scrollTop = t.top);
  }
}
var vV = jo && "documentMode" in document && 11 >= document.documentMode,
  w0 = null,
  y6 = null,
  Ih = null,
  g6 = !1;
function eA(t, e, r) {
  var n = r.window === r ? r.document : r.nodeType === 9 ? r : r.ownerDocument;
  g6 ||
    w0 == null ||
    w0 !== cg(n) ||
    ((n = w0),
    "selectionStart" in n && s8(n)
      ? (n = {
          start: n.selectionStart,
          end: n.selectionEnd,
        })
      : ((n = (
          (n.ownerDocument && n.ownerDocument.defaultView) ||
          window
        ).getSelection()),
        (n = {
          anchorNode: n.anchorNode,
          anchorOffset: n.anchorOffset,
          focusNode: n.focusNode,
          focusOffset: n.focusOffset,
        })),
    (Ih && op(Ih, n)) ||
      ((Ih = n),
      (n = mg(y6, "onSelect")),
      0 < n.length &&
        ((e = new n8("onSelect", "select", null, e, r)),
        t.push({
          event: e,
          listeners: n,
        }),
        (e.target = w0))));
}
function F1(t, e) {
  var r = {};
  return (
    (r[t.toLowerCase()] = e.toLowerCase()),
    (r["Webkit" + t] = "webkit" + e),
    (r["Moz" + t] = "moz" + e),
    r
  );
}
var _0 = {
    animationend: F1("Animation", "AnimationEnd"),
    animationiteration: F1("Animation", "AnimationIteration"),
    animationstart: F1("Animation", "AnimationStart"),
    transitionend: F1("Transition", "TransitionEnd"),
  },
  ww = {},
  fP = {};
jo &&
  ((fP = document.createElement("div").style),
  "AnimationEvent" in window ||
    (delete _0.animationend.animation,
    delete _0.animationiteration.animation,
    delete _0.animationstart.animation),
  "TransitionEvent" in window || delete _0.transitionend.transition);
function Ib(t) {
  if (ww[t]) return ww[t];
  if (!_0[t]) return t;
  var e = _0[t],
    r;
  for (r in e) if (e.hasOwnProperty(r) && r in fP) return (ww[t] = e[r]);
  return t;
}
var dP = Ib("animationend"),
  hP = Ib("animationiteration"),
  pP = Ib("animationstart"),
  mP = Ib("transitionend"),
  yP = new Map(),
  tA =
    "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    );
function ul(t, e) {
  yP.set(t, e), Su(e, [t]);
}
for (var _w = 0; _w < tA.length; _w++) {
  var Ew = tA[_w],
    xV = Ew.toLowerCase(),
    wV = Ew[0].toUpperCase() + Ew.slice(1);
  ul(xV, "on" + wV);
}
ul(dP, "onAnimationEnd");
ul(hP, "onAnimationIteration");
ul(pP, "onAnimationStart");
ul("dblclick", "onDoubleClick");
ul("focusin", "onFocus");
ul("focusout", "onBlur");
ul(mP, "onTransitionEnd");
lf("onMouseEnter", ["mouseout", "mouseover"]);
lf("onMouseLeave", ["mouseout", "mouseover"]);
lf("onPointerEnter", ["pointerout", "pointerover"]);
lf("onPointerLeave", ["pointerout", "pointerover"]);
Su(
  "onChange",
  "change click focusin focusout input keydown keyup selectionchange".split(" ")
);
Su(
  "onSelect",
  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
    " "
  )
);
Su("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
Su(
  "onCompositionEnd",
  "compositionend focusout keydown keypress keyup mousedown".split(" ")
);
Su(
  "onCompositionStart",
  "compositionstart focusout keydown keypress keyup mousedown".split(" ")
);
Su(
  "onCompositionUpdate",
  "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
);
var mh =
    "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ),
  _V = new Set("cancel close invalid load scroll toggle".split(" ").concat(mh));
function rA(t, e, r) {
  var n = t.type || "unknown-event";
  (t.currentTarget = r), xq(n, e, void 0, t), (t.currentTarget = null);
}
function gP(t, e) {
  e = (e & 4) !== 0;
  for (var r = 0; r < t.length; r++) {
    var n = t[r],
      i = n.event;
    n = n.listeners;
    e: {
      var a = void 0;
      if (e)
        for (var s = n.length - 1; 0 <= s; s--) {
          var o = n[s],
            c = o.instance,
            u = o.currentTarget;
          if (((o = o.listener), c !== a && i.isPropagationStopped())) break e;
          rA(i, o, u), (a = c);
        }
      else
        for (s = 0; s < n.length; s++) {
          if (
            ((o = n[s]),
            (c = o.instance),
            (u = o.currentTarget),
            (o = o.listener),
            c !== a && i.isPropagationStopped())
          )
            break e;
          rA(i, o, u), (a = c);
        }
    }
  }
  if (ug) throw ((t = d6), (ug = !1), (d6 = null), t);
}
function Cr(t, e) {
  var r = e[_6];
  r === void 0 && (r = e[_6] = new Set());
  var n = t + "__bubble";
  r.has(n) || (bP(e, t, 2, !1), r.add(n));
}
function Tw(t, e, r) {
  var n = 0;
  e && (n |= 4), bP(r, t, n, e);
}
var L1 = "_reactListening" + Math.random().toString(36).slice(2);
function cp(t) {
  if (!t[L1]) {
    (t[L1] = !0),
      CR.forEach(function (r) {
        r !== "selectionchange" && (_V.has(r) || Tw(r, !1, t), Tw(r, !0, t));
      });
    var e = t.nodeType === 9 ? t : t.ownerDocument;
    e === null || e[L1] || ((e[L1] = !0), Tw("selectionchange", !1, e));
  }
}
function bP(t, e, r, n) {
  switch (tP(e)) {
    case 1:
      var i = Oq;
      break;
    case 4:
      i = Fq;
      break;
    default:
      i = t8;
  }
  (r = i.bind(null, e, r, t)),
    (i = void 0),
    !f6 ||
      (e !== "touchstart" && e !== "touchmove" && e !== "wheel") ||
      (i = !0),
    n
      ? i !== void 0
        ? t.addEventListener(e, r, {
            capture: !0,
            passive: i,
          })
        : t.addEventListener(e, r, !0)
      : i !== void 0
      ? t.addEventListener(e, r, {
          passive: i,
        })
      : t.addEventListener(e, r, !1);
}
function Cw(t, e, r, n, i) {
  var a = n;
  if (!(e & 1) && !(e & 2) && n !== null)
    e: for (;;) {
      if (n === null) return;
      var s = n.tag;
      if (s === 3 || s === 4) {
        var o = n.stateNode.containerInfo;
        if (o === i || (o.nodeType === 8 && o.parentNode === i)) break;
        if (s === 4)
          for (s = n.return; s !== null; ) {
            var c = s.tag;
            if (
              (c === 3 || c === 4) &&
              ((c = s.stateNode.containerInfo),
              c === i || (c.nodeType === 8 && c.parentNode === i))
            )
              return;
            s = s.return;
          }
        for (; o !== null; ) {
          if (((s = Wl(o)), s === null)) return;
          if (((c = s.tag), c === 5 || c === 6)) {
            n = a = s;
            continue e;
          }
          o = o.parentNode;
        }
      }
      n = n.return;
    }
  WR(function () {
    var u = a,
      d = Q4(r),
      m = [];
    e: {
      var v = yP.get(t);
      if (v !== void 0) {
        var E = n8,
          A = t;
        switch (t) {
          case "keypress":
            if (Dy(r) === 0) break e;
          case "keydown":
          case "keyup":
            E = Yq;
            break;
          case "focusin":
            (A = "focus"), (E = bw);
            break;
          case "focusout":
            (A = "blur"), (E = bw);
            break;
          case "beforeblur":
          case "afterblur":
            E = bw;
            break;
          case "click":
            if (r.button === 2) break e;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            E = zC;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            E = Uq;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            E = tV;
            break;
          case dP:
          case hP:
          case pP:
            E = Hq;
            break;
          case mP:
            E = nV;
            break;
          case "scroll":
            E = Lq;
            break;
          case "wheel":
            E = aV;
            break;
          case "copy":
          case "cut":
          case "paste":
            E = qq;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            E = VC;
        }
        var I = (e & 4) !== 0,
          b = !I && t === "scroll",
          w = I ? (v !== null ? v + "Capture" : null) : v;
        I = [];
        for (var S = u, k; S !== null; ) {
          k = S;
          var N = k.stateNode;
          if (
            (k.tag === 5 &&
              N !== null &&
              ((k = N),
              w !== null && ((N = rp(S, w)), N != null && I.push(lp(S, N, k)))),
            b)
          )
            break;
          S = S.return;
        }
        0 < I.length &&
          ((v = new E(v, A, null, r, d)),
          m.push({
            event: v,
            listeners: I,
          }));
      }
    }
    if (!(e & 7)) {
      e: {
        if (
          ((v = t === "mouseover" || t === "pointerover"),
          (E = t === "mouseout" || t === "pointerout"),
          v &&
            r !== l6 &&
            (A = r.relatedTarget || r.fromElement) &&
            (Wl(A) || A[Ho]))
        )
          break e;
        if (
          (E || v) &&
          ((v =
            d.window === d
              ? d
              : (v = d.ownerDocument)
              ? v.defaultView || v.parentWindow
              : window),
          E
            ? ((A = r.relatedTarget || r.toElement),
              (E = u),
              (A = A ? Wl(A) : null),
              A !== null &&
                ((b = Mu(A)), A !== b || (A.tag !== 5 && A.tag !== 6)) &&
                (A = null))
            : ((E = null), (A = u)),
          E !== A)
        ) {
          if (
            ((I = zC),
            (N = "onMouseLeave"),
            (w = "onMouseEnter"),
            (S = "mouse"),
            (t === "pointerout" || t === "pointerover") &&
              ((I = VC),
              (N = "onPointerLeave"),
              (w = "onPointerEnter"),
              (S = "pointer")),
            (b = E == null ? v : E0(E)),
            (k = A == null ? v : E0(A)),
            (v = new I(N, S + "leave", E, r, d)),
            (v.target = b),
            (v.relatedTarget = k),
            (N = null),
            Wl(d) === u &&
              ((I = new I(w, S + "enter", A, r, d)),
              (I.target = k),
              (I.relatedTarget = b),
              (N = I)),
            (b = N),
            E && A)
          )
            t: {
              for (I = E, w = A, S = 0, k = I; k; k = Gu(k)) S++;
              for (k = 0, N = w; N; N = Gu(N)) k++;
              for (; 0 < S - k; ) (I = Gu(I)), S--;
              for (; 0 < k - S; ) (w = Gu(w)), k--;
              for (; S--; ) {
                if (I === w || (w !== null && I === w.alternate)) break t;
                (I = Gu(I)), (w = Gu(w));
              }
              I = null;
            }
          else I = null;
          E !== null && nA(m, v, E, I, !1),
            A !== null && b !== null && nA(m, b, A, I, !0);
        }
      }
      e: {
        if (
          ((v = u ? E0(u) : window),
          (E = v.nodeName && v.nodeName.toLowerCase()),
          E === "select" || (E === "input" && v.type === "file"))
        )
          var O = dV;
        else if (ZC(v))
          if (oP) O = yV;
          else {
            O = pV;
            var F = hV;
          }
        else
          (E = v.nodeName) &&
            E.toLowerCase() === "input" &&
            (v.type === "checkbox" || v.type === "radio") &&
            (O = mV);
        if (O && (O = O(t, u))) {
          sP(m, O, r, d);
          break e;
        }
        F && F(t, v, u),
          t === "focusout" &&
            (F = v._wrapperState) &&
            F.controlled &&
            v.type === "number" &&
            i6(v, "number", v.value);
      }
      switch (((F = u ? E0(u) : window), t)) {
        case "focusin":
          (ZC(F) || F.contentEditable === "true") &&
            ((w0 = F), (y6 = u), (Ih = null));
          break;
        case "focusout":
          Ih = y6 = w0 = null;
          break;
        case "mousedown":
          g6 = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          (g6 = !1), eA(m, r, d);
          break;
        case "selectionchange":
          if (vV) break;
        case "keydown":
        case "keyup":
          eA(m, r, d);
      }
      var V;
      if (a8)
        e: {
          switch (t) {
            case "compositionstart":
              var j = "onCompositionStart";
              break e;
            case "compositionend":
              j = "onCompositionEnd";
              break e;
            case "compositionupdate":
              j = "onCompositionUpdate";
              break e;
          }
          j = void 0;
        }
      else
        x0
          ? iP(t, r) && (j = "onCompositionEnd")
          : t === "keydown" && r.keyCode === 229 && (j = "onCompositionStart");
      j &&
        (nP &&
          r.locale !== "ko" &&
          (x0 || j !== "onCompositionStart"
            ? j === "onCompositionEnd" && x0 && (V = rP())
            : ((wc = d),
              (r8 = "value" in wc ? wc.value : wc.textContent),
              (x0 = !0))),
        (F = mg(u, j)),
        0 < F.length &&
          ((j = new qC(j, t, null, r, d)),
          m.push({
            event: j,
            listeners: F,
          }),
          V ? (j.data = V) : ((V = aP(r)), V !== null && (j.data = V)))),
        (V = oV ? cV(t, r) : lV(t, r)) &&
          ((u = mg(u, "onBeforeInput")),
          0 < u.length &&
            ((d = new qC("onBeforeInput", "beforeinput", null, r, d)),
            m.push({
              event: d,
              listeners: u,
            }),
            (d.data = V)));
    }
    gP(m, e);
  });
}
function lp(t, e, r) {
  return {
    instance: t,
    listener: e,
    currentTarget: r,
  };
}
function mg(t, e) {
  for (var r = e + "Capture", n = []; t !== null; ) {
    var i = t,
      a = i.stateNode;
    i.tag === 5 &&
      a !== null &&
      ((i = a),
      (a = rp(t, r)),
      a != null && n.unshift(lp(t, a, i)),
      (a = rp(t, e)),
      a != null && n.push(lp(t, a, i))),
      (t = t.return);
  }
  return n;
}
function Gu(t) {
  if (t === null) return null;
  do t = t.return;
  while (t && t.tag !== 5);
  return t || null;
}
function nA(t, e, r, n, i) {
  for (var a = e._reactName, s = []; r !== null && r !== n; ) {
    var o = r,
      c = o.alternate,
      u = o.stateNode;
    if (c !== null && c === n) break;
    o.tag === 5 &&
      u !== null &&
      ((o = u),
      i
        ? ((c = rp(r, a)), c != null && s.unshift(lp(r, c, o)))
        : i || ((c = rp(r, a)), c != null && s.push(lp(r, c, o)))),
      (r = r.return);
  }
  s.length !== 0 &&
    t.push({
      event: e,
      listeners: s,
    });
}
var EV = /\r\n?/g,
  TV = /\u0000|\uFFFD/g;
function iA(t) {
  return (typeof t == "string" ? t : "" + t)
    .replace(
      EV,
      `
`
    )
    .replace(TV, "");
}
function $1(t, e, r) {
  if (((e = iA(e)), iA(t) !== e && r)) throw Error(Ge(425));
}
function yg() {}
var b6 = null,
  v6 = null;
function x6(t, e) {
  return (
    t === "textarea" ||
    t === "noscript" ||
    typeof e.children == "string" ||
    typeof e.children == "number" ||
    (typeof e.dangerouslySetInnerHTML == "object" &&
      e.dangerouslySetInnerHTML !== null &&
      e.dangerouslySetInnerHTML.__html != null)
  );
}
var w6 = typeof setTimeout == "function" ? setTimeout : void 0,
  CV = typeof clearTimeout == "function" ? clearTimeout : void 0,
  aA = typeof Promise == "function" ? Promise : void 0,
  AV =
    typeof queueMicrotask == "function"
      ? queueMicrotask
      : typeof aA < "u"
      ? function (t) {
          return aA.resolve(null).then(t).catch(kV);
        }
      : w6;
function kV(t) {
  setTimeout(function () {
    throw t;
  });
}
function Aw(t, e) {
  var r = e,
    n = 0;
  do {
    var i = r.nextSibling;
    if ((t.removeChild(r), i && i.nodeType === 8))
      if (((r = i.data), r === "/$")) {
        if (n === 0) {
          t.removeChild(i), ap(e);
          return;
        }
        n--;
      } else (r !== "$" && r !== "$?" && r !== "$!") || n++;
    r = i;
  } while (r);
  ap(e);
}
function Rc(t) {
  for (; t != null; t = t.nextSibling) {
    var e = t.nodeType;
    if (e === 1 || e === 3) break;
    if (e === 8) {
      if (((e = t.data), e === "$" || e === "$!" || e === "$?")) break;
      if (e === "/$") return null;
    }
  }
  return t;
}
function sA(t) {
  t = t.previousSibling;
  for (var e = 0; t; ) {
    if (t.nodeType === 8) {
      var r = t.data;
      if (r === "$" || r === "$!" || r === "$?") {
        if (e === 0) return t;
        e--;
      } else r === "/$" && e++;
    }
    t = t.previousSibling;
  }
  return null;
}
var od = Math.random().toString(36).slice(2),
  Ws = "__reactFiber$" + od,
  up = "__reactProps$" + od,
  Ho = "__reactContainer$" + od,
  _6 = "__reactEvents$" + od,
  SV = "__reactListeners$" + od,
  MV = "__reactHandles$" + od;
function Wl(t) {
  var e = t[Ws];
  if (e) return e;
  for (var r = t.parentNode; r; ) {
    if ((e = r[Ho] || r[Ws])) {
      if (
        ((r = e.alternate),
        e.child !== null || (r !== null && r.child !== null))
      )
        for (t = sA(t); t !== null; ) {
          if ((r = t[Ws])) return r;
          t = sA(t);
        }
      return e;
    }
    (t = r), (r = t.parentNode);
  }
  return null;
}
function km(t) {
  return (
    (t = t[Ws] || t[Ho]),
    !t || (t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3) ? null : t
  );
}
function E0(t) {
  if (t.tag === 5 || t.tag === 6) return t.stateNode;
  throw Error(Ge(33));
}
function Rb(t) {
  return t[up] || null;
}
var E6 = [],
  T0 = -1;
function fl(t) {
  return {
    current: t,
  };
}
function Ar(t) {
  0 > T0 || ((t.current = E6[T0]), (E6[T0] = null), T0--);
}
function br(t, e) {
  T0++, (E6[T0] = t.current), (t.current = e);
}
var Zc = {},
  mi = fl(Zc),
  Wi = fl(!1),
  ou = Zc;
function uf(t, e) {
  var r = t.type.contextTypes;
  if (!r) return Zc;
  var n = t.stateNode;
  if (n && n.__reactInternalMemoizedUnmaskedChildContext === e)
    return n.__reactInternalMemoizedMaskedChildContext;
  var i = {},
    a;
  for (a in r) i[a] = e[a];
  return (
    n &&
      ((t = t.stateNode),
      (t.__reactInternalMemoizedUnmaskedChildContext = e),
      (t.__reactInternalMemoizedMaskedChildContext = i)),
    i
  );
}
function ji(t) {
  return (t = t.childContextTypes), t != null;
}
function gg() {
  Ar(Wi), Ar(mi);
}
function oA(t, e, r) {
  if (mi.current !== Zc) throw Error(Ge(168));
  br(mi, e), br(Wi, r);
}
function vP(t, e, r) {
  var n = t.stateNode;
  if (((e = e.childContextTypes), typeof n.getChildContext != "function"))
    return r;
  n = n.getChildContext();
  for (var i in n) if (!(i in e)) throw Error(Ge(108, hq(t) || "Unknown", i));
  return Jr({}, r, n);
}
function bg(t) {
  return (
    (t =
      ((t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext) || Zc),
    (ou = mi.current),
    br(mi, t),
    br(Wi, Wi.current),
    !0
  );
}
function cA(t, e, r) {
  var n = t.stateNode;
  if (!n) throw Error(Ge(169));
  r
    ? ((t = vP(t, e, ou)),
      (n.__reactInternalMemoizedMergedChildContext = t),
      Ar(Wi),
      Ar(mi),
      br(mi, t))
    : Ar(Wi),
    br(Wi, r);
}
var Io = null,
  Pb = !1,
  kw = !1;
function xP(t) {
  Io === null ? (Io = [t]) : Io.push(t);
}
function IV(t) {
  (Pb = !0), xP(t);
}
function dl() {
  if (!kw && Io !== null) {
    kw = !0;
    var t = 0,
      e = er;
    try {
      var r = Io;
      for (er = 1; t < r.length; t++) {
        var n = r[t];
        do n = n(!0);
        while (n !== null);
      }
      (Io = null), (Pb = !1);
    } catch (i) {
      throw (Io !== null && (Io = Io.slice(t + 1)), qR(Y4, dl), i);
    } finally {
      (er = e), (kw = !1);
    }
  }
  return null;
}
var C0 = [],
  A0 = 0,
  vg = null,
  xg = 0,
  Ba = [],
  Da = 0,
  cu = null,
  Oo = 1,
  Fo = "";
function Pl(t, e) {
  (C0[A0++] = xg), (C0[A0++] = vg), (vg = t), (xg = e);
}
function wP(t, e, r) {
  (Ba[Da++] = Oo), (Ba[Da++] = Fo), (Ba[Da++] = cu), (cu = t);
  var n = Oo;
  t = Fo;
  var i = 32 - ps(n) - 1;
  (n &= ~(1 << i)), (r += 1);
  var a = 32 - ps(e) + i;
  if (30 < a) {
    var s = i - (i % 5);
    (a = (n & ((1 << s) - 1)).toString(32)),
      (n >>= s),
      (i -= s),
      (Oo = (1 << (32 - ps(e) + i)) | (r << i) | n),
      (Fo = a + t);
  } else (Oo = (1 << a) | (r << i) | n), (Fo = t);
}
function o8(t) {
  t.return !== null && (Pl(t, 1), wP(t, 1, 0));
}
function c8(t) {
  for (; t === vg; )
    (vg = C0[--A0]), (C0[A0] = null), (xg = C0[--A0]), (C0[A0] = null);
  for (; t === cu; )
    (cu = Ba[--Da]),
      (Ba[Da] = null),
      (Fo = Ba[--Da]),
      (Ba[Da] = null),
      (Oo = Ba[--Da]),
      (Ba[Da] = null);
}
var ua = null,
  sa = null,
  kr = !1,
  ss = null;
function _P(t, e) {
  var r = Fa(5, null, null, 0);
  (r.elementType = "DELETED"),
    (r.stateNode = e),
    (r.return = t),
    (e = t.deletions),
    e === null ? ((t.deletions = [r]), (t.flags |= 16)) : e.push(r);
}
function lA(t, e) {
  switch (t.tag) {
    case 5:
      var r = t.type;
      return (
        (e =
          e.nodeType !== 1 || r.toLowerCase() !== e.nodeName.toLowerCase()
            ? null
            : e),
        e !== null
          ? ((t.stateNode = e), (ua = t), (sa = Rc(e.firstChild)), !0)
          : !1
      );
    case 6:
      return (
        (e = t.pendingProps === "" || e.nodeType !== 3 ? null : e),
        e !== null ? ((t.stateNode = e), (ua = t), (sa = null), !0) : !1
      );
    case 13:
      return (
        (e = e.nodeType !== 8 ? null : e),
        e !== null
          ? ((r =
              cu !== null
                ? {
                    id: Oo,
                    overflow: Fo,
                  }
                : null),
            (t.memoizedState = {
              dehydrated: e,
              treeContext: r,
              retryLane: 1073741824,
            }),
            (r = Fa(18, null, null, 0)),
            (r.stateNode = e),
            (r.return = t),
            (t.child = r),
            (ua = t),
            (sa = null),
            !0)
          : !1
      );
    default:
      return !1;
  }
}
function T6(t) {
  return (t.mode & 1) !== 0 && (t.flags & 128) === 0;
}
function C6(t) {
  if (kr) {
    var e = sa;
    if (e) {
      var r = e;
      if (!lA(t, e)) {
        if (T6(t)) throw Error(Ge(418));
        e = Rc(r.nextSibling);
        var n = ua;
        e && lA(t, e)
          ? _P(n, r)
          : ((t.flags = (t.flags & -4097) | 2), (kr = !1), (ua = t));
      }
    } else {
      if (T6(t)) throw Error(Ge(418));
      (t.flags = (t.flags & -4097) | 2), (kr = !1), (ua = t);
    }
  }
}
function uA(t) {
  for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13; )
    t = t.return;
  ua = t;
}
function U1(t) {
  if (t !== ua) return !1;
  if (!kr) return uA(t), (kr = !0), !1;
  var e;
  if (
    ((e = t.tag !== 3) &&
      !(e = t.tag !== 5) &&
      ((e = t.type),
      (e = e !== "head" && e !== "body" && !x6(t.type, t.memoizedProps))),
    e && (e = sa))
  ) {
    if (T6(t)) throw (EP(), Error(Ge(418)));
    for (; e; ) _P(t, e), (e = Rc(e.nextSibling));
  }
  if ((uA(t), t.tag === 13)) {
    if (((t = t.memoizedState), (t = t !== null ? t.dehydrated : null), !t))
      throw Error(Ge(317));
    e: {
      for (t = t.nextSibling, e = 0; t; ) {
        if (t.nodeType === 8) {
          var r = t.data;
          if (r === "/$") {
            if (e === 0) {
              sa = Rc(t.nextSibling);
              break e;
            }
            e--;
          } else (r !== "$" && r !== "$!" && r !== "$?") || e++;
        }
        t = t.nextSibling;
      }
      sa = null;
    }
  } else sa = ua ? Rc(t.stateNode.nextSibling) : null;
  return !0;
}
function EP() {
  for (var t = sa; t; ) t = Rc(t.nextSibling);
}
function ff() {
  (sa = ua = null), (kr = !1);
}
function l8(t) {
  ss === null ? (ss = [t]) : ss.push(t);
}
var RV = Xo.ReactCurrentBatchConfig;
function qd(t, e, r) {
  if (
    ((t = r.ref), t !== null && typeof t != "function" && typeof t != "object")
  ) {
    if (r._owner) {
      if (((r = r._owner), r)) {
        if (r.tag !== 1) throw Error(Ge(309));
        var n = r.stateNode;
      }
      if (!n) throw Error(Ge(147, t));
      var i = n,
        a = "" + t;
      return e !== null &&
        e.ref !== null &&
        typeof e.ref == "function" &&
        e.ref._stringRef === a
        ? e.ref
        : ((e = function (s) {
            var o = i.refs;
            s === null ? delete o[a] : (o[a] = s);
          }),
          (e._stringRef = a),
          e);
    }
    if (typeof t != "string") throw Error(Ge(284));
    if (!r._owner) throw Error(Ge(290, t));
  }
  return t;
}
function W1(t, e) {
  throw (
    ((t = Object.prototype.toString.call(e)),
    Error(
      Ge(
        31,
        t === "[object Object]"
          ? "object with keys {" + Object.keys(e).join(", ") + "}"
          : t
      )
    ))
  );
}
function fA(t) {
  var e = t._init;
  return e(t._payload);
}
function TP(t) {
  function e(w, S) {
    if (t) {
      var k = w.deletions;
      k === null ? ((w.deletions = [S]), (w.flags |= 16)) : k.push(S);
    }
  }
  function r(w, S) {
    if (!t) return null;
    for (; S !== null; ) e(w, S), (S = S.sibling);
    return null;
  }
  function n(w, S) {
    for (w = new Map(); S !== null; )
      S.key !== null ? w.set(S.key, S) : w.set(S.index, S), (S = S.sibling);
    return w;
  }
  function i(w, S) {
    return (w = Dc(w, S)), (w.index = 0), (w.sibling = null), w;
  }
  function a(w, S, k) {
    return (
      (w.index = k),
      t
        ? ((k = w.alternate),
          k !== null
            ? ((k = k.index), k < S ? ((w.flags |= 2), S) : k)
            : ((w.flags |= 2), S))
        : ((w.flags |= 1048576), S)
    );
  }
  function s(w) {
    return t && w.alternate === null && (w.flags |= 2), w;
  }
  function o(w, S, k, N) {
    return S === null || S.tag !== 6
      ? ((S = Bw(k, w.mode, N)), (S.return = w), S)
      : ((S = i(S, k)), (S.return = w), S);
  }
  function c(w, S, k, N) {
    var O = k.type;
    return O === v0
      ? d(w, S, k.props.children, N, k.key)
      : S !== null &&
        (S.elementType === O ||
          (typeof O == "object" &&
            O !== null &&
            O.$$typeof === dc &&
            fA(O) === S.type))
      ? ((N = i(S, k.props)), (N.ref = qd(w, S, k)), (N.return = w), N)
      : ((N = jy(k.type, k.key, k.props, null, w.mode, N)),
        (N.ref = qd(w, S, k)),
        (N.return = w),
        N);
  }
  function u(w, S, k, N) {
    return S === null ||
      S.tag !== 4 ||
      S.stateNode.containerInfo !== k.containerInfo ||
      S.stateNode.implementation !== k.implementation
      ? ((S = Dw(k, w.mode, N)), (S.return = w), S)
      : ((S = i(S, k.children || [])), (S.return = w), S);
  }
  function d(w, S, k, N, O) {
    return S === null || S.tag !== 7
      ? ((S = Xl(k, w.mode, N, O)), (S.return = w), S)
      : ((S = i(S, k)), (S.return = w), S);
  }
  function m(w, S, k) {
    if ((typeof S == "string" && S !== "") || typeof S == "number")
      return (S = Bw("" + S, w.mode, k)), (S.return = w), S;
    if (typeof S == "object" && S !== null) {
      switch (S.$$typeof) {
        case I1:
          return (
            (k = jy(S.type, S.key, S.props, null, w.mode, k)),
            (k.ref = qd(w, null, S)),
            (k.return = w),
            k
          );
        case b0:
          return (S = Dw(S, w.mode, k)), (S.return = w), S;
        case dc:
          var N = S._init;
          return m(w, N(S._payload), k);
      }
      if (hh(S) || Ud(S))
        return (S = Xl(S, w.mode, k, null)), (S.return = w), S;
      W1(w, S);
    }
    return null;
  }
  function v(w, S, k, N) {
    var O = S !== null ? S.key : null;
    if ((typeof k == "string" && k !== "") || typeof k == "number")
      return O !== null ? null : o(w, S, "" + k, N);
    if (typeof k == "object" && k !== null) {
      switch (k.$$typeof) {
        case I1:
          return k.key === O ? c(w, S, k, N) : null;
        case b0:
          return k.key === O ? u(w, S, k, N) : null;
        case dc:
          return (O = k._init), v(w, S, O(k._payload), N);
      }
      if (hh(k) || Ud(k)) return O !== null ? null : d(w, S, k, N, null);
      W1(w, k);
    }
    return null;
  }
  function E(w, S, k, N, O) {
    if ((typeof N == "string" && N !== "") || typeof N == "number")
      return (w = w.get(k) || null), o(S, w, "" + N, O);
    if (typeof N == "object" && N !== null) {
      switch (N.$$typeof) {
        case I1:
          return (w = w.get(N.key === null ? k : N.key) || null), c(S, w, N, O);
        case b0:
          return (w = w.get(N.key === null ? k : N.key) || null), u(S, w, N, O);
        case dc:
          var F = N._init;
          return E(w, S, k, F(N._payload), O);
      }
      if (hh(N) || Ud(N)) return (w = w.get(k) || null), d(S, w, N, O, null);
      W1(S, N);
    }
    return null;
  }
  function A(w, S, k, N) {
    for (
      var O = null, F = null, V = S, j = (S = 0), X = null;
      V !== null && j < k.length;
      j++
    ) {
      V.index > j ? ((X = V), (V = null)) : (X = V.sibling);
      var C = v(w, V, k[j], N);
      if (C === null) {
        V === null && (V = X);
        break;
      }
      t && V && C.alternate === null && e(w, V),
        (S = a(C, S, j)),
        F === null ? (O = C) : (F.sibling = C),
        (F = C),
        (V = X);
    }
    if (j === k.length) return r(w, V), kr && Pl(w, j), O;
    if (V === null) {
      for (; j < k.length; j++)
        (V = m(w, k[j], N)),
          V !== null &&
            ((S = a(V, S, j)), F === null ? (O = V) : (F.sibling = V), (F = V));
      return kr && Pl(w, j), O;
    }
    for (V = n(w, V); j < k.length; j++)
      (X = E(V, w, j, k[j], N)),
        X !== null &&
          (t && X.alternate !== null && V.delete(X.key === null ? j : X.key),
          (S = a(X, S, j)),
          F === null ? (O = X) : (F.sibling = X),
          (F = X));
    return (
      t &&
        V.forEach(function (l) {
          return e(w, l);
        }),
      kr && Pl(w, j),
      O
    );
  }
  function I(w, S, k, N) {
    var O = Ud(k);
    if (typeof O != "function") throw Error(Ge(150));
    if (((k = O.call(k)), k == null)) throw Error(Ge(151));
    for (
      var F = (O = null), V = S, j = (S = 0), X = null, C = k.next();
      V !== null && !C.done;
      j++, C = k.next()
    ) {
      V.index > j ? ((X = V), (V = null)) : (X = V.sibling);
      var l = v(w, V, C.value, N);
      if (l === null) {
        V === null && (V = X);
        break;
      }
      t && V && l.alternate === null && e(w, V),
        (S = a(l, S, j)),
        F === null ? (O = l) : (F.sibling = l),
        (F = l),
        (V = X);
    }
    if (C.done) return r(w, V), kr && Pl(w, j), O;
    if (V === null) {
      for (; !C.done; j++, C = k.next())
        (C = m(w, C.value, N)),
          C !== null &&
            ((S = a(C, S, j)), F === null ? (O = C) : (F.sibling = C), (F = C));
      return kr && Pl(w, j), O;
    }
    for (V = n(w, V); !C.done; j++, C = k.next())
      (C = E(V, w, j, C.value, N)),
        C !== null &&
          (t && C.alternate !== null && V.delete(C.key === null ? j : C.key),
          (S = a(C, S, j)),
          F === null ? (O = C) : (F.sibling = C),
          (F = C));
    return (
      t &&
        V.forEach(function (p) {
          return e(w, p);
        }),
      kr && Pl(w, j),
      O
    );
  }
  function b(w, S, k, N) {
    if (
      (typeof k == "object" &&
        k !== null &&
        k.type === v0 &&
        k.key === null &&
        (k = k.props.children),
      typeof k == "object" && k !== null)
    ) {
      switch (k.$$typeof) {
        case I1:
          e: {
            for (var O = k.key, F = S; F !== null; ) {
              if (F.key === O) {
                if (((O = k.type), O === v0)) {
                  if (F.tag === 7) {
                    r(w, F.sibling),
                      (S = i(F, k.props.children)),
                      (S.return = w),
                      (w = S);
                    break e;
                  }
                } else if (
                  F.elementType === O ||
                  (typeof O == "object" &&
                    O !== null &&
                    O.$$typeof === dc &&
                    fA(O) === F.type)
                ) {
                  r(w, F.sibling),
                    (S = i(F, k.props)),
                    (S.ref = qd(w, F, k)),
                    (S.return = w),
                    (w = S);
                  break e;
                }
                r(w, F);
                break;
              } else e(w, F);
              F = F.sibling;
            }
            k.type === v0
              ? ((S = Xl(k.props.children, w.mode, N, k.key)),
                (S.return = w),
                (w = S))
              : ((N = jy(k.type, k.key, k.props, null, w.mode, N)),
                (N.ref = qd(w, S, k)),
                (N.return = w),
                (w = N));
          }
          return s(w);
        case b0:
          e: {
            for (F = k.key; S !== null; ) {
              if (S.key === F)
                if (
                  S.tag === 4 &&
                  S.stateNode.containerInfo === k.containerInfo &&
                  S.stateNode.implementation === k.implementation
                ) {
                  r(w, S.sibling),
                    (S = i(S, k.children || [])),
                    (S.return = w),
                    (w = S);
                  break e;
                } else {
                  r(w, S);
                  break;
                }
              else e(w, S);
              S = S.sibling;
            }
            (S = Dw(k, w.mode, N)), (S.return = w), (w = S);
          }
          return s(w);
        case dc:
          return (F = k._init), b(w, S, F(k._payload), N);
      }
      if (hh(k)) return A(w, S, k, N);
      if (Ud(k)) return I(w, S, k, N);
      W1(w, k);
    }
    return (typeof k == "string" && k !== "") || typeof k == "number"
      ? ((k = "" + k),
        S !== null && S.tag === 6
          ? (r(w, S.sibling), (S = i(S, k)), (S.return = w), (w = S))
          : (r(w, S), (S = Bw(k, w.mode, N)), (S.return = w), (w = S)),
        s(w))
      : r(w, S);
  }
  return b;
}
var df = TP(!0),
  CP = TP(!1),
  wg = fl(null),
  _g = null,
  k0 = null,
  u8 = null;
function f8() {
  u8 = k0 = _g = null;
}
function d8(t) {
  var e = wg.current;
  Ar(wg), (t._currentValue = e);
}
function A6(t, e, r) {
  for (; t !== null; ) {
    var n = t.alternate;
    if (
      ((t.childLanes & e) !== e
        ? ((t.childLanes |= e), n !== null && (n.childLanes |= e))
        : n !== null && (n.childLanes & e) !== e && (n.childLanes |= e),
      t === r)
    )
      break;
    t = t.return;
  }
}
function H0(t, e) {
  (_g = t),
    (u8 = k0 = null),
    (t = t.dependencies),
    t !== null &&
      t.firstContext !== null &&
      (t.lanes & e && ($i = !0), (t.firstContext = null));
}
function ja(t) {
  var e = t._currentValue;
  if (u8 !== t)
    if (
      ((t = {
        context: t,
        memoizedValue: e,
        next: null,
      }),
      k0 === null)
    ) {
      if (_g === null) throw Error(Ge(308));
      (k0 = t),
        (_g.dependencies = {
          lanes: 0,
          firstContext: t,
        });
    } else k0 = k0.next = t;
  return e;
}
var jl = null;
function h8(t) {
  jl === null ? (jl = [t]) : jl.push(t);
}
function AP(t, e, r, n) {
  var i = e.interleaved;
  return (
    i === null ? ((r.next = r), h8(e)) : ((r.next = i.next), (i.next = r)),
    (e.interleaved = r),
    zo(t, n)
  );
}
function zo(t, e) {
  t.lanes |= e;
  var r = t.alternate;
  for (r !== null && (r.lanes |= e), r = t, t = t.return; t !== null; )
    (t.childLanes |= e),
      (r = t.alternate),
      r !== null && (r.childLanes |= e),
      (r = t),
      (t = t.return);
  return r.tag === 3 ? r.stateNode : null;
}
var hc = !1;
function p8(t) {
  t.updateQueue = {
    baseState: t.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: {
      pending: null,
      interleaved: null,
      lanes: 0,
    },
    effects: null,
  };
}
function kP(t, e) {
  (t = t.updateQueue),
    e.updateQueue === t &&
      (e.updateQueue = {
        baseState: t.baseState,
        firstBaseUpdate: t.firstBaseUpdate,
        lastBaseUpdate: t.lastBaseUpdate,
        shared: t.shared,
        effects: t.effects,
      });
}
function Uo(t, e) {
  return {
    eventTime: t,
    lane: e,
    tag: 0,
    payload: null,
    callback: null,
    next: null,
  };
}
function Pc(t, e, r) {
  var n = t.updateQueue;
  if (n === null) return null;
  if (((n = n.shared), qt & 2)) {
    var i = n.pending;
    return (
      i === null ? (e.next = e) : ((e.next = i.next), (i.next = e)),
      (n.pending = e),
      zo(t, r)
    );
  }
  return (
    (i = n.interleaved),
    i === null ? ((e.next = e), h8(n)) : ((e.next = i.next), (i.next = e)),
    (n.interleaved = e),
    zo(t, r)
  );
}
function Oy(t, e, r) {
  if (
    ((e = e.updateQueue), e !== null && ((e = e.shared), (r & 4194240) !== 0))
  ) {
    var n = e.lanes;
    (n &= t.pendingLanes), (r |= n), (e.lanes = r), X4(t, r);
  }
}
function dA(t, e) {
  var r = t.updateQueue,
    n = t.alternate;
  if (n !== null && ((n = n.updateQueue), r === n)) {
    var i = null,
      a = null;
    if (((r = r.firstBaseUpdate), r !== null)) {
      do {
        var s = {
          eventTime: r.eventTime,
          lane: r.lane,
          tag: r.tag,
          payload: r.payload,
          callback: r.callback,
          next: null,
        };
        a === null ? (i = a = s) : (a = a.next = s), (r = r.next);
      } while (r !== null);
      a === null ? (i = a = e) : (a = a.next = e);
    } else i = a = e;
    (r = {
      baseState: n.baseState,
      firstBaseUpdate: i,
      lastBaseUpdate: a,
      shared: n.shared,
      effects: n.effects,
    }),
      (t.updateQueue = r);
    return;
  }
  (t = r.lastBaseUpdate),
    t === null ? (r.firstBaseUpdate = e) : (t.next = e),
    (r.lastBaseUpdate = e);
}
function Eg(t, e, r, n) {
  var i = t.updateQueue;
  hc = !1;
  var a = i.firstBaseUpdate,
    s = i.lastBaseUpdate,
    o = i.shared.pending;
  if (o !== null) {
    i.shared.pending = null;
    var c = o,
      u = c.next;
    (c.next = null), s === null ? (a = u) : (s.next = u), (s = c);
    var d = t.alternate;
    d !== null &&
      ((d = d.updateQueue),
      (o = d.lastBaseUpdate),
      o !== s &&
        (o === null ? (d.firstBaseUpdate = u) : (o.next = u),
        (d.lastBaseUpdate = c)));
  }
  if (a !== null) {
    var m = i.baseState;
    (s = 0), (d = u = c = null), (o = a);
    do {
      var v = o.lane,
        E = o.eventTime;
      if ((n & v) === v) {
        d !== null &&
          (d = d.next =
            {
              eventTime: E,
              lane: 0,
              tag: o.tag,
              payload: o.payload,
              callback: o.callback,
              next: null,
            });
        e: {
          var A = t,
            I = o;
          switch (((v = e), (E = r), I.tag)) {
            case 1:
              if (((A = I.payload), typeof A == "function")) {
                m = A.call(E, m, v);
                break e;
              }
              m = A;
              break e;
            case 3:
              A.flags = (A.flags & -65537) | 128;
            case 0:
              if (
                ((A = I.payload),
                (v = typeof A == "function" ? A.call(E, m, v) : A),
                v == null)
              )
                break e;
              m = Jr({}, m, v);
              break e;
            case 2:
              hc = !0;
          }
        }
        o.callback !== null &&
          o.lane !== 0 &&
          ((t.flags |= 64),
          (v = i.effects),
          v === null ? (i.effects = [o]) : v.push(o));
      } else
        (E = {
          eventTime: E,
          lane: v,
          tag: o.tag,
          payload: o.payload,
          callback: o.callback,
          next: null,
        }),
          d === null ? ((u = d = E), (c = m)) : (d = d.next = E),
          (s |= v);
      if (((o = o.next), o === null)) {
        if (((o = i.shared.pending), o === null)) break;
        (v = o),
          (o = v.next),
          (v.next = null),
          (i.lastBaseUpdate = v),
          (i.shared.pending = null);
      }
    } while (!0);
    if (
      (d === null && (c = m),
      (i.baseState = c),
      (i.firstBaseUpdate = u),
      (i.lastBaseUpdate = d),
      (e = i.shared.interleaved),
      e !== null)
    ) {
      i = e;
      do (s |= i.lane), (i = i.next);
      while (i !== e);
    } else a === null && (i.shared.lanes = 0);
    (uu |= s), (t.lanes = s), (t.memoizedState = m);
  }
}
function hA(t, e, r) {
  if (((t = e.effects), (e.effects = null), t !== null))
    for (e = 0; e < t.length; e++) {
      var n = t[e],
        i = n.callback;
      if (i !== null) {
        if (((n.callback = null), (n = r), typeof i != "function"))
          throw Error(Ge(191, i));
        i.call(n);
      }
    }
}
var Sm = {},
  Xs = fl(Sm),
  fp = fl(Sm),
  dp = fl(Sm);
function Hl(t) {
  if (t === Sm) throw Error(Ge(174));
  return t;
}
function m8(t, e) {
  switch ((br(dp, e), br(fp, t), br(Xs, Sm), (t = e.nodeType), t)) {
    case 9:
    case 11:
      e = (e = e.documentElement) ? e.namespaceURI : s6(null, "");
      break;
    default:
      (t = t === 8 ? e.parentNode : e),
        (e = t.namespaceURI || null),
        (t = t.tagName),
        (e = s6(e, t));
  }
  Ar(Xs), br(Xs, e);
}
function hf() {
  Ar(Xs), Ar(fp), Ar(dp);
}
function SP(t) {
  Hl(dp.current);
  var e = Hl(Xs.current),
    r = s6(e, t.type);
  e !== r && (br(fp, t), br(Xs, r));
}
function y8(t) {
  fp.current === t && (Ar(Xs), Ar(fp));
}
var Vr = fl(0);
function Tg(t) {
  for (var e = t; e !== null; ) {
    if (e.tag === 13) {
      var r = e.memoizedState;
      if (
        r !== null &&
        ((r = r.dehydrated), r === null || r.data === "$?" || r.data === "$!")
      )
        return e;
    } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
      if (e.flags & 128) return e;
    } else if (e.child !== null) {
      (e.child.return = e), (e = e.child);
      continue;
    }
    if (e === t) break;
    for (; e.sibling === null; ) {
      if (e.return === null || e.return === t) return null;
      e = e.return;
    }
    (e.sibling.return = e.return), (e = e.sibling);
  }
  return null;
}
var Sw = [];
function g8() {
  for (var t = 0; t < Sw.length; t++)
    Sw[t]._workInProgressVersionPrimary = null;
  Sw.length = 0;
}
var Fy = Xo.ReactCurrentDispatcher,
  Mw = Xo.ReactCurrentBatchConfig,
  lu = 0,
  Zr = null,
  _n = null,
  In = null,
  Cg = !1,
  Rh = !1,
  hp = 0,
  PV = 0;
function ri() {
  throw Error(Ge(321));
}
function b8(t, e) {
  if (e === null) return !1;
  for (var r = 0; r < e.length && r < t.length; r++)
    if (!bs(t[r], e[r])) return !1;
  return !0;
}
function v8(t, e, r, n, i, a) {
  if (
    ((lu = a),
    (Zr = e),
    (e.memoizedState = null),
    (e.updateQueue = null),
    (e.lanes = 0),
    (Fy.current = t === null || t.memoizedState === null ? OV : FV),
    (t = r(n, i)),
    Rh)
  ) {
    a = 0;
    do {
      if (((Rh = !1), (hp = 0), 25 <= a)) throw Error(Ge(301));
      (a += 1),
        (In = _n = null),
        (e.updateQueue = null),
        (Fy.current = LV),
        (t = r(n, i));
    } while (Rh);
  }
  if (
    ((Fy.current = Ag),
    (e = _n !== null && _n.next !== null),
    (lu = 0),
    (In = _n = Zr = null),
    (Cg = !1),
    e)
  )
    throw Error(Ge(300));
  return t;
}
function x8() {
  var t = hp !== 0;
  return (hp = 0), t;
}
function Ns() {
  var t = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null,
  };
  return In === null ? (Zr.memoizedState = In = t) : (In = In.next = t), In;
}
function Ha() {
  if (_n === null) {
    var t = Zr.alternate;
    t = t !== null ? t.memoizedState : null;
  } else t = _n.next;
  var e = In === null ? Zr.memoizedState : In.next;
  if (e !== null) (In = e), (_n = t);
  else {
    if (t === null) throw Error(Ge(310));
    (_n = t),
      (t = {
        memoizedState: _n.memoizedState,
        baseState: _n.baseState,
        baseQueue: _n.baseQueue,
        queue: _n.queue,
        next: null,
      }),
      In === null ? (Zr.memoizedState = In = t) : (In = In.next = t);
  }
  return In;
}
function pp(t, e) {
  return typeof e == "function" ? e(t) : e;
}
function Iw(t) {
  var e = Ha(),
    r = e.queue;
  if (r === null) throw Error(Ge(311));
  r.lastRenderedReducer = t;
  var n = _n,
    i = n.baseQueue,
    a = r.pending;
  if (a !== null) {
    if (i !== null) {
      var s = i.next;
      (i.next = a.next), (a.next = s);
    }
    (n.baseQueue = i = a), (r.pending = null);
  }
  if (i !== null) {
    (a = i.next), (n = n.baseState);
    var o = (s = null),
      c = null,
      u = a;
    do {
      var d = u.lane;
      if ((lu & d) === d)
        c !== null &&
          (c = c.next =
            {
              lane: 0,
              action: u.action,
              hasEagerState: u.hasEagerState,
              eagerState: u.eagerState,
              next: null,
            }),
          (n = u.hasEagerState ? u.eagerState : t(n, u.action));
      else {
        var m = {
          lane: d,
          action: u.action,
          hasEagerState: u.hasEagerState,
          eagerState: u.eagerState,
          next: null,
        };
        c === null ? ((o = c = m), (s = n)) : (c = c.next = m),
          (Zr.lanes |= d),
          (uu |= d);
      }
      u = u.next;
    } while (u !== null && u !== a);
    c === null ? (s = n) : (c.next = o),
      bs(n, e.memoizedState) || ($i = !0),
      (e.memoizedState = n),
      (e.baseState = s),
      (e.baseQueue = c),
      (r.lastRenderedState = n);
  }
  if (((t = r.interleaved), t !== null)) {
    i = t;
    do (a = i.lane), (Zr.lanes |= a), (uu |= a), (i = i.next);
    while (i !== t);
  } else i === null && (r.lanes = 0);
  return [e.memoizedState, r.dispatch];
}
function Rw(t) {
  var e = Ha(),
    r = e.queue;
  if (r === null) throw Error(Ge(311));
  r.lastRenderedReducer = t;
  var n = r.dispatch,
    i = r.pending,
    a = e.memoizedState;
  if (i !== null) {
    r.pending = null;
    var s = (i = i.next);
    do (a = t(a, s.action)), (s = s.next);
    while (s !== i);
    bs(a, e.memoizedState) || ($i = !0),
      (e.memoizedState = a),
      e.baseQueue === null && (e.baseState = a),
      (r.lastRenderedState = a);
  }
  return [a, n];
}
function MP() {}
function IP(t, e) {
  var r = Zr,
    n = Ha(),
    i = e(),
    a = !bs(n.memoizedState, i);
  if (
    (a && ((n.memoizedState = i), ($i = !0)),
    (n = n.queue),
    w8(NP.bind(null, r, n, t), [t]),
    n.getSnapshot !== e || a || (In !== null && In.memoizedState.tag & 1))
  ) {
    if (
      ((r.flags |= 2048),
      mp(9, PP.bind(null, r, n, i, e), void 0, null),
      Nn === null)
    )
      throw Error(Ge(349));
    lu & 30 || RP(r, e, i);
  }
  return i;
}
function RP(t, e, r) {
  (t.flags |= 16384),
    (t = {
      getSnapshot: e,
      value: r,
    }),
    (e = Zr.updateQueue),
    e === null
      ? ((e = {
          lastEffect: null,
          stores: null,
        }),
        (Zr.updateQueue = e),
        (e.stores = [t]))
      : ((r = e.stores), r === null ? (e.stores = [t]) : r.push(t));
}
function PP(t, e, r, n) {
  (e.value = r), (e.getSnapshot = n), BP(e) && DP(t);
}
function NP(t, e, r) {
  return r(function () {
    BP(e) && DP(t);
  });
}
function BP(t) {
  var e = t.getSnapshot;
  t = t.value;
  try {
    var r = e();
    return !bs(t, r);
  } catch {
    return !0;
  }
}
function DP(t) {
  var e = zo(t, 1);
  e !== null && ms(e, t, 1, -1);
}
function pA(t) {
  var e = Ns();
  return (
    typeof t == "function" && (t = t()),
    (e.memoizedState = e.baseState = t),
    (t = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: pp,
      lastRenderedState: t,
    }),
    (e.queue = t),
    (t = t.dispatch = DV.bind(null, Zr, t)),
    [e.memoizedState, t]
  );
}
function mp(t, e, r, n) {
  return (
    (t = {
      tag: t,
      create: e,
      destroy: r,
      deps: n,
      next: null,
    }),
    (e = Zr.updateQueue),
    e === null
      ? ((e = {
          lastEffect: null,
          stores: null,
        }),
        (Zr.updateQueue = e),
        (e.lastEffect = t.next = t))
      : ((r = e.lastEffect),
        r === null
          ? (e.lastEffect = t.next = t)
          : ((n = r.next), (r.next = t), (t.next = n), (e.lastEffect = t))),
    t
  );
}
function OP() {
  return Ha().memoizedState;
}
function Ly(t, e, r, n) {
  var i = Ns();
  (Zr.flags |= t),
    (i.memoizedState = mp(1 | e, r, void 0, n === void 0 ? null : n));
}
function Nb(t, e, r, n) {
  var i = Ha();
  n = n === void 0 ? null : n;
  var a = void 0;
  if (_n !== null) {
    var s = _n.memoizedState;
    if (((a = s.destroy), n !== null && b8(n, s.deps))) {
      i.memoizedState = mp(e, r, a, n);
      return;
    }
  }
  (Zr.flags |= t), (i.memoizedState = mp(1 | e, r, a, n));
}
function mA(t, e) {
  return Ly(8390656, 8, t, e);
}
function w8(t, e) {
  return Nb(2048, 8, t, e);
}
function FP(t, e) {
  return Nb(4, 2, t, e);
}
function LP(t, e) {
  return Nb(4, 4, t, e);
}
function $P(t, e) {
  if (typeof e == "function")
    return (
      (t = t()),
      e(t),
      function () {
        e(null);
      }
    );
  if (e != null)
    return (
      (t = t()),
      (e.current = t),
      function () {
        e.current = null;
      }
    );
}
function UP(t, e, r) {
  return (
    (r = r != null ? r.concat([t]) : null), Nb(4, 4, $P.bind(null, e, t), r)
  );
}
function _8() {}
function WP(t, e) {
  var r = Ha();
  e = e === void 0 ? null : e;
  var n = r.memoizedState;
  return n !== null && e !== null && b8(e, n[1])
    ? n[0]
    : ((r.memoizedState = [t, e]), t);
}
function jP(t, e) {
  var r = Ha();
  e = e === void 0 ? null : e;
  var n = r.memoizedState;
  return n !== null && e !== null && b8(e, n[1])
    ? n[0]
    : ((t = t()), (r.memoizedState = [t, e]), t);
}
function HP(t, e, r) {
  return lu & 21
    ? (bs(r, e) || ((r = GR()), (Zr.lanes |= r), (uu |= r), (t.baseState = !0)),
      e)
    : (t.baseState && ((t.baseState = !1), ($i = !0)), (t.memoizedState = r));
}
function NV(t, e) {
  var r = er;
  (er = r !== 0 && 4 > r ? r : 4), t(!0);
  var n = Mw.transition;
  Mw.transition = {};
  try {
    t(!1), e();
  } finally {
    (er = r), (Mw.transition = n);
  }
}
function zP() {
  return Ha().memoizedState;
}
function BV(t, e, r) {
  var n = Bc(t);
  if (
    ((r = {
      lane: n,
      action: r,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
    qP(t))
  )
    VP(e, r);
  else if (((r = AP(t, e, r, n)), r !== null)) {
    var i = ki();
    ms(r, t, n, i), KP(r, e, n);
  }
}
function DV(t, e, r) {
  var n = Bc(t),
    i = {
      lane: n,
      action: r,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    };
  if (qP(t)) VP(e, i);
  else {
    var a = t.alternate;
    if (
      t.lanes === 0 &&
      (a === null || a.lanes === 0) &&
      ((a = e.lastRenderedReducer), a !== null)
    )
      try {
        var s = e.lastRenderedState,
          o = a(s, r);
        if (((i.hasEagerState = !0), (i.eagerState = o), bs(o, s))) {
          var c = e.interleaved;
          c === null
            ? ((i.next = i), h8(e))
            : ((i.next = c.next), (c.next = i)),
            (e.interleaved = i);
          return;
        }
      } catch {
      } finally {
      }
    (r = AP(t, e, i, n)),
      r !== null && ((i = ki()), ms(r, t, n, i), KP(r, e, n));
  }
}
function qP(t) {
  var e = t.alternate;
  return t === Zr || (e !== null && e === Zr);
}
function VP(t, e) {
  Rh = Cg = !0;
  var r = t.pending;
  r === null ? (e.next = e) : ((e.next = r.next), (r.next = e)),
    (t.pending = e);
}
function KP(t, e, r) {
  if (r & 4194240) {
    var n = e.lanes;
    (n &= t.pendingLanes), (r |= n), (e.lanes = r), X4(t, r);
  }
}
var Ag = {
    readContext: ja,
    useCallback: ri,
    useContext: ri,
    useEffect: ri,
    useImperativeHandle: ri,
    useInsertionEffect: ri,
    useLayoutEffect: ri,
    useMemo: ri,
    useReducer: ri,
    useRef: ri,
    useState: ri,
    useDebugValue: ri,
    useDeferredValue: ri,
    useTransition: ri,
    useMutableSource: ri,
    useSyncExternalStore: ri,
    useId: ri,
    unstable_isNewReconciler: !1,
  },
  OV = {
    readContext: ja,
    useCallback: function (t, e) {
      return (Ns().memoizedState = [t, e === void 0 ? null : e]), t;
    },
    useContext: ja,
    useEffect: mA,
    useImperativeHandle: function (t, e, r) {
      return (
        (r = r != null ? r.concat([t]) : null),
        Ly(4194308, 4, $P.bind(null, e, t), r)
      );
    },
    useLayoutEffect: function (t, e) {
      return Ly(4194308, 4, t, e);
    },
    useInsertionEffect: function (t, e) {
      return Ly(4, 2, t, e);
    },
    useMemo: function (t, e) {
      var r = Ns();
      return (
        (e = e === void 0 ? null : e), (t = t()), (r.memoizedState = [t, e]), t
      );
    },
    useReducer: function (t, e, r) {
      var n = Ns();
      return (
        (e = r !== void 0 ? r(e) : e),
        (n.memoizedState = n.baseState = e),
        (t = {
          pending: null,
          interleaved: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: t,
          lastRenderedState: e,
        }),
        (n.queue = t),
        (t = t.dispatch = BV.bind(null, Zr, t)),
        [n.memoizedState, t]
      );
    },
    useRef: function (t) {
      var e = Ns();
      return (
        (t = {
          current: t,
        }),
        (e.memoizedState = t)
      );
    },
    useState: pA,
    useDebugValue: _8,
    useDeferredValue: function (t) {
      return (Ns().memoizedState = t);
    },
    useTransition: function () {
      var t = pA(!1),
        e = t[0];
      return (t = NV.bind(null, t[1])), (Ns().memoizedState = t), [e, t];
    },
    useMutableSource: function () {},
    useSyncExternalStore: function (t, e, r) {
      var n = Zr,
        i = Ns();
      if (kr) {
        if (r === void 0) throw Error(Ge(407));
        r = r();
      } else {
        if (((r = e()), Nn === null)) throw Error(Ge(349));
        lu & 30 || RP(n, e, r);
      }
      i.memoizedState = r;
      var a = {
        value: r,
        getSnapshot: e,
      };
      return (
        (i.queue = a),
        mA(NP.bind(null, n, a, t), [t]),
        (n.flags |= 2048),
        mp(9, PP.bind(null, n, a, r, e), void 0, null),
        r
      );
    },
    useId: function () {
      var t = Ns(),
        e = Nn.identifierPrefix;
      if (kr) {
        var r = Fo,
          n = Oo;
        (r = (n & ~(1 << (32 - ps(n) - 1))).toString(32) + r),
          (e = ":" + e + "R" + r),
          (r = hp++),
          0 < r && (e += "H" + r.toString(32)),
          (e += ":");
      } else (r = PV++), (e = ":" + e + "r" + r.toString(32) + ":");
      return (t.memoizedState = e);
    },
    unstable_isNewReconciler: !1,
  },
  FV = {
    readContext: ja,
    useCallback: WP,
    useContext: ja,
    useEffect: w8,
    useImperativeHandle: UP,
    useInsertionEffect: FP,
    useLayoutEffect: LP,
    useMemo: jP,
    useReducer: Iw,
    useRef: OP,
    useState: function () {
      return Iw(pp);
    },
    useDebugValue: _8,
    useDeferredValue: function (t) {
      var e = Ha();
      return HP(e, _n.memoizedState, t);
    },
    useTransition: function () {
      var t = Iw(pp)[0],
        e = Ha().memoizedState;
      return [t, e];
    },
    useMutableSource: MP,
    useSyncExternalStore: IP,
    useId: zP,
    unstable_isNewReconciler: !1,
  },
  LV = {
    readContext: ja,
    useCallback: WP,
    useContext: ja,
    useEffect: w8,
    useImperativeHandle: UP,
    useInsertionEffect: FP,
    useLayoutEffect: LP,
    useMemo: jP,
    useReducer: Rw,
    useRef: OP,
    useState: function () {
      return Rw(pp);
    },
    useDebugValue: _8,
    useDeferredValue: function (t) {
      var e = Ha();
      return _n === null ? (e.memoizedState = t) : HP(e, _n.memoizedState, t);
    },
    useTransition: function () {
      var t = Rw(pp)[0],
        e = Ha().memoizedState;
      return [t, e];
    },
    useMutableSource: MP,
    useSyncExternalStore: IP,
    useId: zP,
    unstable_isNewReconciler: !1,
  };
function is(t, e) {
  if (t && t.defaultProps) {
    (e = Jr({}, e)), (t = t.defaultProps);
    for (var r in t) e[r] === void 0 && (e[r] = t[r]);
    return e;
  }
  return e;
}
function k6(t, e, r, n) {
  (e = t.memoizedState),
    (r = r(n, e)),
    (r = r == null ? e : Jr({}, e, r)),
    (t.memoizedState = r),
    t.lanes === 0 && (t.updateQueue.baseState = r);
}
var Bb = {
  isMounted: function (t) {
    return (t = t._reactInternals) ? Mu(t) === t : !1;
  },
  enqueueSetState: function (t, e, r) {
    t = t._reactInternals;
    var n = ki(),
      i = Bc(t),
      a = Uo(n, i);
    (a.payload = e),
      r != null && (a.callback = r),
      (e = Pc(t, a, i)),
      e !== null && (ms(e, t, i, n), Oy(e, t, i));
  },
  enqueueReplaceState: function (t, e, r) {
    t = t._reactInternals;
    var n = ki(),
      i = Bc(t),
      a = Uo(n, i);
    (a.tag = 1),
      (a.payload = e),
      r != null && (a.callback = r),
      (e = Pc(t, a, i)),
      e !== null && (ms(e, t, i, n), Oy(e, t, i));
  },
  enqueueForceUpdate: function (t, e) {
    t = t._reactInternals;
    var r = ki(),
      n = Bc(t),
      i = Uo(r, n);
    (i.tag = 2),
      e != null && (i.callback = e),
      (e = Pc(t, i, n)),
      e !== null && (ms(e, t, n, r), Oy(e, t, n));
  },
};
function yA(t, e, r, n, i, a, s) {
  return (
    (t = t.stateNode),
    typeof t.shouldComponentUpdate == "function"
      ? t.shouldComponentUpdate(n, a, s)
      : e.prototype && e.prototype.isPureReactComponent
      ? !op(r, n) || !op(i, a)
      : !0
  );
}
function GP(t, e, r) {
  var n = !1,
    i = Zc,
    a = e.contextType;
  return (
    typeof a == "object" && a !== null
      ? (a = ja(a))
      : ((i = ji(e) ? ou : mi.current),
        (n = e.contextTypes),
        (a = (n = n != null) ? uf(t, i) : Zc)),
    (e = new e(r, a)),
    (t.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null),
    (e.updater = Bb),
    (t.stateNode = e),
    (e._reactInternals = t),
    n &&
      ((t = t.stateNode),
      (t.__reactInternalMemoizedUnmaskedChildContext = i),
      (t.__reactInternalMemoizedMaskedChildContext = a)),
    e
  );
}
function gA(t, e, r, n) {
  (t = e.state),
    typeof e.componentWillReceiveProps == "function" &&
      e.componentWillReceiveProps(r, n),
    typeof e.UNSAFE_componentWillReceiveProps == "function" &&
      e.UNSAFE_componentWillReceiveProps(r, n),
    e.state !== t && Bb.enqueueReplaceState(e, e.state, null);
}
function S6(t, e, r, n) {
  var i = t.stateNode;
  (i.props = r), (i.state = t.memoizedState), (i.refs = {}), p8(t);
  var a = e.contextType;
  typeof a == "object" && a !== null
    ? (i.context = ja(a))
    : ((a = ji(e) ? ou : mi.current), (i.context = uf(t, a))),
    (i.state = t.memoizedState),
    (a = e.getDerivedStateFromProps),
    typeof a == "function" && (k6(t, e, a, r), (i.state = t.memoizedState)),
    typeof e.getDerivedStateFromProps == "function" ||
      typeof i.getSnapshotBeforeUpdate == "function" ||
      (typeof i.UNSAFE_componentWillMount != "function" &&
        typeof i.componentWillMount != "function") ||
      ((e = i.state),
      typeof i.componentWillMount == "function" && i.componentWillMount(),
      typeof i.UNSAFE_componentWillMount == "function" &&
        i.UNSAFE_componentWillMount(),
      e !== i.state && Bb.enqueueReplaceState(i, i.state, null),
      Eg(t, r, i, n),
      (i.state = t.memoizedState)),
    typeof i.componentDidMount == "function" && (t.flags |= 4194308);
}
function pf(t, e) {
  try {
    var r = "",
      n = e;
    do (r += dq(n)), (n = n.return);
    while (n);
    var i = r;
  } catch (a) {
    i =
      `
Error generating stack: ` +
      a.message +
      `
` +
      a.stack;
  }
  return {
    value: t,
    source: e,
    stack: i,
    digest: null,
  };
}
function Pw(t, e, r) {
  return {
    value: t,
    source: null,
    stack: r ?? null,
    digest: e ?? null,
  };
}
function M6(t, e) {
  try {
    console.error(e.value);
  } catch (r) {
    setTimeout(function () {
      throw r;
    });
  }
}
var $V = typeof WeakMap == "function" ? WeakMap : Map;
function ZP(t, e, r) {
  (r = Uo(-1, r)),
    (r.tag = 3),
    (r.payload = {
      element: null,
    });
  var n = e.value;
  return (
    (r.callback = function () {
      Sg || ((Sg = !0), ($6 = n)), M6(t, e);
    }),
    r
  );
}
function JP(t, e, r) {
  (r = Uo(-1, r)), (r.tag = 3);
  var n = t.type.getDerivedStateFromError;
  if (typeof n == "function") {
    var i = e.value;
    (r.payload = function () {
      return n(i);
    }),
      (r.callback = function () {
        M6(t, e);
      });
  }
  var a = t.stateNode;
  return (
    a !== null &&
      typeof a.componentDidCatch == "function" &&
      (r.callback = function () {
        M6(t, e),
          typeof n != "function" &&
            (Nc === null ? (Nc = new Set([this])) : Nc.add(this));
        var s = e.stack;
        this.componentDidCatch(e.value, {
          componentStack: s !== null ? s : "",
        });
      }),
    r
  );
}
function bA(t, e, r) {
  var n = t.pingCache;
  if (n === null) {
    n = t.pingCache = new $V();
    var i = new Set();
    n.set(e, i);
  } else (i = n.get(e)), i === void 0 && ((i = new Set()), n.set(e, i));
  i.has(r) || (i.add(r), (t = XV.bind(null, t, e, r)), e.then(t, t));
}
function vA(t) {
  do {
    var e;
    if (
      ((e = t.tag === 13) &&
        ((e = t.memoizedState), (e = e !== null ? e.dehydrated !== null : !0)),
      e)
    )
      return t;
    t = t.return;
  } while (t !== null);
  return null;
}
function xA(t, e, r, n, i) {
  return t.mode & 1
    ? ((t.flags |= 65536), (t.lanes = i), t)
    : (t === e
        ? (t.flags |= 65536)
        : ((t.flags |= 128),
          (r.flags |= 131072),
          (r.flags &= -52805),
          r.tag === 1 &&
            (r.alternate === null
              ? (r.tag = 17)
              : ((e = Uo(-1, 1)), (e.tag = 2), Pc(r, e, 1))),
          (r.lanes |= 1)),
      t);
}
var UV = Xo.ReactCurrentOwner,
  $i = !1;
function xi(t, e, r, n) {
  e.child = t === null ? CP(e, null, r, n) : df(e, t.child, r, n);
}
function wA(t, e, r, n, i) {
  r = r.render;
  var a = e.ref;
  return (
    H0(e, i),
    (n = v8(t, e, r, n, a, i)),
    (r = x8()),
    t !== null && !$i
      ? ((e.updateQueue = t.updateQueue),
        (e.flags &= -2053),
        (t.lanes &= ~i),
        qo(t, e, i))
      : (kr && r && o8(e), (e.flags |= 1), xi(t, e, n, i), e.child)
  );
}
function _A(t, e, r, n, i) {
  if (t === null) {
    var a = r.type;
    return typeof a == "function" &&
      !I8(a) &&
      a.defaultProps === void 0 &&
      r.compare === null &&
      r.defaultProps === void 0
      ? ((e.tag = 15), (e.type = a), QP(t, e, a, n, i))
      : ((t = jy(r.type, null, n, e, e.mode, i)),
        (t.ref = e.ref),
        (t.return = e),
        (e.child = t));
  }
  if (((a = t.child), !(t.lanes & i))) {
    var s = a.memoizedProps;
    if (
      ((r = r.compare), (r = r !== null ? r : op), r(s, n) && t.ref === e.ref)
    )
      return qo(t, e, i);
  }
  return (
    (e.flags |= 1),
    (t = Dc(a, n)),
    (t.ref = e.ref),
    (t.return = e),
    (e.child = t)
  );
}
function QP(t, e, r, n, i) {
  if (t !== null) {
    var a = t.memoizedProps;
    if (op(a, n) && t.ref === e.ref)
      if ((($i = !1), (e.pendingProps = n = a), (t.lanes & i) !== 0))
        t.flags & 131072 && ($i = !0);
      else return (e.lanes = t.lanes), qo(t, e, i);
  }
  return I6(t, e, r, n, i);
}
function YP(t, e, r) {
  var n = e.pendingProps,
    i = n.children,
    a = t !== null ? t.memoizedState : null;
  if (n.mode === "hidden")
    if (!(e.mode & 1))
      (e.memoizedState = {
        baseLanes: 0,
        cachePool: null,
        transitions: null,
      }),
        br(M0, ta),
        (ta |= r);
    else {
      if (!(r & 1073741824))
        return (
          (t = a !== null ? a.baseLanes | r : r),
          (e.lanes = e.childLanes = 1073741824),
          (e.memoizedState = {
            baseLanes: t,
            cachePool: null,
            transitions: null,
          }),
          (e.updateQueue = null),
          br(M0, ta),
          (ta |= t),
          null
        );
      (e.memoizedState = {
        baseLanes: 0,
        cachePool: null,
        transitions: null,
      }),
        (n = a !== null ? a.baseLanes : r),
        br(M0, ta),
        (ta |= n);
    }
  else
    a !== null ? ((n = a.baseLanes | r), (e.memoizedState = null)) : (n = r),
      br(M0, ta),
      (ta |= n);
  return xi(t, e, i, r), e.child;
}
function XP(t, e) {
  var r = e.ref;
  ((t === null && r !== null) || (t !== null && t.ref !== r)) &&
    ((e.flags |= 512), (e.flags |= 2097152));
}
function I6(t, e, r, n, i) {
  var a = ji(r) ? ou : mi.current;
  return (
    (a = uf(e, a)),
    H0(e, i),
    (r = v8(t, e, r, n, a, i)),
    (n = x8()),
    t !== null && !$i
      ? ((e.updateQueue = t.updateQueue),
        (e.flags &= -2053),
        (t.lanes &= ~i),
        qo(t, e, i))
      : (kr && n && o8(e), (e.flags |= 1), xi(t, e, r, i), e.child)
  );
}
function EA(t, e, r, n, i) {
  if (ji(r)) {
    var a = !0;
    bg(e);
  } else a = !1;
  if ((H0(e, i), e.stateNode === null))
    $y(t, e), GP(e, r, n), S6(e, r, n, i), (n = !0);
  else if (t === null) {
    var s = e.stateNode,
      o = e.memoizedProps;
    s.props = o;
    var c = s.context,
      u = r.contextType;
    typeof u == "object" && u !== null
      ? (u = ja(u))
      : ((u = ji(r) ? ou : mi.current), (u = uf(e, u)));
    var d = r.getDerivedStateFromProps,
      m =
        typeof d == "function" ||
        typeof s.getSnapshotBeforeUpdate == "function";
    m ||
      (typeof s.UNSAFE_componentWillReceiveProps != "function" &&
        typeof s.componentWillReceiveProps != "function") ||
      ((o !== n || c !== u) && gA(e, s, n, u)),
      (hc = !1);
    var v = e.memoizedState;
    (s.state = v),
      Eg(e, n, s, i),
      (c = e.memoizedState),
      o !== n || v !== c || Wi.current || hc
        ? (typeof d == "function" && (k6(e, r, d, n), (c = e.memoizedState)),
          (o = hc || yA(e, r, o, n, v, c, u))
            ? (m ||
                (typeof s.UNSAFE_componentWillMount != "function" &&
                  typeof s.componentWillMount != "function") ||
                (typeof s.componentWillMount == "function" &&
                  s.componentWillMount(),
                typeof s.UNSAFE_componentWillMount == "function" &&
                  s.UNSAFE_componentWillMount()),
              typeof s.componentDidMount == "function" && (e.flags |= 4194308))
            : (typeof s.componentDidMount == "function" && (e.flags |= 4194308),
              (e.memoizedProps = n),
              (e.memoizedState = c)),
          (s.props = n),
          (s.state = c),
          (s.context = u),
          (n = o))
        : (typeof s.componentDidMount == "function" && (e.flags |= 4194308),
          (n = !1));
  } else {
    (s = e.stateNode),
      kP(t, e),
      (o = e.memoizedProps),
      (u = e.type === e.elementType ? o : is(e.type, o)),
      (s.props = u),
      (m = e.pendingProps),
      (v = s.context),
      (c = r.contextType),
      typeof c == "object" && c !== null
        ? (c = ja(c))
        : ((c = ji(r) ? ou : mi.current), (c = uf(e, c)));
    var E = r.getDerivedStateFromProps;
    (d =
      typeof E == "function" ||
      typeof s.getSnapshotBeforeUpdate == "function") ||
      (typeof s.UNSAFE_componentWillReceiveProps != "function" &&
        typeof s.componentWillReceiveProps != "function") ||
      ((o !== m || v !== c) && gA(e, s, n, c)),
      (hc = !1),
      (v = e.memoizedState),
      (s.state = v),
      Eg(e, n, s, i);
    var A = e.memoizedState;
    o !== m || v !== A || Wi.current || hc
      ? (typeof E == "function" && (k6(e, r, E, n), (A = e.memoizedState)),
        (u = hc || yA(e, r, u, n, v, A, c) || !1)
          ? (d ||
              (typeof s.UNSAFE_componentWillUpdate != "function" &&
                typeof s.componentWillUpdate != "function") ||
              (typeof s.componentWillUpdate == "function" &&
                s.componentWillUpdate(n, A, c),
              typeof s.UNSAFE_componentWillUpdate == "function" &&
                s.UNSAFE_componentWillUpdate(n, A, c)),
            typeof s.componentDidUpdate == "function" && (e.flags |= 4),
            typeof s.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024))
          : (typeof s.componentDidUpdate != "function" ||
              (o === t.memoizedProps && v === t.memoizedState) ||
              (e.flags |= 4),
            typeof s.getSnapshotBeforeUpdate != "function" ||
              (o === t.memoizedProps && v === t.memoizedState) ||
              (e.flags |= 1024),
            (e.memoizedProps = n),
            (e.memoizedState = A)),
        (s.props = n),
        (s.state = A),
        (s.context = c),
        (n = u))
      : (typeof s.componentDidUpdate != "function" ||
          (o === t.memoizedProps && v === t.memoizedState) ||
          (e.flags |= 4),
        typeof s.getSnapshotBeforeUpdate != "function" ||
          (o === t.memoizedProps && v === t.memoizedState) ||
          (e.flags |= 1024),
        (n = !1));
  }
  return R6(t, e, r, n, a, i);
}
function R6(t, e, r, n, i, a) {
  XP(t, e);
  var s = (e.flags & 128) !== 0;
  if (!n && !s) return i && cA(e, r, !1), qo(t, e, a);
  (n = e.stateNode), (UV.current = e);
  var o =
    s && typeof r.getDerivedStateFromError != "function" ? null : n.render();
  return (
    (e.flags |= 1),
    t !== null && s
      ? ((e.child = df(e, t.child, null, a)), (e.child = df(e, null, o, a)))
      : xi(t, e, o, a),
    (e.memoizedState = n.state),
    i && cA(e, r, !0),
    e.child
  );
}
function eN(t) {
  var e = t.stateNode;
  e.pendingContext
    ? oA(t, e.pendingContext, e.pendingContext !== e.context)
    : e.context && oA(t, e.context, !1),
    m8(t, e.containerInfo);
}
function TA(t, e, r, n, i) {
  return ff(), l8(i), (e.flags |= 256), xi(t, e, r, n), e.child;
}
var P6 = {
  dehydrated: null,
  treeContext: null,
  retryLane: 0,
};
function N6(t) {
  return {
    baseLanes: t,
    cachePool: null,
    transitions: null,
  };
}
function tN(t, e, r) {
  var n = e.pendingProps,
    i = Vr.current,
    a = !1,
    s = (e.flags & 128) !== 0,
    o;
  if (
    ((o = s) ||
      (o = t !== null && t.memoizedState === null ? !1 : (i & 2) !== 0),
    o
      ? ((a = !0), (e.flags &= -129))
      : (t === null || t.memoizedState !== null) && (i |= 1),
    br(Vr, i & 1),
    t === null)
  )
    return (
      C6(e),
      (t = e.memoizedState),
      t !== null && ((t = t.dehydrated), t !== null)
        ? (e.mode & 1
            ? t.data === "$!"
              ? (e.lanes = 8)
              : (e.lanes = 1073741824)
            : (e.lanes = 1),
          null)
        : ((s = n.children),
          (t = n.fallback),
          a
            ? ((n = e.mode),
              (a = e.child),
              (s = {
                mode: "hidden",
                children: s,
              }),
              !(n & 1) && a !== null
                ? ((a.childLanes = 0), (a.pendingProps = s))
                : (a = Fb(s, n, 0, null)),
              (t = Xl(t, n, r, null)),
              (a.return = e),
              (t.return = e),
              (a.sibling = t),
              (e.child = a),
              (e.child.memoizedState = N6(r)),
              (e.memoizedState = P6),
              t)
            : E8(e, s))
    );
  if (((i = t.memoizedState), i !== null && ((o = i.dehydrated), o !== null)))
    return WV(t, e, s, n, o, i, r);
  if (a) {
    (a = n.fallback), (s = e.mode), (i = t.child), (o = i.sibling);
    var c = {
      mode: "hidden",
      children: n.children,
    };
    return (
      !(s & 1) && e.child !== i
        ? ((n = e.child),
          (n.childLanes = 0),
          (n.pendingProps = c),
          (e.deletions = null))
        : ((n = Dc(i, c)), (n.subtreeFlags = i.subtreeFlags & 14680064)),
      o !== null ? (a = Dc(o, a)) : ((a = Xl(a, s, r, null)), (a.flags |= 2)),
      (a.return = e),
      (n.return = e),
      (n.sibling = a),
      (e.child = n),
      (n = a),
      (a = e.child),
      (s = t.child.memoizedState),
      (s =
        s === null
          ? N6(r)
          : {
              baseLanes: s.baseLanes | r,
              cachePool: null,
              transitions: s.transitions,
            }),
      (a.memoizedState = s),
      (a.childLanes = t.childLanes & ~r),
      (e.memoizedState = P6),
      n
    );
  }
  return (
    (a = t.child),
    (t = a.sibling),
    (n = Dc(a, {
      mode: "visible",
      children: n.children,
    })),
    !(e.mode & 1) && (n.lanes = r),
    (n.return = e),
    (n.sibling = null),
    t !== null &&
      ((r = e.deletions),
      r === null ? ((e.deletions = [t]), (e.flags |= 16)) : r.push(t)),
    (e.child = n),
    (e.memoizedState = null),
    n
  );
}
function E8(t, e) {
  return (
    (e = Fb(
      {
        mode: "visible",
        children: e,
      },
      t.mode,
      0,
      null
    )),
    (e.return = t),
    (t.child = e)
  );
}
function j1(t, e, r, n) {
  return (
    n !== null && l8(n),
    df(e, t.child, null, r),
    (t = E8(e, e.pendingProps.children)),
    (t.flags |= 2),
    (e.memoizedState = null),
    t
  );
}
function WV(t, e, r, n, i, a, s) {
  if (r)
    return e.flags & 256
      ? ((e.flags &= -257), (n = Pw(Error(Ge(422)))), j1(t, e, s, n))
      : e.memoizedState !== null
      ? ((e.child = t.child), (e.flags |= 128), null)
      : ((a = n.fallback),
        (i = e.mode),
        (n = Fb(
          {
            mode: "visible",
            children: n.children,
          },
          i,
          0,
          null
        )),
        (a = Xl(a, i, s, null)),
        (a.flags |= 2),
        (n.return = e),
        (a.return = e),
        (n.sibling = a),
        (e.child = n),
        e.mode & 1 && df(e, t.child, null, s),
        (e.child.memoizedState = N6(s)),
        (e.memoizedState = P6),
        a);
  if (!(e.mode & 1)) return j1(t, e, s, null);
  if (i.data === "$!") {
    if (((n = i.nextSibling && i.nextSibling.dataset), n)) var o = n.dgst;
    return (
      (n = o), (a = Error(Ge(419))), (n = Pw(a, n, void 0)), j1(t, e, s, n)
    );
  }
  if (((o = (s & t.childLanes) !== 0), $i || o)) {
    if (((n = Nn), n !== null)) {
      switch (s & -s) {
        case 4:
          i = 2;
          break;
        case 16:
          i = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          i = 32;
          break;
        case 536870912:
          i = 268435456;
          break;
        default:
          i = 0;
      }
      (i = i & (n.suspendedLanes | s) ? 0 : i),
        i !== 0 &&
          i !== a.retryLane &&
          ((a.retryLane = i), zo(t, i), ms(n, t, i, -1));
    }
    return M8(), (n = Pw(Error(Ge(421)))), j1(t, e, s, n);
  }
  return i.data === "$?"
    ? ((e.flags |= 128),
      (e.child = t.child),
      (e = eK.bind(null, t)),
      (i._reactRetry = e),
      null)
    : ((t = a.treeContext),
      (sa = Rc(i.nextSibling)),
      (ua = e),
      (kr = !0),
      (ss = null),
      t !== null &&
        ((Ba[Da++] = Oo),
        (Ba[Da++] = Fo),
        (Ba[Da++] = cu),
        (Oo = t.id),
        (Fo = t.overflow),
        (cu = e)),
      (e = E8(e, n.children)),
      (e.flags |= 4096),
      e);
}
function CA(t, e, r) {
  t.lanes |= e;
  var n = t.alternate;
  n !== null && (n.lanes |= e), A6(t.return, e, r);
}
function Nw(t, e, r, n, i) {
  var a = t.memoizedState;
  a === null
    ? (t.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: n,
        tail: r,
        tailMode: i,
      })
    : ((a.isBackwards = e),
      (a.rendering = null),
      (a.renderingStartTime = 0),
      (a.last = n),
      (a.tail = r),
      (a.tailMode = i));
}
function rN(t, e, r) {
  var n = e.pendingProps,
    i = n.revealOrder,
    a = n.tail;
  if ((xi(t, e, n.children, r), (n = Vr.current), n & 2))
    (n = (n & 1) | 2), (e.flags |= 128);
  else {
    if (t !== null && t.flags & 128)
      e: for (t = e.child; t !== null; ) {
        if (t.tag === 13) t.memoizedState !== null && CA(t, r, e);
        else if (t.tag === 19) CA(t, r, e);
        else if (t.child !== null) {
          (t.child.return = t), (t = t.child);
          continue;
        }
        if (t === e) break e;
        for (; t.sibling === null; ) {
          if (t.return === null || t.return === e) break e;
          t = t.return;
        }
        (t.sibling.return = t.return), (t = t.sibling);
      }
    n &= 1;
  }
  if ((br(Vr, n), !(e.mode & 1))) e.memoizedState = null;
  else
    switch (i) {
      case "forwards":
        for (r = e.child, i = null; r !== null; )
          (t = r.alternate),
            t !== null && Tg(t) === null && (i = r),
            (r = r.sibling);
        (r = i),
          r === null
            ? ((i = e.child), (e.child = null))
            : ((i = r.sibling), (r.sibling = null)),
          Nw(e, !1, i, r, a);
        break;
      case "backwards":
        for (r = null, i = e.child, e.child = null; i !== null; ) {
          if (((t = i.alternate), t !== null && Tg(t) === null)) {
            e.child = i;
            break;
          }
          (t = i.sibling), (i.sibling = r), (r = i), (i = t);
        }
        Nw(e, !0, r, null, a);
        break;
      case "together":
        Nw(e, !1, null, null, void 0);
        break;
      default:
        e.memoizedState = null;
    }
  return e.child;
}
function $y(t, e) {
  !(e.mode & 1) &&
    t !== null &&
    ((t.alternate = null), (e.alternate = null), (e.flags |= 2));
}
function qo(t, e, r) {
  if (
    (t !== null && (e.dependencies = t.dependencies),
    (uu |= e.lanes),
    !(r & e.childLanes))
  )
    return null;
  if (t !== null && e.child !== t.child) throw Error(Ge(153));
  if (e.child !== null) {
    for (
      t = e.child, r = Dc(t, t.pendingProps), e.child = r, r.return = e;
      t.sibling !== null;

    )
      (t = t.sibling), (r = r.sibling = Dc(t, t.pendingProps)), (r.return = e);
    r.sibling = null;
  }
  return e.child;
}
function jV(t, e, r) {
  switch (e.tag) {
    case 3:
      eN(e), ff();
      break;
    case 5:
      SP(e);
      break;
    case 1:
      ji(e.type) && bg(e);
      break;
    case 4:
      m8(e, e.stateNode.containerInfo);
      break;
    case 10:
      var n = e.type._context,
        i = e.memoizedProps.value;
      br(wg, n._currentValue), (n._currentValue = i);
      break;
    case 13:
      if (((n = e.memoizedState), n !== null))
        return n.dehydrated !== null
          ? (br(Vr, Vr.current & 1), (e.flags |= 128), null)
          : r & e.child.childLanes
          ? tN(t, e, r)
          : (br(Vr, Vr.current & 1),
            (t = qo(t, e, r)),
            t !== null ? t.sibling : null);
      br(Vr, Vr.current & 1);
      break;
    case 19:
      if (((n = (r & e.childLanes) !== 0), t.flags & 128)) {
        if (n) return rN(t, e, r);
        e.flags |= 128;
      }
      if (
        ((i = e.memoizedState),
        i !== null &&
          ((i.rendering = null), (i.tail = null), (i.lastEffect = null)),
        br(Vr, Vr.current),
        n)
      )
        break;
      return null;
    case 22:
    case 23:
      return (e.lanes = 0), YP(t, e, r);
  }
  return qo(t, e, r);
}
var nN, B6, iN, aN;
nN = function (t, e) {
  for (var r = e.child; r !== null; ) {
    if (r.tag === 5 || r.tag === 6) t.appendChild(r.stateNode);
    else if (r.tag !== 4 && r.child !== null) {
      (r.child.return = r), (r = r.child);
      continue;
    }
    if (r === e) break;
    for (; r.sibling === null; ) {
      if (r.return === null || r.return === e) return;
      r = r.return;
    }
    (r.sibling.return = r.return), (r = r.sibling);
  }
};
B6 = function () {};
iN = function (t, e, r, n) {
  var i = t.memoizedProps;
  if (i !== n) {
    (t = e.stateNode), Hl(Xs.current);
    var a = null;
    switch (r) {
      case "input":
        (i = r6(t, i)), (n = r6(t, n)), (a = []);
        break;
      case "select":
        (i = Jr({}, i, {
          value: void 0,
        })),
          (n = Jr({}, n, {
            value: void 0,
          })),
          (a = []);
        break;
      case "textarea":
        (i = a6(t, i)), (n = a6(t, n)), (a = []);
        break;
      default:
        typeof i.onClick != "function" &&
          typeof n.onClick == "function" &&
          (t.onclick = yg);
    }
    o6(r, n);
    var s;
    r = null;
    for (u in i)
      if (!n.hasOwnProperty(u) && i.hasOwnProperty(u) && i[u] != null)
        if (u === "style") {
          var o = i[u];
          for (s in o) o.hasOwnProperty(s) && (r || (r = {}), (r[s] = ""));
        } else
          u !== "dangerouslySetInnerHTML" &&
            u !== "children" &&
            u !== "suppressContentEditableWarning" &&
            u !== "suppressHydrationWarning" &&
            u !== "autoFocus" &&
            (ep.hasOwnProperty(u)
              ? a || (a = [])
              : (a = a || []).push(u, null));
    for (u in n) {
      var c = n[u];
      if (
        ((o = i != null ? i[u] : void 0),
        n.hasOwnProperty(u) && c !== o && (c != null || o != null))
      )
        if (u === "style")
          if (o) {
            for (s in o)
              !o.hasOwnProperty(s) ||
                (c && c.hasOwnProperty(s)) ||
                (r || (r = {}), (r[s] = ""));
            for (s in c)
              c.hasOwnProperty(s) &&
                o[s] !== c[s] &&
                (r || (r = {}), (r[s] = c[s]));
          } else r || (a || (a = []), a.push(u, r)), (r = c);
        else
          u === "dangerouslySetInnerHTML"
            ? ((c = c ? c.__html : void 0),
              (o = o ? o.__html : void 0),
              c != null && o !== c && (a = a || []).push(u, c))
            : u === "children"
            ? (typeof c != "string" && typeof c != "number") ||
              (a = a || []).push(u, "" + c)
            : u !== "suppressContentEditableWarning" &&
              u !== "suppressHydrationWarning" &&
              (ep.hasOwnProperty(u)
                ? (c != null && u === "onScroll" && Cr("scroll", t),
                  a || o === c || (a = []))
                : (a = a || []).push(u, c));
    }
    r && (a = a || []).push("style", r);
    var u = a;
    (e.updateQueue = u) && (e.flags |= 4);
  }
};
aN = function (t, e, r, n) {
  r !== n && (e.flags |= 4);
};
function Vd(t, e) {
  if (!kr)
    switch (t.tailMode) {
      case "hidden":
        e = t.tail;
        for (var r = null; e !== null; )
          e.alternate !== null && (r = e), (e = e.sibling);
        r === null ? (t.tail = null) : (r.sibling = null);
        break;
      case "collapsed":
        r = t.tail;
        for (var n = null; r !== null; )
          r.alternate !== null && (n = r), (r = r.sibling);
        n === null
          ? e || t.tail === null
            ? (t.tail = null)
            : (t.tail.sibling = null)
          : (n.sibling = null);
    }
}
function ni(t) {
  var e = t.alternate !== null && t.alternate.child === t.child,
    r = 0,
    n = 0;
  if (e)
    for (var i = t.child; i !== null; )
      (r |= i.lanes | i.childLanes),
        (n |= i.subtreeFlags & 14680064),
        (n |= i.flags & 14680064),
        (i.return = t),
        (i = i.sibling);
  else
    for (i = t.child; i !== null; )
      (r |= i.lanes | i.childLanes),
        (n |= i.subtreeFlags),
        (n |= i.flags),
        (i.return = t),
        (i = i.sibling);
  return (t.subtreeFlags |= n), (t.childLanes = r), e;
}
function HV(t, e, r) {
  var n = e.pendingProps;
  switch ((c8(e), e.tag)) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return ni(e), null;
    case 1:
      return ji(e.type) && gg(), ni(e), null;
    case 3:
      return (
        (n = e.stateNode),
        hf(),
        Ar(Wi),
        Ar(mi),
        g8(),
        n.pendingContext &&
          ((n.context = n.pendingContext), (n.pendingContext = null)),
        (t === null || t.child === null) &&
          (U1(e)
            ? (e.flags |= 4)
            : t === null ||
              (t.memoizedState.isDehydrated && !(e.flags & 256)) ||
              ((e.flags |= 1024), ss !== null && (j6(ss), (ss = null)))),
        B6(t, e),
        ni(e),
        null
      );
    case 5:
      y8(e);
      var i = Hl(dp.current);
      if (((r = e.type), t !== null && e.stateNode != null))
        iN(t, e, r, n, i),
          t.ref !== e.ref && ((e.flags |= 512), (e.flags |= 2097152));
      else {
        if (!n) {
          if (e.stateNode === null) throw Error(Ge(166));
          return ni(e), null;
        }
        if (((t = Hl(Xs.current)), U1(e))) {
          (n = e.stateNode), (r = e.type);
          var a = e.memoizedProps;
          switch (((n[Ws] = e), (n[up] = a), (t = (e.mode & 1) !== 0), r)) {
            case "dialog":
              Cr("cancel", n), Cr("close", n);
              break;
            case "iframe":
            case "object":
            case "embed":
              Cr("load", n);
              break;
            case "video":
            case "audio":
              for (i = 0; i < mh.length; i++) Cr(mh[i], n);
              break;
            case "source":
              Cr("error", n);
              break;
            case "img":
            case "image":
            case "link":
              Cr("error", n), Cr("load", n);
              break;
            case "details":
              Cr("toggle", n);
              break;
            case "input":
              BC(n, a), Cr("invalid", n);
              break;
            case "select":
              (n._wrapperState = {
                wasMultiple: !!a.multiple,
              }),
                Cr("invalid", n);
              break;
            case "textarea":
              OC(n, a), Cr("invalid", n);
          }
          o6(r, a), (i = null);
          for (var s in a)
            if (a.hasOwnProperty(s)) {
              var o = a[s];
              s === "children"
                ? typeof o == "string"
                  ? n.textContent !== o &&
                    (a.suppressHydrationWarning !== !0 &&
                      $1(n.textContent, o, t),
                    (i = ["children", o]))
                  : typeof o == "number" &&
                    n.textContent !== "" + o &&
                    (a.suppressHydrationWarning !== !0 &&
                      $1(n.textContent, o, t),
                    (i = ["children", "" + o]))
                : ep.hasOwnProperty(s) &&
                  o != null &&
                  s === "onScroll" &&
                  Cr("scroll", n);
            }
          switch (r) {
            case "input":
              R1(n), DC(n, a, !0);
              break;
            case "textarea":
              R1(n), FC(n);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof a.onClick == "function" && (n.onclick = yg);
          }
          (n = i), (e.updateQueue = n), n !== null && (e.flags |= 4);
        } else {
          (s = i.nodeType === 9 ? i : i.ownerDocument),
            t === "http://www.w3.org/1999/xhtml" && (t = NR(r)),
            t === "http://www.w3.org/1999/xhtml"
              ? r === "script"
                ? ((t = s.createElement("div")),
                  (t.innerHTML = "<script></script>"),
                  (t = t.removeChild(t.firstChild)))
                : typeof n.is == "string"
                ? (t = s.createElement(r, {
                    is: n.is,
                  }))
                : ((t = s.createElement(r)),
                  r === "select" &&
                    ((s = t),
                    n.multiple
                      ? (s.multiple = !0)
                      : n.size && (s.size = n.size)))
              : (t = s.createElementNS(t, r)),
            (t[Ws] = e),
            (t[up] = n),
            nN(t, e, !1, !1),
            (e.stateNode = t);
          e: {
            switch (((s = c6(r, n)), r)) {
              case "dialog":
                Cr("cancel", t), Cr("close", t), (i = n);
                break;
              case "iframe":
              case "object":
              case "embed":
                Cr("load", t), (i = n);
                break;
              case "video":
              case "audio":
                for (i = 0; i < mh.length; i++) Cr(mh[i], t);
                i = n;
                break;
              case "source":
                Cr("error", t), (i = n);
                break;
              case "img":
              case "image":
              case "link":
                Cr("error", t), Cr("load", t), (i = n);
                break;
              case "details":
                Cr("toggle", t), (i = n);
                break;
              case "input":
                BC(t, n), (i = r6(t, n)), Cr("invalid", t);
                break;
              case "option":
                i = n;
                break;
              case "select":
                (t._wrapperState = {
                  wasMultiple: !!n.multiple,
                }),
                  (i = Jr({}, n, {
                    value: void 0,
                  })),
                  Cr("invalid", t);
                break;
              case "textarea":
                OC(t, n), (i = a6(t, n)), Cr("invalid", t);
                break;
              default:
                i = n;
            }
            o6(r, i), (o = i);
            for (a in o)
              if (o.hasOwnProperty(a)) {
                var c = o[a];
                a === "style"
                  ? OR(t, c)
                  : a === "dangerouslySetInnerHTML"
                  ? ((c = c ? c.__html : void 0), c != null && BR(t, c))
                  : a === "children"
                  ? typeof c == "string"
                    ? (r !== "textarea" || c !== "") && tp(t, c)
                    : typeof c == "number" && tp(t, "" + c)
                  : a !== "suppressContentEditableWarning" &&
                    a !== "suppressHydrationWarning" &&
                    a !== "autoFocus" &&
                    (ep.hasOwnProperty(a)
                      ? c != null && a === "onScroll" && Cr("scroll", t)
                      : c != null && K4(t, a, c, s));
              }
            switch (r) {
              case "input":
                R1(t), DC(t, n, !1);
                break;
              case "textarea":
                R1(t), FC(t);
                break;
              case "option":
                n.value != null && t.setAttribute("value", "" + Gc(n.value));
                break;
              case "select":
                (t.multiple = !!n.multiple),
                  (a = n.value),
                  a != null
                    ? $0(t, !!n.multiple, a, !1)
                    : n.defaultValue != null &&
                      $0(t, !!n.multiple, n.defaultValue, !0);
                break;
              default:
                typeof i.onClick == "function" && (t.onclick = yg);
            }
            switch (r) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                n = !!n.autoFocus;
                break e;
              case "img":
                n = !0;
                break e;
              default:
                n = !1;
            }
          }
          n && (e.flags |= 4);
        }
        e.ref !== null && ((e.flags |= 512), (e.flags |= 2097152));
      }
      return ni(e), null;
    case 6:
      if (t && e.stateNode != null) aN(t, e, t.memoizedProps, n);
      else {
        if (typeof n != "string" && e.stateNode === null) throw Error(Ge(166));
        if (((r = Hl(dp.current)), Hl(Xs.current), U1(e))) {
          if (
            ((n = e.stateNode),
            (r = e.memoizedProps),
            (n[Ws] = e),
            (a = n.nodeValue !== r) && ((t = ua), t !== null))
          )
            switch (t.tag) {
              case 3:
                $1(n.nodeValue, r, (t.mode & 1) !== 0);
                break;
              case 5:
                t.memoizedProps.suppressHydrationWarning !== !0 &&
                  $1(n.nodeValue, r, (t.mode & 1) !== 0);
            }
          a && (e.flags |= 4);
        } else
          (n = (r.nodeType === 9 ? r : r.ownerDocument).createTextNode(n)),
            (n[Ws] = e),
            (e.stateNode = n);
      }
      return ni(e), null;
    case 13:
      if (
        (Ar(Vr),
        (n = e.memoizedState),
        t === null ||
          (t.memoizedState !== null && t.memoizedState.dehydrated !== null))
      ) {
        if (kr && sa !== null && e.mode & 1 && !(e.flags & 128))
          EP(), ff(), (e.flags |= 98560), (a = !1);
        else if (((a = U1(e)), n !== null && n.dehydrated !== null)) {
          if (t === null) {
            if (!a) throw Error(Ge(318));
            if (
              ((a = e.memoizedState),
              (a = a !== null ? a.dehydrated : null),
              !a)
            )
              throw Error(Ge(317));
            a[Ws] = e;
          } else
            ff(), !(e.flags & 128) && (e.memoizedState = null), (e.flags |= 4);
          ni(e), (a = !1);
        } else ss !== null && (j6(ss), (ss = null)), (a = !0);
        if (!a) return e.flags & 65536 ? e : null;
      }
      return e.flags & 128
        ? ((e.lanes = r), e)
        : ((n = n !== null),
          n !== (t !== null && t.memoizedState !== null) &&
            n &&
            ((e.child.flags |= 8192),
            e.mode & 1 &&
              (t === null || Vr.current & 1 ? Cn === 0 && (Cn = 3) : M8())),
          e.updateQueue !== null && (e.flags |= 4),
          ni(e),
          null);
    case 4:
      return (
        hf(), B6(t, e), t === null && cp(e.stateNode.containerInfo), ni(e), null
      );
    case 10:
      return d8(e.type._context), ni(e), null;
    case 17:
      return ji(e.type) && gg(), ni(e), null;
    case 19:
      if ((Ar(Vr), (a = e.memoizedState), a === null)) return ni(e), null;
      if (((n = (e.flags & 128) !== 0), (s = a.rendering), s === null))
        if (n) Vd(a, !1);
        else {
          if (Cn !== 0 || (t !== null && t.flags & 128))
            for (t = e.child; t !== null; ) {
              if (((s = Tg(t)), s !== null)) {
                for (
                  e.flags |= 128,
                    Vd(a, !1),
                    n = s.updateQueue,
                    n !== null && ((e.updateQueue = n), (e.flags |= 4)),
                    e.subtreeFlags = 0,
                    n = r,
                    r = e.child;
                  r !== null;

                )
                  (a = r),
                    (t = n),
                    (a.flags &= 14680066),
                    (s = a.alternate),
                    s === null
                      ? ((a.childLanes = 0),
                        (a.lanes = t),
                        (a.child = null),
                        (a.subtreeFlags = 0),
                        (a.memoizedProps = null),
                        (a.memoizedState = null),
                        (a.updateQueue = null),
                        (a.dependencies = null),
                        (a.stateNode = null))
                      : ((a.childLanes = s.childLanes),
                        (a.lanes = s.lanes),
                        (a.child = s.child),
                        (a.subtreeFlags = 0),
                        (a.deletions = null),
                        (a.memoizedProps = s.memoizedProps),
                        (a.memoizedState = s.memoizedState),
                        (a.updateQueue = s.updateQueue),
                        (a.type = s.type),
                        (t = s.dependencies),
                        (a.dependencies =
                          t === null
                            ? null
                            : {
                                lanes: t.lanes,
                                firstContext: t.firstContext,
                              })),
                    (r = r.sibling);
                return br(Vr, (Vr.current & 1) | 2), e.child;
              }
              t = t.sibling;
            }
          a.tail !== null &&
            on() > mf &&
            ((e.flags |= 128), (n = !0), Vd(a, !1), (e.lanes = 4194304));
        }
      else {
        if (!n)
          if (((t = Tg(s)), t !== null)) {
            if (
              ((e.flags |= 128),
              (n = !0),
              (r = t.updateQueue),
              r !== null && ((e.updateQueue = r), (e.flags |= 4)),
              Vd(a, !0),
              a.tail === null && a.tailMode === "hidden" && !s.alternate && !kr)
            )
              return ni(e), null;
          } else
            2 * on() - a.renderingStartTime > mf &&
              r !== 1073741824 &&
              ((e.flags |= 128), (n = !0), Vd(a, !1), (e.lanes = 4194304));
        a.isBackwards
          ? ((s.sibling = e.child), (e.child = s))
          : ((r = a.last),
            r !== null ? (r.sibling = s) : (e.child = s),
            (a.last = s));
      }
      return a.tail !== null
        ? ((e = a.tail),
          (a.rendering = e),
          (a.tail = e.sibling),
          (a.renderingStartTime = on()),
          (e.sibling = null),
          (r = Vr.current),
          br(Vr, n ? (r & 1) | 2 : r & 1),
          e)
        : (ni(e), null);
    case 22:
    case 23:
      return (
        S8(),
        (n = e.memoizedState !== null),
        t !== null && (t.memoizedState !== null) !== n && (e.flags |= 8192),
        n && e.mode & 1
          ? ta & 1073741824 && (ni(e), e.subtreeFlags & 6 && (e.flags |= 8192))
          : ni(e),
        null
      );
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(Ge(156, e.tag));
}
function zV(t, e) {
  switch ((c8(e), e.tag)) {
    case 1:
      return (
        ji(e.type) && gg(),
        (t = e.flags),
        t & 65536 ? ((e.flags = (t & -65537) | 128), e) : null
      );
    case 3:
      return (
        hf(),
        Ar(Wi),
        Ar(mi),
        g8(),
        (t = e.flags),
        t & 65536 && !(t & 128) ? ((e.flags = (t & -65537) | 128), e) : null
      );
    case 5:
      return y8(e), null;
    case 13:
      if (
        (Ar(Vr), (t = e.memoizedState), t !== null && t.dehydrated !== null)
      ) {
        if (e.alternate === null) throw Error(Ge(340));
        ff();
      }
      return (
        (t = e.flags), t & 65536 ? ((e.flags = (t & -65537) | 128), e) : null
      );
    case 19:
      return Ar(Vr), null;
    case 4:
      return hf(), null;
    case 10:
      return d8(e.type._context), null;
    case 22:
    case 23:
      return S8(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var H1 = !1,
  oi = !1,
  qV = typeof WeakSet == "function" ? WeakSet : Set,
  rt = null;
function S0(t, e) {
  var r = t.ref;
  if (r !== null)
    if (typeof r == "function")
      try {
        r(null);
      } catch (n) {
        tn(t, e, n);
      }
    else r.current = null;
}
function D6(t, e, r) {
  try {
    r();
  } catch (n) {
    tn(t, e, n);
  }
}
var AA = !1;
function VV(t, e) {
  if (((b6 = hg), (t = uP()), s8(t))) {
    if ("selectionStart" in t)
      var r = {
        start: t.selectionStart,
        end: t.selectionEnd,
      };
    else
      e: {
        r = ((r = t.ownerDocument) && r.defaultView) || window;
        var n = r.getSelection && r.getSelection();
        if (n && n.rangeCount !== 0) {
          r = n.anchorNode;
          var i = n.anchorOffset,
            a = n.focusNode;
          n = n.focusOffset;
          try {
            r.nodeType, a.nodeType;
          } catch {
            r = null;
            break e;
          }
          var s = 0,
            o = -1,
            c = -1,
            u = 0,
            d = 0,
            m = t,
            v = null;
          t: for (;;) {
            for (
              var E;
              m !== r || (i !== 0 && m.nodeType !== 3) || (o = s + i),
                m !== a || (n !== 0 && m.nodeType !== 3) || (c = s + n),
                m.nodeType === 3 && (s += m.nodeValue.length),
                (E = m.firstChild) !== null;

            )
              (v = m), (m = E);
            for (;;) {
              if (m === t) break t;
              if (
                (v === r && ++u === i && (o = s),
                v === a && ++d === n && (c = s),
                (E = m.nextSibling) !== null)
              )
                break;
              (m = v), (v = m.parentNode);
            }
            m = E;
          }
          r =
            o === -1 || c === -1
              ? null
              : {
                  start: o,
                  end: c,
                };
        } else r = null;
      }
    r = r || {
      start: 0,
      end: 0,
    };
  } else r = null;
  for (
    v6 = {
      focusedElem: t,
      selectionRange: r,
    },
      hg = !1,
      rt = e;
    rt !== null;

  )
    if (((e = rt), (t = e.child), (e.subtreeFlags & 1028) !== 0 && t !== null))
      (t.return = e), (rt = t);
    else
      for (; rt !== null; ) {
        e = rt;
        try {
          var A = e.alternate;
          if (e.flags & 1024)
            switch (e.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (A !== null) {
                  var I = A.memoizedProps,
                    b = A.memoizedState,
                    w = e.stateNode,
                    S = w.getSnapshotBeforeUpdate(
                      e.elementType === e.type ? I : is(e.type, I),
                      b
                    );
                  w.__reactInternalSnapshotBeforeUpdate = S;
                }
                break;
              case 3:
                var k = e.stateNode.containerInfo;
                k.nodeType === 1
                  ? (k.textContent = "")
                  : k.nodeType === 9 &&
                    k.documentElement &&
                    k.removeChild(k.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(Ge(163));
            }
        } catch (N) {
          tn(e, e.return, N);
        }
        if (((t = e.sibling), t !== null)) {
          (t.return = e.return), (rt = t);
          break;
        }
        rt = e.return;
      }
  return (A = AA), (AA = !1), A;
}
function Ph(t, e, r) {
  var n = e.updateQueue;
  if (((n = n !== null ? n.lastEffect : null), n !== null)) {
    var i = (n = n.next);
    do {
      if ((i.tag & t) === t) {
        var a = i.destroy;
        (i.destroy = void 0), a !== void 0 && D6(e, r, a);
      }
      i = i.next;
    } while (i !== n);
  }
}
function Db(t, e) {
  if (
    ((e = e.updateQueue), (e = e !== null ? e.lastEffect : null), e !== null)
  ) {
    var r = (e = e.next);
    do {
      if ((r.tag & t) === t) {
        var n = r.create;
        r.destroy = n();
      }
      r = r.next;
    } while (r !== e);
  }
}
function O6(t) {
  var e = t.ref;
  if (e !== null) {
    var r = t.stateNode;
    switch (t.tag) {
      case 5:
        t = r;
        break;
      default:
        t = r;
    }
    typeof e == "function" ? e(t) : (e.current = t);
  }
}
function sN(t) {
  var e = t.alternate;
  e !== null && ((t.alternate = null), sN(e)),
    (t.child = null),
    (t.deletions = null),
    (t.sibling = null),
    t.tag === 5 &&
      ((e = t.stateNode),
      e !== null &&
        (delete e[Ws], delete e[up], delete e[_6], delete e[SV], delete e[MV])),
    (t.stateNode = null),
    (t.return = null),
    (t.dependencies = null),
    (t.memoizedProps = null),
    (t.memoizedState = null),
    (t.pendingProps = null),
    (t.stateNode = null),
    (t.updateQueue = null);
}
function oN(t) {
  return t.tag === 5 || t.tag === 3 || t.tag === 4;
}
function kA(t) {
  e: for (;;) {
    for (; t.sibling === null; ) {
      if (t.return === null || oN(t.return)) return null;
      t = t.return;
    }
    for (
      t.sibling.return = t.return, t = t.sibling;
      t.tag !== 5 && t.tag !== 6 && t.tag !== 18;

    ) {
      if (t.flags & 2 || t.child === null || t.tag === 4) continue e;
      (t.child.return = t), (t = t.child);
    }
    if (!(t.flags & 2)) return t.stateNode;
  }
}
function F6(t, e, r) {
  var n = t.tag;
  if (n === 5 || n === 6)
    (t = t.stateNode),
      e
        ? r.nodeType === 8
          ? r.parentNode.insertBefore(t, e)
          : r.insertBefore(t, e)
        : (r.nodeType === 8
            ? ((e = r.parentNode), e.insertBefore(t, r))
            : ((e = r), e.appendChild(t)),
          (r = r._reactRootContainer),
          r != null || e.onclick !== null || (e.onclick = yg));
  else if (n !== 4 && ((t = t.child), t !== null))
    for (F6(t, e, r), t = t.sibling; t !== null; ) F6(t, e, r), (t = t.sibling);
}
function L6(t, e, r) {
  var n = t.tag;
  if (n === 5 || n === 6)
    (t = t.stateNode), e ? r.insertBefore(t, e) : r.appendChild(t);
  else if (n !== 4 && ((t = t.child), t !== null))
    for (L6(t, e, r), t = t.sibling; t !== null; ) L6(t, e, r), (t = t.sibling);
}
var Wn = null,
  as = !1;
function rc(t, e, r) {
  for (r = r.child; r !== null; ) cN(t, e, r), (r = r.sibling);
}
function cN(t, e, r) {
  if (Ys && typeof Ys.onCommitFiberUnmount == "function")
    try {
      Ys.onCommitFiberUnmount(kb, r);
    } catch {}
  switch (r.tag) {
    case 5:
      oi || S0(r, e);
    case 6:
      var n = Wn,
        i = as;
      (Wn = null),
        rc(t, e, r),
        (Wn = n),
        (as = i),
        Wn !== null &&
          (as
            ? ((t = Wn),
              (r = r.stateNode),
              t.nodeType === 8 ? t.parentNode.removeChild(r) : t.removeChild(r))
            : Wn.removeChild(r.stateNode));
      break;
    case 18:
      Wn !== null &&
        (as
          ? ((t = Wn),
            (r = r.stateNode),
            t.nodeType === 8
              ? Aw(t.parentNode, r)
              : t.nodeType === 1 && Aw(t, r),
            ap(t))
          : Aw(Wn, r.stateNode));
      break;
    case 4:
      (n = Wn),
        (i = as),
        (Wn = r.stateNode.containerInfo),
        (as = !0),
        rc(t, e, r),
        (Wn = n),
        (as = i);
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (
        !oi &&
        ((n = r.updateQueue), n !== null && ((n = n.lastEffect), n !== null))
      ) {
        i = n = n.next;
        do {
          var a = i,
            s = a.destroy;
          (a = a.tag),
            s !== void 0 && (a & 2 || a & 4) && D6(r, e, s),
            (i = i.next);
        } while (i !== n);
      }
      rc(t, e, r);
      break;
    case 1:
      if (
        !oi &&
        (S0(r, e),
        (n = r.stateNode),
        typeof n.componentWillUnmount == "function")
      )
        try {
          (n.props = r.memoizedProps),
            (n.state = r.memoizedState),
            n.componentWillUnmount();
        } catch (o) {
          tn(r, e, o);
        }
      rc(t, e, r);
      break;
    case 21:
      rc(t, e, r);
      break;
    case 22:
      r.mode & 1
        ? ((oi = (n = oi) || r.memoizedState !== null), rc(t, e, r), (oi = n))
        : rc(t, e, r);
      break;
    default:
      rc(t, e, r);
  }
}
function SA(t) {
  var e = t.updateQueue;
  if (e !== null) {
    t.updateQueue = null;
    var r = t.stateNode;
    r === null && (r = t.stateNode = new qV()),
      e.forEach(function (n) {
        var i = tK.bind(null, t, n);
        r.has(n) || (r.add(n), n.then(i, i));
      });
  }
}
function Ya(t, e) {
  var r = e.deletions;
  if (r !== null)
    for (var n = 0; n < r.length; n++) {
      var i = r[n];
      try {
        var a = t,
          s = e,
          o = s;
        e: for (; o !== null; ) {
          switch (o.tag) {
            case 5:
              (Wn = o.stateNode), (as = !1);
              break e;
            case 3:
              (Wn = o.stateNode.containerInfo), (as = !0);
              break e;
            case 4:
              (Wn = o.stateNode.containerInfo), (as = !0);
              break e;
          }
          o = o.return;
        }
        if (Wn === null) throw Error(Ge(160));
        cN(a, s, i), (Wn = null), (as = !1);
        var c = i.alternate;
        c !== null && (c.return = null), (i.return = null);
      } catch (u) {
        tn(i, e, u);
      }
    }
  if (e.subtreeFlags & 12854)
    for (e = e.child; e !== null; ) lN(e, t), (e = e.sibling);
}
function lN(t, e) {
  var r = t.alternate,
    n = t.flags;
  switch (t.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if ((Ya(e, t), ks(t), n & 4)) {
        try {
          Ph(3, t, t.return), Db(3, t);
        } catch (I) {
          tn(t, t.return, I);
        }
        try {
          Ph(5, t, t.return);
        } catch (I) {
          tn(t, t.return, I);
        }
      }
      break;
    case 1:
      Ya(e, t), ks(t), n & 512 && r !== null && S0(r, r.return);
      break;
    case 5:
      if (
        (Ya(e, t),
        ks(t),
        n & 512 && r !== null && S0(r, r.return),
        t.flags & 32)
      ) {
        var i = t.stateNode;
        try {
          tp(i, "");
        } catch (I) {
          tn(t, t.return, I);
        }
      }
      if (n & 4 && ((i = t.stateNode), i != null)) {
        var a = t.memoizedProps,
          s = r !== null ? r.memoizedProps : a,
          o = t.type,
          c = t.updateQueue;
        if (((t.updateQueue = null), c !== null))
          try {
            o === "input" && a.type === "radio" && a.name != null && RR(i, a),
              c6(o, s);
            var u = c6(o, a);
            for (s = 0; s < c.length; s += 2) {
              var d = c[s],
                m = c[s + 1];
              d === "style"
                ? OR(i, m)
                : d === "dangerouslySetInnerHTML"
                ? BR(i, m)
                : d === "children"
                ? tp(i, m)
                : K4(i, d, m, u);
            }
            switch (o) {
              case "input":
                n6(i, a);
                break;
              case "textarea":
                PR(i, a);
                break;
              case "select":
                var v = i._wrapperState.wasMultiple;
                i._wrapperState.wasMultiple = !!a.multiple;
                var E = a.value;
                E != null
                  ? $0(i, !!a.multiple, E, !1)
                  : v !== !!a.multiple &&
                    (a.defaultValue != null
                      ? $0(i, !!a.multiple, a.defaultValue, !0)
                      : $0(i, !!a.multiple, a.multiple ? [] : "", !1));
            }
            i[up] = a;
          } catch (I) {
            tn(t, t.return, I);
          }
      }
      break;
    case 6:
      if ((Ya(e, t), ks(t), n & 4)) {
        if (t.stateNode === null) throw Error(Ge(162));
        (i = t.stateNode), (a = t.memoizedProps);
        try {
          i.nodeValue = a;
        } catch (I) {
          tn(t, t.return, I);
        }
      }
      break;
    case 3:
      if (
        (Ya(e, t), ks(t), n & 4 && r !== null && r.memoizedState.isDehydrated)
      )
        try {
          ap(e.containerInfo);
        } catch (I) {
          tn(t, t.return, I);
        }
      break;
    case 4:
      Ya(e, t), ks(t);
      break;
    case 13:
      Ya(e, t),
        ks(t),
        (i = t.child),
        i.flags & 8192 &&
          ((a = i.memoizedState !== null),
          (i.stateNode.isHidden = a),
          !a ||
            (i.alternate !== null && i.alternate.memoizedState !== null) ||
            (A8 = on())),
        n & 4 && SA(t);
      break;
    case 22:
      if (
        ((d = r !== null && r.memoizedState !== null),
        t.mode & 1 ? ((oi = (u = oi) || d), Ya(e, t), (oi = u)) : Ya(e, t),
        ks(t),
        n & 8192)
      ) {
        if (
          ((u = t.memoizedState !== null),
          (t.stateNode.isHidden = u) && !d && t.mode & 1)
        )
          for (rt = t, d = t.child; d !== null; ) {
            for (m = rt = d; rt !== null; ) {
              switch (((v = rt), (E = v.child), v.tag)) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Ph(4, v, v.return);
                  break;
                case 1:
                  S0(v, v.return);
                  var A = v.stateNode;
                  if (typeof A.componentWillUnmount == "function") {
                    (n = v), (r = v.return);
                    try {
                      (e = n),
                        (A.props = e.memoizedProps),
                        (A.state = e.memoizedState),
                        A.componentWillUnmount();
                    } catch (I) {
                      tn(n, r, I);
                    }
                  }
                  break;
                case 5:
                  S0(v, v.return);
                  break;
                case 22:
                  if (v.memoizedState !== null) {
                    IA(m);
                    continue;
                  }
              }
              E !== null ? ((E.return = v), (rt = E)) : IA(m);
            }
            d = d.sibling;
          }
        e: for (d = null, m = t; ; ) {
          if (m.tag === 5) {
            if (d === null) {
              d = m;
              try {
                (i = m.stateNode),
                  u
                    ? ((a = i.style),
                      typeof a.setProperty == "function"
                        ? a.setProperty("display", "none", "important")
                        : (a.display = "none"))
                    : ((o = m.stateNode),
                      (c = m.memoizedProps.style),
                      (s =
                        c != null && c.hasOwnProperty("display")
                          ? c.display
                          : null),
                      (o.style.display = DR("display", s)));
              } catch (I) {
                tn(t, t.return, I);
              }
            }
          } else if (m.tag === 6) {
            if (d === null)
              try {
                m.stateNode.nodeValue = u ? "" : m.memoizedProps;
              } catch (I) {
                tn(t, t.return, I);
              }
          } else if (
            ((m.tag !== 22 && m.tag !== 23) ||
              m.memoizedState === null ||
              m === t) &&
            m.child !== null
          ) {
            (m.child.return = m), (m = m.child);
            continue;
          }
          if (m === t) break e;
          for (; m.sibling === null; ) {
            if (m.return === null || m.return === t) break e;
            d === m && (d = null), (m = m.return);
          }
          d === m && (d = null), (m.sibling.return = m.return), (m = m.sibling);
        }
      }
      break;
    case 19:
      Ya(e, t), ks(t), n & 4 && SA(t);
      break;
    case 21:
      break;
    default:
      Ya(e, t), ks(t);
  }
}
function ks(t) {
  var e = t.flags;
  if (e & 2) {
    try {
      e: {
        for (var r = t.return; r !== null; ) {
          if (oN(r)) {
            var n = r;
            break e;
          }
          r = r.return;
        }
        throw Error(Ge(160));
      }
      switch (n.tag) {
        case 5:
          var i = n.stateNode;
          n.flags & 32 && (tp(i, ""), (n.flags &= -33));
          var a = kA(t);
          L6(t, a, i);
          break;
        case 3:
        case 4:
          var s = n.stateNode.containerInfo,
            o = kA(t);
          F6(t, o, s);
          break;
        default:
          throw Error(Ge(161));
      }
    } catch (c) {
      tn(t, t.return, c);
    }
    t.flags &= -3;
  }
  e & 4096 && (t.flags &= -4097);
}
function KV(t, e, r) {
  (rt = t), uN(t);
}
function uN(t, e, r) {
  for (var n = (t.mode & 1) !== 0; rt !== null; ) {
    var i = rt,
      a = i.child;
    if (i.tag === 22 && n) {
      var s = i.memoizedState !== null || H1;
      if (!s) {
        var o = i.alternate,
          c = (o !== null && o.memoizedState !== null) || oi;
        o = H1;
        var u = oi;
        if (((H1 = s), (oi = c) && !u))
          for (rt = i; rt !== null; )
            (s = rt),
              (c = s.child),
              s.tag === 22 && s.memoizedState !== null
                ? RA(i)
                : c !== null
                ? ((c.return = s), (rt = c))
                : RA(i);
        for (; a !== null; ) (rt = a), uN(a), (a = a.sibling);
        (rt = i), (H1 = o), (oi = u);
      }
      MA(t);
    } else
      i.subtreeFlags & 8772 && a !== null ? ((a.return = i), (rt = a)) : MA(t);
  }
}
function MA(t) {
  for (; rt !== null; ) {
    var e = rt;
    if (e.flags & 8772) {
      var r = e.alternate;
      try {
        if (e.flags & 8772)
          switch (e.tag) {
            case 0:
            case 11:
            case 15:
              oi || Db(5, e);
              break;
            case 1:
              var n = e.stateNode;
              if (e.flags & 4 && !oi)
                if (r === null) n.componentDidMount();
                else {
                  var i =
                    e.elementType === e.type
                      ? r.memoizedProps
                      : is(e.type, r.memoizedProps);
                  n.componentDidUpdate(
                    i,
                    r.memoizedState,
                    n.__reactInternalSnapshotBeforeUpdate
                  );
                }
              var a = e.updateQueue;
              a !== null && hA(e, a, n);
              break;
            case 3:
              var s = e.updateQueue;
              if (s !== null) {
                if (((r = null), e.child !== null))
                  switch (e.child.tag) {
                    case 5:
                      r = e.child.stateNode;
                      break;
                    case 1:
                      r = e.child.stateNode;
                  }
                hA(e, s, r);
              }
              break;
            case 5:
              var o = e.stateNode;
              if (r === null && e.flags & 4) {
                r = o;
                var c = e.memoizedProps;
                switch (e.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    c.autoFocus && r.focus();
                    break;
                  case "img":
                    c.src && (r.src = c.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (e.memoizedState === null) {
                var u = e.alternate;
                if (u !== null) {
                  var d = u.memoizedState;
                  if (d !== null) {
                    var m = d.dehydrated;
                    m !== null && ap(m);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(Ge(163));
          }
        oi || (e.flags & 512 && O6(e));
      } catch (v) {
        tn(e, e.return, v);
      }
    }
    if (e === t) {
      rt = null;
      break;
    }
    if (((r = e.sibling), r !== null)) {
      (r.return = e.return), (rt = r);
      break;
    }
    rt = e.return;
  }
}
function IA(t) {
  for (; rt !== null; ) {
    var e = rt;
    if (e === t) {
      rt = null;
      break;
    }
    var r = e.sibling;
    if (r !== null) {
      (r.return = e.return), (rt = r);
      break;
    }
    rt = e.return;
  }
}
function RA(t) {
  for (; rt !== null; ) {
    var e = rt;
    try {
      switch (e.tag) {
        case 0:
        case 11:
        case 15:
          var r = e.return;
          try {
            Db(4, e);
          } catch (c) {
            tn(e, r, c);
          }
          break;
        case 1:
          var n = e.stateNode;
          if (typeof n.componentDidMount == "function") {
            var i = e.return;
            try {
              n.componentDidMount();
            } catch (c) {
              tn(e, i, c);
            }
          }
          var a = e.return;
          try {
            O6(e);
          } catch (c) {
            tn(e, a, c);
          }
          break;
        case 5:
          var s = e.return;
          try {
            O6(e);
          } catch (c) {
            tn(e, s, c);
          }
      }
    } catch (c) {
      tn(e, e.return, c);
    }
    if (e === t) {
      rt = null;
      break;
    }
    var o = e.sibling;
    if (o !== null) {
      (o.return = e.return), (rt = o);
      break;
    }
    rt = e.return;
  }
}
var GV = Math.ceil,
  kg = Xo.ReactCurrentDispatcher,
  T8 = Xo.ReactCurrentOwner,
  $a = Xo.ReactCurrentBatchConfig,
  qt = 0,
  Nn = null,
  hn = null,
  Kn = 0,
  ta = 0,
  M0 = fl(0),
  Cn = 0,
  yp = null,
  uu = 0,
  Ob = 0,
  C8 = 0,
  Nh = null,
  Fi = null,
  A8 = 0,
  mf = 1 / 0,
  Ao = null,
  Sg = !1,
  $6 = null,
  Nc = null,
  z1 = !1,
  _c = null,
  Mg = 0,
  Bh = 0,
  U6 = null,
  Uy = -1,
  Wy = 0;
function ki() {
  return qt & 6 ? on() : Uy !== -1 ? Uy : (Uy = on());
}
function Bc(t) {
  return t.mode & 1
    ? qt & 2 && Kn !== 0
      ? Kn & -Kn
      : RV.transition !== null
      ? (Wy === 0 && (Wy = GR()), Wy)
      : ((t = er),
        t !== 0 || ((t = window.event), (t = t === void 0 ? 16 : tP(t.type))),
        t)
    : 1;
}
function ms(t, e, r, n) {
  if (50 < Bh) throw ((Bh = 0), (U6 = null), Error(Ge(185)));
  Cm(t, r, n),
    (!(qt & 2) || t !== Nn) &&
      (t === Nn && (!(qt & 2) && (Ob |= r), Cn === 4 && yc(t, Kn)),
      Hi(t, n),
      r === 1 && qt === 0 && !(e.mode & 1) && ((mf = on() + 500), Pb && dl()));
}
function Hi(t, e) {
  var r = t.callbackNode;
  Rq(t, e);
  var n = dg(t, t === Nn ? Kn : 0);
  if (n === 0)
    r !== null && UC(r), (t.callbackNode = null), (t.callbackPriority = 0);
  else if (((e = n & -n), t.callbackPriority !== e)) {
    if ((r != null && UC(r), e === 1))
      t.tag === 0 ? IV(PA.bind(null, t)) : xP(PA.bind(null, t)),
        AV(function () {
          !(qt & 6) && dl();
        }),
        (r = null);
    else {
      switch (ZR(n)) {
        case 1:
          r = Y4;
          break;
        case 4:
          r = VR;
          break;
        case 16:
          r = fg;
          break;
        case 536870912:
          r = KR;
          break;
        default:
          r = fg;
      }
      r = bN(r, fN.bind(null, t));
    }
    (t.callbackPriority = e), (t.callbackNode = r);
  }
}
function fN(t, e) {
  if (((Uy = -1), (Wy = 0), qt & 6)) throw Error(Ge(327));
  var r = t.callbackNode;
  if (z0() && t.callbackNode !== r) return null;
  var n = dg(t, t === Nn ? Kn : 0);
  if (n === 0) return null;
  if (n & 30 || n & t.expiredLanes || e) e = Ig(t, n);
  else {
    e = n;
    var i = qt;
    qt |= 2;
    var a = hN();
    (Nn !== t || Kn !== e) && ((Ao = null), (mf = on() + 500), Yl(t, e));
    do
      try {
        QV();
        break;
      } catch (o) {
        dN(t, o);
      }
    while (!0);
    f8(),
      (kg.current = a),
      (qt = i),
      hn !== null ? (e = 0) : ((Nn = null), (Kn = 0), (e = Cn));
  }
  if (e !== 0) {
    if (
      (e === 2 && ((i = h6(t)), i !== 0 && ((n = i), (e = W6(t, i)))), e === 1)
    )
      throw ((r = yp), Yl(t, 0), yc(t, n), Hi(t, on()), r);
    if (e === 6) yc(t, n);
    else {
      if (
        ((i = t.current.alternate),
        !(n & 30) &&
          !ZV(i) &&
          ((e = Ig(t, n)),
          e === 2 && ((a = h6(t)), a !== 0 && ((n = a), (e = W6(t, a)))),
          e === 1))
      )
        throw ((r = yp), Yl(t, 0), yc(t, n), Hi(t, on()), r);
      switch (((t.finishedWork = i), (t.finishedLanes = n), e)) {
        case 0:
        case 1:
          throw Error(Ge(345));
        case 2:
          Nl(t, Fi, Ao);
          break;
        case 3:
          if (
            (yc(t, n), (n & 130023424) === n && ((e = A8 + 500 - on()), 10 < e))
          ) {
            if (dg(t, 0) !== 0) break;
            if (((i = t.suspendedLanes), (i & n) !== n)) {
              ki(), (t.pingedLanes |= t.suspendedLanes & i);
              break;
            }
            t.timeoutHandle = w6(Nl.bind(null, t, Fi, Ao), e);
            break;
          }
          Nl(t, Fi, Ao);
          break;
        case 4:
          if ((yc(t, n), (n & 4194240) === n)) break;
          for (e = t.eventTimes, i = -1; 0 < n; ) {
            var s = 31 - ps(n);
            (a = 1 << s), (s = e[s]), s > i && (i = s), (n &= ~a);
          }
          if (
            ((n = i),
            (n = on() - n),
            (n =
              (120 > n
                ? 120
                : 480 > n
                ? 480
                : 1080 > n
                ? 1080
                : 1920 > n
                ? 1920
                : 3e3 > n
                ? 3e3
                : 4320 > n
                ? 4320
                : 1960 * GV(n / 1960)) - n),
            10 < n)
          ) {
            t.timeoutHandle = w6(Nl.bind(null, t, Fi, Ao), n);
            break;
          }
          Nl(t, Fi, Ao);
          break;
        case 5:
          Nl(t, Fi, Ao);
          break;
        default:
          throw Error(Ge(329));
      }
    }
  }
  return Hi(t, on()), t.callbackNode === r ? fN.bind(null, t) : null;
}
function W6(t, e) {
  var r = Nh;
  return (
    t.current.memoizedState.isDehydrated && (Yl(t, e).flags |= 256),
    (t = Ig(t, e)),
    t !== 2 && ((e = Fi), (Fi = r), e !== null && j6(e)),
    t
  );
}
function j6(t) {
  Fi === null ? (Fi = t) : Fi.push.apply(Fi, t);
}
function ZV(t) {
  for (var e = t; ; ) {
    if (e.flags & 16384) {
      var r = e.updateQueue;
      if (r !== null && ((r = r.stores), r !== null))
        for (var n = 0; n < r.length; n++) {
          var i = r[n],
            a = i.getSnapshot;
          i = i.value;
          try {
            if (!bs(a(), i)) return !1;
          } catch {
            return !1;
          }
        }
    }
    if (((r = e.child), e.subtreeFlags & 16384 && r !== null))
      (r.return = e), (e = r);
    else {
      if (e === t) break;
      for (; e.sibling === null; ) {
        if (e.return === null || e.return === t) return !0;
        e = e.return;
      }
      (e.sibling.return = e.return), (e = e.sibling);
    }
  }
  return !0;
}
function yc(t, e) {
  for (
    e &= ~C8,
      e &= ~Ob,
      t.suspendedLanes |= e,
      t.pingedLanes &= ~e,
      t = t.expirationTimes;
    0 < e;

  ) {
    var r = 31 - ps(e),
      n = 1 << r;
    (t[r] = -1), (e &= ~n);
  }
}
function PA(t) {
  if (qt & 6) throw Error(Ge(327));
  z0();
  var e = dg(t, 0);
  if (!(e & 1)) return Hi(t, on()), null;
  var r = Ig(t, e);
  if (t.tag !== 0 && r === 2) {
    var n = h6(t);
    n !== 0 && ((e = n), (r = W6(t, n)));
  }
  if (r === 1) throw ((r = yp), Yl(t, 0), yc(t, e), Hi(t, on()), r);
  if (r === 6) throw Error(Ge(345));
  return (
    (t.finishedWork = t.current.alternate),
    (t.finishedLanes = e),
    Nl(t, Fi, Ao),
    Hi(t, on()),
    null
  );
}
function k8(t, e) {
  var r = qt;
  qt |= 1;
  try {
    return t(e);
  } finally {
    (qt = r), qt === 0 && ((mf = on() + 500), Pb && dl());
  }
}
function fu(t) {
  _c !== null && _c.tag === 0 && !(qt & 6) && z0();
  var e = qt;
  qt |= 1;
  var r = $a.transition,
    n = er;
  try {
    if ((($a.transition = null), (er = 1), t)) return t();
  } finally {
    (er = n), ($a.transition = r), (qt = e), !(qt & 6) && dl();
  }
}
function S8() {
  (ta = M0.current), Ar(M0);
}
function Yl(t, e) {
  (t.finishedWork = null), (t.finishedLanes = 0);
  var r = t.timeoutHandle;
  if ((r !== -1 && ((t.timeoutHandle = -1), CV(r)), hn !== null))
    for (r = hn.return; r !== null; ) {
      var n = r;
      switch ((c8(n), n.tag)) {
        case 1:
          (n = n.type.childContextTypes), n != null && gg();
          break;
        case 3:
          hf(), Ar(Wi), Ar(mi), g8();
          break;
        case 5:
          y8(n);
          break;
        case 4:
          hf();
          break;
        case 13:
          Ar(Vr);
          break;
        case 19:
          Ar(Vr);
          break;
        case 10:
          d8(n.type._context);
          break;
        case 22:
        case 23:
          S8();
      }
      r = r.return;
    }
  if (
    ((Nn = t),
    (hn = t = Dc(t.current, null)),
    (Kn = ta = e),
    (Cn = 0),
    (yp = null),
    (C8 = Ob = uu = 0),
    (Fi = Nh = null),
    jl !== null)
  ) {
    for (e = 0; e < jl.length; e++)
      if (((r = jl[e]), (n = r.interleaved), n !== null)) {
        r.interleaved = null;
        var i = n.next,
          a = r.pending;
        if (a !== null) {
          var s = a.next;
          (a.next = i), (n.next = s);
        }
        r.pending = n;
      }
    jl = null;
  }
  return t;
}
function dN(t, e) {
  do {
    var r = hn;
    try {
      if ((f8(), (Fy.current = Ag), Cg)) {
        for (var n = Zr.memoizedState; n !== null; ) {
          var i = n.queue;
          i !== null && (i.pending = null), (n = n.next);
        }
        Cg = !1;
      }
      if (
        ((lu = 0),
        (In = _n = Zr = null),
        (Rh = !1),
        (hp = 0),
        (T8.current = null),
        r === null || r.return === null)
      ) {
        (Cn = 1), (yp = e), (hn = null);
        break;
      }
      e: {
        var a = t,
          s = r.return,
          o = r,
          c = e;
        if (
          ((e = Kn),
          (o.flags |= 32768),
          c !== null && typeof c == "object" && typeof c.then == "function")
        ) {
          var u = c,
            d = o,
            m = d.tag;
          if (!(d.mode & 1) && (m === 0 || m === 11 || m === 15)) {
            var v = d.alternate;
            v
              ? ((d.updateQueue = v.updateQueue),
                (d.memoizedState = v.memoizedState),
                (d.lanes = v.lanes))
              : ((d.updateQueue = null), (d.memoizedState = null));
          }
          var E = vA(s);
          if (E !== null) {
            (E.flags &= -257),
              xA(E, s, o, a, e),
              E.mode & 1 && bA(a, u, e),
              (e = E),
              (c = u);
            var A = e.updateQueue;
            if (A === null) {
              var I = new Set();
              I.add(c), (e.updateQueue = I);
            } else A.add(c);
            break e;
          } else {
            if (!(e & 1)) {
              bA(a, u, e), M8();
              break e;
            }
            c = Error(Ge(426));
          }
        } else if (kr && o.mode & 1) {
          var b = vA(s);
          if (b !== null) {
            !(b.flags & 65536) && (b.flags |= 256),
              xA(b, s, o, a, e),
              l8(pf(c, o));
            break e;
          }
        }
        (a = c = pf(c, o)),
          Cn !== 4 && (Cn = 2),
          Nh === null ? (Nh = [a]) : Nh.push(a),
          (a = s);
        do {
          switch (a.tag) {
            case 3:
              (a.flags |= 65536), (e &= -e), (a.lanes |= e);
              var w = ZP(a, c, e);
              dA(a, w);
              break e;
            case 1:
              o = c;
              var S = a.type,
                k = a.stateNode;
              if (
                !(a.flags & 128) &&
                (typeof S.getDerivedStateFromError == "function" ||
                  (k !== null &&
                    typeof k.componentDidCatch == "function" &&
                    (Nc === null || !Nc.has(k))))
              ) {
                (a.flags |= 65536), (e &= -e), (a.lanes |= e);
                var N = JP(a, o, e);
                dA(a, N);
                break e;
              }
          }
          a = a.return;
        } while (a !== null);
      }
      mN(r);
    } catch (O) {
      (e = O), hn === r && r !== null && (hn = r = r.return);
      continue;
    }
    break;
  } while (!0);
}
function hN() {
  var t = kg.current;
  return (kg.current = Ag), t === null ? Ag : t;
}
function M8() {
  (Cn === 0 || Cn === 3 || Cn === 2) && (Cn = 4),
    Nn === null || (!(uu & 268435455) && !(Ob & 268435455)) || yc(Nn, Kn);
}
function Ig(t, e) {
  var r = qt;
  qt |= 2;
  var n = hN();
  (Nn !== t || Kn !== e) && ((Ao = null), Yl(t, e));
  do
    try {
      JV();
      break;
    } catch (i) {
      dN(t, i);
    }
  while (!0);
  if ((f8(), (qt = r), (kg.current = n), hn !== null)) throw Error(Ge(261));
  return (Nn = null), (Kn = 0), Cn;
}
function JV() {
  for (; hn !== null; ) pN(hn);
}
function QV() {
  for (; hn !== null && !_q(); ) pN(hn);
}
function pN(t) {
  var e = gN(t.alternate, t, ta);
  (t.memoizedProps = t.pendingProps),
    e === null ? mN(t) : (hn = e),
    (T8.current = null);
}
function mN(t) {
  var e = t;
  do {
    var r = e.alternate;
    if (((t = e.return), e.flags & 32768)) {
      if (((r = zV(r, e)), r !== null)) {
        (r.flags &= 32767), (hn = r);
        return;
      }
      if (t !== null)
        (t.flags |= 32768), (t.subtreeFlags = 0), (t.deletions = null);
      else {
        (Cn = 6), (hn = null);
        return;
      }
    } else if (((r = HV(r, e, ta)), r !== null)) {
      hn = r;
      return;
    }
    if (((e = e.sibling), e !== null)) {
      hn = e;
      return;
    }
    hn = e = t;
  } while (e !== null);
  Cn === 0 && (Cn = 5);
}
function Nl(t, e, r) {
  var n = er,
    i = $a.transition;
  try {
    ($a.transition = null), (er = 1), YV(t, e, r, n);
  } finally {
    ($a.transition = i), (er = n);
  }
  return null;
}
function YV(t, e, r, n) {
  do z0();
  while (_c !== null);
  if (qt & 6) throw Error(Ge(327));
  r = t.finishedWork;
  var i = t.finishedLanes;
  if (r === null) return null;
  if (((t.finishedWork = null), (t.finishedLanes = 0), r === t.current))
    throw Error(Ge(177));
  (t.callbackNode = null), (t.callbackPriority = 0);
  var a = r.lanes | r.childLanes;
  if (
    (Pq(t, a),
    t === Nn && ((hn = Nn = null), (Kn = 0)),
    (!(r.subtreeFlags & 2064) && !(r.flags & 2064)) ||
      z1 ||
      ((z1 = !0),
      bN(fg, function () {
        return z0(), null;
      })),
    (a = (r.flags & 15990) !== 0),
    r.subtreeFlags & 15990 || a)
  ) {
    (a = $a.transition), ($a.transition = null);
    var s = er;
    er = 1;
    var o = qt;
    (qt |= 4),
      (T8.current = null),
      VV(t, r),
      lN(r, t),
      bV(v6),
      (hg = !!b6),
      (v6 = b6 = null),
      (t.current = r),
      KV(r),
      Eq(),
      (qt = o),
      (er = s),
      ($a.transition = a);
  } else t.current = r;
  if (
    (z1 && ((z1 = !1), (_c = t), (Mg = i)),
    (a = t.pendingLanes),
    a === 0 && (Nc = null),
    Aq(r.stateNode),
    Hi(t, on()),
    e !== null)
  )
    for (n = t.onRecoverableError, r = 0; r < e.length; r++)
      (i = e[r]),
        n(i.value, {
          componentStack: i.stack,
          digest: i.digest,
        });
  if (Sg) throw ((Sg = !1), (t = $6), ($6 = null), t);
  return (
    Mg & 1 && t.tag !== 0 && z0(),
    (a = t.pendingLanes),
    a & 1 ? (t === U6 ? Bh++ : ((Bh = 0), (U6 = t))) : (Bh = 0),
    dl(),
    null
  );
}
function z0() {
  if (_c !== null) {
    var t = ZR(Mg),
      e = $a.transition,
      r = er;
    try {
      if ((($a.transition = null), (er = 16 > t ? 16 : t), _c === null))
        var n = !1;
      else {
        if (((t = _c), (_c = null), (Mg = 0), qt & 6)) throw Error(Ge(331));
        var i = qt;
        for (qt |= 4, rt = t.current; rt !== null; ) {
          var a = rt,
            s = a.child;
          if (rt.flags & 16) {
            var o = a.deletions;
            if (o !== null) {
              for (var c = 0; c < o.length; c++) {
                var u = o[c];
                for (rt = u; rt !== null; ) {
                  var d = rt;
                  switch (d.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Ph(8, d, a);
                  }
                  var m = d.child;
                  if (m !== null) (m.return = d), (rt = m);
                  else
                    for (; rt !== null; ) {
                      d = rt;
                      var v = d.sibling,
                        E = d.return;
                      if ((sN(d), d === u)) {
                        rt = null;
                        break;
                      }
                      if (v !== null) {
                        (v.return = E), (rt = v);
                        break;
                      }
                      rt = E;
                    }
                }
              }
              var A = a.alternate;
              if (A !== null) {
                var I = A.child;
                if (I !== null) {
                  A.child = null;
                  do {
                    var b = I.sibling;
                    (I.sibling = null), (I = b);
                  } while (I !== null);
                }
              }
              rt = a;
            }
          }
          if (a.subtreeFlags & 2064 && s !== null) (s.return = a), (rt = s);
          else
            e: for (; rt !== null; ) {
              if (((a = rt), a.flags & 2048))
                switch (a.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Ph(9, a, a.return);
                }
              var w = a.sibling;
              if (w !== null) {
                (w.return = a.return), (rt = w);
                break e;
              }
              rt = a.return;
            }
        }
        var S = t.current;
        for (rt = S; rt !== null; ) {
          s = rt;
          var k = s.child;
          if (s.subtreeFlags & 2064 && k !== null) (k.return = s), (rt = k);
          else
            e: for (s = S; rt !== null; ) {
              if (((o = rt), o.flags & 2048))
                try {
                  switch (o.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Db(9, o);
                  }
                } catch (O) {
                  tn(o, o.return, O);
                }
              if (o === s) {
                rt = null;
                break e;
              }
              var N = o.sibling;
              if (N !== null) {
                (N.return = o.return), (rt = N);
                break e;
              }
              rt = o.return;
            }
        }
        if (
          ((qt = i), dl(), Ys && typeof Ys.onPostCommitFiberRoot == "function")
        )
          try {
            Ys.onPostCommitFiberRoot(kb, t);
          } catch {}
        n = !0;
      }
      return n;
    } finally {
      (er = r), ($a.transition = e);
    }
  }
  return !1;
}
function NA(t, e, r) {
  (e = pf(r, e)),
    (e = ZP(t, e, 1)),
    (t = Pc(t, e, 1)),
    (e = ki()),
    t !== null && (Cm(t, 1, e), Hi(t, e));
}
function tn(t, e, r) {
  if (t.tag === 3) NA(t, t, r);
  else
    for (; e !== null; ) {
      if (e.tag === 3) {
        NA(e, t, r);
        break;
      } else if (e.tag === 1) {
        var n = e.stateNode;
        if (
          typeof e.type.getDerivedStateFromError == "function" ||
          (typeof n.componentDidCatch == "function" &&
            (Nc === null || !Nc.has(n)))
        ) {
          (t = pf(r, t)),
            (t = JP(e, t, 1)),
            (e = Pc(e, t, 1)),
            (t = ki()),
            e !== null && (Cm(e, 1, t), Hi(e, t));
          break;
        }
      }
      e = e.return;
    }
}
function XV(t, e, r) {
  var n = t.pingCache;
  n !== null && n.delete(e),
    (e = ki()),
    (t.pingedLanes |= t.suspendedLanes & r),
    Nn === t &&
      (Kn & r) === r &&
      (Cn === 4 || (Cn === 3 && (Kn & 130023424) === Kn && 500 > on() - A8)
        ? Yl(t, 0)
        : (C8 |= r)),
    Hi(t, e);
}
function yN(t, e) {
  e === 0 &&
    (t.mode & 1
      ? ((e = B1), (B1 <<= 1), !(B1 & 130023424) && (B1 = 4194304))
      : (e = 1));
  var r = ki();
  (t = zo(t, e)), t !== null && (Cm(t, e, r), Hi(t, r));
}
function eK(t) {
  var e = t.memoizedState,
    r = 0;
  e !== null && (r = e.retryLane), yN(t, r);
}
function tK(t, e) {
  var r = 0;
  switch (t.tag) {
    case 13:
      var n = t.stateNode,
        i = t.memoizedState;
      i !== null && (r = i.retryLane);
      break;
    case 19:
      n = t.stateNode;
      break;
    default:
      throw Error(Ge(314));
  }
  n !== null && n.delete(e), yN(t, r);
}
var gN;
gN = function (t, e, r) {
  if (t !== null)
    if (t.memoizedProps !== e.pendingProps || Wi.current) $i = !0;
    else {
      if (!(t.lanes & r) && !(e.flags & 128)) return ($i = !1), jV(t, e, r);
      $i = !!(t.flags & 131072);
    }
  else ($i = !1), kr && e.flags & 1048576 && wP(e, xg, e.index);
  switch (((e.lanes = 0), e.tag)) {
    case 2:
      var n = e.type;
      $y(t, e), (t = e.pendingProps);
      var i = uf(e, mi.current);
      H0(e, r), (i = v8(null, e, n, t, i, r));
      var a = x8();
      return (
        (e.flags |= 1),
        typeof i == "object" &&
        i !== null &&
        typeof i.render == "function" &&
        i.$$typeof === void 0
          ? ((e.tag = 1),
            (e.memoizedState = null),
            (e.updateQueue = null),
            ji(n) ? ((a = !0), bg(e)) : (a = !1),
            (e.memoizedState =
              i.state !== null && i.state !== void 0 ? i.state : null),
            p8(e),
            (i.updater = Bb),
            (e.stateNode = i),
            (i._reactInternals = e),
            S6(e, n, t, r),
            (e = R6(null, e, n, !0, a, r)))
          : ((e.tag = 0), kr && a && o8(e), xi(null, e, i, r), (e = e.child)),
        e
      );
    case 16:
      n = e.elementType;
      e: {
        switch (
          ($y(t, e),
          (t = e.pendingProps),
          (i = n._init),
          (n = i(n._payload)),
          (e.type = n),
          (i = e.tag = nK(n)),
          (t = is(n, t)),
          i)
        ) {
          case 0:
            e = I6(null, e, n, t, r);
            break e;
          case 1:
            e = EA(null, e, n, t, r);
            break e;
          case 11:
            e = wA(null, e, n, t, r);
            break e;
          case 14:
            e = _A(null, e, n, is(n.type, t), r);
            break e;
        }
        throw Error(Ge(306, n, ""));
      }
      return e;
    case 0:
      return (
        (n = e.type),
        (i = e.pendingProps),
        (i = e.elementType === n ? i : is(n, i)),
        I6(t, e, n, i, r)
      );
    case 1:
      return (
        (n = e.type),
        (i = e.pendingProps),
        (i = e.elementType === n ? i : is(n, i)),
        EA(t, e, n, i, r)
      );
    case 3:
      e: {
        if ((eN(e), t === null)) throw Error(Ge(387));
        (n = e.pendingProps),
          (a = e.memoizedState),
          (i = a.element),
          kP(t, e),
          Eg(e, n, null, r);
        var s = e.memoizedState;
        if (((n = s.element), a.isDehydrated))
          if (
            ((a = {
              element: n,
              isDehydrated: !1,
              cache: s.cache,
              pendingSuspenseBoundaries: s.pendingSuspenseBoundaries,
              transitions: s.transitions,
            }),
            (e.updateQueue.baseState = a),
            (e.memoizedState = a),
            e.flags & 256)
          ) {
            (i = pf(Error(Ge(423)), e)), (e = TA(t, e, n, r, i));
            break e;
          } else if (n !== i) {
            (i = pf(Error(Ge(424)), e)), (e = TA(t, e, n, r, i));
            break e;
          } else
            for (
              sa = Rc(e.stateNode.containerInfo.firstChild),
                ua = e,
                kr = !0,
                ss = null,
                r = CP(e, null, n, r),
                e.child = r;
              r;

            )
              (r.flags = (r.flags & -3) | 4096), (r = r.sibling);
        else {
          if ((ff(), n === i)) {
            e = qo(t, e, r);
            break e;
          }
          xi(t, e, n, r);
        }
        e = e.child;
      }
      return e;
    case 5:
      return (
        SP(e),
        t === null && C6(e),
        (n = e.type),
        (i = e.pendingProps),
        (a = t !== null ? t.memoizedProps : null),
        (s = i.children),
        x6(n, i) ? (s = null) : a !== null && x6(n, a) && (e.flags |= 32),
        XP(t, e),
        xi(t, e, s, r),
        e.child
      );
    case 6:
      return t === null && C6(e), null;
    case 13:
      return tN(t, e, r);
    case 4:
      return (
        m8(e, e.stateNode.containerInfo),
        (n = e.pendingProps),
        t === null ? (e.child = df(e, null, n, r)) : xi(t, e, n, r),
        e.child
      );
    case 11:
      return (
        (n = e.type),
        (i = e.pendingProps),
        (i = e.elementType === n ? i : is(n, i)),
        wA(t, e, n, i, r)
      );
    case 7:
      return xi(t, e, e.pendingProps, r), e.child;
    case 8:
      return xi(t, e, e.pendingProps.children, r), e.child;
    case 12:
      return xi(t, e, e.pendingProps.children, r), e.child;
    case 10:
      e: {
        if (
          ((n = e.type._context),
          (i = e.pendingProps),
          (a = e.memoizedProps),
          (s = i.value),
          br(wg, n._currentValue),
          (n._currentValue = s),
          a !== null)
        )
          if (bs(a.value, s)) {
            if (a.children === i.children && !Wi.current) {
              e = qo(t, e, r);
              break e;
            }
          } else
            for (a = e.child, a !== null && (a.return = e); a !== null; ) {
              var o = a.dependencies;
              if (o !== null) {
                s = a.child;
                for (var c = o.firstContext; c !== null; ) {
                  if (c.context === n) {
                    if (a.tag === 1) {
                      (c = Uo(-1, r & -r)), (c.tag = 2);
                      var u = a.updateQueue;
                      if (u !== null) {
                        u = u.shared;
                        var d = u.pending;
                        d === null
                          ? (c.next = c)
                          : ((c.next = d.next), (d.next = c)),
                          (u.pending = c);
                      }
                    }
                    (a.lanes |= r),
                      (c = a.alternate),
                      c !== null && (c.lanes |= r),
                      A6(a.return, r, e),
                      (o.lanes |= r);
                    break;
                  }
                  c = c.next;
                }
              } else if (a.tag === 10) s = a.type === e.type ? null : a.child;
              else if (a.tag === 18) {
                if (((s = a.return), s === null)) throw Error(Ge(341));
                (s.lanes |= r),
                  (o = s.alternate),
                  o !== null && (o.lanes |= r),
                  A6(s, r, e),
                  (s = a.sibling);
              } else s = a.child;
              if (s !== null) s.return = a;
              else
                for (s = a; s !== null; ) {
                  if (s === e) {
                    s = null;
                    break;
                  }
                  if (((a = s.sibling), a !== null)) {
                    (a.return = s.return), (s = a);
                    break;
                  }
                  s = s.return;
                }
              a = s;
            }
        xi(t, e, i.children, r), (e = e.child);
      }
      return e;
    case 9:
      return (
        (i = e.type),
        (n = e.pendingProps.children),
        H0(e, r),
        (i = ja(i)),
        (n = n(i)),
        (e.flags |= 1),
        xi(t, e, n, r),
        e.child
      );
    case 14:
      return (
        (n = e.type),
        (i = is(n, e.pendingProps)),
        (i = is(n.type, i)),
        _A(t, e, n, i, r)
      );
    case 15:
      return QP(t, e, e.type, e.pendingProps, r);
    case 17:
      return (
        (n = e.type),
        (i = e.pendingProps),
        (i = e.elementType === n ? i : is(n, i)),
        $y(t, e),
        (e.tag = 1),
        ji(n) ? ((t = !0), bg(e)) : (t = !1),
        H0(e, r),
        GP(e, n, i),
        S6(e, n, i, r),
        R6(null, e, n, !0, t, r)
      );
    case 19:
      return rN(t, e, r);
    case 22:
      return YP(t, e, r);
  }
  throw Error(Ge(156, e.tag));
};
function bN(t, e) {
  return qR(t, e);
}
function rK(t, e, r, n) {
  (this.tag = t),
    (this.key = r),
    (this.sibling =
      this.child =
      this.return =
      this.stateNode =
      this.type =
      this.elementType =
        null),
    (this.index = 0),
    (this.ref = null),
    (this.pendingProps = e),
    (this.dependencies =
      this.memoizedState =
      this.updateQueue =
      this.memoizedProps =
        null),
    (this.mode = n),
    (this.subtreeFlags = this.flags = 0),
    (this.deletions = null),
    (this.childLanes = this.lanes = 0),
    (this.alternate = null);
}
function Fa(t, e, r, n) {
  return new rK(t, e, r, n);
}
function I8(t) {
  return (t = t.prototype), !(!t || !t.isReactComponent);
}
function nK(t) {
  if (typeof t == "function") return I8(t) ? 1 : 0;
  if (t != null) {
    if (((t = t.$$typeof), t === Z4)) return 11;
    if (t === J4) return 14;
  }
  return 2;
}
function Dc(t, e) {
  var r = t.alternate;
  return (
    r === null
      ? ((r = Fa(t.tag, e, t.key, t.mode)),
        (r.elementType = t.elementType),
        (r.type = t.type),
        (r.stateNode = t.stateNode),
        (r.alternate = t),
        (t.alternate = r))
      : ((r.pendingProps = e),
        (r.type = t.type),
        (r.flags = 0),
        (r.subtreeFlags = 0),
        (r.deletions = null)),
    (r.flags = t.flags & 14680064),
    (r.childLanes = t.childLanes),
    (r.lanes = t.lanes),
    (r.child = t.child),
    (r.memoizedProps = t.memoizedProps),
    (r.memoizedState = t.memoizedState),
    (r.updateQueue = t.updateQueue),
    (e = t.dependencies),
    (r.dependencies =
      e === null
        ? null
        : {
            lanes: e.lanes,
            firstContext: e.firstContext,
          }),
    (r.sibling = t.sibling),
    (r.index = t.index),
    (r.ref = t.ref),
    r
  );
}
function jy(t, e, r, n, i, a) {
  var s = 2;
  if (((n = t), typeof t == "function")) I8(t) && (s = 1);
  else if (typeof t == "string") s = 5;
  else
    e: switch (t) {
      case v0:
        return Xl(r.children, i, a, e);
      case G4:
        (s = 8), (i |= 8);
        break;
      case Y5:
        return (
          (t = Fa(12, r, e, i | 2)), (t.elementType = Y5), (t.lanes = a), t
        );
      case X5:
        return (t = Fa(13, r, e, i)), (t.elementType = X5), (t.lanes = a), t;
      case e6:
        return (t = Fa(19, r, e, i)), (t.elementType = e6), (t.lanes = a), t;
      case SR:
        return Fb(r, i, a, e);
      default:
        if (typeof t == "object" && t !== null)
          switch (t.$$typeof) {
            case AR:
              s = 10;
              break e;
            case kR:
              s = 9;
              break e;
            case Z4:
              s = 11;
              break e;
            case J4:
              s = 14;
              break e;
            case dc:
              (s = 16), (n = null);
              break e;
          }
        throw Error(Ge(130, t == null ? t : typeof t, ""));
    }
  return (
    (e = Fa(s, r, e, i)), (e.elementType = t), (e.type = n), (e.lanes = a), e
  );
}
function Xl(t, e, r, n) {
  return (t = Fa(7, t, n, e)), (t.lanes = r), t;
}
function Fb(t, e, r, n) {
  return (
    (t = Fa(22, t, n, e)),
    (t.elementType = SR),
    (t.lanes = r),
    (t.stateNode = {
      isHidden: !1,
    }),
    t
  );
}
function Bw(t, e, r) {
  return (t = Fa(6, t, null, e)), (t.lanes = r), t;
}
function Dw(t, e, r) {
  return (
    (e = Fa(4, t.children !== null ? t.children : [], t.key, e)),
    (e.lanes = r),
    (e.stateNode = {
      containerInfo: t.containerInfo,
      pendingChildren: null,
      implementation: t.implementation,
    }),
    e
  );
}
function iK(t, e, r, n, i) {
  (this.tag = e),
    (this.containerInfo = t),
    (this.finishedWork =
      this.pingCache =
      this.current =
      this.pendingChildren =
        null),
    (this.timeoutHandle = -1),
    (this.callbackNode = this.pendingContext = this.context = null),
    (this.callbackPriority = 0),
    (this.eventTimes = mw(0)),
    (this.expirationTimes = mw(-1)),
    (this.entangledLanes =
      this.finishedLanes =
      this.mutableReadLanes =
      this.expiredLanes =
      this.pingedLanes =
      this.suspendedLanes =
      this.pendingLanes =
        0),
    (this.entanglements = mw(0)),
    (this.identifierPrefix = n),
    (this.onRecoverableError = i),
    (this.mutableSourceEagerHydrationData = null);
}
function R8(t, e, r, n, i, a, s, o, c) {
  return (
    (t = new iK(t, e, r, o, c)),
    e === 1 ? ((e = 1), a === !0 && (e |= 8)) : (e = 0),
    (a = Fa(3, null, null, e)),
    (t.current = a),
    (a.stateNode = t),
    (a.memoizedState = {
      element: n,
      isDehydrated: r,
      cache: null,
      transitions: null,
      pendingSuspenseBoundaries: null,
    }),
    p8(a),
    t
  );
}
function aK(t, e, r) {
  var n = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return {
    $$typeof: b0,
    key: n == null ? null : "" + n,
    children: t,
    containerInfo: e,
    implementation: r,
  };
}
function vN(t) {
  if (!t) return Zc;
  t = t._reactInternals;
  e: {
    if (Mu(t) !== t || t.tag !== 1) throw Error(Ge(170));
    var e = t;
    do {
      switch (e.tag) {
        case 3:
          e = e.stateNode.context;
          break e;
        case 1:
          if (ji(e.type)) {
            e = e.stateNode.__reactInternalMemoizedMergedChildContext;
            break e;
          }
      }
      e = e.return;
    } while (e !== null);
    throw Error(Ge(171));
  }
  if (t.tag === 1) {
    var r = t.type;
    if (ji(r)) return vP(t, r, e);
  }
  return e;
}
function xN(t, e, r, n, i, a, s, o, c) {
  return (
    (t = R8(r, n, !0, t, i, a, s, o, c)),
    (t.context = vN(null)),
    (r = t.current),
    (n = ki()),
    (i = Bc(r)),
    (a = Uo(n, i)),
    (a.callback = e ?? null),
    Pc(r, a, i),
    (t.current.lanes = i),
    Cm(t, i, n),
    Hi(t, n),
    t
  );
}
function Lb(t, e, r, n) {
  var i = e.current,
    a = ki(),
    s = Bc(i);
  return (
    (r = vN(r)),
    e.context === null ? (e.context = r) : (e.pendingContext = r),
    (e = Uo(a, s)),
    (e.payload = {
      element: t,
    }),
    (n = n === void 0 ? null : n),
    n !== null && (e.callback = n),
    (t = Pc(i, e, s)),
    t !== null && (ms(t, i, s, a), Oy(t, i, s)),
    s
  );
}
function Rg(t) {
  if (((t = t.current), !t.child)) return null;
  switch (t.child.tag) {
    case 5:
      return t.child.stateNode;
    default:
      return t.child.stateNode;
  }
}
function BA(t, e) {
  if (((t = t.memoizedState), t !== null && t.dehydrated !== null)) {
    var r = t.retryLane;
    t.retryLane = r !== 0 && r < e ? r : e;
  }
}
function P8(t, e) {
  BA(t, e), (t = t.alternate) && BA(t, e);
}
function sK() {
  return null;
}
var wN =
  typeof reportError == "function"
    ? reportError
    : function (t) {
        console.error(t);
      };
function N8(t) {
  this._internalRoot = t;
}
$b.prototype.render = N8.prototype.render = function (t) {
  var e = this._internalRoot;
  if (e === null) throw Error(Ge(409));
  Lb(t, e, null, null);
};
$b.prototype.unmount = N8.prototype.unmount = function () {
  var t = this._internalRoot;
  if (t !== null) {
    this._internalRoot = null;
    var e = t.containerInfo;
    fu(function () {
      Lb(null, t, null, null);
    }),
      (e[Ho] = null);
  }
};
function $b(t) {
  this._internalRoot = t;
}
$b.prototype.unstable_scheduleHydration = function (t) {
  if (t) {
    var e = YR();
    t = {
      blockedOn: null,
      target: t,
      priority: e,
    };
    for (var r = 0; r < mc.length && e !== 0 && e < mc[r].priority; r++);
    mc.splice(r, 0, t), r === 0 && eP(t);
  }
};
function B8(t) {
  return !(!t || (t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11));
}
function Ub(t) {
  return !(
    !t ||
    (t.nodeType !== 1 &&
      t.nodeType !== 9 &&
      t.nodeType !== 11 &&
      (t.nodeType !== 8 || t.nodeValue !== " react-mount-point-unstable "))
  );
}
function DA() {}
function oK(t, e, r, n, i) {
  if (i) {
    if (typeof n == "function") {
      var a = n;
      n = function () {
        var u = Rg(s);
        a.call(u);
      };
    }
    var s = xN(e, n, t, 0, null, !1, !1, "", DA);
    return (
      (t._reactRootContainer = s),
      (t[Ho] = s.current),
      cp(t.nodeType === 8 ? t.parentNode : t),
      fu(),
      s
    );
  }
  for (; (i = t.lastChild); ) t.removeChild(i);
  if (typeof n == "function") {
    var o = n;
    n = function () {
      var u = Rg(c);
      o.call(u);
    };
  }
  var c = R8(t, 0, !1, null, null, !1, !1, "", DA);
  return (
    (t._reactRootContainer = c),
    (t[Ho] = c.current),
    cp(t.nodeType === 8 ? t.parentNode : t),
    fu(function () {
      Lb(e, c, r, n);
    }),
    c
  );
}
function Wb(t, e, r, n, i) {
  var a = r._reactRootContainer;
  if (a) {
    var s = a;
    if (typeof i == "function") {
      var o = i;
      i = function () {
        var c = Rg(s);
        o.call(c);
      };
    }
    Lb(e, s, t, i);
  } else s = oK(r, e, t, i, n);
  return Rg(s);
}
JR = function (t) {
  switch (t.tag) {
    case 3:
      var e = t.stateNode;
      if (e.current.memoizedState.isDehydrated) {
        var r = ph(e.pendingLanes);
        r !== 0 &&
          (X4(e, r | 1), Hi(e, on()), !(qt & 6) && ((mf = on() + 500), dl()));
      }
      break;
    case 13:
      fu(function () {
        var n = zo(t, 1);
        if (n !== null) {
          var i = ki();
          ms(n, t, 1, i);
        }
      }),
        P8(t, 1);
  }
};
e8 = function (t) {
  if (t.tag === 13) {
    var e = zo(t, 134217728);
    if (e !== null) {
      var r = ki();
      ms(e, t, 134217728, r);
    }
    P8(t, 134217728);
  }
};
QR = function (t) {
  if (t.tag === 13) {
    var e = Bc(t),
      r = zo(t, e);
    if (r !== null) {
      var n = ki();
      ms(r, t, e, n);
    }
    P8(t, e);
  }
};
YR = function () {
  return er;
};
XR = function (t, e) {
  var r = er;
  try {
    return (er = t), e();
  } finally {
    er = r;
  }
};
u6 = function (t, e, r) {
  switch (e) {
    case "input":
      if ((n6(t, r), (e = r.name), r.type === "radio" && e != null)) {
        for (r = t; r.parentNode; ) r = r.parentNode;
        for (
          r = r.querySelectorAll(
            "input[name=" + JSON.stringify("" + e) + '][type="radio"]'
          ),
            e = 0;
          e < r.length;
          e++
        ) {
          var n = r[e];
          if (n !== t && n.form === t.form) {
            var i = Rb(n);
            if (!i) throw Error(Ge(90));
            IR(n), n6(n, i);
          }
        }
      }
      break;
    case "textarea":
      PR(t, r);
      break;
    case "select":
      (e = r.value), e != null && $0(t, !!r.multiple, e, !1);
  }
};
$R = k8;
UR = fu;
var cK = {
    usingClientEntryPoint: !1,
    Events: [km, E0, Rb, FR, LR, k8],
  },
  Kd = {
    findFiberByHostInstance: Wl,
    bundleType: 0,
    version: "18.3.1",
    rendererPackageName: "react-dom",
  },
  lK = {
    bundleType: Kd.bundleType,
    version: Kd.version,
    rendererPackageName: Kd.rendererPackageName,
    rendererConfig: Kd.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: Xo.ReactCurrentDispatcher,
    findHostInstanceByFiber: function (t) {
      return (t = HR(t)), t === null ? null : t.stateNode;
    },
    findFiberByHostInstance: Kd.findFiberByHostInstance || sK,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.3.1-next-f1338f8080-20240426",
  };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var q1 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!q1.isDisabled && q1.supportsFiber)
    try {
      (kb = q1.inject(lK)), (Ys = q1);
    } catch {}
}
ga.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = cK;
ga.createPortal = function (t, e) {
  var r = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!B8(e)) throw Error(Ge(200));
  return aK(t, e, null, r);
};
ga.createRoot = function (t, e) {
  if (!B8(t)) throw Error(Ge(299));
  var r = !1,
    n = "",
    i = wN;
  return (
    e != null &&
      (e.unstable_strictMode === !0 && (r = !0),
      e.identifierPrefix !== void 0 && (n = e.identifierPrefix),
      e.onRecoverableError !== void 0 && (i = e.onRecoverableError)),
    (e = R8(t, 1, !1, null, null, r, !1, n, i)),
    (t[Ho] = e.current),
    cp(t.nodeType === 8 ? t.parentNode : t),
    new N8(e)
  );
};
ga.findDOMNode = function (t) {
  if (t == null) return null;
  if (t.nodeType === 1) return t;
  var e = t._reactInternals;
  if (e === void 0)
    throw typeof t.render == "function"
      ? Error(Ge(188))
      : ((t = Object.keys(t).join(",")), Error(Ge(268, t)));
  return (t = HR(e)), (t = t === null ? null : t.stateNode), t;
};
ga.flushSync = function (t) {
  return fu(t);
};
ga.hydrate = function (t, e, r) {
  if (!Ub(e)) throw Error(Ge(200));
  return Wb(null, t, e, !0, r);
};
ga.hydrateRoot = function (t, e, r) {
  if (!B8(t)) throw Error(Ge(405));
  var n = (r != null && r.hydratedSources) || null,
    i = !1,
    a = "",
    s = wN;
  if (
    (r != null &&
      (r.unstable_strictMode === !0 && (i = !0),
      r.identifierPrefix !== void 0 && (a = r.identifierPrefix),
      r.onRecoverableError !== void 0 && (s = r.onRecoverableError)),
    (e = xN(e, null, t, 1, r ?? null, i, !1, a, s)),
    (t[Ho] = e.current),
    cp(t),
    n)
  )
    for (t = 0; t < n.length; t++)
      (r = n[t]),
        (i = r._getVersion),
        (i = i(r._source)),
        e.mutableSourceEagerHydrationData == null
          ? (e.mutableSourceEagerHydrationData = [r, i])
          : e.mutableSourceEagerHydrationData.push(r, i);
  return new $b(e);
};
ga.render = function (t, e, r) {
  if (!Ub(e)) throw Error(Ge(200));
  return Wb(null, t, e, !1, r);
};
ga.unmountComponentAtNode = function (t) {
  if (!Ub(t)) throw Error(Ge(40));
  return t._reactRootContainer
    ? (fu(function () {
        Wb(null, null, t, !1, function () {
          (t._reactRootContainer = null), (t[Ho] = null);
        });
      }),
      !0)
    : !1;
};
ga.unstable_batchedUpdates = k8;
ga.unstable_renderSubtreeIntoContainer = function (t, e, r, n) {
  if (!Ub(r)) throw Error(Ge(200));
  if (t == null || t._reactInternals === void 0) throw Error(Ge(38));
  return Wb(t, e, r, !1, n);
};
ga.version = "18.3.1-next-f1338f8080-20240426";
function _N() {
  if (
    !(
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
    )
  )
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(_N);
    } catch (t) {
      console.error(t);
    }
}
_N(), (_R.exports = ga);
var uK = _R.exports,
  EN,
  OA = uK;
(EN = OA.createRoot), OA.hydrateRoot;
/**
 * @remix-run/router v1.19.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function gp() {
  return (
    (gp = Object.assign
      ? Object.assign.bind()
      : function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var r = arguments[e];
            for (var n in r)
              Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);
          }
          return t;
        }),
    gp.apply(this, arguments)
  );
}
var Ec;
(function (t) {
  (t.Pop = "POP"), (t.Push = "PUSH"), (t.Replace = "REPLACE");
})(Ec || (Ec = {}));
const FA = "popstate";
function fK(t) {
  t === void 0 && (t = {});
  function e(n, i) {
    let { pathname: a, search: s, hash: o } = n.location;
    return H6(
      "",
      {
        pathname: a,
        search: s,
        hash: o,
      },
      (i.state && i.state.usr) || null,
      (i.state && i.state.key) || "default"
    );
  }
  function r(n, i) {
    return typeof i == "string" ? i : Pg(i);
  }
  return hK(e, r, null, t);
}
function pn(t, e) {
  if (t === !1 || t === null || typeof t > "u") throw new Error(e);
}
function TN(t, e) {
  if (!t) {
    typeof console < "u" && console.warn(e);
    try {
      throw new Error(e);
    } catch {}
  }
}
function dK() {
  return Math.random().toString(36).substr(2, 8);
}
function LA(t, e) {
  return {
    usr: t.state,
    key: t.key,
    idx: e,
  };
}
function H6(t, e, r, n) {
  return (
    r === void 0 && (r = null),
    gp(
      {
        pathname: typeof t == "string" ? t : t.pathname,
        search: "",
        hash: "",
      },
      typeof e == "string" ? cd(e) : e,
      {
        state: r,
        key: (e && e.key) || n || dK(),
      }
    )
  );
}
function Pg(t) {
  let { pathname: e = "/", search: r = "", hash: n = "" } = t;
  return (
    r && r !== "?" && (e += r.charAt(0) === "?" ? r : "?" + r),
    n && n !== "#" && (e += n.charAt(0) === "#" ? n : "#" + n),
    e
  );
}
function cd(t) {
  let e = {};
  if (t) {
    let r = t.indexOf("#");
    r >= 0 && ((e.hash = t.substr(r)), (t = t.substr(0, r)));
    let n = t.indexOf("?");
    n >= 0 && ((e.search = t.substr(n)), (t = t.substr(0, n))),
      t && (e.pathname = t);
  }
  return e;
}
function hK(t, e, r, n) {
  n === void 0 && (n = {});
  let { window: i = document.defaultView, v5Compat: a = !1 } = n,
    s = i.history,
    o = Ec.Pop,
    c = null,
    u = d();
  u == null &&
    ((u = 0),
    s.replaceState(
      gp({}, s.state, {
        idx: u,
      }),
      ""
    ));
  function d() {
    return (
      s.state || {
        idx: null,
      }
    ).idx;
  }
  function m() {
    o = Ec.Pop;
    let b = d(),
      w = b == null ? null : b - u;
    (u = b),
      c &&
        c({
          action: o,
          location: I.location,
          delta: w,
        });
  }
  function v(b, w) {
    o = Ec.Push;
    let S = H6(I.location, b, w);
    u = d() + 1;
    let k = LA(S, u),
      N = I.createHref(S);
    try {
      s.pushState(k, "", N);
    } catch (O) {
      if (O instanceof DOMException && O.name === "DataCloneError") throw O;
      i.location.assign(N);
    }
    a &&
      c &&
      c({
        action: o,
        location: I.location,
        delta: 1,
      });
  }
  function E(b, w) {
    o = Ec.Replace;
    let S = H6(I.location, b, w);
    u = d();
    let k = LA(S, u),
      N = I.createHref(S);
    s.replaceState(k, "", N),
      a &&
        c &&
        c({
          action: o,
          location: I.location,
          delta: 0,
        });
  }
  function A(b) {
    let w = i.location.origin !== "null" ? i.location.origin : i.location.href,
      S = typeof b == "string" ? b : Pg(b);
    return (
      (S = S.replace(/ $/, "%20")),
      pn(
        w,
        "No window.location.(origin|href) available to create URL for href: " +
          S
      ),
      new URL(S, w)
    );
  }
  let I = {
    get action() {
      return o;
    },
    get location() {
      return t(i, s);
    },
    listen(b) {
      if (c) throw new Error("A history only accepts one active listener");
      return (
        i.addEventListener(FA, m),
        (c = b),
        () => {
          i.removeEventListener(FA, m), (c = null);
        }
      );
    },
    createHref(b) {
      return e(i, b);
    },
    createURL: A,
    encodeLocation(b) {
      let w = A(b);
      return {
        pathname: w.pathname,
        search: w.search,
        hash: w.hash,
      };
    },
    push: v,
    replace: E,
    go(b) {
      return s.go(b);
    },
  };
  return I;
}
var $A;
(function (t) {
  (t.data = "data"),
    (t.deferred = "deferred"),
    (t.redirect = "redirect"),
    (t.error = "error");
})($A || ($A = {}));
function pK(t, e, r) {
  return r === void 0 && (r = "/"), mK(t, e, r, !1);
}
function mK(t, e, r, n) {
  let i = typeof e == "string" ? cd(e) : e,
    a = D8(i.pathname || "/", r);
  if (a == null) return null;
  let s = CN(t);
  yK(s);
  let o = null;
  for (let c = 0; o == null && c < s.length; ++c) {
    let u = kK(a);
    o = CK(s[c], u, n);
  }
  return o;
}
function CN(t, e, r, n) {
  e === void 0 && (e = []), r === void 0 && (r = []), n === void 0 && (n = "");
  let i = (a, s, o) => {
    let c = {
      relativePath: o === void 0 ? a.path || "" : o,
      caseSensitive: a.caseSensitive === !0,
      childrenIndex: s,
      route: a,
    };
    c.relativePath.startsWith("/") &&
      (pn(
        c.relativePath.startsWith(n),
        'Absolute route path "' +
          c.relativePath +
          '" nested under path ' +
          ('"' + n + '" is not valid. An absolute child route path ') +
          "must start with the combined path of all its parent routes."
      ),
      (c.relativePath = c.relativePath.slice(n.length)));
    let u = Oc([n, c.relativePath]),
      d = r.concat(c);
    a.children &&
      a.children.length > 0 &&
      (pn(
        a.index !== !0,
        "Index routes must not have child routes. Please remove " +
          ('all child routes from route path "' + u + '".')
      ),
      CN(a.children, e, d, u)),
      !(a.path == null && !a.index) &&
        e.push({
          path: u,
          score: EK(u, a.index),
          routesMeta: d,
        });
  };
  return (
    t.forEach((a, s) => {
      var o;
      if (a.path === "" || !((o = a.path) != null && o.includes("?"))) i(a, s);
      else for (let c of AN(a.path)) i(a, s, c);
    }),
    e
  );
}
function AN(t) {
  let e = t.split("/");
  if (e.length === 0) return [];
  let [r, ...n] = e,
    i = r.endsWith("?"),
    a = r.replace(/\?$/, "");
  if (n.length === 0) return i ? [a, ""] : [a];
  let s = AN(n.join("/")),
    o = [];
  return (
    o.push(...s.map((c) => (c === "" ? a : [a, c].join("/")))),
    i && o.push(...s),
    o.map((c) => (t.startsWith("/") && c === "" ? "/" : c))
  );
}
function yK(t) {
  t.sort((e, r) =>
    e.score !== r.score
      ? r.score - e.score
      : TK(
          e.routesMeta.map((n) => n.childrenIndex),
          r.routesMeta.map((n) => n.childrenIndex)
        )
  );
}
const gK = /^:[\w-]+$/,
  bK = 3,
  vK = 2,
  xK = 1,
  wK = 10,
  _K = -2,
  UA = (t) => t === "*";
function EK(t, e) {
  let r = t.split("/"),
    n = r.length;
  return (
    r.some(UA) && (n += _K),
    e && (n += vK),
    r
      .filter((i) => !UA(i))
      .reduce((i, a) => i + (gK.test(a) ? bK : a === "" ? xK : wK), n)
  );
}
function TK(t, e) {
  return t.length === e.length && t.slice(0, -1).every((n, i) => n === e[i])
    ? t[t.length - 1] - e[e.length - 1]
    : 0;
}
function CK(t, e, r) {
  let { routesMeta: n } = t,
    i = {},
    a = "/",
    s = [];
  for (let o = 0; o < n.length; ++o) {
    let c = n[o],
      u = o === n.length - 1,
      d = a === "/" ? e : e.slice(a.length) || "/",
      m = WA(
        {
          path: c.relativePath,
          caseSensitive: c.caseSensitive,
          end: u,
        },
        d
      ),
      v = c.route;
    if (
      (!m &&
        u &&
        r &&
        !n[n.length - 1].route.index &&
        (m = WA(
          {
            path: c.relativePath,
            caseSensitive: c.caseSensitive,
            end: !1,
          },
          d
        )),
      !m)
    )
      return null;
    Object.assign(i, m.params),
      s.push({
        params: i,
        pathname: Oc([a, m.pathname]),
        pathnameBase: RK(Oc([a, m.pathnameBase])),
        route: v,
      }),
      m.pathnameBase !== "/" && (a = Oc([a, m.pathnameBase]));
  }
  return s;
}
function WA(t, e) {
  typeof t == "string" &&
    (t = {
      path: t,
      caseSensitive: !1,
      end: !0,
    });
  let [r, n] = AK(t.path, t.caseSensitive, t.end),
    i = e.match(r);
  if (!i) return null;
  let a = i[0],
    s = a.replace(/(.)\/+$/, "$1"),
    o = i.slice(1);
  return {
    params: n.reduce((u, d, m) => {
      let { paramName: v, isOptional: E } = d;
      if (v === "*") {
        let I = o[m] || "";
        s = a.slice(0, a.length - I.length).replace(/(.)\/+$/, "$1");
      }
      const A = o[m];
      return (
        E && !A ? (u[v] = void 0) : (u[v] = (A || "").replace(/%2F/g, "/")), u
      );
    }, {}),
    pathname: a,
    pathnameBase: s,
    pattern: t,
  };
}
function AK(t, e, r) {
  e === void 0 && (e = !1),
    r === void 0 && (r = !0),
    TN(
      t === "*" || !t.endsWith("*") || t.endsWith("/*"),
      'Route path "' +
        t +
        '" will be treated as if it were ' +
        ('"' + t.replace(/\*$/, "/*") + '" because the `*` character must ') +
        "always follow a `/` in the pattern. To get rid of this warning, " +
        ('please change the route path to "' + t.replace(/\*$/, "/*") + '".')
    );
  let n = [],
    i =
      "^" +
      t
        .replace(/\/*\*?$/, "")
        .replace(/^\/*/, "/")
        .replace(/[\\.*+^${}|()[\]]/g, "\\$&")
        .replace(
          /\/:([\w-]+)(\?)?/g,
          (s, o, c) => (
            n.push({
              paramName: o,
              isOptional: c != null,
            }),
            c ? "/?([^\\/]+)?" : "/([^\\/]+)"
          )
        );
  return (
    t.endsWith("*")
      ? (n.push({
          paramName: "*",
        }),
        (i += t === "*" || t === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$"))
      : r
      ? (i += "\\/*$")
      : t !== "" && t !== "/" && (i += "(?:(?=\\/|$))"),
    [new RegExp(i, e ? void 0 : "i"), n]
  );
}
function kK(t) {
  try {
    return t
      .split("/")
      .map((e) => decodeURIComponent(e).replace(/\//g, "%2F"))
      .join("/");
  } catch (e) {
    return (
      TN(
        !1,
        'The URL path "' +
          t +
          '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' +
          ("encoding (" + e + ").")
      ),
      t
    );
  }
}
function D8(t, e) {
  if (e === "/") return t;
  if (!t.toLowerCase().startsWith(e.toLowerCase())) return null;
  let r = e.endsWith("/") ? e.length - 1 : e.length,
    n = t.charAt(r);
  return n && n !== "/" ? null : t.slice(r) || "/";
}
function SK(t, e) {
  e === void 0 && (e = "/");
  let {
    pathname: r,
    search: n = "",
    hash: i = "",
  } = typeof t == "string" ? cd(t) : t;
  return {
    pathname: r ? (r.startsWith("/") ? r : MK(r, e)) : e,
    search: PK(n),
    hash: NK(i),
  };
}
function MK(t, e) {
  let r = e.replace(/\/+$/, "").split("/");
  return (
    t.split("/").forEach((i) => {
      i === ".." ? r.length > 1 && r.pop() : i !== "." && r.push(i);
    }),
    r.length > 1 ? r.join("/") : "/"
  );
}
function Ow(t, e, r, n) {
  return (
    "Cannot include a '" +
    t +
    "' character in a manually specified " +
    ("`to." +
      e +
      "` field [" +
      JSON.stringify(n) +
      "].  Please separate it out to the ") +
    ("`to." + r + "` field. Alternatively you may provide the full path as ") +
    'a string in <Link to="..."> and the router will parse it for you.'
  );
}
function IK(t) {
  return t.filter(
    (e, r) => r === 0 || (e.route.path && e.route.path.length > 0)
  );
}
function kN(t, e) {
  let r = IK(t);
  return e
    ? r.map((n, i) => (i === r.length - 1 ? n.pathname : n.pathnameBase))
    : r.map((n) => n.pathnameBase);
}
function SN(t, e, r, n) {
  n === void 0 && (n = !1);
  let i;
  typeof t == "string"
    ? (i = cd(t))
    : ((i = gp({}, t)),
      pn(
        !i.pathname || !i.pathname.includes("?"),
        Ow("?", "pathname", "search", i)
      ),
      pn(
        !i.pathname || !i.pathname.includes("#"),
        Ow("#", "pathname", "hash", i)
      ),
      pn(!i.search || !i.search.includes("#"), Ow("#", "search", "hash", i)));
  let a = t === "" || i.pathname === "",
    s = a ? "/" : i.pathname,
    o;
  if (s == null) o = r;
  else {
    let m = e.length - 1;
    if (!n && s.startsWith("..")) {
      let v = s.split("/");
      for (; v[0] === ".."; ) v.shift(), (m -= 1);
      i.pathname = v.join("/");
    }
    o = m >= 0 ? e[m] : "/";
  }
  let c = SK(i, o),
    u = s && s !== "/" && s.endsWith("/"),
    d = (a || s === ".") && r.endsWith("/");
  return !c.pathname.endsWith("/") && (u || d) && (c.pathname += "/"), c;
}
const Oc = (t) => t.join("/").replace(/\/\/+/g, "/"),
  RK = (t) => t.replace(/\/+$/, "").replace(/^\/*/, "/"),
  PK = (t) => (!t || t === "?" ? "" : t.startsWith("?") ? t : "?" + t),
  NK = (t) => (!t || t === "#" ? "" : t.startsWith("#") ? t : "#" + t);
function BK(t) {
  return (
    t != null &&
    typeof t.status == "number" &&
    typeof t.statusText == "string" &&
    typeof t.internal == "boolean" &&
    "data" in t
  );
}
const MN = ["post", "put", "patch", "delete"];
new Set(MN);
const DK = ["get", ...MN];
new Set(DK);
/**
 * React Router v6.26.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function bp() {
  return (
    (bp = Object.assign
      ? Object.assign.bind()
      : function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var r = arguments[e];
            for (var n in r)
              Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);
          }
          return t;
        }),
    bp.apply(this, arguments)
  );
}
const O8 = ye.createContext(null),
  OK = ye.createContext(null),
  Iu = ye.createContext(null),
  jb = ye.createContext(null),
  Ru = ye.createContext({
    outlet: null,
    matches: [],
    isDataRoute: !1,
  }),
  IN = ye.createContext(null);
function FK(t, e) {
  let { relative: r } = e === void 0 ? {} : e;
  Mm() || pn(!1);
  let { basename: n, navigator: i } = ye.useContext(Iu),
    {
      hash: a,
      pathname: s,
      search: o,
    } = PN(t, {
      relative: r,
    }),
    c = s;
  return (
    n !== "/" && (c = s === "/" ? n : Oc([n, s])),
    i.createHref({
      pathname: c,
      search: o,
      hash: a,
    })
  );
}
function Mm() {
  return ye.useContext(jb) != null;
}
function Im() {
  return Mm() || pn(!1), ye.useContext(jb).location;
}
function RN(t) {
  ye.useContext(Iu).static || ye.useLayoutEffect(t);
}
function ld() {
  let { isDataRoute: t } = ye.useContext(Ru);
  return t ? JK() : LK();
}
function LK() {
  Mm() || pn(!1);
  let t = ye.useContext(O8),
    { basename: e, future: r, navigator: n } = ye.useContext(Iu),
    { matches: i } = ye.useContext(Ru),
    { pathname: a } = Im(),
    s = JSON.stringify(kN(i, r.v7_relativeSplatPath)),
    o = ye.useRef(!1);
  return (
    RN(() => {
      o.current = !0;
    }),
    ye.useCallback(
      function (u, d) {
        if ((d === void 0 && (d = {}), !o.current)) return;
        if (typeof u == "number") {
          n.go(u);
          return;
        }
        let m = SN(u, JSON.parse(s), a, d.relative === "path");
        t == null &&
          e !== "/" &&
          (m.pathname = m.pathname === "/" ? e : Oc([e, m.pathname])),
          (d.replace ? n.replace : n.push)(m, d.state, d);
      },
      [e, n, s, a, t]
    )
  );
}
function PN(t, e) {
  let { relative: r } = e === void 0 ? {} : e,
    { future: n } = ye.useContext(Iu),
    { matches: i } = ye.useContext(Ru),
    { pathname: a } = Im(),
    s = JSON.stringify(kN(i, n.v7_relativeSplatPath));
  return ye.useMemo(() => SN(t, JSON.parse(s), a, r === "path"), [t, s, a, r]);
}
function $K(t, e) {
  return UK(t, e);
}
function UK(t, e, r, n) {
  Mm() || pn(!1);
  let { navigator: i } = ye.useContext(Iu),
    { matches: a } = ye.useContext(Ru),
    s = a[a.length - 1],
    o = s ? s.params : {};
  s && s.pathname;
  let c = s ? s.pathnameBase : "/";
  s && s.route;
  let u = Im(),
    d;
  if (e) {
    var m;
    let b = typeof e == "string" ? cd(e) : e;
    c === "/" || ((m = b.pathname) != null && m.startsWith(c)) || pn(!1),
      (d = b);
  } else d = u;
  let v = d.pathname || "/",
    E = v;
  if (c !== "/") {
    let b = c.replace(/^\//, "").split("/");
    E = "/" + v.replace(/^\//, "").split("/").slice(b.length).join("/");
  }
  let A = pK(t, {
      pathname: E,
    }),
    I = qK(
      A &&
        A.map((b) =>
          Object.assign({}, b, {
            params: Object.assign({}, o, b.params),
            pathname: Oc([
              c,
              i.encodeLocation
                ? i.encodeLocation(b.pathname).pathname
                : b.pathname,
            ]),
            pathnameBase:
              b.pathnameBase === "/"
                ? c
                : Oc([
                    c,
                    i.encodeLocation
                      ? i.encodeLocation(b.pathnameBase).pathname
                      : b.pathnameBase,
                  ]),
          })
        ),
      a,
      r,
      n
    );
  return e && I
    ? ye.createElement(
        jb.Provider,
        {
          value: {
            location: bp(
              {
                pathname: "/",
                search: "",
                hash: "",
                state: null,
                key: "default",
              },
              d
            ),
            navigationType: Ec.Pop,
          },
        },
        I
      )
    : I;
}
function WK() {
  let t = ZK(),
    e = BK(t)
      ? t.status + " " + t.statusText
      : t instanceof Error
      ? t.message
      : JSON.stringify(t),
    r = t instanceof Error ? t.stack : null,
    i = {
      padding: "0.5rem",
      backgroundColor: "rgba(200,200,200, 0.5)",
    };
  return ye.createElement(
    ye.Fragment,
    null,
    ye.createElement("h2", null, "Unexpected Application Error!"),
    ye.createElement(
      "h3",
      {
        style: {
          fontStyle: "italic",
        },
      },
      e
    ),
    r
      ? ye.createElement(
          "pre",
          {
            style: i,
          },
          r
        )
      : null,
    null
  );
}
const jK = ye.createElement(WK, null);
class HK extends ye.Component {
  constructor(e) {
    super(e),
      (this.state = {
        location: e.location,
        revalidation: e.revalidation,
        error: e.error,
      });
  }
  static getDerivedStateFromError(e) {
    return {
      error: e,
    };
  }
  static getDerivedStateFromProps(e, r) {
    return r.location !== e.location ||
      (r.revalidation !== "idle" && e.revalidation === "idle")
      ? {
          error: e.error,
          location: e.location,
          revalidation: e.revalidation,
        }
      : {
          error: e.error !== void 0 ? e.error : r.error,
          location: r.location,
          revalidation: e.revalidation || r.revalidation,
        };
  }
  componentDidCatch(e, r) {
    console.error(
      "React Router caught the following error during render",
      e,
      r
    );
  }
  render() {
    return this.state.error !== void 0
      ? ye.createElement(
          Ru.Provider,
          {
            value: this.props.routeContext,
          },
          ye.createElement(IN.Provider, {
            value: this.state.error,
            children: this.props.component,
          })
        )
      : this.props.children;
  }
}
function zK(t) {
  let { routeContext: e, match: r, children: n } = t,
    i = ye.useContext(O8);
  return (
    i &&
      i.static &&
      i.staticContext &&
      (r.route.errorElement || r.route.ErrorBoundary) &&
      (i.staticContext._deepestRenderedBoundaryId = r.route.id),
    ye.createElement(
      Ru.Provider,
      {
        value: e,
      },
      n
    )
  );
}
function qK(t, e, r, n) {
  var i;
  if (
    (e === void 0 && (e = []),
    r === void 0 && (r = null),
    n === void 0 && (n = null),
    t == null)
  ) {
    var a;
    if (!r) return null;
    if (r.errors) t = r.matches;
    else if (
      (a = n) != null &&
      a.v7_partialHydration &&
      e.length === 0 &&
      !r.initialized &&
      r.matches.length > 0
    )
      t = r.matches;
    else return null;
  }
  let s = t,
    o = (i = r) == null ? void 0 : i.errors;
  if (o != null) {
    let d = s.findIndex(
      (m) => m.route.id && (o == null ? void 0 : o[m.route.id]) !== void 0
    );
    d >= 0 || pn(!1), (s = s.slice(0, Math.min(s.length, d + 1)));
  }
  let c = !1,
    u = -1;
  if (r && n && n.v7_partialHydration)
    for (let d = 0; d < s.length; d++) {
      let m = s[d];
      if (
        ((m.route.HydrateFallback || m.route.hydrateFallbackElement) && (u = d),
        m.route.id)
      ) {
        let { loaderData: v, errors: E } = r,
          A =
            m.route.loader &&
            v[m.route.id] === void 0 &&
            (!E || E[m.route.id] === void 0);
        if (m.route.lazy || A) {
          (c = !0), u >= 0 ? (s = s.slice(0, u + 1)) : (s = [s[0]]);
          break;
        }
      }
    }
  return s.reduceRight((d, m, v) => {
    let E,
      A = !1,
      I = null,
      b = null;
    r &&
      ((E = o && m.route.id ? o[m.route.id] : void 0),
      (I = m.route.errorElement || jK),
      c &&
        (u < 0 && v === 0
          ? ((A = !0), (b = null))
          : u === v &&
            ((A = !0), (b = m.route.hydrateFallbackElement || null))));
    let w = e.concat(s.slice(0, v + 1)),
      S = () => {
        let k;
        return (
          E
            ? (k = I)
            : A
            ? (k = b)
            : m.route.Component
            ? (k = ye.createElement(m.route.Component, null))
            : m.route.element
            ? (k = m.route.element)
            : (k = d),
          ye.createElement(zK, {
            match: m,
            routeContext: {
              outlet: d,
              matches: w,
              isDataRoute: r != null,
            },
            children: k,
          })
        );
      };
    return r && (m.route.ErrorBoundary || m.route.errorElement || v === 0)
      ? ye.createElement(HK, {
          location: r.location,
          revalidation: r.revalidation,
          component: I,
          error: E,
          children: S(),
          routeContext: {
            outlet: null,
            matches: w,
            isDataRoute: !0,
          },
        })
      : S();
  }, null);
}
var NN = (function (t) {
    return (
      (t.UseBlocker = "useBlocker"),
      (t.UseRevalidator = "useRevalidator"),
      (t.UseNavigateStable = "useNavigate"),
      t
    );
  })(NN || {}),
  Ng = (function (t) {
    return (
      (t.UseBlocker = "useBlocker"),
      (t.UseLoaderData = "useLoaderData"),
      (t.UseActionData = "useActionData"),
      (t.UseRouteError = "useRouteError"),
      (t.UseNavigation = "useNavigation"),
      (t.UseRouteLoaderData = "useRouteLoaderData"),
      (t.UseMatches = "useMatches"),
      (t.UseRevalidator = "useRevalidator"),
      (t.UseNavigateStable = "useNavigate"),
      (t.UseRouteId = "useRouteId"),
      t
    );
  })(Ng || {});
function VK(t) {
  let e = ye.useContext(O8);
  return e || pn(!1), e;
}
function KK(t) {
  let e = ye.useContext(OK);
  return e || pn(!1), e;
}
function GK(t) {
  let e = ye.useContext(Ru);
  return e || pn(!1), e;
}
function BN(t) {
  let e = GK(),
    r = e.matches[e.matches.length - 1];
  return r.route.id || pn(!1), r.route.id;
}
function ZK() {
  var t;
  let e = ye.useContext(IN),
    r = KK(Ng.UseRouteError),
    n = BN(Ng.UseRouteError);
  return e !== void 0 ? e : (t = r.errors) == null ? void 0 : t[n];
}
function JK() {
  let { router: t } = VK(NN.UseNavigateStable),
    e = BN(Ng.UseNavigateStable),
    r = ye.useRef(!1);
  return (
    RN(() => {
      r.current = !0;
    }),
    ye.useCallback(
      function (i, a) {
        a === void 0 && (a = {}),
          r.current &&
            (typeof i == "number"
              ? t.navigate(i)
              : t.navigate(
                  i,
                  bp(
                    {
                      fromRouteId: e,
                    },
                    a
                  )
                ));
      },
      [t, e]
    )
  );
}
function yh(t) {
  pn(!1);
}
function QK(t) {
  let {
    basename: e = "/",
    children: r = null,
    location: n,
    navigationType: i = Ec.Pop,
    navigator: a,
    static: s = !1,
    future: o,
  } = t;
  Mm() && pn(!1);
  let c = e.replace(/^\/*/, "/"),
    u = ye.useMemo(
      () => ({
        basename: c,
        navigator: a,
        static: s,
        future: bp(
          {
            v7_relativeSplatPath: !1,
          },
          o
        ),
      }),
      [c, o, a, s]
    );
  typeof n == "string" && (n = cd(n));
  let {
      pathname: d = "/",
      search: m = "",
      hash: v = "",
      state: E = null,
      key: A = "default",
    } = n,
    I = ye.useMemo(() => {
      let b = D8(d, c);
      return b == null
        ? null
        : {
            location: {
              pathname: b,
              search: m,
              hash: v,
              state: E,
              key: A,
            },
            navigationType: i,
          };
    }, [c, d, m, v, E, A, i]);
  return I == null
    ? null
    : ye.createElement(
        Iu.Provider,
        {
          value: u,
        },
        ye.createElement(jb.Provider, {
          children: r,
          value: I,
        })
      );
}
function YK(t) {
  let { children: e, location: r } = t;
  return $K(z6(e), r);
}
new Promise(() => {});
function z6(t, e) {
  e === void 0 && (e = []);
  let r = [];
  return (
    ye.Children.forEach(t, (n, i) => {
      if (!ye.isValidElement(n)) return;
      let a = [...e, i];
      if (n.type === ye.Fragment) {
        r.push.apply(r, z6(n.props.children, a));
        return;
      }
      n.type !== yh && pn(!1), !n.props.index || !n.props.children || pn(!1);
      let s = {
        id: n.props.id || a.join("-"),
        caseSensitive: n.props.caseSensitive,
        element: n.props.element,
        Component: n.props.Component,
        index: n.props.index,
        path: n.props.path,
        loader: n.props.loader,
        action: n.props.action,
        errorElement: n.props.errorElement,
        ErrorBoundary: n.props.ErrorBoundary,
        hasErrorBoundary:
          n.props.ErrorBoundary != null || n.props.errorElement != null,
        shouldRevalidate: n.props.shouldRevalidate,
        handle: n.props.handle,
        lazy: n.props.lazy,
      };
      n.props.children && (s.children = z6(n.props.children, a)), r.push(s);
    }),
    r
  );
}
/**
 * React Router DOM v6.26.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function q6() {
  return (
    (q6 = Object.assign
      ? Object.assign.bind()
      : function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var r = arguments[e];
            for (var n in r)
              Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);
          }
          return t;
        }),
    q6.apply(this, arguments)
  );
}
function XK(t, e) {
  if (t == null) return {};
  var r = {},
    n = Object.keys(t),
    i,
    a;
  for (a = 0; a < n.length; a++)
    (i = n[a]), !(e.indexOf(i) >= 0) && (r[i] = t[i]);
  return r;
}
function eG(t) {
  return !!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey);
}
function tG(t, e) {
  return t.button === 0 && (!e || e === "_self") && !eG(t);
}
const rG = [
    "onClick",
    "relative",
    "reloadDocument",
    "replace",
    "state",
    "target",
    "to",
    "preventScrollReset",
    "unstable_viewTransition",
  ],
  nG = "6";
try {
  window.__reactRouterVersion = nG;
} catch {}
const iG = "startTransition",
  jA = J5[iG];
function aG(t) {
  let { basename: e, children: r, future: n, window: i } = t,
    a = ye.useRef();
  a.current == null &&
    (a.current = fK({
      window: i,
      v5Compat: !0,
    }));
  let s = a.current,
    [o, c] = ye.useState({
      action: s.action,
      location: s.location,
    }),
    { v7_startTransition: u } = n || {},
    d = ye.useCallback(
      (m) => {
        u && jA ? jA(() => c(m)) : c(m);
      },
      [c, u]
    );
  return (
    ye.useLayoutEffect(() => s.listen(d), [s, d]),
    ye.createElement(QK, {
      basename: e,
      children: r,
      location: o.location,
      navigationType: o.action,
      navigator: s,
      future: n,
    })
  );
}
const sG =
    typeof window < "u" &&
    typeof window.document < "u" &&
    typeof window.document.createElement < "u",
  oG = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
  DN = ye.forwardRef(function (e, r) {
    let {
        onClick: n,
        relative: i,
        reloadDocument: a,
        replace: s,
        state: o,
        target: c,
        to: u,
        preventScrollReset: d,
        unstable_viewTransition: m,
      } = e,
      v = XK(e, rG),
      { basename: E } = ye.useContext(Iu),
      A,
      I = !1;
    if (typeof u == "string" && oG.test(u) && ((A = u), sG))
      try {
        let k = new URL(window.location.href),
          N = u.startsWith("//") ? new URL(k.protocol + u) : new URL(u),
          O = D8(N.pathname, E);
        N.origin === k.origin && O != null
          ? (u = O + N.search + N.hash)
          : (I = !0);
      } catch {}
    let b = FK(u, {
        relative: i,
      }),
      w = cG(u, {
        replace: s,
        state: o,
        target: c,
        preventScrollReset: d,
        relative: i,
        unstable_viewTransition: m,
      });
    function S(k) {
      n && n(k), k.defaultPrevented || w(k);
    }
    return ye.createElement(
      "a",
      q6({}, v, {
        href: A || b,
        onClick: I || a ? n : S,
        ref: r,
        target: c,
      })
    );
  });
var HA;
(function (t) {
  (t.UseScrollRestoration = "useScrollRestoration"),
    (t.UseSubmit = "useSubmit"),
    (t.UseSubmitFetcher = "useSubmitFetcher"),
    (t.UseFetcher = "useFetcher"),
    (t.useViewTransitionState = "useViewTransitionState");
})(HA || (HA = {}));
var zA;
(function (t) {
  (t.UseFetcher = "useFetcher"),
    (t.UseFetchers = "useFetchers"),
    (t.UseScrollRestoration = "useScrollRestoration");
})(zA || (zA = {}));
function cG(t, e) {
  let {
      target: r,
      replace: n,
      state: i,
      preventScrollReset: a,
      relative: s,
      unstable_viewTransition: o,
    } = e === void 0 ? {} : e,
    c = ld(),
    u = Im(),
    d = PN(t, {
      relative: s,
    });
  return ye.useCallback(
    (m) => {
      if (tG(m, r)) {
        m.preventDefault();
        let v = n !== void 0 ? n : Pg(u) === Pg(d);
        c(t, {
          replace: v,
          state: i,
          preventScrollReset: a,
          relative: s,
          unstable_viewTransition: o,
        });
      }
    },
    [u, c, d, n, i, r, t, a, s, o]
  );
}
const lG =
    "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20clip-path='url(%23clip0_1071_25627)'%3e%3cpath%20d='M17%200C16.7348%200%2016.4804%200.105357%2016.2929%200.292893C16.1054%200.48043%2016%200.734784%2016%201C16%203.949%2013.417%205%2011%205H4C2.93913%205%201.92172%205.42143%201.17157%206.17157C0.421427%206.92172%200%207.93913%200%209L0%2011C0.00218416%2011.5987%200.139462%2012.1893%200.401603%2012.7276C0.663743%2013.2659%201.04399%2013.7381%201.514%2014.109L5.086%2022.081C5.34004%2022.6521%205.75417%2023.1373%206.27827%2023.4779C6.80237%2023.8185%207.41396%2023.9998%208.039%2024C8.53631%2023.9997%209.02565%2023.875%209.46247%2023.6373C9.89929%2023.3996%2010.2697%2023.0564%2010.54%2022.639C10.8104%2022.2215%2010.972%2021.7431%2011.0103%2021.2473C11.0485%2020.7515%2010.9621%2020.2539%2010.759%2019.8L8.559%2015H11C13.417%2015%2016%2016.051%2016%2019C16%2019.2652%2016.1054%2019.5196%2016.2929%2019.7071C16.4804%2019.8946%2016.7348%2020%2017%2020C17.2652%2020%2017.5196%2019.8946%2017.7071%2019.7071C17.8946%2019.5196%2018%2019.2652%2018%2019V1C18%200.734784%2017.8946%200.48043%2017.7071%200.292893C17.5196%200.105357%2017.2652%200%2017%200V0ZM8.937%2020.619C9.00324%2020.7686%209.03109%2020.9323%209.01804%2021.0954C9.005%2021.2585%208.95145%2021.4157%208.86227%2021.5529C8.77309%2021.69%208.65109%2021.8027%208.50733%2021.8808C8.36357%2021.9589%208.20259%2021.9999%208.039%2022C7.80039%2021.9998%207.56697%2021.9304%207.36709%2021.8001C7.1672%2021.6698%207.00945%2021.4842%206.913%2021.266L4.105%2015H6.359L8.937%2020.619ZM16%2014.6C14.5713%2013.4992%2012.8024%2012.9331%2011%2013H4C3.46957%2013%202.96086%2012.7893%202.58579%2012.4142C2.21071%2012.0391%202%2011.5304%202%2011V9C2%208.46957%202.21071%207.96086%202.58579%207.58579C2.96086%207.21071%203.46957%207%204%207H11C12.8018%207.0683%2014.5706%206.50403%2016%205.405V14.6ZM23.9%2015.452C23.8413%2015.5696%2023.7601%2015.6744%2023.6609%2015.7606C23.5617%2015.8467%2023.4465%2015.9125%2023.3218%2015.9541C23.1972%2015.9957%2023.0656%2016.0123%2022.9345%2016.0031C22.8035%2015.9938%2022.6755%2015.9588%2022.558%2015.9L20.558%2014.9C20.3206%2014.7814%2020.1401%2014.5735%2020.0561%2014.3218C19.972%2014.0701%2019.9915%2013.7954%2020.11%2013.558C20.2286%2013.3206%2020.4365%2013.1401%2020.6882%2013.0561C20.9399%2012.972%2021.2146%2012.9914%2021.452%2013.11L23.452%2014.11C23.6881%2014.2285%2023.8678%2014.4356%2023.9518%2014.6861C24.0357%2014.9366%2024.0171%2015.2102%2023.9%2015.447V15.452ZM20.11%206.452C20.0512%206.33448%2020.0162%206.20653%2020.0069%206.07546C19.9977%205.9444%2020.0143%205.81279%2020.0559%205.68816C20.0975%205.56353%2020.1633%205.44832%2020.2494%205.34912C20.3356%205.24991%2020.4404%205.16866%2020.558%205.11L22.558%204.11C22.7954%203.99145%2023.0701%203.97205%2023.3218%204.05606C23.5735%204.14008%2023.7815%204.32063%2023.9%204.558C24.0186%204.79537%2024.038%205.07011%2023.9539%205.32178C23.8699%205.57346%2023.6894%205.78145%2023.452%205.9L21.452%206.9C21.3345%206.95876%2021.2065%206.99378%2021.0755%207.00306C20.9444%207.01234%2020.8128%206.99571%2020.6882%206.9541C20.5635%206.9125%2020.4483%206.84674%2020.3491%206.76058C20.2499%206.67443%2020.1687%206.56957%2020.11%206.452V6.452ZM20%2010C20%209.73478%2020.1054%209.48043%2020.2929%209.29289C20.4804%209.10536%2020.7348%209%2021%209H23C23.2652%209%2023.5196%209.10536%2023.7071%209.29289C23.8946%209.48043%2024%209.73478%2024%2010C24%2010.2652%2023.8946%2010.5196%2023.7071%2010.7071C23.5196%2010.8946%2023.2652%2011%2023%2011H21C20.7348%2011%2020.4804%2010.8946%2020.2929%2010.7071C20.1054%2010.5196%2020%2010.2652%2020%2010Z'%20fill='%231DC071'/%3e%3c/g%3e%3cdefs%3e%3cclipPath%20id='clip0_1071_25627'%3e%3crect%20width='24'%20height='24'%20fill='white'/%3e%3c/clipPath%3e%3c/defs%3e%3c/svg%3e",
  uG =
    "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M1%204.5C1%201.87479%201.02811%201%204.5%201C7.97189%201%208%201.87479%208%204.5C8%207.12521%208.01107%208%204.5%208C0.988927%208%201%207.12521%201%204.5Z'%20stroke='%231DC071'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M12%204.5C12%201.87479%2012.0281%201%2015.5%201C18.9719%201%2019%201.87479%2019%204.5C19%207.12521%2019.0111%208%2015.5%208C11.9889%208%2012%207.12521%2012%204.5Z'%20stroke='%231DC071'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M1%2015.5C1%2012.8748%201.02811%2012%204.5%2012C7.97189%2012%208%2012.8748%208%2015.5C8%2018.1252%208.01107%2019%204.5%2019C0.988927%2019%201%2018.1252%201%2015.5Z'%20stroke='%231DC071'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M12%2015.5C12%2012.8748%2012.0281%2012%2015.5%2012C18.9719%2012%2019%2012.8748%2019%2015.5C19%2018.1252%2019.0111%2019%2015.5%2019C11.9889%2019%2012%2018.1252%2012%2015.5Z'%20stroke='%231DC071'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e",
  fG =
    "data:image/svg+xml,%3csvg%20width='28'%20height='24'%20viewBox='0%200%2028%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M3.18595%209.23478C1.8487%206.89136%202.58741%203.92689%204.83591%202.61345C7.0844%201.30002%209.99122%202.13499%2011.3285%204.47841L17.1985%2014.7652C18.5358%2017.1086%2017.797%2020.0731%2015.5485%2021.3865C13.3001%2022.6999%2010.3932%2021.865%209.05598%2019.5215L3.18595%209.23478Z'%20fill='url(%23paint0_linear_2290_2172)'/%3e%3cpath%20d='M27.2349%206.6917C27.2349%209.32347%2025.1345%2011.4569%2022.5435%2011.4569C19.9525%2011.4569%2017.8521%209.32347%2017.8521%206.6917C17.8521%204.05992%2019.9525%201.92645%2022.5435%201.92645C25.1345%201.92645%2027.2349%204.05992%2027.2349%206.6917Z'%20fill='url(%23paint1_linear_2290_2172)'/%3e%3cdefs%3e%3clinearGradient%20id='paint0_linear_2290_2172'%20x1='4.83591'%20y1='2.61345'%20x2='15.441'%20y2='21.0019'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%231DC071'/%3e%3cstop%20offset='1'%20stop-color='%2377D9AA'/%3e%3c/linearGradient%3e%3clinearGradient%20id='paint1_linear_2290_2172'%20x1='22.5435'%20y1='1.92645'%20x2='22.5205'%20y2='11.2863'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%231DC071'/%3e%3cstop%20offset='1'%20stop-color='%2377D9AA'/%3e%3c/linearGradient%3e%3c/defs%3e%3c/svg%3e",
  dG =
    "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M5%206.64513V5.551C5%203.43076%205%202.37064%205.67965%201.77328C6.35931%201.17591%207.41066%201.31197%209.51337%201.58408L16.77%202.52318C19.2611%202.84556%2020.5067%203.00675%2021.2533%203.85626C22%204.70577%2022%205.9617%2022%208.47356V15.5264C22%2018.0383%2022%2019.2942%2021.2533%2020.1437C20.5067%2020.9933%2019.2611%2021.1544%2016.77%2021.4768L9.51337%2022.4159C7.41066%2022.688%206.35931%2022.8241%205.67965%2022.2267C5%2021.6294%205%2020.5692%205%2018.449V17.5726'%20stroke='%231DC071'%20stroke-width='2'/%3e%3cpath%20d='M15%2012L15.8107%2011.4145L16.2335%2012L15.8107%2012.5855L15%2012ZM1%2013C0.447715%2013%200%2012.5523%200%2012C0%2011.4477%200.447715%2011%201%2011V13ZM11.4773%205.41451L15.8107%2011.4145L14.1893%2012.5855L9.85599%206.58549L11.4773%205.41451ZM15.8107%2012.5855L11.4773%2018.5855L9.85599%2017.4145L14.1893%2011.4145L15.8107%2012.5855ZM15%2013H1V11H15V13Z'%20fill='%231DC071'/%3e%3c/svg%3e",
  hG =
    "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3ccircle%20cx='12'%20cy='9'%20r='3'%20stroke='%231DC071'%20stroke-width='2'%20stroke-linecap='round'/%3e%3ccircle%20cx='12'%20cy='12'%20r='11'%20stroke='%231DC071'%20stroke-width='2'/%3e%3cpath%20d='M19%2020C18.5871%2018.8525%2017.6773%2017.8384%2016.4117%2017.1152C15.146%2016.392%2013.5953%2016%2012%2016C10.4047%2016%208.85398%2016.392%207.58835%2017.1152C6.32271%2017.8384%205.41289%2018.8525%205%2020'%20stroke='%231DC071'%20stroke-width='2'%20stroke-linecap='round'/%3e%3c/svg%3e",
  pG =
    "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M12%2018.5455C10.264%2018.5455%208.59918%2017.8558%207.37167%2016.6283C6.14415%2015.4008%205.45455%2013.736%205.45455%2012C5.45455%2010.264%206.14415%208.59918%207.37167%207.37167C8.59918%206.14415%2010.264%205.45455%2012%205.45455C13.736%205.45455%2015.4008%206.14415%2016.6283%207.37167C17.8558%208.59918%2018.5455%2010.264%2018.5455%2012C18.5455%2013.736%2017.8558%2015.4008%2016.6283%2016.6283C15.4008%2017.8558%2013.736%2018.5455%2012%2018.5455ZM12%2016.3636C13.1573%2016.3636%2014.2672%2015.9039%2015.0856%2015.0856C15.9039%2014.2672%2016.3636%2013.1573%2016.3636%2012C16.3636%2010.8427%2015.9039%209.73278%2015.0856%208.91444C14.2672%208.0961%2013.1573%207.63636%2012%207.63636C10.8427%207.63636%209.73278%208.0961%208.91444%208.91444C8.0961%209.73278%207.63636%2010.8427%207.63636%2012C7.63636%2013.1573%208.0961%2014.2672%208.91444%2015.0856C9.73278%2015.9039%2010.8427%2016.3636%2012%2016.3636ZM10.9091%201.09091C10.9091%200.488417%2011.3975%200%2012%200C12.6025%200%2013.0909%200.488417%2013.0909%201.09091V2.18182C13.0909%202.78431%2012.6025%203.27273%2012%203.27273C11.3975%203.27273%2010.9091%202.78431%2010.9091%202.18182V1.09091ZM10.9091%2021.8182C10.9091%2021.2157%2011.3975%2020.7273%2012%2020.7273C12.6025%2020.7273%2013.0909%2021.2157%2013.0909%2021.8182V22.9091C13.0909%2023.5116%2012.6025%2024%2012%2024C11.3975%2024%2010.9091%2023.5116%2010.9091%2022.9091V21.8182ZM3.51491%205.05745C3.08895%204.63149%203.08895%203.94087%203.51491%203.51491C3.94087%203.08895%204.63149%203.08895%205.05745%203.51491L5.82873%204.28618C6.25469%204.71214%206.25469%205.40277%205.82873%205.82873C5.40277%206.25469%204.71214%206.25469%204.28618%205.82873L3.51491%205.05745ZM18.1713%2019.7138C17.7453%2019.2879%2017.7453%2018.5972%2018.1713%2018.1713C18.5972%2017.7453%2019.2879%2017.7453%2019.7138%2018.1713L20.4851%2018.9425C20.9111%2019.3685%2020.9111%2020.0591%2020.4851%2020.4851C20.0591%2020.9111%2019.3685%2020.9111%2018.9425%2020.4851L18.1713%2019.7138ZM18.9421%203.51464C19.3682%203.0883%2020.0594%203.08834%2020.4855%203.51473C20.9113%203.94083%2020.9111%204.63141%2020.4852%205.05736L19.7139%205.82864C19.2879%206.25465%2018.5972%206.25465%2018.1712%205.82864C17.7452%205.4027%2017.7452%204.71213%2018.171%204.28609L18.9421%203.51464ZM4.28618%2018.1713C4.71214%2017.7453%205.40277%2017.7453%205.82873%2018.1713C6.25469%2018.5972%206.25469%2019.2879%205.82873%2019.7138L5.05746%2020.4851C4.63149%2020.9111%203.94087%2020.9111%203.51491%2020.4851C3.08895%2020.0591%203.08895%2019.3685%203.51491%2018.9425L4.28618%2018.1713ZM22.9091%2010.9091C23.5116%2010.9091%2024%2011.3975%2024%2012C24%2012.6025%2023.5116%2013.0909%2022.9091%2013.0909H21.8182C21.2157%2013.0909%2020.7273%2012.6025%2020.7273%2012C20.7273%2011.3975%2021.2157%2010.9091%2021.8182%2010.9091H22.9091ZM2.18182%2010.9091C2.78431%2010.9091%203.27273%2011.3975%203.27273%2012C3.27273%2012.6025%202.78431%2013.0909%202.18182%2013.0909H1.09091C0.488417%2013.0909%200%2012.6025%200%2012C0%2011.3975%200.488417%2010.9091%201.09091%2010.9091H2.18182Z'%20fill='%23808191'/%3e%3c/svg%3e",
  mG =
    "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20clip-path='url(%23clip0_1071_25635)'%3e%3cpath%20d='M4.46098%2011H2.1C1.49249%2011%201%2010.5026%201%209.88889V2.11111C1%201.49746%201.49249%201%202.1%201H21.9C22.5075%201%2023%201.49746%2023%202.11111V9.88889C23%2010.5026%2022.5075%2011%2021.9%2011H19.8207'%20stroke='%231DC071'%20stroke-width='2'/%3e%3cpath%20d='M19.4286%206H4.57143C4.25583%206%204%206.24551%204%206.54839V22.4516C4%2022.7545%204.25583%2023%204.57143%2023H19.4286C19.7442%2023%2020%2022.7545%2020%2022.4516V6.54839C20%206.24551%2019.7442%206%2019.4286%206Z'%20stroke='%231DC071'%20stroke-width='2'/%3e%3cpath%20d='M15%2016.3794C15%2016.8153%2014.8949%2017.2259%2014.6848%2017.6114C14.4825%2017.9886%2014.179%2018.3029%2013.7744%2018.5543C13.3775%2018.7973%2012.9066%2018.9398%2012.3619%2018.9817V20H11.6148V18.9691C10.8366%2018.8937%2010.2101%2018.6423%209.73537%2018.2149C9.2607%2017.779%209.0156%2017.1924%209%2016.4549H10.751C10.7977%2017.0583%2011.0856%2017.4229%2011.6148%2017.5486V15.1474C11.0545%2014.9966%2010.6031%2014.8457%2010.2607%2014.6949C9.9183%2014.544%209.62258%2014.301%209.37358%2013.9657C9.1245%2013.6304%209%2013.1737%209%2012.5954C9%2011.8663%209.24128%2011.2713%209.72375%2010.8103C10.214%2010.3493%2010.8443%2010.0853%2011.6148%2010.0183V9H12.3619V10.0183C13.109%2010.0853%2013.7043%2010.3284%2014.1479%2010.7474C14.5992%2011.1665%2014.8522%2011.7447%2014.9066%2012.4823H13.144C13.1206%2012.2393%2013.0389%2012.0297%2012.8988%2011.8537C12.7665%2011.6693%2012.5876%2011.5394%2012.3619%2011.464V13.84C12.9455%2013.9993%2013.4047%2014.1543%2013.7393%2014.3051C14.0817%2014.4476%2014.3774%2014.6864%2014.6264%2015.0217C14.8755%2015.3486%2015%2015.8011%2015%2016.3794ZM10.7043%2012.5074C10.7043%2012.784%2010.7821%2013.0103%2010.9378%2013.1863C11.0934%2013.3539%2011.3191%2013.4922%2011.6148%2013.6011V11.4263C11.3346%2011.4682%2011.1128%2011.5813%2010.9494%2011.7657C10.786%2011.9501%2010.7043%2012.1973%2010.7043%2012.5074ZM12.3619%2017.5737C12.6576%2017.515%2012.8872%2017.3851%2013.0506%2017.184C13.2218%2016.9829%2013.3074%2016.7398%2013.3074%2016.4549C13.3074%2016.1783%2013.2256%2015.9562%2013.0622%2015.7886C12.8988%2015.621%2012.6654%2015.4827%2012.3619%2015.3737V17.5737Z'%20fill='%231DC071'/%3e%3c/g%3e%3cdefs%3e%3cclipPath%20id='clip0_1071_25635'%3e%3crect%20width='24'%20height='24'%20fill='white'/%3e%3c/clipPath%3e%3c/defs%3e%3c/svg%3e",
  yG =
    "data:image/svg+xml,%3csvg%20width='16'%20height='12'%20viewBox='0%200%2016%2012'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M5.8775%201.5L7.3775%203H14V10.5H2V1.5H5.8775ZM6.5%200H2C1.175%200%200.5075%200.675%200.5075%201.5L0.5%2010.5C0.5%2011.325%201.175%2012%202%2012H14C14.825%2012%2015.5%2011.325%2015.5%2010.5V3C15.5%202.175%2014.825%201.5%2014%201.5H8L6.5%200Z'%20fill='%23808191'/%3e%3c/svg%3e",
  gG =
    "data:image/svg+xml,%3csvg%20width='19'%20height='18'%20viewBox='0%200%2019%2018'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20clip-path='url(%23clip0_2290_2179)'%3e%3cpath%20d='M16.9702%2016.5L13.2202%2012.75M15.0952%208.0625C15.0952%208.9243%2014.9255%209.77766%2014.5957%2010.5739C14.2659%2011.3701%2013.7825%2012.0935%2013.1731%2012.7029C12.5637%2013.3123%2011.8403%2013.7957%2011.0441%2014.1255C10.2479%2014.4553%209.39451%2014.625%208.53271%2014.625C7.67092%2014.625%206.81755%2014.4553%206.02135%2014.1255C5.22516%2013.7957%204.50171%2013.3123%203.89233%2012.7029C3.28294%2012.0935%202.79955%2011.3701%202.46976%2010.5739C2.13996%209.77766%201.97021%208.9243%201.97021%208.0625C1.97021%206.32202%202.66162%204.65282%203.89233%203.42211C5.12303%202.1914%206.79223%201.5%208.53271%201.5C10.2732%201.5%2011.9424%202.1914%2013.1731%203.42211C14.4038%204.65282%2015.0952%206.32202%2015.0952%208.0625Z'%20stroke='white'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/g%3e%3cdefs%3e%3cclipPath%20id='clip0_2290_2179'%3e%3crect%20width='18'%20height='18'%20fill='white'%20transform='translate(0.470215)'/%3e%3c/clipPath%3e%3c/defs%3e%3c/svg%3e",
  bG =
    "data:image/svg+xml,%3csvg%20width='20'%20height='14'%20viewBox='0%200%2020%2014'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M0%208.4H20V5.6H0V8.4ZM0%2014H20V11.2H0V14ZM0%202.8H20V0H0V2.8Z'%20fill='%23808191'/%3e%3c/svg%3e",
  vG =
    "data:image/svg+xml,%3csvg%20width='32'%20height='40'%20viewBox='0%200%2032%2040'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M22.4997%209.979H9.16634C8.66634%209.979%208.33301%2010.3123%208.33301%2010.8123C8.33301%2011.3123%208.66634%2011.6457%209.16634%2011.6457H22.4997C22.9997%2011.6457%2023.333%2011.3123%2023.333%2010.8123C23.333%2010.3123%2022.9997%209.979%2022.4997%209.979Z'%20fill='white'/%3e%3cpath%20d='M8.4999%207.81266C8.4999%208.146%208.83324%208.31266%209.16657%208.31266H22.4999C22.8332%208.31266%2023.1666%208.146%2023.1666%207.81266L26.4999%201.146C26.6666%200.812663%2026.6666%200.479329%2026.3332%200.145996C26.1666%20-0.0206706%2025.8332%20-0.0206706%2025.4999%200.145996L19.3332%203.146L16.4999%200.312663C16.1666%20-0.0206706%2015.6666%20-0.0206706%2015.3332%200.312663L12.3332%203.146L6.16657%200.145996C5.83324%20-0.0206706%205.4999%20-0.0206706%205.16657%200.145996C4.83324%200.312663%204.9999%200.812663%205.16657%201.146L8.4999%207.81266Z'%20fill='white'/%3e%3cpath%20d='M23.1667%2013.6456C23%2013.4789%2022.6667%2013.3123%2022.5%2013.3123H9.16667C9%2013.3123%208.66667%2013.4789%208.5%2013.6456C8.16667%2013.9789%200%2022.6456%200%2027.4789C0%2034.3123%207.16667%2039.9789%2015.8333%2039.9789C24.5%2039.9789%2031.6667%2034.3123%2031.6667%2027.4789C31.6667%2022.6456%2023.5%2013.9789%2023.1667%2013.6456ZM16.6667%2033.3123V34.1456C16.6667%2034.6456%2016.3333%2034.9789%2015.8333%2034.9789C15.3333%2034.9789%2015%2034.6456%2015%2034.1456V33.3123C13.1667%2032.9789%2011.8333%2031.8123%2011.6667%2030.3123C11.6667%2029.8123%2012%2029.4789%2012.5%2029.4789C13%2029.4789%2013.3333%2029.8123%2013.3333%2030.3123C13.3333%2030.9789%2014.1667%2031.6456%2015%2031.8123V28.4789C12.8333%2027.9789%2011.6667%2026.8123%2011.6667%2025.3123C11.6667%2023.6456%2013.1667%2022.3123%2015%2021.9789V21.1456C15%2020.6456%2015.3333%2020.3123%2015.8333%2020.3123C16.3333%2020.3123%2016.6667%2020.6456%2016.6667%2021.1456V21.6456C18.5%2021.9789%2019.8333%2023.1456%2020%2024.6456C20%2025.1456%2019.6667%2025.4789%2019.1667%2025.4789C18.6667%2025.4789%2018.3333%2025.1456%2018.3333%2024.6456C18.3333%2023.9789%2017.5%2023.3123%2016.6667%2023.1456V26.4789C18.8333%2026.9789%2020%2028.1456%2020%2029.6456C20%2031.6456%2018.5%2032.9789%2016.6667%2033.3123Z'%20fill='white'/%3e%3cpath%20d='M16.667%2028.4785V31.4785C17.667%2031.3119%2018.3337%2030.6452%2018.3337%2029.9785C18.3337%2029.3119%2017.8337%2028.8118%2016.667%2028.4785Z'%20fill='white'/%3e%3cpath%20d='M13.333%2024.9788C13.333%2025.6454%2013.833%2026.1454%2014.9997%2026.4788V23.4788C13.9997%2023.6454%2013.333%2024.3121%2013.333%2024.9788Z'%20fill='white'/%3e%3c/svg%3e",
  ON =
    "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20style='margin:auto;background:transparent;display:block;'%20width='200px'%20height='200px'%20viewBox='0%200%20100%20100'%20preserveAspectRatio='xMidYMid'%3e%3cg%20transform='rotate(0%2050%2050)'%3e%3crect%20x='47'%20y='24'%20rx='2.52'%20ry='2.52'%20width='6'%20height='12'%20fill='%231dc071'%3e%3canimate%20attributeName='opacity'%20values='1;0'%20keyTimes='0;1'%20dur='1s'%20begin='-0.9166666666666666s'%20repeatCount='indefinite'%3e%3c/animate%3e%3c/rect%3e%3c/g%3e%3cg%20transform='rotate(30%2050%2050)'%3e%3crect%20x='47'%20y='24'%20rx='2.52'%20ry='2.52'%20width='6'%20height='12'%20fill='%231dc071'%3e%3canimate%20attributeName='opacity'%20values='1;0'%20keyTimes='0;1'%20dur='1s'%20begin='-0.8333333333333334s'%20repeatCount='indefinite'%3e%3c/animate%3e%3c/rect%3e%3c/g%3e%3cg%20transform='rotate(60%2050%2050)'%3e%3crect%20x='47'%20y='24'%20rx='2.52'%20ry='2.52'%20width='6'%20height='12'%20fill='%231dc071'%3e%3canimate%20attributeName='opacity'%20values='1;0'%20keyTimes='0;1'%20dur='1s'%20begin='-0.75s'%20repeatCount='indefinite'%3e%3c/animate%3e%3c/rect%3e%3c/g%3e%3cg%20transform='rotate(90%2050%2050)'%3e%3crect%20x='47'%20y='24'%20rx='2.52'%20ry='2.52'%20width='6'%20height='12'%20fill='%231dc071'%3e%3canimate%20attributeName='opacity'%20values='1;0'%20keyTimes='0;1'%20dur='1s'%20begin='-0.6666666666666666s'%20repeatCount='indefinite'%3e%3c/animate%3e%3c/rect%3e%3c/g%3e%3cg%20transform='rotate(120%2050%2050)'%3e%3crect%20x='47'%20y='24'%20rx='2.52'%20ry='2.52'%20width='6'%20height='12'%20fill='%231dc071'%3e%3canimate%20attributeName='opacity'%20values='1;0'%20keyTimes='0;1'%20dur='1s'%20begin='-0.5833333333333334s'%20repeatCount='indefinite'%3e%3c/animate%3e%3c/rect%3e%3c/g%3e%3cg%20transform='rotate(150%2050%2050)'%3e%3crect%20x='47'%20y='24'%20rx='2.52'%20ry='2.52'%20width='6'%20height='12'%20fill='%231dc071'%3e%3canimate%20attributeName='opacity'%20values='1;0'%20keyTimes='0;1'%20dur='1s'%20begin='-0.5s'%20repeatCount='indefinite'%3e%3c/animate%3e%3c/rect%3e%3c/g%3e%3cg%20transform='rotate(180%2050%2050)'%3e%3crect%20x='47'%20y='24'%20rx='2.52'%20ry='2.52'%20width='6'%20height='12'%20fill='%231dc071'%3e%3canimate%20attributeName='opacity'%20values='1;0'%20keyTimes='0;1'%20dur='1s'%20begin='-0.4166666666666667s'%20repeatCount='indefinite'%3e%3c/animate%3e%3c/rect%3e%3c/g%3e%3cg%20transform='rotate(210%2050%2050)'%3e%3crect%20x='47'%20y='24'%20rx='2.52'%20ry='2.52'%20width='6'%20height='12'%20fill='%231dc071'%3e%3canimate%20attributeName='opacity'%20values='1;0'%20keyTimes='0;1'%20dur='1s'%20begin='-0.3333333333333333s'%20repeatCount='indefinite'%3e%3c/animate%3e%3c/rect%3e%3c/g%3e%3cg%20transform='rotate(240%2050%2050)'%3e%3crect%20x='47'%20y='24'%20rx='2.52'%20ry='2.52'%20width='6'%20height='12'%20fill='%231dc071'%3e%3canimate%20attributeName='opacity'%20values='1;0'%20keyTimes='0;1'%20dur='1s'%20begin='-0.25s'%20repeatCount='indefinite'%3e%3c/animate%3e%3c/rect%3e%3c/g%3e%3cg%20transform='rotate(270%2050%2050)'%3e%3crect%20x='47'%20y='24'%20rx='2.52'%20ry='2.52'%20width='6'%20height='12'%20fill='%231dc071'%3e%3canimate%20attributeName='opacity'%20values='1;0'%20keyTimes='0;1'%20dur='1s'%20begin='-0.16666666666666666s'%20repeatCount='indefinite'%3e%3c/animate%3e%3c/rect%3e%3c/g%3e%3cg%20transform='rotate(300%2050%2050)'%3e%3crect%20x='47'%20y='24'%20rx='2.52'%20ry='2.52'%20width='6'%20height='12'%20fill='%231dc071'%3e%3canimate%20attributeName='opacity'%20values='1;0'%20keyTimes='0;1'%20dur='1s'%20begin='-0.08333333333333333s'%20repeatCount='indefinite'%3e%3c/animate%3e%3c/rect%3e%3c/g%3e%3cg%20transform='rotate(330%2050%2050)'%3e%3crect%20x='47'%20y='24'%20rx='2.52'%20ry='2.52'%20width='6'%20height='12'%20fill='%231dc071'%3e%3canimate%20attributeName='opacity'%20values='1;0'%20keyTimes='0;1'%20dur='1s'%20begin='0s'%20repeatCount='indefinite'%3e%3c/animate%3e%3c/rect%3e%3c/g%3e%3c/svg%3e",
  FN = "/assets/thirdweb-B5ZT6TZm.png",
  LN = [
    {
      name: "dashboard",
      imgUrl: uG,
      link: "/",
    },
    {
      name: "campaign",
      imgUrl: lG,
      link: "/create-campaign",
    },
    {
      name: "withdraw",
      imgUrl: mG,
      link: "/",
      disabled: !0,
    },
    {
      name: "profile",
      imgUrl: hG,
      link: "/profile",
    },
    {
      name: "logout",
      imgUrl: dG,
      link: "/",
      disabled: !0,
    },
  ],
  Fw = ({
    styles: t,
    name: e,
    imgUrl: r,
    isActive: n,
    disabled: i,
    handleClick: a,
  }) =>
    de.jsx("div", {
      className: `w-[48px] h-[48px] rounded-[10px] ${
        n && n === e && "bg-[#2c2f32]"
      } flex justify-center items-center ${!i && "cursor-pointer"} ${t}`,
      onClick: a,
      children: n
        ? de.jsx("img", {
            src: r,
            alt: "fund_logo",
            className: `w-1/2 h-1/2 ${n !== e && "grayscale"}`,
          })
        : de.jsx("img", {
            src: r,
            alt: "fund_logo",
            className: "w-1/2 h-1/2",
          }),
    }),
  xG = () => {
    const t = ld(),
      [e, r] = ye.useState("dashboard");
    return de.jsxs("div", {
      className:
        "flex justify-between items-center flex-col sticky top-5 h-[93vh]",
      children: [
        de.jsx(DN, {
          to: "/",
          children: de.jsx(Fw, {
            styles: "w-[52px] h-[52px] bg-[#2c2f32]",
            imgUrl: "{logo}",
          }),
        }),
        de.jsxs("div", {
          className:
            "flex-1 flex flex-col justify-between items-center bg-[#1c1c24] rounded-[20px] w-[76px] py-4 mt-12",
          children: [
            de.jsx("div", {
              className: "flex flex-col justify-center items-center gap-3",
              children: LN.map((n) =>
                de.jsx(
                  Fw,
                  {
                    ...n,
                    isActive: e,
                    handleClick: () => {
                      n.disabled || (r(n.name), t(n.link));
                    },
                  },
                  n.name
                )
              ),
            }),
            de.jsx(Fw, {
              styles: "bg-[#1c1c24] shadow-secondary",
              imgUrl: pG,
            }),
          ],
        }),
      ],
    });
  },
  wG = "modulepreload",
  _G = function (t) {
    return "/" + t;
  },
  qA = {},
  Zt = function (e, r, n) {
    let i = Promise.resolve();
    if (r && r.length > 0) {
      document.getElementsByTagName("link");
      const s = document.querySelector("meta[property=csp-nonce]"),
        o =
          (s == null ? void 0 : s.nonce) ||
          (s == null ? void 0 : s.getAttribute("nonce"));
      i = Promise.allSettled(
        r.map((c) => {
          if (((c = _G(c)), c in qA)) return;
          qA[c] = !0;
          const u = c.endsWith(".css"),
            d = u ? '[rel="stylesheet"]' : "";
          if (document.querySelector(`link[href="${c}"]${d}`)) return;
          const m = document.createElement("link");
          if (
            ((m.rel = u ? "stylesheet" : wG),
            u || (m.as = "script"),
            (m.crossOrigin = ""),
            (m.href = c),
            o && m.setAttribute("nonce", o),
            document.head.appendChild(m),
            u)
          )
            return new Promise((v, E) => {
              m.addEventListener("load", v),
                m.addEventListener("error", () =>
                  E(new Error(`Unable to preload CSS for ${c}`))
                );
            });
        })
      );
    }
    function a(s) {
      const o = new Event("vite:preloadError", {
        cancelable: !0,
      });
      if (((o.payload = s), window.dispatchEvent(o), !o.defaultPrevented))
        throw s;
    }
    return i.then((s) => {
      for (const o of s || []) o.status === "rejected" && a(o.reason);
      return e().catch(a);
    });
  };
var EG = {
    chain: "ETH",
    chainId: 1,
    ens: {
      registry: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    },
    explorers: [
      {
        name: "etherscan",
        url: "https://etherscan.io",
        standard: "EIP3091",
      },
      {
        name: "blockscout",
        url: "https://eth.blockscout.com",
        standard: "EIP3091",
        icon: {
          url: "ipfs://QmYtUimyqHkkFxYdbXXRbUqNg2VLPUg6Uu2C2nmFWowiZM",
          width: 551,
          height: 540,
          format: "png",
        },
      },
      {
        name: "dexguru",
        url: "https://ethereum.dex.guru",
        standard: "EIP3091",
        icon: {
          url: "ipfs://QmRaASKRSjQ5btoUQ2rNTJNxKtx2a2RoewgA7DMQkLVEne",
          width: 83,
          height: 82,
          format: "svg",
        },
      },
    ],
    faucets: [],
    features: [
      {
        name: "EIP155",
      },
      {
        name: "EIP1559",
      },
    ],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/ethereum/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://ethereum.org",
    name: "Ethereum Mainnet",
    nativeCurrency: {
      name: "Ether",
      symbol: "ETH",
      decimals: 18,
    },
    networkId: 1,
    redFlags: [],
    rpc: [
      "https://1.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://mainnet.infura.io/v3/${INFURA_API_KEY}",
      "wss://mainnet.infura.io/ws/v3/${INFURA_API_KEY}",
      "https://eth-mainnet.g.alchemy.com/v2/${ALCHEMY_API_KEY}",
      "https://api.mycryptoapi.com/eth",
      "https://cloudflare-eth.com",
      "https://ethereum-rpc.publicnode.com",
      "wss://ethereum-rpc.publicnode.com",
      "https://mainnet.gateway.tenderly.co",
      "wss://mainnet.gateway.tenderly.co",
      "https://rpc.blocknative.com/boost",
      "https://rpc.flashbots.net",
      "https://rpc.flashbots.net/fast",
      "https://rpc.mevblocker.io",
      "https://rpc.mevblocker.io/fast",
      "https://rpc.mevblocker.io/noreverts",
      "https://rpc.mevblocker.io/fullprivacy",
      "https://eth.drpc.org",
      "wss://eth.drpc.org",
    ],
    shortName: "eth",
    slip44: 60,
    slug: "ethereum",
    testnet: !1,
  },
  TG = {
    chain: "ETH",
    chainId: 10,
    explorers: [
      {
        name: "etherscan",
        url: "https://optimistic.etherscan.io",
        standard: "EIP3091",
      },
      {
        name: "blockscout",
        url: "https://optimism.blockscout.com",
        standard: "EIP3091",
        icon: {
          url: "ipfs://QmYtUimyqHkkFxYdbXXRbUqNg2VLPUg6Uu2C2nmFWowiZM",
          width: 551,
          height: 540,
          format: "png",
        },
      },
      {
        name: "dexguru",
        url: "https://optimism.dex.guru",
        standard: "EIP3091",
        icon: {
          url: "ipfs://QmRaASKRSjQ5btoUQ2rNTJNxKtx2a2RoewgA7DMQkLVEne",
          width: 83,
          height: 82,
          format: "svg",
        },
      },
    ],
    faucets: [],
    features: [],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/optimism/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://optimism.io",
    name: "OP Mainnet",
    nativeCurrency: {
      name: "Ether",
      symbol: "ETH",
      decimals: 18,
    },
    networkId: 10,
    redFlags: [],
    rpc: [
      "https://10.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://optimism-mainnet.infura.io/v3/${INFURA_API_KEY}",
      "https://mainnet.optimism.io",
      "https://optimism.publicnode.com",
      "wss://optimism.publicnode.com",
      "https://optimism.gateway.tenderly.co",
      "wss://optimism.gateway.tenderly.co",
      "https://optimism-rpc.publicnode.com",
      "wss://optimism-rpc.publicnode.com",
      "https://optimism.drpc.org",
      "wss://optimism.drpc.org",
    ],
    shortName: "oeth",
    slug: "optimism",
    testnet: !1,
  },
  CG = {
    chain: "BSC",
    chainId: 56,
    explorers: [
      {
        name: "bscscan",
        url: "https://bscscan.com",
        standard: "EIP3091",
      },
      {
        name: "dexguru",
        url: "https://bnb.dex.guru",
        standard: "EIP3091",
        icon: {
          url: "ipfs://QmRaASKRSjQ5btoUQ2rNTJNxKtx2a2RoewgA7DMQkLVEne",
          width: 83,
          height: 82,
          format: "svg",
        },
      },
    ],
    faucets: [],
    features: [],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/binance-coin/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://www.bnbchain.org/en",
    name: "BNB Smart Chain Mainnet",
    nativeCurrency: {
      name: "BNB Chain Native Token",
      symbol: "BNB",
      decimals: 18,
    },
    networkId: 56,
    redFlags: [],
    rpc: [
      "https://56.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://bsc-dataseed1.bnbchain.org",
      "https://bsc-dataseed2.bnbchain.org",
      "https://bsc-dataseed3.bnbchain.org",
      "https://bsc-dataseed4.bnbchain.org",
      "https://bsc-dataseed1.defibit.io",
      "https://bsc-dataseed2.defibit.io",
      "https://bsc-dataseed3.defibit.io",
      "https://bsc-dataseed4.defibit.io",
      "https://bsc-dataseed1.ninicoin.io",
      "https://bsc-dataseed2.ninicoin.io",
      "https://bsc-dataseed3.ninicoin.io",
      "https://bsc-dataseed4.ninicoin.io",
      "https://bsc-rpc.publicnode.com",
      "wss://bsc-rpc.publicnode.com",
      "wss://bsc-ws-node.nariox.org",
    ],
    shortName: "bnb",
    slip44: 714,
    slug: "binance",
    testnet: !1,
  },
  AG = {
    chain: "BSC",
    chainId: 97,
    explorers: [
      {
        name: "bscscan-testnet",
        url: "https://testnet.bscscan.com",
        standard: "EIP3091",
      },
    ],
    faucets: ["https://testnet.bnbchain.org/faucet-smart"],
    features: [],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/binance-coin/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://www.bnbchain.org/en",
    name: "BNB Smart Chain Testnet",
    nativeCurrency: {
      name: "BNB Chain Native Token",
      symbol: "tBNB",
      decimals: 18,
    },
    networkId: 97,
    redFlags: [],
    rpc: [
      "https://97.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://data-seed-prebsc-1-s1.bnbchain.org:8545",
      "https://data-seed-prebsc-2-s1.bnbchain.org:8545",
      "https://data-seed-prebsc-1-s2.bnbchain.org:8545",
      "https://data-seed-prebsc-2-s2.bnbchain.org:8545",
      "https://data-seed-prebsc-1-s3.bnbchain.org:8545",
      "https://data-seed-prebsc-2-s3.bnbchain.org:8545",
      "https://bsc-testnet-rpc.publicnode.com",
      "wss://bsc-testnet-rpc.publicnode.com",
    ],
    shortName: "bnbt",
    slip44: 1,
    slug: "binance-testnet",
    testnet: !0,
  },
  kG = {
    chain: "Polygon",
    chainId: 137,
    explorers: [
      {
        name: "polygonscan",
        url: "https://polygonscan.com",
        standard: "EIP3091",
      },
      {
        name: "dexguru",
        url: "https://polygon.dex.guru",
        standard: "EIP3091",
        icon: {
          url: "ipfs://QmRaASKRSjQ5btoUQ2rNTJNxKtx2a2RoewgA7DMQkLVEne",
          width: 83,
          height: 82,
          format: "svg",
        },
      },
    ],
    faucets: [],
    features: [],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/polygon/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://polygon.technology/",
    name: "Polygon Mainnet",
    nativeCurrency: {
      name: "MATIC",
      symbol: "MATIC",
      decimals: 18,
    },
    networkId: 137,
    redFlags: [],
    rpc: [
      "https://137.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://polygon-mainnet.infura.io/v3/${INFURA_API_KEY}",
      "https://polygon-mainnet.g.alchemy.com/v2/${ALCHEMY_API_KEY}",
      "https://polygon-rpc.com/",
      "https://rpc-mainnet.matic.network",
      "https://matic-mainnet.chainstacklabs.com",
      "https://rpc-mainnet.maticvigil.com",
      "https://rpc-mainnet.matic.quiknode.pro",
      "https://matic-mainnet-full-rpc.bwarelabs.com",
      "https://polygon-bor-rpc.publicnode.com",
      "wss://polygon-bor-rpc.publicnode.com",
      "https://polygon.gateway.tenderly.co",
      "wss://polygon.gateway.tenderly.co",
      "https://polygon.drpc.org",
      "wss://polygon.drpc.org",
    ],
    shortName: "matic",
    slip44: 966,
    slug: "polygon",
    testnet: !1,
  },
  SG = {
    chain: "FTM",
    chainId: 250,
    explorers: [
      {
        name: "ftmscan",
        url: "https://ftmscan.com",
        standard: "EIP3091",
        icon: {
          url: "ipfs://QmRqbK449Fo9sJ3xMpkPbg6uV1weQj4yVV1xNMP9cdPmjf",
          width: 73,
          height: 73,
          format: "png",
        },
      },
      {
        name: "dexguru",
        url: "https://fantom.dex.guru",
        standard: "EIP3091",
        icon: {
          url: "ipfs://QmRaASKRSjQ5btoUQ2rNTJNxKtx2a2RoewgA7DMQkLVEne",
          width: 83,
          height: 82,
          format: "svg",
        },
      },
    ],
    faucets: [],
    features: [],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/fantom/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://fantom.foundation",
    name: "Fantom Opera",
    nativeCurrency: {
      name: "Fantom",
      symbol: "FTM",
      decimals: 18,
    },
    networkId: 250,
    redFlags: [],
    rpc: [
      "https://250.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://rpc.ftm.tools",
      "https://fantom-rpc.publicnode.com",
      "wss://fantom-rpc.publicnode.com",
      "https://fantom.drpc.org",
      "wss://fantom.drpc.org",
    ],
    shortName: "ftm",
    slug: "fantom",
    testnet: !1,
  },
  MG = {
    chain: "ETH",
    chainId: 1337,
    explorers: [],
    faucets: [],
    features: [],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/ethereum/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    name: "Localhost",
    nativeCurrency: {
      name: "Ether",
      symbol: "ETH",
      decimals: 18,
    },
    networkId: 1337,
    redFlags: [],
    rpc: ["http://localhost:8545"],
    shortName: "local",
    slug: "localhost",
    testnet: !0,
  },
  IG = {
    chain: "FTM",
    chainId: 4002,
    explorers: [
      {
        name: "ftmscan",
        url: "https://testnet.ftmscan.com",
        standard: "EIP3091",
        icon: {
          url: "ipfs://QmRqbK449Fo9sJ3xMpkPbg6uV1weQj4yVV1xNMP9cdPmjf",
          width: 73,
          height: 73,
          format: "png",
        },
      },
    ],
    faucets: ["https://faucet.fantom.network"],
    features: [],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/fantom/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL:
      "https://docs.fantom.foundation/quick-start/short-guide#fantom-testnet",
    name: "Fantom Testnet",
    nativeCurrency: {
      name: "Fantom",
      symbol: "FTM",
      decimals: 18,
    },
    networkId: 4002,
    redFlags: [],
    rpc: [
      "https://4002.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://rpc.testnet.fantom.network",
      "https://fantom-testnet-rpc.publicnode.com",
      "wss://fantom-testnet-rpc.publicnode.com",
      "https://fantom-testnet.drpc.org",
      "wss://fantom-testnet.drpc.org",
    ],
    shortName: "tftm",
    slip44: 1,
    slug: "fantom-testnet",
    testnet: !0,
  },
  RG = {
    chain: "ETH",
    chainId: 8453,
    explorers: [
      {
        name: "basescan",
        url: "https://basescan.org",
        standard: "none",
      },
      {
        name: "basescout",
        url: "https://base.blockscout.com",
        standard: "EIP3091",
        icon: {
          url: "ipfs://QmYtUimyqHkkFxYdbXXRbUqNg2VLPUg6Uu2C2nmFWowiZM",
          width: 551,
          height: 540,
          format: "png",
        },
      },
      {
        name: "dexguru",
        url: "https://base.dex.guru",
        standard: "EIP3091",
        icon: {
          url: "ipfs://QmRaASKRSjQ5btoUQ2rNTJNxKtx2a2RoewgA7DMQkLVEne",
          width: 83,
          height: 82,
          format: "svg",
        },
      },
    ],
    faucets: [],
    features: [],
    icon: {
      url: "ipfs://QmW5Vn15HeRkScMfPcW12ZdZcC2yUASpu6eCsECRdEmjjj/base-512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://base.org",
    name: "Base",
    nativeCurrency: {
      name: "Ether",
      symbol: "ETH",
      decimals: 18,
    },
    networkId: 8453,
    redFlags: [],
    rpc: [
      "https://8453.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://mainnet.base.org/",
      "https://developer-access-mainnet.base.org/",
      "https://base.gateway.tenderly.co",
      "wss://base.gateway.tenderly.co",
      "https://base-rpc.publicnode.com",
      "wss://base-rpc.publicnode.com",
    ],
    shortName: "base",
    slug: "base",
    status: "active",
    testnet: !1,
  },
  PG = {
    chain: "ETH",
    chainId: 42161,
    explorers: [
      {
        name: "Arbiscan",
        url: "https://arbiscan.io",
        standard: "EIP3091",
      },
      {
        name: "Arbitrum Explorer",
        url: "https://explorer.arbitrum.io",
        standard: "EIP3091",
      },
      {
        name: "dexguru",
        url: "https://arbitrum.dex.guru",
        standard: "EIP3091",
        icon: {
          url: "ipfs://QmRaASKRSjQ5btoUQ2rNTJNxKtx2a2RoewgA7DMQkLVEne",
          width: 83,
          height: 82,
          format: "svg",
        },
      },
    ],
    faucets: [],
    features: [],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/arbitrum/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://arbitrum.io",
    name: "Arbitrum One",
    nativeCurrency: {
      name: "Ether",
      symbol: "ETH",
      decimals: 18,
    },
    networkId: 42161,
    parent: {
      type: "L2",
      chain: "eip155-1",
      bridges: [
        {
          url: "https://bridge.arbitrum.io",
        },
      ],
    },
    redFlags: [],
    rpc: [
      "https://42161.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://arbitrum-mainnet.infura.io/v3/${INFURA_API_KEY}",
      "https://arb-mainnet.g.alchemy.com/v2/${ALCHEMY_API_KEY}",
      "https://arb1.arbitrum.io/rpc",
      "https://arbitrum-one.publicnode.com",
      "wss://arbitrum-one.publicnode.com",
    ],
    shortName: "arb1",
    slug: "arbitrum",
    testnet: !1,
  },
  NG = {
    chain: "AVAX",
    chainId: 43113,
    explorers: [
      {
        name: "snowtrace",
        url: "https://testnet.snowtrace.io",
        standard: "EIP3091",
      },
    ],
    faucets: ["https://faucet.avax-test.network/"],
    features: [],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/avalanche/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://cchain.explorer.avax-test.network",
    name: "Avalanche Fuji Testnet",
    nativeCurrency: {
      name: "Avalanche",
      symbol: "AVAX",
      decimals: 18,
    },
    networkId: 43113,
    redFlags: [],
    rpc: [
      "https://43113.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://api.avax-test.network/ext/bc/C/rpc",
      "https://avalanche-fuji-c-chain-rpc.publicnode.com",
      "wss://avalanche-fuji-c-chain-rpc.publicnode.com",
    ],
    shortName: "Fuji",
    slip44: 1,
    slug: "avalanche-fuji",
    testnet: !0,
  },
  BG = {
    chain: "AVAX",
    chainId: 43114,
    explorers: [
      {
        name: "snowtrace",
        url: "https://snowtrace.io",
        standard: "EIP3091",
      },
    ],
    faucets: [],
    features: [
      {
        name: "EIP1559",
      },
    ],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/avalanche/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://www.avax.network/",
    name: "Avalanche C-Chain",
    nativeCurrency: {
      name: "Avalanche",
      symbol: "AVAX",
      decimals: 18,
    },
    networkId: 43114,
    redFlags: [],
    rpc: [
      "https://43114.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://avalanche-mainnet.infura.io/v3/${INFURA_API_KEY}",
      "https://api.avax.network/ext/bc/C/rpc",
      "https://avalanche-c-chain-rpc.publicnode.com",
      "wss://avalanche-c-chain-rpc.publicnode.com",
    ],
    shortName: "avax",
    slip44: 9005,
    slug: "avalanche",
    testnet: !1,
  },
  DG = {
    chain: "Polygon",
    chainId: 80001,
    explorers: [
      {
        name: "polygonscan",
        url: "https://mumbai.polygonscan.com",
        standard: "EIP3091",
      },
    ],
    faucets: ["https://faucet.polygon.technology/"],
    features: [],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/polygon/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://polygon.technology/",
    name: "Mumbai",
    nativeCurrency: {
      name: "MATIC",
      symbol: "MATIC",
      decimals: 18,
    },
    networkId: 80001,
    redFlags: [],
    rpc: [
      "https://80001.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://rpc-mumbai.maticvigil.com",
      "https://polygon-mumbai-bor-rpc.publicnode.com",
      "wss://polygon-mumbai-bor-rpc.publicnode.com",
      "https://polygon-mumbai.gateway.tenderly.co",
      "wss://polygon-mumbai.gateway.tenderly.co",
    ],
    shortName: "maticmum",
    slip44: 1,
    slug: "mumbai",
    status: "deprecated",
    testnet: !0,
    title: "Polygon Testnet Mumbai",
  },
  OG = {
    chain: "ETH",
    chainId: 84532,
    explorers: [
      {
        name: "basescout",
        url: "https://base-sepolia.blockscout.com",
        standard: "EIP3091",
        icon: {
          url: "ipfs://QmYtUimyqHkkFxYdbXXRbUqNg2VLPUg6Uu2C2nmFWowiZM",
          width: 551,
          height: 540,
          format: "png",
        },
      },
    ],
    faucets: [],
    icon: {
      url: "ipfs://QmaxRoHpxZd8PqccAynherrMznMufG6sdmHZLihkECXmZv",
      width: 1200,
      height: 1200,
      format: "png",
    },
    infoURL: "https://base.org",
    name: "Base Sepolia Testnet",
    nativeCurrency: {
      name: "Sepolia Ether",
      symbol: "ETH",
      decimals: 18,
    },
    networkId: 84532,
    rpc: [
      "https://84532.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://sepolia.base.org",
      "https://base-sepolia-rpc.publicnode.com",
      "wss://base-sepolia-rpc.publicnode.com",
    ],
    shortName: "basesep",
    slip44: 1,
    slug: "base-sepolia-testnet",
    testnet: !0,
  },
  FG = {
    chain: "ETH",
    chainId: 421614,
    explorers: [
      {
        name: "Arbitrum Sepolia Rollup Testnet Explorer",
        url: "https://sepolia-explorer.arbitrum.io",
        standard: "EIP3091",
      },
    ],
    faucets: [],
    infoURL: "https://arbitrum.io",
    name: "Arbitrum Sepolia",
    nativeCurrency: {
      name: "Sepolia Ether",
      symbol: "ETH",
      decimals: 18,
    },
    networkId: 421614,
    parent: {
      type: "L2",
      chain: "eip155-11155111",
      bridges: [
        {
          url: "https://bridge.arbitrum.io",
        },
      ],
    },
    rpc: [
      "https://421614.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://sepolia-rollup.arbitrum.io/rpc",
      "https://arbitrum-sepolia.infura.io/v3/${INFURA_API_KEY}",
    ],
    shortName: "arb-sep",
    slip44: 1,
    slug: "arbitrum-sepolia",
    testnet: !0,
    title: "Arbitrum Sepolia Rollup Testnet",
  },
  LG = {
    chain: "ETH",
    chainId: 11155111,
    explorers: [
      {
        name: "etherscan-sepolia",
        url: "https://sepolia.etherscan.io",
        standard: "EIP3091",
      },
      {
        name: "otterscan-sepolia",
        url: "https://sepolia.otterscan.io",
        standard: "EIP3091",
      },
    ],
    faucets: ["http://fauceth.komputing.org?chain=11155111&address=${ADDRESS}"],
    features: [],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/ethereum/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://sepolia.otterscan.io",
    name: "Sepolia",
    nativeCurrency: {
      name: "Sepolia Ether",
      symbol: "ETH",
      decimals: 18,
    },
    networkId: 11155111,
    redFlags: [],
    rpc: [
      "https://11155111.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://sepolia.infura.io/v3/${INFURA_API_KEY}",
      "wss://sepolia.infura.io/v3/${INFURA_API_KEY}",
      "https://rpc.sepolia.org",
      "https://rpc2.sepolia.org",
      "https://rpc-sepolia.rockx.com",
      "https://rpc.sepolia.ethpandaops.io",
      "https://sepolia.gateway.tenderly.co",
      "wss://sepolia.gateway.tenderly.co",
      "https://ethereum-sepolia-rpc.publicnode.com",
      "wss://ethereum-sepolia-rpc.publicnode.com",
      "https://sepolia.drpc.org",
      "wss://sepolia.drpc.org",
    ],
    shortName: "sep",
    slip44: 1,
    slug: "sepolia",
    testnet: !0,
    title: "Ethereum Testnet Sepolia",
  },
  $G = {
    chain: "ETH",
    chainId: 11155420,
    explorers: [
      {
        name: "opscout",
        url: "https://optimism-sepolia.blockscout.com",
        standard: "EIP3091",
        icon: {
          url: "ipfs://QmYtUimyqHkkFxYdbXXRbUqNg2VLPUg6Uu2C2nmFWowiZM",
          width: 551,
          height: 540,
          format: "png",
        },
      },
    ],
    faucets: ["https://app.optimism.io/faucet"],
    features: [],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/optimism/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://optimism.io",
    name: "OP Sepolia Testnet",
    nativeCurrency: {
      name: "Sepolia Ether",
      symbol: "ETH",
      decimals: 18,
    },
    networkId: 11155420,
    redFlags: [],
    rpc: [
      "https://11155420.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://sepolia.optimism.io",
      "https://optimism-sepolia.drpc.org",
      "wss://optimism-sepolia.drpc.org",
    ],
    shortName: "opsep",
    slip44: 1,
    slug: "op-sepolia-testnet",
    testnet: !0,
  };
const UG = {
  mode: "http",
};
function WG(t, e) {
  const {
      thirdwebApiKey: r,
      alchemyApiKey: n,
      infuraApiKey: i,
      mode: a,
    } = {
      ...UG,
      ...e,
    },
    s = [];
  if (
    (t.rpc.forEach((o) => {
      if (
        !(a === "http" && !o.startsWith("http")) &&
        !(a === "ws" && !o.startsWith("ws"))
      )
        if (r && o.includes("${THIRDWEB_API_KEY}"))
          s.push(o.replace("${THIRDWEB_API_KEY}", r));
        else if (i && o.includes("${INFURA_API_KEY}"))
          s.push(o.replace("${INFURA_API_KEY}", i));
        else if (n && o.includes("${ALCHEMY_API_KEY}"))
          s.push(o.replace("${ALCHEMY_API_KEY}", n));
        else {
          if (o.includes("${")) return;
          s.push(o);
        }
    }),
    s.length === 0)
  )
    throw new Error(
      `No RPC available for chainId "${t.chainId}" with mode ${a}`
    );
  return s;
}
function jG(t, e) {
  return WG(t, e)[0];
}
const HG = [EG, LG, RG, OG, kG, DG, PG, FG, TG, $G, CG, AG, SG, IG, BG, NG, MG];
function Hb() {
  (this._types = Object.create(null)), (this._extensions = Object.create(null));
  for (let t = 0; t < arguments.length; t++) this.define(arguments[t]);
  (this.define = this.define.bind(this)),
    (this.getType = this.getType.bind(this)),
    (this.getExtension = this.getExtension.bind(this));
}
Hb.prototype.define = function (t, e) {
  for (let r in t) {
    let n = t[r].map(function (i) {
      return i.toLowerCase();
    });
    r = r.toLowerCase();
    for (let i = 0; i < n.length; i++) {
      const a = n[i];
      if (a[0] !== "*") {
        if (!e && a in this._types)
          throw new Error(
            'Attempt to change mapping for "' +
              a +
              '" extension from "' +
              this._types[a] +
              '" to "' +
              r +
              '". Pass `force=true` to allow this, otherwise remove "' +
              a +
              '" from the list of extensions for "' +
              r +
              '".'
          );
        this._types[a] = r;
      }
    }
    if (e || !this._extensions[r]) {
      const i = n[0];
      this._extensions[r] = i[0] !== "*" ? i : i.substr(1);
    }
  }
};
Hb.prototype.getType = function (t) {
  t = String(t);
  let e = t.replace(/^.*[/\\]/, "").toLowerCase(),
    r = e.replace(/^.*\./, "").toLowerCase(),
    n = e.length < t.length;
  return ((r.length < e.length - 1 || !n) && this._types[r]) || null;
};
Hb.prototype.getExtension = function (t) {
  return (
    (t = /^\s*([^;\s]*)/.test(t) && RegExp.$1),
    (t && this._extensions[t.toLowerCase()]) || null
  );
};
var zG = Hb,
  qG = {
    "application/andrew-inset": ["ez"],
    "application/applixware": ["aw"],
    "application/atom+xml": ["atom"],
    "application/atomcat+xml": ["atomcat"],
    "application/atomdeleted+xml": ["atomdeleted"],
    "application/atomsvc+xml": ["atomsvc"],
    "application/atsc-dwd+xml": ["dwd"],
    "application/atsc-held+xml": ["held"],
    "application/atsc-rsat+xml": ["rsat"],
    "application/bdoc": ["bdoc"],
    "application/calendar+xml": ["xcs"],
    "application/ccxml+xml": ["ccxml"],
    "application/cdfx+xml": ["cdfx"],
    "application/cdmi-capability": ["cdmia"],
    "application/cdmi-container": ["cdmic"],
    "application/cdmi-domain": ["cdmid"],
    "application/cdmi-object": ["cdmio"],
    "application/cdmi-queue": ["cdmiq"],
    "application/cu-seeme": ["cu"],
    "application/dash+xml": ["mpd"],
    "application/davmount+xml": ["davmount"],
    "application/docbook+xml": ["dbk"],
    "application/dssc+der": ["dssc"],
    "application/dssc+xml": ["xdssc"],
    "application/ecmascript": ["es", "ecma"],
    "application/emma+xml": ["emma"],
    "application/emotionml+xml": ["emotionml"],
    "application/epub+zip": ["epub"],
    "application/exi": ["exi"],
    "application/express": ["exp"],
    "application/fdt+xml": ["fdt"],
    "application/font-tdpfr": ["pfr"],
    "application/geo+json": ["geojson"],
    "application/gml+xml": ["gml"],
    "application/gpx+xml": ["gpx"],
    "application/gxf": ["gxf"],
    "application/gzip": ["gz"],
    "application/hjson": ["hjson"],
    "application/hyperstudio": ["stk"],
    "application/inkml+xml": ["ink", "inkml"],
    "application/ipfix": ["ipfix"],
    "application/its+xml": ["its"],
    "application/java-archive": ["jar", "war", "ear"],
    "application/java-serialized-object": ["ser"],
    "application/java-vm": ["class"],
    "application/javascript": ["js", "mjs"],
    "application/json": ["json", "map"],
    "application/json5": ["json5"],
    "application/jsonml+json": ["jsonml"],
    "application/ld+json": ["jsonld"],
    "application/lgr+xml": ["lgr"],
    "application/lost+xml": ["lostxml"],
    "application/mac-binhex40": ["hqx"],
    "application/mac-compactpro": ["cpt"],
    "application/mads+xml": ["mads"],
    "application/manifest+json": ["webmanifest"],
    "application/marc": ["mrc"],
    "application/marcxml+xml": ["mrcx"],
    "application/mathematica": ["ma", "nb", "mb"],
    "application/mathml+xml": ["mathml"],
    "application/mbox": ["mbox"],
    "application/mediaservercontrol+xml": ["mscml"],
    "application/metalink+xml": ["metalink"],
    "application/metalink4+xml": ["meta4"],
    "application/mets+xml": ["mets"],
    "application/mmt-aei+xml": ["maei"],
    "application/mmt-usd+xml": ["musd"],
    "application/mods+xml": ["mods"],
    "application/mp21": ["m21", "mp21"],
    "application/mp4": ["mp4s", "m4p"],
    "application/msword": ["doc", "dot"],
    "application/mxf": ["mxf"],
    "application/n-quads": ["nq"],
    "application/n-triples": ["nt"],
    "application/node": ["cjs"],
    "application/octet-stream": [
      "bin",
      "dms",
      "lrf",
      "mar",
      "so",
      "dist",
      "distz",
      "pkg",
      "bpk",
      "dump",
      "elc",
      "deploy",
      "exe",
      "dll",
      "deb",
      "dmg",
      "iso",
      "img",
      "msi",
      "msp",
      "msm",
      "buffer",
    ],
    "application/oda": ["oda"],
    "application/oebps-package+xml": ["opf"],
    "application/ogg": ["ogx"],
    "application/omdoc+xml": ["omdoc"],
    "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"],
    "application/oxps": ["oxps"],
    "application/p2p-overlay+xml": ["relo"],
    "application/patch-ops-error+xml": ["xer"],
    "application/pdf": ["pdf"],
    "application/pgp-encrypted": ["pgp"],
    "application/pgp-signature": ["asc", "sig"],
    "application/pics-rules": ["prf"],
    "application/pkcs10": ["p10"],
    "application/pkcs7-mime": ["p7m", "p7c"],
    "application/pkcs7-signature": ["p7s"],
    "application/pkcs8": ["p8"],
    "application/pkix-attr-cert": ["ac"],
    "application/pkix-cert": ["cer"],
    "application/pkix-crl": ["crl"],
    "application/pkix-pkipath": ["pkipath"],
    "application/pkixcmp": ["pki"],
    "application/pls+xml": ["pls"],
    "application/postscript": ["ai", "eps", "ps"],
    "application/provenance+xml": ["provx"],
    "application/pskc+xml": ["pskcxml"],
    "application/raml+yaml": ["raml"],
    "application/rdf+xml": ["rdf", "owl"],
    "application/reginfo+xml": ["rif"],
    "application/relax-ng-compact-syntax": ["rnc"],
    "application/resource-lists+xml": ["rl"],
    "application/resource-lists-diff+xml": ["rld"],
    "application/rls-services+xml": ["rs"],
    "application/route-apd+xml": ["rapd"],
    "application/route-s-tsid+xml": ["sls"],
    "application/route-usd+xml": ["rusd"],
    "application/rpki-ghostbusters": ["gbr"],
    "application/rpki-manifest": ["mft"],
    "application/rpki-roa": ["roa"],
    "application/rsd+xml": ["rsd"],
    "application/rss+xml": ["rss"],
    "application/rtf": ["rtf"],
    "application/sbml+xml": ["sbml"],
    "application/scvp-cv-request": ["scq"],
    "application/scvp-cv-response": ["scs"],
    "application/scvp-vp-request": ["spq"],
    "application/scvp-vp-response": ["spp"],
    "application/sdp": ["sdp"],
    "application/senml+xml": ["senmlx"],
    "application/sensml+xml": ["sensmlx"],
    "application/set-payment-initiation": ["setpay"],
    "application/set-registration-initiation": ["setreg"],
    "application/shf+xml": ["shf"],
    "application/sieve": ["siv", "sieve"],
    "application/smil+xml": ["smi", "smil"],
    "application/sparql-query": ["rq"],
    "application/sparql-results+xml": ["srx"],
    "application/srgs": ["gram"],
    "application/srgs+xml": ["grxml"],
    "application/sru+xml": ["sru"],
    "application/ssdl+xml": ["ssdl"],
    "application/ssml+xml": ["ssml"],
    "application/swid+xml": ["swidtag"],
    "application/tei+xml": ["tei", "teicorpus"],
    "application/thraud+xml": ["tfi"],
    "application/timestamped-data": ["tsd"],
    "application/toml": ["toml"],
    "application/trig": ["trig"],
    "application/ttml+xml": ["ttml"],
    "application/ubjson": ["ubj"],
    "application/urc-ressheet+xml": ["rsheet"],
    "application/urc-targetdesc+xml": ["td"],
    "application/voicexml+xml": ["vxml"],
    "application/wasm": ["wasm"],
    "application/widget": ["wgt"],
    "application/winhlp": ["hlp"],
    "application/wsdl+xml": ["wsdl"],
    "application/wspolicy+xml": ["wspolicy"],
    "application/xaml+xml": ["xaml"],
    "application/xcap-att+xml": ["xav"],
    "application/xcap-caps+xml": ["xca"],
    "application/xcap-diff+xml": ["xdf"],
    "application/xcap-el+xml": ["xel"],
    "application/xcap-ns+xml": ["xns"],
    "application/xenc+xml": ["xenc"],
    "application/xhtml+xml": ["xhtml", "xht"],
    "application/xliff+xml": ["xlf"],
    "application/xml": ["xml", "xsl", "xsd", "rng"],
    "application/xml-dtd": ["dtd"],
    "application/xop+xml": ["xop"],
    "application/xproc+xml": ["xpl"],
    "application/xslt+xml": ["*xsl", "xslt"],
    "application/xspf+xml": ["xspf"],
    "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"],
    "application/yang": ["yang"],
    "application/yin+xml": ["yin"],
    "application/zip": ["zip"],
    "audio/3gpp": ["*3gpp"],
    "audio/adpcm": ["adp"],
    "audio/amr": ["amr"],
    "audio/basic": ["au", "snd"],
    "audio/midi": ["mid", "midi", "kar", "rmi"],
    "audio/mobile-xmf": ["mxmf"],
    "audio/mp3": ["*mp3"],
    "audio/mp4": ["m4a", "mp4a"],
    "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"],
    "audio/ogg": ["oga", "ogg", "spx", "opus"],
    "audio/s3m": ["s3m"],
    "audio/silk": ["sil"],
    "audio/wav": ["wav"],
    "audio/wave": ["*wav"],
    "audio/webm": ["weba"],
    "audio/xm": ["xm"],
    "font/collection": ["ttc"],
    "font/otf": ["otf"],
    "font/ttf": ["ttf"],
    "font/woff": ["woff"],
    "font/woff2": ["woff2"],
    "image/aces": ["exr"],
    "image/apng": ["apng"],
    "image/avif": ["avif"],
    "image/bmp": ["bmp"],
    "image/cgm": ["cgm"],
    "image/dicom-rle": ["drle"],
    "image/emf": ["emf"],
    "image/fits": ["fits"],
    "image/g3fax": ["g3"],
    "image/gif": ["gif"],
    "image/heic": ["heic"],
    "image/heic-sequence": ["heics"],
    "image/heif": ["heif"],
    "image/heif-sequence": ["heifs"],
    "image/hej2k": ["hej2"],
    "image/hsj2": ["hsj2"],
    "image/ief": ["ief"],
    "image/jls": ["jls"],
    "image/jp2": ["jp2", "jpg2"],
    "image/jpeg": ["jpeg", "jpg", "jpe"],
    "image/jph": ["jph"],
    "image/jphc": ["jhc"],
    "image/jpm": ["jpm"],
    "image/jpx": ["jpx", "jpf"],
    "image/jxr": ["jxr"],
    "image/jxra": ["jxra"],
    "image/jxrs": ["jxrs"],
    "image/jxs": ["jxs"],
    "image/jxsc": ["jxsc"],
    "image/jxsi": ["jxsi"],
    "image/jxss": ["jxss"],
    "image/ktx": ["ktx"],
    "image/ktx2": ["ktx2"],
    "image/png": ["png"],
    "image/sgi": ["sgi"],
    "image/svg+xml": ["svg", "svgz"],
    "image/t38": ["t38"],
    "image/tiff": ["tif", "tiff"],
    "image/tiff-fx": ["tfx"],
    "image/webp": ["webp"],
    "image/wmf": ["wmf"],
    "message/disposition-notification": ["disposition-notification"],
    "message/global": ["u8msg"],
    "message/global-delivery-status": ["u8dsn"],
    "message/global-disposition-notification": ["u8mdn"],
    "message/global-headers": ["u8hdr"],
    "message/rfc822": ["eml", "mime"],
    "model/3mf": ["3mf"],
    "model/gltf+json": ["gltf"],
    "model/gltf-binary": ["glb"],
    "model/iges": ["igs", "iges"],
    "model/mesh": ["msh", "mesh", "silo"],
    "model/mtl": ["mtl"],
    "model/obj": ["obj"],
    "model/step+xml": ["stpx"],
    "model/step+zip": ["stpz"],
    "model/step-xml+zip": ["stpxz"],
    "model/stl": ["stl"],
    "model/vrml": ["wrl", "vrml"],
    "model/x3d+binary": ["*x3db", "x3dbz"],
    "model/x3d+fastinfoset": ["x3db"],
    "model/x3d+vrml": ["*x3dv", "x3dvz"],
    "model/x3d+xml": ["x3d", "x3dz"],
    "model/x3d-vrml": ["x3dv"],
    "text/cache-manifest": ["appcache", "manifest"],
    "text/calendar": ["ics", "ifb"],
    "text/coffeescript": ["coffee", "litcoffee"],
    "text/css": ["css"],
    "text/csv": ["csv"],
    "text/html": ["html", "htm", "shtml"],
    "text/jade": ["jade"],
    "text/jsx": ["jsx"],
    "text/less": ["less"],
    "text/markdown": ["markdown", "md"],
    "text/mathml": ["mml"],
    "text/mdx": ["mdx"],
    "text/n3": ["n3"],
    "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"],
    "text/richtext": ["rtx"],
    "text/rtf": ["*rtf"],
    "text/sgml": ["sgml", "sgm"],
    "text/shex": ["shex"],
    "text/slim": ["slim", "slm"],
    "text/spdx": ["spdx"],
    "text/stylus": ["stylus", "styl"],
    "text/tab-separated-values": ["tsv"],
    "text/troff": ["t", "tr", "roff", "man", "me", "ms"],
    "text/turtle": ["ttl"],
    "text/uri-list": ["uri", "uris", "urls"],
    "text/vcard": ["vcard"],
    "text/vtt": ["vtt"],
    "text/xml": ["*xml"],
    "text/yaml": ["yaml", "yml"],
    "video/3gpp": ["3gp", "3gpp"],
    "video/3gpp2": ["3g2"],
    "video/h261": ["h261"],
    "video/h263": ["h263"],
    "video/h264": ["h264"],
    "video/iso.segment": ["m4s"],
    "video/jpeg": ["jpgv"],
    "video/jpm": ["*jpm", "jpgm"],
    "video/mj2": ["mj2", "mjp2"],
    "video/mp2t": ["ts"],
    "video/mp4": ["mp4", "mp4v", "mpg4"],
    "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"],
    "video/ogg": ["ogv"],
    "video/quicktime": ["qt", "mov"],
    "video/webm": ["webm"],
  };
let VG = zG;
var KG = new VG(qG);
const GG = mn(KG);
class Rm {
  constructor() {
    (this.listeners = new Set()), (this.subscribe = this.subscribe.bind(this));
  }
  subscribe(e) {
    const r = {
      listener: e,
    };
    return (
      this.listeners.add(r),
      this.onSubscribe(),
      () => {
        this.listeners.delete(r), this.onUnsubscribe();
      }
    );
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {}
  onUnsubscribe() {}
}
const vp = typeof window > "u" || "Deno" in window;
function Ia() {}
function ZG(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function V6(t) {
  return typeof t == "number" && t >= 0 && t !== 1 / 0;
}
function $N(t, e) {
  return Math.max(t + (e || 0) - Date.now(), 0);
}
function gh(t, e, r) {
  return zb(t)
    ? typeof e == "function"
      ? {
          ...r,
          queryKey: t,
          queryFn: e,
        }
      : {
          ...e,
          queryKey: t,
        }
    : t;
}
function pc(t, e, r) {
  return zb(t)
    ? [
        {
          ...e,
          queryKey: t,
        },
        r,
      ]
    : [t || {}, e];
}
function VA(t, e) {
  const {
    type: r = "all",
    exact: n,
    fetchStatus: i,
    predicate: a,
    queryKey: s,
    stale: o,
  } = t;
  if (zb(s)) {
    if (n) {
      if (e.queryHash !== F8(s, e.options)) return !1;
    } else if (!Bg(e.queryKey, s)) return !1;
  }
  if (r !== "all") {
    const c = e.isActive();
    if ((r === "active" && !c) || (r === "inactive" && c)) return !1;
  }
  return !(
    (typeof o == "boolean" && e.isStale() !== o) ||
    (typeof i < "u" && i !== e.state.fetchStatus) ||
    (a && !a(e))
  );
}
function KA(t, e) {
  const { exact: r, fetching: n, predicate: i, mutationKey: a } = t;
  if (zb(a)) {
    if (!e.options.mutationKey) return !1;
    if (r) {
      if (zl(e.options.mutationKey) !== zl(a)) return !1;
    } else if (!Bg(e.options.mutationKey, a)) return !1;
  }
  return !(
    (typeof n == "boolean" && (e.state.status === "loading") !== n) ||
    (i && !i(e))
  );
}
function F8(t, e) {
  return ((e == null ? void 0 : e.queryKeyHashFn) || zl)(t);
}
function zl(t) {
  return JSON.stringify(t, (e, r) =>
    G6(r)
      ? Object.keys(r)
          .sort()
          .reduce((n, i) => ((n[i] = r[i]), n), {})
      : r
  );
}
function Bg(t, e) {
  return UN(t, e);
}
function UN(t, e) {
  return t === e
    ? !0
    : typeof t != typeof e
    ? !1
    : t && e && typeof t == "object" && typeof e == "object"
    ? !Object.keys(e).some((r) => !UN(t[r], e[r]))
    : !1;
}
function WN(t, e) {
  if (t === e) return t;
  const r = GA(t) && GA(e);
  if (r || (G6(t) && G6(e))) {
    const n = r ? t.length : Object.keys(t).length,
      i = r ? e : Object.keys(e),
      a = i.length,
      s = r ? [] : {};
    let o = 0;
    for (let c = 0; c < a; c++) {
      const u = r ? c : i[c];
      (s[u] = WN(t[u], e[u])), s[u] === t[u] && o++;
    }
    return n === a && o === n ? t : s;
  }
  return e;
}
function K6(t, e) {
  if ((t && !e) || (e && !t)) return !1;
  for (const r in t) if (t[r] !== e[r]) return !1;
  return !0;
}
function GA(t) {
  return Array.isArray(t) && t.length === Object.keys(t).length;
}
function G6(t) {
  if (!ZA(t)) return !1;
  const e = t.constructor;
  if (typeof e > "u") return !0;
  const r = e.prototype;
  return !(!ZA(r) || !r.hasOwnProperty("isPrototypeOf"));
}
function ZA(t) {
  return Object.prototype.toString.call(t) === "[object Object]";
}
function zb(t) {
  return Array.isArray(t);
}
function jN(t) {
  return new Promise((e) => {
    setTimeout(e, t);
  });
}
function JA(t) {
  jN(0).then(t);
}
function JG() {
  if (typeof AbortController == "function") return new AbortController();
}
function Z6(t, e, r) {
  return r.isDataEqual != null && r.isDataEqual(t, e)
    ? t
    : typeof r.structuralSharing == "function"
    ? r.structuralSharing(t, e)
    : r.structuralSharing !== !1
    ? WN(t, e)
    : e;
}
class QG extends Rm {
  constructor() {
    super(),
      (this.setup = (e) => {
        if (!vp && window.addEventListener) {
          const r = () => e();
          return (
            window.addEventListener("visibilitychange", r, !1),
            window.addEventListener("focus", r, !1),
            () => {
              window.removeEventListener("visibilitychange", r),
                window.removeEventListener("focus", r);
            }
          );
        }
      });
  }
  onSubscribe() {
    this.cleanup || this.setEventListener(this.setup);
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      var e;
      (e = this.cleanup) == null || e.call(this), (this.cleanup = void 0);
    }
  }
  setEventListener(e) {
    var r;
    (this.setup = e),
      (r = this.cleanup) == null || r.call(this),
      (this.cleanup = e((n) => {
        typeof n == "boolean" ? this.setFocused(n) : this.onFocus();
      }));
  }
  setFocused(e) {
    this.focused !== e && ((this.focused = e), this.onFocus());
  }
  onFocus() {
    this.listeners.forEach(({ listener: e }) => {
      e();
    });
  }
  isFocused() {
    return typeof this.focused == "boolean"
      ? this.focused
      : typeof document > "u"
      ? !0
      : [void 0, "visible", "prerender"].includes(document.visibilityState);
  }
}
const Dg = new QG(),
  QA = ["online", "offline"];
class YG extends Rm {
  constructor() {
    super(),
      (this.setup = (e) => {
        if (!vp && window.addEventListener) {
          const r = () => e();
          return (
            QA.forEach((n) => {
              window.addEventListener(n, r, !1);
            }),
            () => {
              QA.forEach((n) => {
                window.removeEventListener(n, r);
              });
            }
          );
        }
      });
  }
  onSubscribe() {
    this.cleanup || this.setEventListener(this.setup);
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      var e;
      (e = this.cleanup) == null || e.call(this), (this.cleanup = void 0);
    }
  }
  setEventListener(e) {
    var r;
    (this.setup = e),
      (r = this.cleanup) == null || r.call(this),
      (this.cleanup = e((n) => {
        typeof n == "boolean" ? this.setOnline(n) : this.onOnline();
      }));
  }
  setOnline(e) {
    this.online !== e && ((this.online = e), this.onOnline());
  }
  onOnline() {
    this.listeners.forEach(({ listener: e }) => {
      e();
    });
  }
  isOnline() {
    return typeof this.online == "boolean"
      ? this.online
      : typeof navigator > "u" || typeof navigator.onLine > "u"
      ? !0
      : navigator.onLine;
  }
}
const Og = new YG();
function XG(t) {
  return Math.min(1e3 * 2 ** t, 3e4);
}
function qb(t) {
  return (t ?? "online") === "online" ? Og.isOnline() : !0;
}
class HN {
  constructor(e) {
    (this.revert = e == null ? void 0 : e.revert),
      (this.silent = e == null ? void 0 : e.silent);
  }
}
function Hy(t) {
  return t instanceof HN;
}
function zN(t) {
  let e = !1,
    r = 0,
    n = !1,
    i,
    a,
    s;
  const o = new Promise((b, w) => {
      (a = b), (s = w);
    }),
    c = (b) => {
      n || (E(new HN(b)), t.abort == null || t.abort());
    },
    u = () => {
      e = !0;
    },
    d = () => {
      e = !1;
    },
    m = () => !Dg.isFocused() || (t.networkMode !== "always" && !Og.isOnline()),
    v = (b) => {
      n ||
        ((n = !0),
        t.onSuccess == null || t.onSuccess(b),
        i == null || i(),
        a(b));
    },
    E = (b) => {
      n ||
        ((n = !0), t.onError == null || t.onError(b), i == null || i(), s(b));
    },
    A = () =>
      new Promise((b) => {
        (i = (w) => {
          const S = n || !m();
          return S && b(w), S;
        }),
          t.onPause == null || t.onPause();
      }).then(() => {
        (i = void 0), n || t.onContinue == null || t.onContinue();
      }),
    I = () => {
      if (n) return;
      let b;
      try {
        b = t.fn();
      } catch (w) {
        b = Promise.reject(w);
      }
      Promise.resolve(b)
        .then(v)
        .catch((w) => {
          var S, k;
          if (n) return;
          const N = (S = t.retry) != null ? S : 3,
            O = (k = t.retryDelay) != null ? k : XG,
            F = typeof O == "function" ? O(r, w) : O,
            V =
              N === !0 ||
              (typeof N == "number" && r < N) ||
              (typeof N == "function" && N(r, w));
          if (e || !V) {
            E(w);
            return;
          }
          r++,
            t.onFail == null || t.onFail(r, w),
            jN(F)
              .then(() => {
                if (m()) return A();
              })
              .then(() => {
                e ? E(w) : I();
              });
        });
    };
  return (
    qb(t.networkMode) ? I() : A().then(I),
    {
      promise: o,
      cancel: c,
      continue: () => ((i == null ? void 0 : i()) ? o : Promise.resolve()),
      cancelRetry: u,
      continueRetry: d,
    }
  );
}
const L8 = console;
function eZ() {
  let t = [],
    e = 0,
    r = (d) => {
      d();
    },
    n = (d) => {
      d();
    };
  const i = (d) => {
      let m;
      e++;
      try {
        m = d();
      } finally {
        e--, e || o();
      }
      return m;
    },
    a = (d) => {
      e
        ? t.push(d)
        : JA(() => {
            r(d);
          });
    },
    s =
      (d) =>
      (...m) => {
        a(() => {
          d(...m);
        });
      },
    o = () => {
      const d = t;
      (t = []),
        d.length &&
          JA(() => {
            n(() => {
              d.forEach((m) => {
                r(m);
              });
            });
          });
    };
  return {
    batch: i,
    batchCalls: s,
    schedule: a,
    setNotifyFunction: (d) => {
      r = d;
    },
    setBatchNotifyFunction: (d) => {
      n = d;
    },
  };
}
const fn = eZ();
class qN {
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(),
      V6(this.cacheTime) &&
        (this.gcTimeout = setTimeout(() => {
          this.optionalRemove();
        }, this.cacheTime));
  }
  updateCacheTime(e) {
    this.cacheTime = Math.max(
      this.cacheTime || 0,
      e ?? (vp ? 1 / 0 : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    this.gcTimeout && (clearTimeout(this.gcTimeout), (this.gcTimeout = void 0));
  }
}
class tZ extends qN {
  constructor(e) {
    super(),
      (this.abortSignalConsumed = !1),
      (this.defaultOptions = e.defaultOptions),
      this.setOptions(e.options),
      (this.observers = []),
      (this.cache = e.cache),
      (this.logger = e.logger || L8),
      (this.queryKey = e.queryKey),
      (this.queryHash = e.queryHash),
      (this.initialState = e.state || rZ(this.options)),
      (this.state = this.initialState),
      this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  setOptions(e) {
    (this.options = {
      ...this.defaultOptions,
      ...e,
    }),
      this.updateCacheTime(this.options.cacheTime);
  }
  optionalRemove() {
    !this.observers.length &&
      this.state.fetchStatus === "idle" &&
      this.cache.remove(this);
  }
  setData(e, r) {
    const n = Z6(this.state.data, e, this.options);
    return (
      this.dispatch({
        data: n,
        type: "success",
        dataUpdatedAt: r == null ? void 0 : r.updatedAt,
        manual: r == null ? void 0 : r.manual,
      }),
      n
    );
  }
  setState(e, r) {
    this.dispatch({
      type: "setState",
      state: e,
      setStateOptions: r,
    });
  }
  cancel(e) {
    var r;
    const n = this.promise;
    return (
      (r = this.retryer) == null || r.cancel(e),
      n ? n.then(Ia).catch(Ia) : Promise.resolve()
    );
  }
  destroy() {
    super.destroy(),
      this.cancel({
        silent: !0,
      });
  }
  reset() {
    this.destroy(), this.setState(this.initialState);
  }
  isActive() {
    return this.observers.some((e) => e.options.enabled !== !1);
  }
  isDisabled() {
    return this.getObserversCount() > 0 && !this.isActive();
  }
  isStale() {
    return (
      this.state.isInvalidated ||
      !this.state.dataUpdatedAt ||
      this.observers.some((e) => e.getCurrentResult().isStale)
    );
  }
  isStaleByTime(e = 0) {
    return (
      this.state.isInvalidated ||
      !this.state.dataUpdatedAt ||
      !$N(this.state.dataUpdatedAt, e)
    );
  }
  onFocus() {
    var e;
    const r = this.observers.find((n) => n.shouldFetchOnWindowFocus());
    r &&
      r.refetch({
        cancelRefetch: !1,
      }),
      (e = this.retryer) == null || e.continue();
  }
  onOnline() {
    var e;
    const r = this.observers.find((n) => n.shouldFetchOnReconnect());
    r &&
      r.refetch({
        cancelRefetch: !1,
      }),
      (e = this.retryer) == null || e.continue();
  }
  addObserver(e) {
    this.observers.includes(e) ||
      (this.observers.push(e),
      this.clearGcTimeout(),
      this.cache.notify({
        type: "observerAdded",
        query: this,
        observer: e,
      }));
  }
  removeObserver(e) {
    this.observers.includes(e) &&
      ((this.observers = this.observers.filter((r) => r !== e)),
      this.observers.length ||
        (this.retryer &&
          (this.abortSignalConsumed
            ? this.retryer.cancel({
                revert: !0,
              })
            : this.retryer.cancelRetry()),
        this.scheduleGc()),
      this.cache.notify({
        type: "observerRemoved",
        query: this,
        observer: e,
      }));
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    this.state.isInvalidated ||
      this.dispatch({
        type: "invalidate",
      });
  }
  fetch(e, r) {
    var n, i;
    if (this.state.fetchStatus !== "idle") {
      if (this.state.dataUpdatedAt && r != null && r.cancelRefetch)
        this.cancel({
          silent: !0,
        });
      else if (this.promise) {
        var a;
        return (a = this.retryer) == null || a.continueRetry(), this.promise;
      }
    }
    if ((e && this.setOptions(e), !this.options.queryFn)) {
      const E = this.observers.find((A) => A.options.queryFn);
      E && this.setOptions(E.options);
    }
    const s = JG(),
      o = {
        queryKey: this.queryKey,
        pageParam: void 0,
        meta: this.meta,
      },
      c = (E) => {
        Object.defineProperty(E, "signal", {
          enumerable: !0,
          get: () => {
            if (s) return (this.abortSignalConsumed = !0), s.signal;
          },
        });
      };
    c(o);
    const u = () =>
        this.options.queryFn
          ? ((this.abortSignalConsumed = !1), this.options.queryFn(o))
          : Promise.reject(
              "Missing queryFn for queryKey '" + this.options.queryHash + "'"
            ),
      d = {
        fetchOptions: r,
        options: this.options,
        queryKey: this.queryKey,
        state: this.state,
        fetchFn: u,
      };
    if (
      (c(d),
      (n = this.options.behavior) == null || n.onFetch(d),
      (this.revertState = this.state),
      this.state.fetchStatus === "idle" ||
        this.state.fetchMeta !==
          ((i = d.fetchOptions) == null ? void 0 : i.meta))
    ) {
      var m;
      this.dispatch({
        type: "fetch",
        meta: (m = d.fetchOptions) == null ? void 0 : m.meta,
      });
    }
    const v = (E) => {
      if (
        ((Hy(E) && E.silent) ||
          this.dispatch({
            type: "error",
            error: E,
          }),
        !Hy(E))
      ) {
        var A, I, b, w;
        (A = (I = this.cache.config).onError) == null || A.call(I, E, this),
          (b = (w = this.cache.config).onSettled) == null ||
            b.call(w, this.state.data, E, this);
      }
      this.isFetchingOptimistic || this.scheduleGc(),
        (this.isFetchingOptimistic = !1);
    };
    return (
      (this.retryer = zN({
        fn: d.fetchFn,
        abort: s == null ? void 0 : s.abort.bind(s),
        onSuccess: (E) => {
          var A, I, b, w;
          if (typeof E > "u") {
            v(new Error(this.queryHash + " data is undefined"));
            return;
          }
          this.setData(E),
            (A = (I = this.cache.config).onSuccess) == null ||
              A.call(I, E, this),
            (b = (w = this.cache.config).onSettled) == null ||
              b.call(w, E, this.state.error, this),
            this.isFetchingOptimistic || this.scheduleGc(),
            (this.isFetchingOptimistic = !1);
        },
        onError: v,
        onFail: (E, A) => {
          this.dispatch({
            type: "failed",
            failureCount: E,
            error: A,
          });
        },
        onPause: () => {
          this.dispatch({
            type: "pause",
          });
        },
        onContinue: () => {
          this.dispatch({
            type: "continue",
          });
        },
        retry: d.options.retry,
        retryDelay: d.options.retryDelay,
        networkMode: d.options.networkMode,
      })),
      (this.promise = this.retryer.promise),
      this.promise
    );
  }
  dispatch(e) {
    const r = (n) => {
      var i, a;
      switch (e.type) {
        case "failed":
          return {
            ...n,
            fetchFailureCount: e.failureCount,
            fetchFailureReason: e.error,
          };
        case "pause":
          return {
            ...n,
            fetchStatus: "paused",
          };
        case "continue":
          return {
            ...n,
            fetchStatus: "fetching",
          };
        case "fetch":
          return {
            ...n,
            fetchFailureCount: 0,
            fetchFailureReason: null,
            fetchMeta: (i = e.meta) != null ? i : null,
            fetchStatus: qb(this.options.networkMode) ? "fetching" : "paused",
            ...(!n.dataUpdatedAt && {
              error: null,
              status: "loading",
            }),
          };
        case "success":
          return {
            ...n,
            data: e.data,
            dataUpdateCount: n.dataUpdateCount + 1,
            dataUpdatedAt: (a = e.dataUpdatedAt) != null ? a : Date.now(),
            error: null,
            isInvalidated: !1,
            status: "success",
            ...(!e.manual && {
              fetchStatus: "idle",
              fetchFailureCount: 0,
              fetchFailureReason: null,
            }),
          };
        case "error":
          const s = e.error;
          return Hy(s) && s.revert && this.revertState
            ? {
                ...this.revertState,
                fetchStatus: "idle",
              }
            : {
                ...n,
                error: s,
                errorUpdateCount: n.errorUpdateCount + 1,
                errorUpdatedAt: Date.now(),
                fetchFailureCount: n.fetchFailureCount + 1,
                fetchFailureReason: s,
                fetchStatus: "idle",
                status: "error",
              };
        case "invalidate":
          return {
            ...n,
            isInvalidated: !0,
          };
        case "setState":
          return {
            ...n,
            ...e.state,
          };
      }
    };
    (this.state = r(this.state)),
      fn.batch(() => {
        this.observers.forEach((n) => {
          n.onQueryUpdate(e);
        }),
          this.cache.notify({
            query: this,
            type: "updated",
            action: e,
          });
      });
  }
}
function rZ(t) {
  const e =
      typeof t.initialData == "function" ? t.initialData() : t.initialData,
    r = typeof e < "u",
    n = r
      ? typeof t.initialDataUpdatedAt == "function"
        ? t.initialDataUpdatedAt()
        : t.initialDataUpdatedAt
      : 0;
  return {
    data: e,
    dataUpdateCount: 0,
    dataUpdatedAt: r ? n ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: r ? "success" : "loading",
    fetchStatus: "idle",
  };
}
class nZ extends Rm {
  constructor(e) {
    super(),
      (this.config = e || {}),
      (this.queries = []),
      (this.queriesMap = {});
  }
  build(e, r, n) {
    var i;
    const a = r.queryKey,
      s = (i = r.queryHash) != null ? i : F8(a, r);
    let o = this.get(s);
    return (
      o ||
        ((o = new tZ({
          cache: this,
          logger: e.getLogger(),
          queryKey: a,
          queryHash: s,
          options: e.defaultQueryOptions(r),
          state: n,
          defaultOptions: e.getQueryDefaults(a),
        })),
        this.add(o)),
      o
    );
  }
  add(e) {
    this.queriesMap[e.queryHash] ||
      ((this.queriesMap[e.queryHash] = e),
      this.queries.push(e),
      this.notify({
        type: "added",
        query: e,
      }));
  }
  remove(e) {
    const r = this.queriesMap[e.queryHash];
    r &&
      (e.destroy(),
      (this.queries = this.queries.filter((n) => n !== e)),
      r === e && delete this.queriesMap[e.queryHash],
      this.notify({
        type: "removed",
        query: e,
      }));
  }
  clear() {
    fn.batch(() => {
      this.queries.forEach((e) => {
        this.remove(e);
      });
    });
  }
  get(e) {
    return this.queriesMap[e];
  }
  getAll() {
    return this.queries;
  }
  find(e, r) {
    const [n] = pc(e, r);
    return (
      typeof n.exact > "u" && (n.exact = !0), this.queries.find((i) => VA(n, i))
    );
  }
  findAll(e, r) {
    const [n] = pc(e, r);
    return Object.keys(n).length > 0
      ? this.queries.filter((i) => VA(n, i))
      : this.queries;
  }
  notify(e) {
    fn.batch(() => {
      this.listeners.forEach(({ listener: r }) => {
        r(e);
      });
    });
  }
  onFocus() {
    fn.batch(() => {
      this.queries.forEach((e) => {
        e.onFocus();
      });
    });
  }
  onOnline() {
    fn.batch(() => {
      this.queries.forEach((e) => {
        e.onOnline();
      });
    });
  }
}
class iZ extends qN {
  constructor(e) {
    super(),
      (this.defaultOptions = e.defaultOptions),
      (this.mutationId = e.mutationId),
      (this.mutationCache = e.mutationCache),
      (this.logger = e.logger || L8),
      (this.observers = []),
      (this.state = e.state || aZ()),
      this.setOptions(e.options),
      this.scheduleGc();
  }
  setOptions(e) {
    (this.options = {
      ...this.defaultOptions,
      ...e,
    }),
      this.updateCacheTime(this.options.cacheTime);
  }
  get meta() {
    return this.options.meta;
  }
  setState(e) {
    this.dispatch({
      type: "setState",
      state: e,
    });
  }
  addObserver(e) {
    this.observers.includes(e) ||
      (this.observers.push(e),
      this.clearGcTimeout(),
      this.mutationCache.notify({
        type: "observerAdded",
        mutation: this,
        observer: e,
      }));
  }
  removeObserver(e) {
    (this.observers = this.observers.filter((r) => r !== e)),
      this.scheduleGc(),
      this.mutationCache.notify({
        type: "observerRemoved",
        mutation: this,
        observer: e,
      });
  }
  optionalRemove() {
    this.observers.length ||
      (this.state.status === "loading"
        ? this.scheduleGc()
        : this.mutationCache.remove(this));
  }
  continue() {
    var e, r;
    return (e = (r = this.retryer) == null ? void 0 : r.continue()) != null
      ? e
      : this.execute();
  }
  async execute() {
    const e = () => {
        var V;
        return (
          (this.retryer = zN({
            fn: () =>
              this.options.mutationFn
                ? this.options.mutationFn(this.state.variables)
                : Promise.reject("No mutationFn found"),
            onFail: (j, X) => {
              this.dispatch({
                type: "failed",
                failureCount: j,
                error: X,
              });
            },
            onPause: () => {
              this.dispatch({
                type: "pause",
              });
            },
            onContinue: () => {
              this.dispatch({
                type: "continue",
              });
            },
            retry: (V = this.options.retry) != null ? V : 0,
            retryDelay: this.options.retryDelay,
            networkMode: this.options.networkMode,
          })),
          this.retryer.promise
        );
      },
      r = this.state.status === "loading";
    try {
      var n, i, a, s, o, c, u, d;
      if (!r) {
        var m, v, E, A;
        this.dispatch({
          type: "loading",
          variables: this.options.variables,
        }),
          await ((m = (v = this.mutationCache.config).onMutate) == null
            ? void 0
            : m.call(v, this.state.variables, this));
        const j = await ((E = (A = this.options).onMutate) == null
          ? void 0
          : E.call(A, this.state.variables));
        j !== this.state.context &&
          this.dispatch({
            type: "loading",
            context: j,
            variables: this.state.variables,
          });
      }
      const V = await e();
      return (
        await ((n = (i = this.mutationCache.config).onSuccess) == null
          ? void 0
          : n.call(i, V, this.state.variables, this.state.context, this)),
        await ((a = (s = this.options).onSuccess) == null
          ? void 0
          : a.call(s, V, this.state.variables, this.state.context)),
        await ((o = (c = this.mutationCache.config).onSettled) == null
          ? void 0
          : o.call(c, V, null, this.state.variables, this.state.context, this)),
        await ((u = (d = this.options).onSettled) == null
          ? void 0
          : u.call(d, V, null, this.state.variables, this.state.context)),
        this.dispatch({
          type: "success",
          data: V,
        }),
        V
      );
    } catch (V) {
      try {
        var I, b, w, S, k, N, O, F;
        throw (
          (await ((I = (b = this.mutationCache.config).onError) == null
            ? void 0
            : I.call(b, V, this.state.variables, this.state.context, this)),
          await ((w = (S = this.options).onError) == null
            ? void 0
            : w.call(S, V, this.state.variables, this.state.context)),
          await ((k = (N = this.mutationCache.config).onSettled) == null
            ? void 0
            : k.call(
                N,
                void 0,
                V,
                this.state.variables,
                this.state.context,
                this
              )),
          await ((O = (F = this.options).onSettled) == null
            ? void 0
            : O.call(F, void 0, V, this.state.variables, this.state.context)),
          V)
        );
      } finally {
        this.dispatch({
          type: "error",
          error: V,
        });
      }
    }
  }
  dispatch(e) {
    const r = (n) => {
      switch (e.type) {
        case "failed":
          return {
            ...n,
            failureCount: e.failureCount,
            failureReason: e.error,
          };
        case "pause":
          return {
            ...n,
            isPaused: !0,
          };
        case "continue":
          return {
            ...n,
            isPaused: !1,
          };
        case "loading":
          return {
            ...n,
            context: e.context,
            data: void 0,
            failureCount: 0,
            failureReason: null,
            error: null,
            isPaused: !qb(this.options.networkMode),
            status: "loading",
            variables: e.variables,
          };
        case "success":
          return {
            ...n,
            data: e.data,
            failureCount: 0,
            failureReason: null,
            error: null,
            status: "success",
            isPaused: !1,
          };
        case "error":
          return {
            ...n,
            data: void 0,
            error: e.error,
            failureCount: n.failureCount + 1,
            failureReason: e.error,
            isPaused: !1,
            status: "error",
          };
        case "setState":
          return {
            ...n,
            ...e.state,
          };
      }
    };
    (this.state = r(this.state)),
      fn.batch(() => {
        this.observers.forEach((n) => {
          n.onMutationUpdate(e);
        }),
          this.mutationCache.notify({
            mutation: this,
            type: "updated",
            action: e,
          });
      });
  }
}
function aZ() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0,
  };
}
class sZ extends Rm {
  constructor(e) {
    super(),
      (this.config = e || {}),
      (this.mutations = []),
      (this.mutationId = 0);
  }
  build(e, r, n) {
    const i = new iZ({
      mutationCache: this,
      logger: e.getLogger(),
      mutationId: ++this.mutationId,
      options: e.defaultMutationOptions(r),
      state: n,
      defaultOptions: r.mutationKey
        ? e.getMutationDefaults(r.mutationKey)
        : void 0,
    });
    return this.add(i), i;
  }
  add(e) {
    this.mutations.push(e),
      this.notify({
        type: "added",
        mutation: e,
      });
  }
  remove(e) {
    (this.mutations = this.mutations.filter((r) => r !== e)),
      this.notify({
        type: "removed",
        mutation: e,
      });
  }
  clear() {
    fn.batch(() => {
      this.mutations.forEach((e) => {
        this.remove(e);
      });
    });
  }
  getAll() {
    return this.mutations;
  }
  find(e) {
    return (
      typeof e.exact > "u" && (e.exact = !0),
      this.mutations.find((r) => KA(e, r))
    );
  }
  findAll(e) {
    return this.mutations.filter((r) => KA(e, r));
  }
  notify(e) {
    fn.batch(() => {
      this.listeners.forEach(({ listener: r }) => {
        r(e);
      });
    });
  }
  resumePausedMutations() {
    var e;
    return (
      (this.resuming = ((e = this.resuming) != null ? e : Promise.resolve())
        .then(() => {
          const r = this.mutations.filter((n) => n.state.isPaused);
          return fn.batch(() =>
            r.reduce(
              (n, i) => n.then(() => i.continue().catch(Ia)),
              Promise.resolve()
            )
          );
        })
        .then(() => {
          this.resuming = void 0;
        })),
      this.resuming
    );
  }
}
function oZ() {
  return {
    onFetch: (t) => {
      t.fetchFn = () => {
        var e, r, n, i, a, s;
        const o =
            (e = t.fetchOptions) == null || (r = e.meta) == null
              ? void 0
              : r.refetchPage,
          c =
            (n = t.fetchOptions) == null || (i = n.meta) == null
              ? void 0
              : i.fetchMore,
          u = c == null ? void 0 : c.pageParam,
          d = (c == null ? void 0 : c.direction) === "forward",
          m = (c == null ? void 0 : c.direction) === "backward",
          v = ((a = t.state.data) == null ? void 0 : a.pages) || [],
          E = ((s = t.state.data) == null ? void 0 : s.pageParams) || [];
        let A = E,
          I = !1;
        const b = (F) => {
            Object.defineProperty(F, "signal", {
              enumerable: !0,
              get: () => {
                var V;
                if ((V = t.signal) != null && V.aborted) I = !0;
                else {
                  var j;
                  (j = t.signal) == null ||
                    j.addEventListener("abort", () => {
                      I = !0;
                    });
                }
                return t.signal;
              },
            });
          },
          w =
            t.options.queryFn ||
            (() =>
              Promise.reject(
                "Missing queryFn for queryKey '" + t.options.queryHash + "'"
              )),
          S = (F, V, j, X) => (
            (A = X ? [V, ...A] : [...A, V]), X ? [j, ...F] : [...F, j]
          ),
          k = (F, V, j, X) => {
            if (I) return Promise.reject("Cancelled");
            if (typeof j > "u" && !V && F.length) return Promise.resolve(F);
            const C = {
              queryKey: t.queryKey,
              pageParam: j,
              meta: t.options.meta,
            };
            b(C);
            const l = w(C);
            return Promise.resolve(l).then((y) => S(F, j, y, X));
          };
        let N;
        if (!v.length) N = k([]);
        else if (d) {
          const F = typeof u < "u",
            V = F ? u : YA(t.options, v);
          N = k(v, F, V);
        } else if (m) {
          const F = typeof u < "u",
            V = F ? u : cZ(t.options, v);
          N = k(v, F, V, !0);
        } else {
          A = [];
          const F = typeof t.options.getNextPageParam > "u";
          N = (o && v[0] ? o(v[0], 0, v) : !0)
            ? k([], F, E[0])
            : Promise.resolve(S([], E[0], v[0]));
          for (let j = 1; j < v.length; j++)
            N = N.then((X) => {
              if (o && v[j] ? o(v[j], j, v) : !0) {
                const l = F ? E[j] : YA(t.options, X);
                return k(X, F, l);
              }
              return Promise.resolve(S(X, E[j], v[j]));
            });
        }
        return N.then((F) => ({
          pages: F,
          pageParams: A,
        }));
      };
    },
  };
}
function YA(t, e) {
  return t.getNextPageParam == null
    ? void 0
    : t.getNextPageParam(e[e.length - 1], e);
}
function cZ(t, e) {
  return t.getPreviousPageParam == null
    ? void 0
    : t.getPreviousPageParam(e[0], e);
}
class lZ {
  constructor(e = {}) {
    (this.queryCache = e.queryCache || new nZ()),
      (this.mutationCache = e.mutationCache || new sZ()),
      (this.logger = e.logger || L8),
      (this.defaultOptions = e.defaultOptions || {}),
      (this.queryDefaults = []),
      (this.mutationDefaults = []),
      (this.mountCount = 0);
  }
  mount() {
    this.mountCount++,
      this.mountCount === 1 &&
        ((this.unsubscribeFocus = Dg.subscribe(() => {
          Dg.isFocused() &&
            (this.resumePausedMutations(), this.queryCache.onFocus());
        })),
        (this.unsubscribeOnline = Og.subscribe(() => {
          Og.isOnline() &&
            (this.resumePausedMutations(), this.queryCache.onOnline());
        })));
  }
  unmount() {
    var e, r;
    this.mountCount--,
      this.mountCount === 0 &&
        ((e = this.unsubscribeFocus) == null || e.call(this),
        (this.unsubscribeFocus = void 0),
        (r = this.unsubscribeOnline) == null || r.call(this),
        (this.unsubscribeOnline = void 0));
  }
  isFetching(e, r) {
    const [n] = pc(e, r);
    return (n.fetchStatus = "fetching"), this.queryCache.findAll(n).length;
  }
  isMutating(e) {
    return this.mutationCache.findAll({
      ...e,
      fetching: !0,
    }).length;
  }
  getQueryData(e, r) {
    var n;
    return (n = this.queryCache.find(e, r)) == null ? void 0 : n.state.data;
  }
  ensureQueryData(e, r, n) {
    const i = gh(e, r, n),
      a = this.getQueryData(i.queryKey);
    return a ? Promise.resolve(a) : this.fetchQuery(i);
  }
  getQueriesData(e) {
    return this.getQueryCache()
      .findAll(e)
      .map(({ queryKey: r, state: n }) => {
        const i = n.data;
        return [r, i];
      });
  }
  setQueryData(e, r, n) {
    const i = this.queryCache.find(e),
      a = i == null ? void 0 : i.state.data,
      s = ZG(r, a);
    if (typeof s > "u") return;
    const o = gh(e),
      c = this.defaultQueryOptions(o);
    return this.queryCache.build(this, c).setData(s, {
      ...n,
      manual: !0,
    });
  }
  setQueriesData(e, r, n) {
    return fn.batch(() =>
      this.getQueryCache()
        .findAll(e)
        .map(({ queryKey: i }) => [i, this.setQueryData(i, r, n)])
    );
  }
  getQueryState(e, r) {
    var n;
    return (n = this.queryCache.find(e, r)) == null ? void 0 : n.state;
  }
  removeQueries(e, r) {
    const [n] = pc(e, r),
      i = this.queryCache;
    fn.batch(() => {
      i.findAll(n).forEach((a) => {
        i.remove(a);
      });
    });
  }
  resetQueries(e, r, n) {
    const [i, a] = pc(e, r, n),
      s = this.queryCache,
      o = {
        type: "active",
        ...i,
      };
    return fn.batch(
      () => (
        s.findAll(i).forEach((c) => {
          c.reset();
        }),
        this.refetchQueries(o, a)
      )
    );
  }
  cancelQueries(e, r, n) {
    const [i, a = {}] = pc(e, r, n);
    typeof a.revert > "u" && (a.revert = !0);
    const s = fn.batch(() =>
      this.queryCache.findAll(i).map((o) => o.cancel(a))
    );
    return Promise.all(s).then(Ia).catch(Ia);
  }
  invalidateQueries(e, r, n) {
    const [i, a] = pc(e, r, n);
    return fn.batch(() => {
      var s, o;
      if (
        (this.queryCache.findAll(i).forEach((u) => {
          u.invalidate();
        }),
        i.refetchType === "none")
      )
        return Promise.resolve();
      const c = {
        ...i,
        type:
          (s = (o = i.refetchType) != null ? o : i.type) != null ? s : "active",
      };
      return this.refetchQueries(c, a);
    });
  }
  refetchQueries(e, r, n) {
    const [i, a] = pc(e, r, n),
      s = fn.batch(() =>
        this.queryCache
          .findAll(i)
          .filter((c) => !c.isDisabled())
          .map((c) => {
            var u;
            return c.fetch(void 0, {
              ...a,
              cancelRefetch:
                (u = a == null ? void 0 : a.cancelRefetch) != null ? u : !0,
              meta: {
                refetchPage: i.refetchPage,
              },
            });
          })
      );
    let o = Promise.all(s).then(Ia);
    return (a != null && a.throwOnError) || (o = o.catch(Ia)), o;
  }
  fetchQuery(e, r, n) {
    const i = gh(e, r, n),
      a = this.defaultQueryOptions(i);
    typeof a.retry > "u" && (a.retry = !1);
    const s = this.queryCache.build(this, a);
    return s.isStaleByTime(a.staleTime)
      ? s.fetch(a)
      : Promise.resolve(s.state.data);
  }
  prefetchQuery(e, r, n) {
    return this.fetchQuery(e, r, n).then(Ia).catch(Ia);
  }
  fetchInfiniteQuery(e, r, n) {
    const i = gh(e, r, n);
    return (i.behavior = oZ()), this.fetchQuery(i);
  }
  prefetchInfiniteQuery(e, r, n) {
    return this.fetchInfiniteQuery(e, r, n).then(Ia).catch(Ia);
  }
  resumePausedMutations() {
    return this.mutationCache.resumePausedMutations();
  }
  getQueryCache() {
    return this.queryCache;
  }
  getMutationCache() {
    return this.mutationCache;
  }
  getLogger() {
    return this.logger;
  }
  getDefaultOptions() {
    return this.defaultOptions;
  }
  setDefaultOptions(e) {
    this.defaultOptions = e;
  }
  setQueryDefaults(e, r) {
    const n = this.queryDefaults.find((i) => zl(e) === zl(i.queryKey));
    n
      ? (n.defaultOptions = r)
      : this.queryDefaults.push({
          queryKey: e,
          defaultOptions: r,
        });
  }
  getQueryDefaults(e) {
    if (!e) return;
    const r = this.queryDefaults.find((n) => Bg(e, n.queryKey));
    return r == null ? void 0 : r.defaultOptions;
  }
  setMutationDefaults(e, r) {
    const n = this.mutationDefaults.find((i) => zl(e) === zl(i.mutationKey));
    n
      ? (n.defaultOptions = r)
      : this.mutationDefaults.push({
          mutationKey: e,
          defaultOptions: r,
        });
  }
  getMutationDefaults(e) {
    if (!e) return;
    const r = this.mutationDefaults.find((n) => Bg(e, n.mutationKey));
    return r == null ? void 0 : r.defaultOptions;
  }
  defaultQueryOptions(e) {
    if (e != null && e._defaulted) return e;
    const r = {
      ...this.defaultOptions.queries,
      ...this.getQueryDefaults(e == null ? void 0 : e.queryKey),
      ...e,
      _defaulted: !0,
    };
    return (
      !r.queryHash && r.queryKey && (r.queryHash = F8(r.queryKey, r)),
      typeof r.refetchOnReconnect > "u" &&
        (r.refetchOnReconnect = r.networkMode !== "always"),
      typeof r.useErrorBoundary > "u" && (r.useErrorBoundary = !!r.suspense),
      r
    );
  }
  defaultMutationOptions(e) {
    return e != null && e._defaulted
      ? e
      : {
          ...this.defaultOptions.mutations,
          ...this.getMutationDefaults(e == null ? void 0 : e.mutationKey),
          ...e,
          _defaulted: !0,
        };
  }
  clear() {
    this.queryCache.clear(), this.mutationCache.clear();
  }
}
class uZ extends Rm {
  constructor(e, r) {
    super(),
      (this.client = e),
      (this.options = r),
      (this.trackedProps = new Set()),
      (this.selectError = null),
      this.bindMethods(),
      this.setOptions(r);
  }
  bindMethods() {
    (this.remove = this.remove.bind(this)),
      (this.refetch = this.refetch.bind(this));
  }
  onSubscribe() {
    this.listeners.size === 1 &&
      (this.currentQuery.addObserver(this),
      XA(this.currentQuery, this.options) && this.executeFetch(),
      this.updateTimers());
  }
  onUnsubscribe() {
    this.hasListeners() || this.destroy();
  }
  shouldFetchOnReconnect() {
    return J6(this.currentQuery, this.options, this.options.refetchOnReconnect);
  }
  shouldFetchOnWindowFocus() {
    return J6(
      this.currentQuery,
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    (this.listeners = new Set()),
      this.clearStaleTimeout(),
      this.clearRefetchInterval(),
      this.currentQuery.removeObserver(this);
  }
  setOptions(e, r) {
    const n = this.options,
      i = this.currentQuery;
    if (
      ((this.options = this.client.defaultQueryOptions(e)),
      K6(n, this.options) ||
        this.client.getQueryCache().notify({
          type: "observerOptionsUpdated",
          query: this.currentQuery,
          observer: this,
        }),
      typeof this.options.enabled < "u" &&
        typeof this.options.enabled != "boolean")
    )
      throw new Error("Expected enabled to be a boolean");
    this.options.queryKey || (this.options.queryKey = n.queryKey),
      this.updateQuery();
    const a = this.hasListeners();
    a && ek(this.currentQuery, i, this.options, n) && this.executeFetch(),
      this.updateResult(r),
      a &&
        (this.currentQuery !== i ||
          this.options.enabled !== n.enabled ||
          this.options.staleTime !== n.staleTime) &&
        this.updateStaleTimeout();
    const s = this.computeRefetchInterval();
    a &&
      (this.currentQuery !== i ||
        this.options.enabled !== n.enabled ||
        s !== this.currentRefetchInterval) &&
      this.updateRefetchInterval(s);
  }
  getOptimisticResult(e) {
    const r = this.client.getQueryCache().build(this.client, e),
      n = this.createResult(r, e);
    return (
      dZ(this, n, e) &&
        ((this.currentResult = n),
        (this.currentResultOptions = this.options),
        (this.currentResultState = this.currentQuery.state)),
      n
    );
  }
  getCurrentResult() {
    return this.currentResult;
  }
  trackResult(e) {
    const r = {};
    return (
      Object.keys(e).forEach((n) => {
        Object.defineProperty(r, n, {
          configurable: !1,
          enumerable: !0,
          get: () => (this.trackedProps.add(n), e[n]),
        });
      }),
      r
    );
  }
  getCurrentQuery() {
    return this.currentQuery;
  }
  remove() {
    this.client.getQueryCache().remove(this.currentQuery);
  }
  refetch({ refetchPage: e, ...r } = {}) {
    return this.fetch({
      ...r,
      meta: {
        refetchPage: e,
      },
    });
  }
  fetchOptimistic(e) {
    const r = this.client.defaultQueryOptions(e),
      n = this.client.getQueryCache().build(this.client, r);
    return (
      (n.isFetchingOptimistic = !0),
      n.fetch().then(() => this.createResult(n, r))
    );
  }
  fetch(e) {
    var r;
    return this.executeFetch({
      ...e,
      cancelRefetch: (r = e.cancelRefetch) != null ? r : !0,
    }).then(() => (this.updateResult(), this.currentResult));
  }
  executeFetch(e) {
    this.updateQuery();
    let r = this.currentQuery.fetch(this.options, e);
    return (e != null && e.throwOnError) || (r = r.catch(Ia)), r;
  }
  updateStaleTimeout() {
    if (
      (this.clearStaleTimeout(),
      vp || this.currentResult.isStale || !V6(this.options.staleTime))
    )
      return;
    const r = $N(this.currentResult.dataUpdatedAt, this.options.staleTime) + 1;
    this.staleTimeoutId = setTimeout(() => {
      this.currentResult.isStale || this.updateResult();
    }, r);
  }
  computeRefetchInterval() {
    var e;
    return typeof this.options.refetchInterval == "function"
      ? this.options.refetchInterval(this.currentResult.data, this.currentQuery)
      : (e = this.options.refetchInterval) != null
      ? e
      : !1;
  }
  updateRefetchInterval(e) {
    this.clearRefetchInterval(),
      (this.currentRefetchInterval = e),
      !(
        vp ||
        this.options.enabled === !1 ||
        !V6(this.currentRefetchInterval) ||
        this.currentRefetchInterval === 0
      ) &&
        (this.refetchIntervalId = setInterval(() => {
          (this.options.refetchIntervalInBackground || Dg.isFocused()) &&
            this.executeFetch();
        }, this.currentRefetchInterval));
  }
  updateTimers() {
    this.updateStaleTimeout(),
      this.updateRefetchInterval(this.computeRefetchInterval());
  }
  clearStaleTimeout() {
    this.staleTimeoutId &&
      (clearTimeout(this.staleTimeoutId), (this.staleTimeoutId = void 0));
  }
  clearRefetchInterval() {
    this.refetchIntervalId &&
      (clearInterval(this.refetchIntervalId),
      (this.refetchIntervalId = void 0));
  }
  createResult(e, r) {
    const n = this.currentQuery,
      i = this.options,
      a = this.currentResult,
      s = this.currentResultState,
      o = this.currentResultOptions,
      c = e !== n,
      u = c ? e.state : this.currentQueryInitialState,
      d = c ? this.currentResult : this.previousQueryResult,
      { state: m } = e;
    let {
        dataUpdatedAt: v,
        error: E,
        errorUpdatedAt: A,
        fetchStatus: I,
        status: b,
      } = m,
      w = !1,
      S = !1,
      k;
    if (r._optimisticResults) {
      const j = this.hasListeners(),
        X = !j && XA(e, r),
        C = j && ek(e, n, r, i);
      (X || C) &&
        ((I = qb(e.options.networkMode) ? "fetching" : "paused"),
        v || (b = "loading")),
        r._optimisticResults === "isRestoring" && (I = "idle");
    }
    if (
      r.keepPreviousData &&
      !m.dataUpdatedAt &&
      d != null &&
      d.isSuccess &&
      b !== "error"
    )
      (k = d.data), (v = d.dataUpdatedAt), (b = d.status), (w = !0);
    else if (r.select && typeof m.data < "u")
      if (
        a &&
        m.data === (s == null ? void 0 : s.data) &&
        r.select === this.selectFn
      )
        k = this.selectResult;
      else
        try {
          (this.selectFn = r.select),
            (k = r.select(m.data)),
            (k = Z6(a == null ? void 0 : a.data, k, r)),
            (this.selectResult = k),
            (this.selectError = null);
        } catch (j) {
          this.selectError = j;
        }
    else k = m.data;
    if (typeof r.placeholderData < "u" && typeof k > "u" && b === "loading") {
      let j;
      if (
        a != null &&
        a.isPlaceholderData &&
        r.placeholderData === (o == null ? void 0 : o.placeholderData)
      )
        j = a.data;
      else if (
        ((j =
          typeof r.placeholderData == "function"
            ? r.placeholderData()
            : r.placeholderData),
        r.select && typeof j < "u")
      )
        try {
          (j = r.select(j)), (this.selectError = null);
        } catch (X) {
          this.selectError = X;
        }
      typeof j < "u" &&
        ((b = "success"),
        (k = Z6(a == null ? void 0 : a.data, j, r)),
        (S = !0));
    }
    this.selectError &&
      ((E = this.selectError),
      (k = this.selectResult),
      (A = Date.now()),
      (b = "error"));
    const N = I === "fetching",
      O = b === "loading",
      F = b === "error";
    return {
      status: b,
      fetchStatus: I,
      isLoading: O,
      isSuccess: b === "success",
      isError: F,
      isInitialLoading: O && N,
      data: k,
      dataUpdatedAt: v,
      error: E,
      errorUpdatedAt: A,
      failureCount: m.fetchFailureCount,
      failureReason: m.fetchFailureReason,
      errorUpdateCount: m.errorUpdateCount,
      isFetched: m.dataUpdateCount > 0 || m.errorUpdateCount > 0,
      isFetchedAfterMount:
        m.dataUpdateCount > u.dataUpdateCount ||
        m.errorUpdateCount > u.errorUpdateCount,
      isFetching: N,
      isRefetching: N && !O,
      isLoadingError: F && m.dataUpdatedAt === 0,
      isPaused: I === "paused",
      isPlaceholderData: S,
      isPreviousData: w,
      isRefetchError: F && m.dataUpdatedAt !== 0,
      isStale: $8(e, r),
      refetch: this.refetch,
      remove: this.remove,
    };
  }
  updateResult(e) {
    const r = this.currentResult,
      n = this.createResult(this.currentQuery, this.options);
    if (
      ((this.currentResultState = this.currentQuery.state),
      (this.currentResultOptions = this.options),
      K6(n, r))
    )
      return;
    this.currentResult = n;
    const i = {
        cache: !0,
      },
      a = () => {
        if (!r) return !0;
        const { notifyOnChangeProps: s } = this.options,
          o = typeof s == "function" ? s() : s;
        if (o === "all" || (!o && !this.trackedProps.size)) return !0;
        const c = new Set(o ?? this.trackedProps);
        return (
          this.options.useErrorBoundary && c.add("error"),
          Object.keys(this.currentResult).some((u) => {
            const d = u;
            return this.currentResult[d] !== r[d] && c.has(d);
          })
        );
      };
    (e == null ? void 0 : e.listeners) !== !1 && a() && (i.listeners = !0),
      this.notify({
        ...i,
        ...e,
      });
  }
  updateQuery() {
    const e = this.client.getQueryCache().build(this.client, this.options);
    if (e === this.currentQuery) return;
    const r = this.currentQuery;
    (this.currentQuery = e),
      (this.currentQueryInitialState = e.state),
      (this.previousQueryResult = this.currentResult),
      this.hasListeners() &&
        (r == null || r.removeObserver(this), e.addObserver(this));
  }
  onQueryUpdate(e) {
    const r = {};
    e.type === "success"
      ? (r.onSuccess = !e.manual)
      : e.type === "error" && !Hy(e.error) && (r.onError = !0),
      this.updateResult(r),
      this.hasListeners() && this.updateTimers();
  }
  notify(e) {
    fn.batch(() => {
      if (e.onSuccess) {
        var r, n, i, a;
        (r = (n = this.options).onSuccess) == null ||
          r.call(n, this.currentResult.data),
          (i = (a = this.options).onSettled) == null ||
            i.call(a, this.currentResult.data, null);
      } else if (e.onError) {
        var s, o, c, u;
        (s = (o = this.options).onError) == null ||
          s.call(o, this.currentResult.error),
          (c = (u = this.options).onSettled) == null ||
            c.call(u, void 0, this.currentResult.error);
      }
      e.listeners &&
        this.listeners.forEach(({ listener: d }) => {
          d(this.currentResult);
        }),
        e.cache &&
          this.client.getQueryCache().notify({
            query: this.currentQuery,
            type: "observerResultsUpdated",
          });
    });
  }
}
function fZ(t, e) {
  return (
    e.enabled !== !1 &&
    !t.state.dataUpdatedAt &&
    !(t.state.status === "error" && e.retryOnMount === !1)
  );
}
function XA(t, e) {
  return fZ(t, e) || (t.state.dataUpdatedAt > 0 && J6(t, e, e.refetchOnMount));
}
function J6(t, e, r) {
  if (e.enabled !== !1) {
    const n = typeof r == "function" ? r(t) : r;
    return n === "always" || (n !== !1 && $8(t, e));
  }
  return !1;
}
function ek(t, e, r, n) {
  return (
    r.enabled !== !1 &&
    (t !== e || n.enabled === !1) &&
    (!r.suspense || t.state.status !== "error") &&
    $8(t, r)
  );
}
function $8(t, e) {
  return t.isStaleByTime(e.staleTime);
}
function dZ(t, e, r) {
  return r.keepPreviousData
    ? !1
    : r.placeholderData !== void 0
    ? e.isPlaceholderData
    : !K6(t.getCurrentResult(), e);
}
var VN = {
    exports: {},
  },
  KN = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var yf = ye;
function hZ(t, e) {
  return (t === e && (t !== 0 || 1 / t === 1 / e)) || (t !== t && e !== e);
}
var pZ = typeof Object.is == "function" ? Object.is : hZ,
  mZ = yf.useState,
  yZ = yf.useEffect,
  gZ = yf.useLayoutEffect,
  bZ = yf.useDebugValue;
function vZ(t, e) {
  var r = e(),
    n = mZ({
      inst: {
        value: r,
        getSnapshot: e,
      },
    }),
    i = n[0].inst,
    a = n[1];
  return (
    gZ(
      function () {
        (i.value = r),
          (i.getSnapshot = e),
          Lw(i) &&
            a({
              inst: i,
            });
      },
      [t, r, e]
    ),
    yZ(
      function () {
        return (
          Lw(i) &&
            a({
              inst: i,
            }),
          t(function () {
            Lw(i) &&
              a({
                inst: i,
              });
          })
        );
      },
      [t]
    ),
    bZ(r),
    r
  );
}
function Lw(t) {
  var e = t.getSnapshot;
  t = t.value;
  try {
    var r = e();
    return !pZ(t, r);
  } catch {
    return !0;
  }
}
function xZ(t, e) {
  return e();
}
var wZ =
  typeof window > "u" ||
  typeof window.document > "u" ||
  typeof window.document.createElement > "u"
    ? xZ
    : vZ;
KN.useSyncExternalStore =
  yf.useSyncExternalStore !== void 0 ? yf.useSyncExternalStore : wZ;
VN.exports = KN;
var _Z = VN.exports;
const EZ = _Z.useSyncExternalStore,
  tk = ye.createContext(void 0),
  GN = ye.createContext(!1);
function ZN(t, e) {
  return (
    t ||
    (e && typeof window < "u"
      ? (window.ReactQueryClientContext ||
          (window.ReactQueryClientContext = tk),
        window.ReactQueryClientContext)
      : tk)
  );
}
const TZ = ({ context: t } = {}) => {
    const e = ye.useContext(ZN(t, ye.useContext(GN)));
    if (!e)
      throw new Error("No QueryClient set, use QueryClientProvider to set one");
    return e;
  },
  CZ = ({ client: t, children: e, context: r, contextSharing: n = !1 }) => {
    ye.useEffect(
      () => (
        t.mount(),
        () => {
          t.unmount();
        }
      ),
      [t]
    );
    const i = ZN(r, n);
    return ye.createElement(
      GN.Provider,
      {
        value: !r && n,
      },
      ye.createElement(
        i.Provider,
        {
          value: t,
        },
        e
      )
    );
  },
  JN = ye.createContext(!1),
  AZ = () => ye.useContext(JN);
JN.Provider;
function kZ() {
  let t = !1;
  return {
    clearReset: () => {
      t = !1;
    },
    reset: () => {
      t = !0;
    },
    isReset: () => t,
  };
}
const SZ = ye.createContext(kZ()),
  MZ = () => ye.useContext(SZ);
function IZ(t, e) {
  return typeof t == "function" ? t(...e) : !!t;
}
const RZ = (t, e) => {
    (t.suspense || t.useErrorBoundary) &&
      (e.isReset() || (t.retryOnMount = !1));
  },
  PZ = (t) => {
    ye.useEffect(() => {
      t.clearReset();
    }, [t]);
  },
  NZ = ({ result: t, errorResetBoundary: e, useErrorBoundary: r, query: n }) =>
    t.isError && !e.isReset() && !t.isFetching && IZ(r, [t.error, n]),
  BZ = (t) => {
    t.suspense && typeof t.staleTime != "number" && (t.staleTime = 1e3);
  },
  DZ = (t, e) => t.isLoading && t.isFetching && !e,
  OZ = (t, e, r) => (t == null ? void 0 : t.suspense) && DZ(e, r),
  FZ = (t, e, r) =>
    e
      .fetchOptimistic(t)
      .then(({ data: n }) => {
        t.onSuccess == null || t.onSuccess(n),
          t.onSettled == null || t.onSettled(n, null);
      })
      .catch((n) => {
        r.clearReset(),
          t.onError == null || t.onError(n),
          t.onSettled == null || t.onSettled(void 0, n);
      });
function LZ(t, e) {
  const r = TZ({
      context: t.context,
    }),
    n = AZ(),
    i = MZ(),
    a = r.defaultQueryOptions(t);
  (a._optimisticResults = n ? "isRestoring" : "optimistic"),
    a.onError && (a.onError = fn.batchCalls(a.onError)),
    a.onSuccess && (a.onSuccess = fn.batchCalls(a.onSuccess)),
    a.onSettled && (a.onSettled = fn.batchCalls(a.onSettled)),
    BZ(a),
    RZ(a, i),
    PZ(i);
  const [s] = ye.useState(() => new e(r, a)),
    o = s.getOptimisticResult(a);
  if (
    (EZ(
      ye.useCallback(
        (c) => {
          const u = n ? () => {} : s.subscribe(fn.batchCalls(c));
          return s.updateResult(), u;
        },
        [s, n]
      ),
      () => s.getCurrentResult(),
      () => s.getCurrentResult()
    ),
    ye.useEffect(() => {
      s.setOptions(a, {
        listeners: !1,
      });
    }, [a, s]),
    OZ(a, o, n))
  )
    throw FZ(a, s, i);
  if (
    NZ({
      result: o,
      errorResetBoundary: i,
      useErrorBoundary: a.useErrorBoundary,
      query: s.getCurrentQuery(),
    })
  )
    throw o.error;
  return a.notifyOnChangeProps ? o : s.trackResult(o);
}
function $Z(t, e, r) {
  const n = gh(t, e, r);
  return LZ(n, uZ);
}
var $t;
(function (t) {
  t.assertEqual = (i) => i;
  function e(i) {}
  t.assertIs = e;
  function r(i) {
    throw new Error();
  }
  (t.assertNever = r),
    (t.arrayToEnum = (i) => {
      const a = {};
      for (const s of i) a[s] = s;
      return a;
    }),
    (t.getValidEnumValues = (i) => {
      const a = t.objectKeys(i).filter((o) => typeof i[i[o]] != "number"),
        s = {};
      for (const o of a) s[o] = i[o];
      return t.objectValues(s);
    }),
    (t.objectValues = (i) =>
      t.objectKeys(i).map(function (a) {
        return i[a];
      })),
    (t.objectKeys =
      typeof Object.keys == "function"
        ? (i) => Object.keys(i)
        : (i) => {
            const a = [];
            for (const s in i)
              Object.prototype.hasOwnProperty.call(i, s) && a.push(s);
            return a;
          }),
    (t.find = (i, a) => {
      for (const s of i) if (a(s)) return s;
    }),
    (t.isInteger =
      typeof Number.isInteger == "function"
        ? (i) => Number.isInteger(i)
        : (i) => typeof i == "number" && isFinite(i) && Math.floor(i) === i);
  function n(i, a = " | ") {
    return i.map((s) => (typeof s == "string" ? `'${s}'` : s)).join(a);
  }
  (t.joinValues = n),
    (t.jsonStringifyReplacer = (i, a) =>
      typeof a == "bigint" ? a.toString() : a);
})($t || ($t = {}));
var Q6;
(function (t) {
  t.mergeShapes = (e, r) => ({
    ...e,
    ...r,
  });
})(Q6 || (Q6 = {}));
const tt = $t.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set",
  ]),
  gc = (t) => {
    switch (typeof t) {
      case "undefined":
        return tt.undefined;
      case "string":
        return tt.string;
      case "number":
        return isNaN(t) ? tt.nan : tt.number;
      case "boolean":
        return tt.boolean;
      case "function":
        return tt.function;
      case "bigint":
        return tt.bigint;
      case "symbol":
        return tt.symbol;
      case "object":
        return Array.isArray(t)
          ? tt.array
          : t === null
          ? tt.null
          : t.then &&
            typeof t.then == "function" &&
            t.catch &&
            typeof t.catch == "function"
          ? tt.promise
          : typeof Map < "u" && t instanceof Map
          ? tt.map
          : typeof Set < "u" && t instanceof Set
          ? tt.set
          : typeof Date < "u" && t instanceof Date
          ? tt.date
          : tt.object;
      default:
        return tt.unknown;
    }
  },
  Ze = $t.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite",
  ]),
  UZ = (t) => JSON.stringify(t, null, 2).replace(/"([^"]+)":/g, "$1:");
class fa extends Error {
  constructor(e) {
    super(),
      (this.issues = []),
      (this.addIssue = (n) => {
        this.issues = [...this.issues, n];
      }),
      (this.addIssues = (n = []) => {
        this.issues = [...this.issues, ...n];
      });
    const r = new.target.prototype;
    Object.setPrototypeOf
      ? Object.setPrototypeOf(this, r)
      : (this.__proto__ = r),
      (this.name = "ZodError"),
      (this.issues = e);
  }
  get errors() {
    return this.issues;
  }
  format(e) {
    const r =
        e ||
        function (a) {
          return a.message;
        },
      n = {
        _errors: [],
      },
      i = (a) => {
        for (const s of a.issues)
          if (s.code === "invalid_union") s.unionErrors.map(i);
          else if (s.code === "invalid_return_type") i(s.returnTypeError);
          else if (s.code === "invalid_arguments") i(s.argumentsError);
          else if (s.path.length === 0) n._errors.push(r(s));
          else {
            let o = n,
              c = 0;
            for (; c < s.path.length; ) {
              const u = s.path[c];
              c === s.path.length - 1
                ? ((o[u] = o[u] || {
                    _errors: [],
                  }),
                  o[u]._errors.push(r(s)))
                : (o[u] = o[u] || {
                    _errors: [],
                  }),
                (o = o[u]),
                c++;
            }
          }
      };
    return i(this), n;
  }
  static assert(e) {
    if (!(e instanceof fa)) throw new Error(`Not a ZodError: ${e}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, $t.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e = (r) => r.message) {
    const r = {},
      n = [];
    for (const i of this.issues)
      i.path.length > 0
        ? ((r[i.path[0]] = r[i.path[0]] || []), r[i.path[0]].push(e(i)))
        : n.push(e(i));
    return {
      formErrors: n,
      fieldErrors: r,
    };
  }
  get formErrors() {
    return this.flatten();
  }
}
fa.create = (t) => new fa(t);
const gf = (t, e) => {
  let r;
  switch (t.code) {
    case Ze.invalid_type:
      t.received === tt.undefined
        ? (r = "Required")
        : (r = `Expected ${t.expected}, received ${t.received}`);
      break;
    case Ze.invalid_literal:
      r = `Invalid literal value, expected ${JSON.stringify(
        t.expected,
        $t.jsonStringifyReplacer
      )}`;
      break;
    case Ze.unrecognized_keys:
      r = `Unrecognized key(s) in object: ${$t.joinValues(t.keys, ", ")}`;
      break;
    case Ze.invalid_union:
      r = "Invalid input";
      break;
    case Ze.invalid_union_discriminator:
      r = `Invalid discriminator value. Expected ${$t.joinValues(t.options)}`;
      break;
    case Ze.invalid_enum_value:
      r = `Invalid enum value. Expected ${$t.joinValues(
        t.options
      )}, received '${t.received}'`;
      break;
    case Ze.invalid_arguments:
      r = "Invalid function arguments";
      break;
    case Ze.invalid_return_type:
      r = "Invalid function return type";
      break;
    case Ze.invalid_date:
      r = "Invalid date";
      break;
    case Ze.invalid_string:
      typeof t.validation == "object"
        ? "includes" in t.validation
          ? ((r = `Invalid input: must include "${t.validation.includes}"`),
            typeof t.validation.position == "number" &&
              (r = `${r} at one or more positions greater than or equal to ${t.validation.position}`))
          : "startsWith" in t.validation
          ? (r = `Invalid input: must start with "${t.validation.startsWith}"`)
          : "endsWith" in t.validation
          ? (r = `Invalid input: must end with "${t.validation.endsWith}"`)
          : $t.assertNever(t.validation)
        : t.validation !== "regex"
        ? (r = `Invalid ${t.validation}`)
        : (r = "Invalid");
      break;
    case Ze.too_small:
      t.type === "array"
        ? (r = `Array must contain ${
            t.exact ? "exactly" : t.inclusive ? "at least" : "more than"
          } ${t.minimum} element(s)`)
        : t.type === "string"
        ? (r = `String must contain ${
            t.exact ? "exactly" : t.inclusive ? "at least" : "over"
          } ${t.minimum} character(s)`)
        : t.type === "number"
        ? (r = `Number must be ${
            t.exact
              ? "exactly equal to "
              : t.inclusive
              ? "greater than or equal to "
              : "greater than "
          }${t.minimum}`)
        : t.type === "date"
        ? (r = `Date must be ${
            t.exact
              ? "exactly equal to "
              : t.inclusive
              ? "greater than or equal to "
              : "greater than "
          }${new Date(Number(t.minimum))}`)
        : (r = "Invalid input");
      break;
    case Ze.too_big:
      t.type === "array"
        ? (r = `Array must contain ${
            t.exact ? "exactly" : t.inclusive ? "at most" : "less than"
          } ${t.maximum} element(s)`)
        : t.type === "string"
        ? (r = `String must contain ${
            t.exact ? "exactly" : t.inclusive ? "at most" : "under"
          } ${t.maximum} character(s)`)
        : t.type === "number"
        ? (r = `Number must be ${
            t.exact
              ? "exactly"
              : t.inclusive
              ? "less than or equal to"
              : "less than"
          } ${t.maximum}`)
        : t.type === "bigint"
        ? (r = `BigInt must be ${
            t.exact
              ? "exactly"
              : t.inclusive
              ? "less than or equal to"
              : "less than"
          } ${t.maximum}`)
        : t.type === "date"
        ? (r = `Date must be ${
            t.exact
              ? "exactly"
              : t.inclusive
              ? "smaller than or equal to"
              : "smaller than"
          } ${new Date(Number(t.maximum))}`)
        : (r = "Invalid input");
      break;
    case Ze.custom:
      r = "Invalid input";
      break;
    case Ze.invalid_intersection_types:
      r = "Intersection results could not be merged";
      break;
    case Ze.not_multiple_of:
      r = `Number must be a multiple of ${t.multipleOf}`;
      break;
    case Ze.not_finite:
      r = "Number must be finite";
      break;
    default:
      (r = e.defaultError), $t.assertNever(t);
  }
  return {
    message: r,
  };
};
let QN = gf;
function WZ(t) {
  QN = t;
}
function Fg() {
  return QN;
}
const Lg = (t) => {
    const { data: e, path: r, errorMaps: n, issueData: i } = t,
      a = [...r, ...(i.path || [])],
      s = {
        ...i,
        path: a,
      };
    if (i.message !== void 0)
      return {
        ...i,
        path: a,
        message: i.message,
      };
    let o = "";
    const c = n
      .filter((u) => !!u)
      .slice()
      .reverse();
    for (const u of c)
      o = u(s, {
        data: e,
        defaultError: o,
      }).message;
    return {
      ...i,
      path: a,
      message: o,
    };
  },
  jZ = [];
function Ye(t, e) {
  const r = Fg(),
    n = Lg({
      issueData: e,
      data: t.data,
      path: t.path,
      errorMaps: [
        t.common.contextualErrorMap,
        t.schemaErrorMap,
        r,
        r === gf ? void 0 : gf,
      ].filter((i) => !!i),
    });
  t.common.issues.push(n);
}
class yi {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(e, r) {
    const n = [];
    for (const i of r) {
      if (i.status === "aborted") return dt;
      i.status === "dirty" && e.dirty(), n.push(i.value);
    }
    return {
      status: e.value,
      value: n,
    };
  }
  static async mergeObjectAsync(e, r) {
    const n = [];
    for (const i of r) {
      const a = await i.key,
        s = await i.value;
      n.push({
        key: a,
        value: s,
      });
    }
    return yi.mergeObjectSync(e, n);
  }
  static mergeObjectSync(e, r) {
    const n = {};
    for (const i of r) {
      const { key: a, value: s } = i;
      if (a.status === "aborted" || s.status === "aborted") return dt;
      a.status === "dirty" && e.dirty(),
        s.status === "dirty" && e.dirty(),
        a.value !== "__proto__" &&
          (typeof s.value < "u" || i.alwaysSet) &&
          (n[a.value] = s.value);
    }
    return {
      status: e.value,
      value: n,
    };
  }
}
const dt = Object.freeze({
    status: "aborted",
  }),
  I0 = (t) => ({
    status: "dirty",
    value: t,
  }),
  Si = (t) => ({
    status: "valid",
    value: t,
  }),
  Y6 = (t) => t.status === "aborted",
  X6 = (t) => t.status === "dirty",
  xp = (t) => t.status === "valid",
  wp = (t) => typeof Promise < "u" && t instanceof Promise;
function $g(t, e, r, n) {
  if (typeof e == "function" ? t !== e || !n : !e.has(t))
    throw new TypeError(
      "Cannot read private member from an object whose class did not declare it"
    );
  return e.get(t);
}
function YN(t, e, r, n, i) {
  if (typeof e == "function" ? t !== e || !i : !e.has(t))
    throw new TypeError(
      "Cannot write private member to an object whose class did not declare it"
    );
  return e.set(t, r), r;
}
var lt;
(function (t) {
  (t.errToObj = (e) =>
    typeof e == "string"
      ? {
          message: e,
        }
      : e || {}),
    (t.toString = (e) =>
      typeof e == "string" ? e : e == null ? void 0 : e.message);
})(lt || (lt = {}));
var bh, vh;
class so {
  constructor(e, r, n, i) {
    (this._cachedPath = []),
      (this.parent = e),
      (this.data = r),
      (this._path = n),
      (this._key = i);
  }
  get path() {
    return (
      this._cachedPath.length ||
        (this._key instanceof Array
          ? this._cachedPath.push(...this._path, ...this._key)
          : this._cachedPath.push(...this._path, this._key)),
      this._cachedPath
    );
  }
}
const rk = (t, e) => {
  if (xp(e))
    return {
      success: !0,
      data: e.value,
    };
  if (!t.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error) return this._error;
      const r = new fa(t.common.issues);
      return (this._error = r), this._error;
    },
  };
};
function xt(t) {
  if (!t) return {};
  const {
    errorMap: e,
    invalid_type_error: r,
    required_error: n,
    description: i,
  } = t;
  if (e && (r || n))
    throw new Error(
      `Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`
    );
  return e
    ? {
        errorMap: e,
        description: i,
      }
    : {
        errorMap: (s, o) => {
          var c, u;
          const { message: d } = t;
          return s.code === "invalid_enum_value"
            ? {
                message: d ?? o.defaultError,
              }
            : typeof o.data > "u"
            ? {
                message:
                  (c = d ?? n) !== null && c !== void 0 ? c : o.defaultError,
              }
            : s.code !== "invalid_type"
            ? {
                message: o.defaultError,
              }
            : {
                message:
                  (u = d ?? r) !== null && u !== void 0 ? u : o.defaultError,
              };
        },
        description: i,
      };
}
class _t {
  constructor(e) {
    (this.spa = this.safeParseAsync),
      (this._def = e),
      (this.parse = this.parse.bind(this)),
      (this.safeParse = this.safeParse.bind(this)),
      (this.parseAsync = this.parseAsync.bind(this)),
      (this.safeParseAsync = this.safeParseAsync.bind(this)),
      (this.spa = this.spa.bind(this)),
      (this.refine = this.refine.bind(this)),
      (this.refinement = this.refinement.bind(this)),
      (this.superRefine = this.superRefine.bind(this)),
      (this.optional = this.optional.bind(this)),
      (this.nullable = this.nullable.bind(this)),
      (this.nullish = this.nullish.bind(this)),
      (this.array = this.array.bind(this)),
      (this.promise = this.promise.bind(this)),
      (this.or = this.or.bind(this)),
      (this.and = this.and.bind(this)),
      (this.transform = this.transform.bind(this)),
      (this.brand = this.brand.bind(this)),
      (this.default = this.default.bind(this)),
      (this.catch = this.catch.bind(this)),
      (this.describe = this.describe.bind(this)),
      (this.pipe = this.pipe.bind(this)),
      (this.readonly = this.readonly.bind(this)),
      (this.isNullable = this.isNullable.bind(this)),
      (this.isOptional = this.isOptional.bind(this));
  }
  get description() {
    return this._def.description;
  }
  _getType(e) {
    return gc(e.data);
  }
  _getOrReturnCtx(e, r) {
    return (
      r || {
        common: e.parent.common,
        data: e.data,
        parsedType: gc(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent,
      }
    );
  }
  _processInputParams(e) {
    return {
      status: new yi(),
      ctx: {
        common: e.parent.common,
        data: e.data,
        parsedType: gc(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent,
      },
    };
  }
  _parseSync(e) {
    const r = this._parse(e);
    if (wp(r)) throw new Error("Synchronous parse encountered promise.");
    return r;
  }
  _parseAsync(e) {
    const r = this._parse(e);
    return Promise.resolve(r);
  }
  parse(e, r) {
    const n = this.safeParse(e, r);
    if (n.success) return n.data;
    throw n.error;
  }
  safeParse(e, r) {
    var n;
    const i = {
        common: {
          issues: [],
          async:
            (n = r == null ? void 0 : r.async) !== null && n !== void 0
              ? n
              : !1,
          contextualErrorMap: r == null ? void 0 : r.errorMap,
        },
        path: (r == null ? void 0 : r.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: e,
        parsedType: gc(e),
      },
      a = this._parseSync({
        data: e,
        path: i.path,
        parent: i,
      });
    return rk(i, a);
  }
  async parseAsync(e, r) {
    const n = await this.safeParseAsync(e, r);
    if (n.success) return n.data;
    throw n.error;
  }
  async safeParseAsync(e, r) {
    const n = {
        common: {
          issues: [],
          contextualErrorMap: r == null ? void 0 : r.errorMap,
          async: !0,
        },
        path: (r == null ? void 0 : r.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: e,
        parsedType: gc(e),
      },
      i = this._parse({
        data: e,
        path: n.path,
        parent: n,
      }),
      a = await (wp(i) ? i : Promise.resolve(i));
    return rk(n, a);
  }
  refine(e, r) {
    const n = (i) =>
      typeof r == "string" || typeof r > "u"
        ? {
            message: r,
          }
        : typeof r == "function"
        ? r(i)
        : r;
    return this._refinement((i, a) => {
      const s = e(i),
        o = () =>
          a.addIssue({
            code: Ze.custom,
            ...n(i),
          });
      return typeof Promise < "u" && s instanceof Promise
        ? s.then((c) => (c ? !0 : (o(), !1)))
        : s
        ? !0
        : (o(), !1);
    });
  }
  refinement(e, r) {
    return this._refinement((n, i) =>
      e(n) ? !0 : (i.addIssue(typeof r == "function" ? r(n, i) : r), !1)
    );
  }
  _refinement(e) {
    return new vs({
      schema: this,
      typeName: ut.ZodEffects,
      effect: {
        type: "refinement",
        refinement: e,
      },
    });
  }
  superRefine(e) {
    return this._refinement(e);
  }
  optional() {
    return eo.create(this, this._def);
  }
  nullable() {
    return Xc.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ys.create(this, this._def);
  }
  promise() {
    return vf.create(this, this._def);
  }
  or(e) {
    return Cp.create([this, e], this._def);
  }
  and(e) {
    return Ap.create(this, e, this._def);
  }
  transform(e) {
    return new vs({
      ...xt(this._def),
      schema: this,
      typeName: ut.ZodEffects,
      effect: {
        type: "transform",
        transform: e,
      },
    });
  }
  default(e) {
    const r = typeof e == "function" ? e : () => e;
    return new Rp({
      ...xt(this._def),
      innerType: this,
      defaultValue: r,
      typeName: ut.ZodDefault,
    });
  }
  brand() {
    return new U8({
      typeName: ut.ZodBranded,
      type: this,
      ...xt(this._def),
    });
  }
  catch(e) {
    const r = typeof e == "function" ? e : () => e;
    return new Pp({
      ...xt(this._def),
      innerType: this,
      catchValue: r,
      typeName: ut.ZodCatch,
    });
  }
  describe(e) {
    const r = this.constructor;
    return new r({
      ...this._def,
      description: e,
    });
  }
  pipe(e) {
    return Pm.create(this, e);
  }
  readonly() {
    return Np.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const HZ = /^c[^\s-]{8,}$/i,
  zZ = /^[0-9a-z]+$/,
  qZ = /^[0-9A-HJKMNP-TV-Z]{26}$/,
  VZ =
    /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
  KZ = /^[a-z0-9_-]{21}$/i,
  GZ =
    /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,
  ZZ =
    /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,
  JZ = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let $w;
const QZ =
    /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  YZ =
    /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  XZ = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  XN =
    "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))",
  eJ = new RegExp(`^${XN}$`);
function eB(t) {
  let e = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
  return (
    t.precision
      ? (e = `${e}\\.\\d{${t.precision}}`)
      : t.precision == null && (e = `${e}(\\.\\d+)?`),
    e
  );
}
function tJ(t) {
  return new RegExp(`^${eB(t)}$`);
}
function tB(t) {
  let e = `${XN}T${eB(t)}`;
  const r = [];
  return (
    r.push(t.local ? "Z?" : "Z"),
    t.offset && r.push("([+-]\\d{2}:?\\d{2})"),
    (e = `${e}(${r.join("|")})`),
    new RegExp(`^${e}$`)
  );
}
function rJ(t, e) {
  return !!(
    ((e === "v4" || !e) && QZ.test(t)) ||
    ((e === "v6" || !e) && YZ.test(t))
  );
}
class fs extends _t {
  _parse(e) {
    if (
      (this._def.coerce && (e.data = String(e.data)),
      this._getType(e) !== tt.string)
    ) {
      const a = this._getOrReturnCtx(e);
      return (
        Ye(a, {
          code: Ze.invalid_type,
          expected: tt.string,
          received: a.parsedType,
        }),
        dt
      );
    }
    const n = new yi();
    let i;
    for (const a of this._def.checks)
      if (a.kind === "min")
        e.data.length < a.value &&
          ((i = this._getOrReturnCtx(e, i)),
          Ye(i, {
            code: Ze.too_small,
            minimum: a.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: a.message,
          }),
          n.dirty());
      else if (a.kind === "max")
        e.data.length > a.value &&
          ((i = this._getOrReturnCtx(e, i)),
          Ye(i, {
            code: Ze.too_big,
            maximum: a.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: a.message,
          }),
          n.dirty());
      else if (a.kind === "length") {
        const s = e.data.length > a.value,
          o = e.data.length < a.value;
        (s || o) &&
          ((i = this._getOrReturnCtx(e, i)),
          s
            ? Ye(i, {
                code: Ze.too_big,
                maximum: a.value,
                type: "string",
                inclusive: !0,
                exact: !0,
                message: a.message,
              })
            : o &&
              Ye(i, {
                code: Ze.too_small,
                minimum: a.value,
                type: "string",
                inclusive: !0,
                exact: !0,
                message: a.message,
              }),
          n.dirty());
      } else if (a.kind === "email")
        ZZ.test(e.data) ||
          ((i = this._getOrReturnCtx(e, i)),
          Ye(i, {
            validation: "email",
            code: Ze.invalid_string,
            message: a.message,
          }),
          n.dirty());
      else if (a.kind === "emoji")
        $w || ($w = new RegExp(JZ, "u")),
          $w.test(e.data) ||
            ((i = this._getOrReturnCtx(e, i)),
            Ye(i, {
              validation: "emoji",
              code: Ze.invalid_string,
              message: a.message,
            }),
            n.dirty());
      else if (a.kind === "uuid")
        VZ.test(e.data) ||
          ((i = this._getOrReturnCtx(e, i)),
          Ye(i, {
            validation: "uuid",
            code: Ze.invalid_string,
            message: a.message,
          }),
          n.dirty());
      else if (a.kind === "nanoid")
        KZ.test(e.data) ||
          ((i = this._getOrReturnCtx(e, i)),
          Ye(i, {
            validation: "nanoid",
            code: Ze.invalid_string,
            message: a.message,
          }),
          n.dirty());
      else if (a.kind === "cuid")
        HZ.test(e.data) ||
          ((i = this._getOrReturnCtx(e, i)),
          Ye(i, {
            validation: "cuid",
            code: Ze.invalid_string,
            message: a.message,
          }),
          n.dirty());
      else if (a.kind === "cuid2")
        zZ.test(e.data) ||
          ((i = this._getOrReturnCtx(e, i)),
          Ye(i, {
            validation: "cuid2",
            code: Ze.invalid_string,
            message: a.message,
          }),
          n.dirty());
      else if (a.kind === "ulid")
        qZ.test(e.data) ||
          ((i = this._getOrReturnCtx(e, i)),
          Ye(i, {
            validation: "ulid",
            code: Ze.invalid_string,
            message: a.message,
          }),
          n.dirty());
      else if (a.kind === "url")
        try {
          new URL(e.data);
        } catch {
          (i = this._getOrReturnCtx(e, i)),
            Ye(i, {
              validation: "url",
              code: Ze.invalid_string,
              message: a.message,
            }),
            n.dirty();
        }
      else
        a.kind === "regex"
          ? ((a.regex.lastIndex = 0),
            a.regex.test(e.data) ||
              ((i = this._getOrReturnCtx(e, i)),
              Ye(i, {
                validation: "regex",
                code: Ze.invalid_string,
                message: a.message,
              }),
              n.dirty()))
          : a.kind === "trim"
          ? (e.data = e.data.trim())
          : a.kind === "includes"
          ? e.data.includes(a.value, a.position) ||
            ((i = this._getOrReturnCtx(e, i)),
            Ye(i, {
              code: Ze.invalid_string,
              validation: {
                includes: a.value,
                position: a.position,
              },
              message: a.message,
            }),
            n.dirty())
          : a.kind === "toLowerCase"
          ? (e.data = e.data.toLowerCase())
          : a.kind === "toUpperCase"
          ? (e.data = e.data.toUpperCase())
          : a.kind === "startsWith"
          ? e.data.startsWith(a.value) ||
            ((i = this._getOrReturnCtx(e, i)),
            Ye(i, {
              code: Ze.invalid_string,
              validation: {
                startsWith: a.value,
              },
              message: a.message,
            }),
            n.dirty())
          : a.kind === "endsWith"
          ? e.data.endsWith(a.value) ||
            ((i = this._getOrReturnCtx(e, i)),
            Ye(i, {
              code: Ze.invalid_string,
              validation: {
                endsWith: a.value,
              },
              message: a.message,
            }),
            n.dirty())
          : a.kind === "datetime"
          ? tB(a).test(e.data) ||
            ((i = this._getOrReturnCtx(e, i)),
            Ye(i, {
              code: Ze.invalid_string,
              validation: "datetime",
              message: a.message,
            }),
            n.dirty())
          : a.kind === "date"
          ? eJ.test(e.data) ||
            ((i = this._getOrReturnCtx(e, i)),
            Ye(i, {
              code: Ze.invalid_string,
              validation: "date",
              message: a.message,
            }),
            n.dirty())
          : a.kind === "time"
          ? tJ(a).test(e.data) ||
            ((i = this._getOrReturnCtx(e, i)),
            Ye(i, {
              code: Ze.invalid_string,
              validation: "time",
              message: a.message,
            }),
            n.dirty())
          : a.kind === "duration"
          ? GZ.test(e.data) ||
            ((i = this._getOrReturnCtx(e, i)),
            Ye(i, {
              validation: "duration",
              code: Ze.invalid_string,
              message: a.message,
            }),
            n.dirty())
          : a.kind === "ip"
          ? rJ(e.data, a.version) ||
            ((i = this._getOrReturnCtx(e, i)),
            Ye(i, {
              validation: "ip",
              code: Ze.invalid_string,
              message: a.message,
            }),
            n.dirty())
          : a.kind === "base64"
          ? XZ.test(e.data) ||
            ((i = this._getOrReturnCtx(e, i)),
            Ye(i, {
              validation: "base64",
              code: Ze.invalid_string,
              message: a.message,
            }),
            n.dirty())
          : $t.assertNever(a);
    return {
      status: n.value,
      value: e.data,
    };
  }
  _regex(e, r, n) {
    return this.refinement((i) => e.test(i), {
      validation: r,
      code: Ze.invalid_string,
      ...lt.errToObj(n),
    });
  }
  _addCheck(e) {
    return new fs({
      ...this._def,
      checks: [...this._def.checks, e],
    });
  }
  email(e) {
    return this._addCheck({
      kind: "email",
      ...lt.errToObj(e),
    });
  }
  url(e) {
    return this._addCheck({
      kind: "url",
      ...lt.errToObj(e),
    });
  }
  emoji(e) {
    return this._addCheck({
      kind: "emoji",
      ...lt.errToObj(e),
    });
  }
  uuid(e) {
    return this._addCheck({
      kind: "uuid",
      ...lt.errToObj(e),
    });
  }
  nanoid(e) {
    return this._addCheck({
      kind: "nanoid",
      ...lt.errToObj(e),
    });
  }
  cuid(e) {
    return this._addCheck({
      kind: "cuid",
      ...lt.errToObj(e),
    });
  }
  cuid2(e) {
    return this._addCheck({
      kind: "cuid2",
      ...lt.errToObj(e),
    });
  }
  ulid(e) {
    return this._addCheck({
      kind: "ulid",
      ...lt.errToObj(e),
    });
  }
  base64(e) {
    return this._addCheck({
      kind: "base64",
      ...lt.errToObj(e),
    });
  }
  ip(e) {
    return this._addCheck({
      kind: "ip",
      ...lt.errToObj(e),
    });
  }
  datetime(e) {
    var r, n;
    return typeof e == "string"
      ? this._addCheck({
          kind: "datetime",
          precision: null,
          offset: !1,
          local: !1,
          message: e,
        })
      : this._addCheck({
          kind: "datetime",
          precision:
            typeof (e == null ? void 0 : e.precision) > "u"
              ? null
              : e == null
              ? void 0
              : e.precision,
          offset:
            (r = e == null ? void 0 : e.offset) !== null && r !== void 0
              ? r
              : !1,
          local:
            (n = e == null ? void 0 : e.local) !== null && n !== void 0
              ? n
              : !1,
          ...lt.errToObj(e == null ? void 0 : e.message),
        });
  }
  date(e) {
    return this._addCheck({
      kind: "date",
      message: e,
    });
  }
  time(e) {
    return typeof e == "string"
      ? this._addCheck({
          kind: "time",
          precision: null,
          message: e,
        })
      : this._addCheck({
          kind: "time",
          precision:
            typeof (e == null ? void 0 : e.precision) > "u"
              ? null
              : e == null
              ? void 0
              : e.precision,
          ...lt.errToObj(e == null ? void 0 : e.message),
        });
  }
  duration(e) {
    return this._addCheck({
      kind: "duration",
      ...lt.errToObj(e),
    });
  }
  regex(e, r) {
    return this._addCheck({
      kind: "regex",
      regex: e,
      ...lt.errToObj(r),
    });
  }
  includes(e, r) {
    return this._addCheck({
      kind: "includes",
      value: e,
      position: r == null ? void 0 : r.position,
      ...lt.errToObj(r == null ? void 0 : r.message),
    });
  }
  startsWith(e, r) {
    return this._addCheck({
      kind: "startsWith",
      value: e,
      ...lt.errToObj(r),
    });
  }
  endsWith(e, r) {
    return this._addCheck({
      kind: "endsWith",
      value: e,
      ...lt.errToObj(r),
    });
  }
  min(e, r) {
    return this._addCheck({
      kind: "min",
      value: e,
      ...lt.errToObj(r),
    });
  }
  max(e, r) {
    return this._addCheck({
      kind: "max",
      value: e,
      ...lt.errToObj(r),
    });
  }
  length(e, r) {
    return this._addCheck({
      kind: "length",
      value: e,
      ...lt.errToObj(r),
    });
  }
  nonempty(e) {
    return this.min(1, lt.errToObj(e));
  }
  trim() {
    return new fs({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: "trim",
        },
      ],
    });
  }
  toLowerCase() {
    return new fs({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: "toLowerCase",
        },
      ],
    });
  }
  toUpperCase() {
    return new fs({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: "toUpperCase",
        },
      ],
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((e) => e.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((e) => e.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((e) => e.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((e) => e.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((e) => e.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e) => e.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((e) => e.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((e) => e.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((e) => e.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((e) => e.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((e) => e.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((e) => e.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((e) => e.kind === "ip");
  }
  get isBase64() {
    return !!this._def.checks.find((e) => e.kind === "base64");
  }
  get minLength() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxLength() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
}
fs.create = (t) => {
  var e;
  return new fs({
    checks: [],
    typeName: ut.ZodString,
    coerce:
      (e = t == null ? void 0 : t.coerce) !== null && e !== void 0 ? e : !1,
    ...xt(t),
  });
};
function nJ(t, e) {
  const r = (t.toString().split(".")[1] || "").length,
    n = (e.toString().split(".")[1] || "").length,
    i = r > n ? r : n,
    a = parseInt(t.toFixed(i).replace(".", "")),
    s = parseInt(e.toFixed(i).replace(".", ""));
  return (a % s) / Math.pow(10, i);
}
class Jc extends _t {
  constructor() {
    super(...arguments),
      (this.min = this.gte),
      (this.max = this.lte),
      (this.step = this.multipleOf);
  }
  _parse(e) {
    if (
      (this._def.coerce && (e.data = Number(e.data)),
      this._getType(e) !== tt.number)
    ) {
      const a = this._getOrReturnCtx(e);
      return (
        Ye(a, {
          code: Ze.invalid_type,
          expected: tt.number,
          received: a.parsedType,
        }),
        dt
      );
    }
    let n;
    const i = new yi();
    for (const a of this._def.checks)
      a.kind === "int"
        ? $t.isInteger(e.data) ||
          ((n = this._getOrReturnCtx(e, n)),
          Ye(n, {
            code: Ze.invalid_type,
            expected: "integer",
            received: "float",
            message: a.message,
          }),
          i.dirty())
        : a.kind === "min"
        ? (a.inclusive ? e.data < a.value : e.data <= a.value) &&
          ((n = this._getOrReturnCtx(e, n)),
          Ye(n, {
            code: Ze.too_small,
            minimum: a.value,
            type: "number",
            inclusive: a.inclusive,
            exact: !1,
            message: a.message,
          }),
          i.dirty())
        : a.kind === "max"
        ? (a.inclusive ? e.data > a.value : e.data >= a.value) &&
          ((n = this._getOrReturnCtx(e, n)),
          Ye(n, {
            code: Ze.too_big,
            maximum: a.value,
            type: "number",
            inclusive: a.inclusive,
            exact: !1,
            message: a.message,
          }),
          i.dirty())
        : a.kind === "multipleOf"
        ? nJ(e.data, a.value) !== 0 &&
          ((n = this._getOrReturnCtx(e, n)),
          Ye(n, {
            code: Ze.not_multiple_of,
            multipleOf: a.value,
            message: a.message,
          }),
          i.dirty())
        : a.kind === "finite"
        ? Number.isFinite(e.data) ||
          ((n = this._getOrReturnCtx(e, n)),
          Ye(n, {
            code: Ze.not_finite,
            message: a.message,
          }),
          i.dirty())
        : $t.assertNever(a);
    return {
      status: i.value,
      value: e.data,
    };
  }
  gte(e, r) {
    return this.setLimit("min", e, !0, lt.toString(r));
  }
  gt(e, r) {
    return this.setLimit("min", e, !1, lt.toString(r));
  }
  lte(e, r) {
    return this.setLimit("max", e, !0, lt.toString(r));
  }
  lt(e, r) {
    return this.setLimit("max", e, !1, lt.toString(r));
  }
  setLimit(e, r, n, i) {
    return new Jc({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: r,
          inclusive: n,
          message: lt.toString(i),
        },
      ],
    });
  }
  _addCheck(e) {
    return new Jc({
      ...this._def,
      checks: [...this._def.checks, e],
    });
  }
  int(e) {
    return this._addCheck({
      kind: "int",
      message: lt.toString(e),
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: lt.toString(e),
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: lt.toString(e),
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: lt.toString(e),
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: lt.toString(e),
    });
  }
  multipleOf(e, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: lt.toString(r),
    });
  }
  finite(e) {
    return this._addCheck({
      kind: "finite",
      message: lt.toString(e),
    });
  }
  safe(e) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: lt.toString(e),
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: lt.toString(e),
    });
  }
  get minValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
  get isInt() {
    return !!this._def.checks.find(
      (e) =>
        e.kind === "int" || (e.kind === "multipleOf" && $t.isInteger(e.value))
    );
  }
  get isFinite() {
    let e = null,
      r = null;
    for (const n of this._def.checks) {
      if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf")
        return !0;
      n.kind === "min"
        ? (r === null || n.value > r) && (r = n.value)
        : n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    }
    return Number.isFinite(r) && Number.isFinite(e);
  }
}
Jc.create = (t) =>
  new Jc({
    checks: [],
    typeName: ut.ZodNumber,
    coerce: (t == null ? void 0 : t.coerce) || !1,
    ...xt(t),
  });
class Qc extends _t {
  constructor() {
    super(...arguments), (this.min = this.gte), (this.max = this.lte);
  }
  _parse(e) {
    if (
      (this._def.coerce && (e.data = BigInt(e.data)),
      this._getType(e) !== tt.bigint)
    ) {
      const a = this._getOrReturnCtx(e);
      return (
        Ye(a, {
          code: Ze.invalid_type,
          expected: tt.bigint,
          received: a.parsedType,
        }),
        dt
      );
    }
    let n;
    const i = new yi();
    for (const a of this._def.checks)
      a.kind === "min"
        ? (a.inclusive ? e.data < a.value : e.data <= a.value) &&
          ((n = this._getOrReturnCtx(e, n)),
          Ye(n, {
            code: Ze.too_small,
            type: "bigint",
            minimum: a.value,
            inclusive: a.inclusive,
            message: a.message,
          }),
          i.dirty())
        : a.kind === "max"
        ? (a.inclusive ? e.data > a.value : e.data >= a.value) &&
          ((n = this._getOrReturnCtx(e, n)),
          Ye(n, {
            code: Ze.too_big,
            type: "bigint",
            maximum: a.value,
            inclusive: a.inclusive,
            message: a.message,
          }),
          i.dirty())
        : a.kind === "multipleOf"
        ? e.data % a.value !== BigInt(0) &&
          ((n = this._getOrReturnCtx(e, n)),
          Ye(n, {
            code: Ze.not_multiple_of,
            multipleOf: a.value,
            message: a.message,
          }),
          i.dirty())
        : $t.assertNever(a);
    return {
      status: i.value,
      value: e.data,
    };
  }
  gte(e, r) {
    return this.setLimit("min", e, !0, lt.toString(r));
  }
  gt(e, r) {
    return this.setLimit("min", e, !1, lt.toString(r));
  }
  lte(e, r) {
    return this.setLimit("max", e, !0, lt.toString(r));
  }
  lt(e, r) {
    return this.setLimit("max", e, !1, lt.toString(r));
  }
  setLimit(e, r, n, i) {
    return new Qc({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: r,
          inclusive: n,
          message: lt.toString(i),
        },
      ],
    });
  }
  _addCheck(e) {
    return new Qc({
      ...this._def,
      checks: [...this._def.checks, e],
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: lt.toString(e),
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: lt.toString(e),
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: lt.toString(e),
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: lt.toString(e),
    });
  }
  multipleOf(e, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: lt.toString(r),
    });
  }
  get minValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
}
Qc.create = (t) => {
  var e;
  return new Qc({
    checks: [],
    typeName: ut.ZodBigInt,
    coerce:
      (e = t == null ? void 0 : t.coerce) !== null && e !== void 0 ? e : !1,
    ...xt(t),
  });
};
class _p extends _t {
  _parse(e) {
    if (
      (this._def.coerce && (e.data = !!e.data), this._getType(e) !== tt.boolean)
    ) {
      const n = this._getOrReturnCtx(e);
      return (
        Ye(n, {
          code: Ze.invalid_type,
          expected: tt.boolean,
          received: n.parsedType,
        }),
        dt
      );
    }
    return Si(e.data);
  }
}
_p.create = (t) =>
  new _p({
    typeName: ut.ZodBoolean,
    coerce: (t == null ? void 0 : t.coerce) || !1,
    ...xt(t),
  });
class du extends _t {
  _parse(e) {
    if (
      (this._def.coerce && (e.data = new Date(e.data)),
      this._getType(e) !== tt.date)
    ) {
      const a = this._getOrReturnCtx(e);
      return (
        Ye(a, {
          code: Ze.invalid_type,
          expected: tt.date,
          received: a.parsedType,
        }),
        dt
      );
    }
    if (isNaN(e.data.getTime())) {
      const a = this._getOrReturnCtx(e);
      return (
        Ye(a, {
          code: Ze.invalid_date,
        }),
        dt
      );
    }
    const n = new yi();
    let i;
    for (const a of this._def.checks)
      a.kind === "min"
        ? e.data.getTime() < a.value &&
          ((i = this._getOrReturnCtx(e, i)),
          Ye(i, {
            code: Ze.too_small,
            message: a.message,
            inclusive: !0,
            exact: !1,
            minimum: a.value,
            type: "date",
          }),
          n.dirty())
        : a.kind === "max"
        ? e.data.getTime() > a.value &&
          ((i = this._getOrReturnCtx(e, i)),
          Ye(i, {
            code: Ze.too_big,
            message: a.message,
            inclusive: !0,
            exact: !1,
            maximum: a.value,
            type: "date",
          }),
          n.dirty())
        : $t.assertNever(a);
    return {
      status: n.value,
      value: new Date(e.data.getTime()),
    };
  }
  _addCheck(e) {
    return new du({
      ...this._def,
      checks: [...this._def.checks, e],
    });
  }
  min(e, r) {
    return this._addCheck({
      kind: "min",
      value: e.getTime(),
      message: lt.toString(r),
    });
  }
  max(e, r) {
    return this._addCheck({
      kind: "max",
      value: e.getTime(),
      message: lt.toString(r),
    });
  }
  get minDate() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e != null ? new Date(e) : null;
  }
  get maxDate() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e != null ? new Date(e) : null;
  }
}
du.create = (t) =>
  new du({
    checks: [],
    coerce: (t == null ? void 0 : t.coerce) || !1,
    typeName: ut.ZodDate,
    ...xt(t),
  });
class Ug extends _t {
  _parse(e) {
    if (this._getType(e) !== tt.symbol) {
      const n = this._getOrReturnCtx(e);
      return (
        Ye(n, {
          code: Ze.invalid_type,
          expected: tt.symbol,
          received: n.parsedType,
        }),
        dt
      );
    }
    return Si(e.data);
  }
}
Ug.create = (t) =>
  new Ug({
    typeName: ut.ZodSymbol,
    ...xt(t),
  });
class Ep extends _t {
  _parse(e) {
    if (this._getType(e) !== tt.undefined) {
      const n = this._getOrReturnCtx(e);
      return (
        Ye(n, {
          code: Ze.invalid_type,
          expected: tt.undefined,
          received: n.parsedType,
        }),
        dt
      );
    }
    return Si(e.data);
  }
}
Ep.create = (t) =>
  new Ep({
    typeName: ut.ZodUndefined,
    ...xt(t),
  });
class Tp extends _t {
  _parse(e) {
    if (this._getType(e) !== tt.null) {
      const n = this._getOrReturnCtx(e);
      return (
        Ye(n, {
          code: Ze.invalid_type,
          expected: tt.null,
          received: n.parsedType,
        }),
        dt
      );
    }
    return Si(e.data);
  }
}
Tp.create = (t) =>
  new Tp({
    typeName: ut.ZodNull,
    ...xt(t),
  });
class bf extends _t {
  constructor() {
    super(...arguments), (this._any = !0);
  }
  _parse(e) {
    return Si(e.data);
  }
}
bf.create = (t) =>
  new bf({
    typeName: ut.ZodAny,
    ...xt(t),
  });
class eu extends _t {
  constructor() {
    super(...arguments), (this._unknown = !0);
  }
  _parse(e) {
    return Si(e.data);
  }
}
eu.create = (t) =>
  new eu({
    typeName: ut.ZodUnknown,
    ...xt(t),
  });
class Vo extends _t {
  _parse(e) {
    const r = this._getOrReturnCtx(e);
    return (
      Ye(r, {
        code: Ze.invalid_type,
        expected: tt.never,
        received: r.parsedType,
      }),
      dt
    );
  }
}
Vo.create = (t) =>
  new Vo({
    typeName: ut.ZodNever,
    ...xt(t),
  });
class Wg extends _t {
  _parse(e) {
    if (this._getType(e) !== tt.undefined) {
      const n = this._getOrReturnCtx(e);
      return (
        Ye(n, {
          code: Ze.invalid_type,
          expected: tt.void,
          received: n.parsedType,
        }),
        dt
      );
    }
    return Si(e.data);
  }
}
Wg.create = (t) =>
  new Wg({
    typeName: ut.ZodVoid,
    ...xt(t),
  });
class ys extends _t {
  _parse(e) {
    const { ctx: r, status: n } = this._processInputParams(e),
      i = this._def;
    if (r.parsedType !== tt.array)
      return (
        Ye(r, {
          code: Ze.invalid_type,
          expected: tt.array,
          received: r.parsedType,
        }),
        dt
      );
    if (i.exactLength !== null) {
      const s = r.data.length > i.exactLength.value,
        o = r.data.length < i.exactLength.value;
      (s || o) &&
        (Ye(r, {
          code: s ? Ze.too_big : Ze.too_small,
          minimum: o ? i.exactLength.value : void 0,
          maximum: s ? i.exactLength.value : void 0,
          type: "array",
          inclusive: !0,
          exact: !0,
          message: i.exactLength.message,
        }),
        n.dirty());
    }
    if (
      (i.minLength !== null &&
        r.data.length < i.minLength.value &&
        (Ye(r, {
          code: Ze.too_small,
          minimum: i.minLength.value,
          type: "array",
          inclusive: !0,
          exact: !1,
          message: i.minLength.message,
        }),
        n.dirty()),
      i.maxLength !== null &&
        r.data.length > i.maxLength.value &&
        (Ye(r, {
          code: Ze.too_big,
          maximum: i.maxLength.value,
          type: "array",
          inclusive: !0,
          exact: !1,
          message: i.maxLength.message,
        }),
        n.dirty()),
      r.common.async)
    )
      return Promise.all(
        [...r.data].map((s, o) => i.type._parseAsync(new so(r, s, r.path, o)))
      ).then((s) => yi.mergeArray(n, s));
    const a = [...r.data].map((s, o) =>
      i.type._parseSync(new so(r, s, r.path, o))
    );
    return yi.mergeArray(n, a);
  }
  get element() {
    return this._def.type;
  }
  min(e, r) {
    return new ys({
      ...this._def,
      minLength: {
        value: e,
        message: lt.toString(r),
      },
    });
  }
  max(e, r) {
    return new ys({
      ...this._def,
      maxLength: {
        value: e,
        message: lt.toString(r),
      },
    });
  }
  length(e, r) {
    return new ys({
      ...this._def,
      exactLength: {
        value: e,
        message: lt.toString(r),
      },
    });
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
ys.create = (t, e) =>
  new ys({
    type: t,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ut.ZodArray,
    ...xt(e),
  });
function l0(t) {
  if (t instanceof zr) {
    const e = {};
    for (const r in t.shape) {
      const n = t.shape[r];
      e[r] = eo.create(l0(n));
    }
    return new zr({
      ...t._def,
      shape: () => e,
    });
  } else
    return t instanceof ys
      ? new ys({
          ...t._def,
          type: l0(t.element),
        })
      : t instanceof eo
      ? eo.create(l0(t.unwrap()))
      : t instanceof Xc
      ? Xc.create(l0(t.unwrap()))
      : t instanceof oo
      ? oo.create(t.items.map((e) => l0(e)))
      : t;
}
class zr extends _t {
  constructor() {
    super(...arguments),
      (this._cached = null),
      (this.nonstrict = this.passthrough),
      (this.augment = this.extend);
  }
  _getCached() {
    if (this._cached !== null) return this._cached;
    const e = this._def.shape(),
      r = $t.objectKeys(e);
    return (this._cached = {
      shape: e,
      keys: r,
    });
  }
  _parse(e) {
    if (this._getType(e) !== tt.object) {
      const u = this._getOrReturnCtx(e);
      return (
        Ye(u, {
          code: Ze.invalid_type,
          expected: tt.object,
          received: u.parsedType,
        }),
        dt
      );
    }
    const { status: n, ctx: i } = this._processInputParams(e),
      { shape: a, keys: s } = this._getCached(),
      o = [];
    if (
      !(this._def.catchall instanceof Vo && this._def.unknownKeys === "strip")
    )
      for (const u in i.data) s.includes(u) || o.push(u);
    const c = [];
    for (const u of s) {
      const d = a[u],
        m = i.data[u];
      c.push({
        key: {
          status: "valid",
          value: u,
        },
        value: d._parse(new so(i, m, i.path, u)),
        alwaysSet: u in i.data,
      });
    }
    if (this._def.catchall instanceof Vo) {
      const u = this._def.unknownKeys;
      if (u === "passthrough")
        for (const d of o)
          c.push({
            key: {
              status: "valid",
              value: d,
            },
            value: {
              status: "valid",
              value: i.data[d],
            },
          });
      else if (u === "strict")
        o.length > 0 &&
          (Ye(i, {
            code: Ze.unrecognized_keys,
            keys: o,
          }),
          n.dirty());
      else if (u !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const u = this._def.catchall;
      for (const d of o) {
        const m = i.data[d];
        c.push({
          key: {
            status: "valid",
            value: d,
          },
          value: u._parse(new so(i, m, i.path, d)),
          alwaysSet: d in i.data,
        });
      }
    }
    return i.common.async
      ? Promise.resolve()
          .then(async () => {
            const u = [];
            for (const d of c) {
              const m = await d.key,
                v = await d.value;
              u.push({
                key: m,
                value: v,
                alwaysSet: d.alwaysSet,
              });
            }
            return u;
          })
          .then((u) => yi.mergeObjectSync(n, u))
      : yi.mergeObjectSync(n, c);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e) {
    return (
      lt.errToObj,
      new zr({
        ...this._def,
        unknownKeys: "strict",
        ...(e !== void 0
          ? {
              errorMap: (r, n) => {
                var i, a, s, o;
                const c =
                  (s =
                    (a = (i = this._def).errorMap) === null || a === void 0
                      ? void 0
                      : a.call(i, r, n).message) !== null && s !== void 0
                    ? s
                    : n.defaultError;
                return r.code === "unrecognized_keys"
                  ? {
                      message:
                        (o = lt.errToObj(e).message) !== null && o !== void 0
                          ? o
                          : c,
                    }
                  : {
                      message: c,
                    };
              },
            }
          : {}),
      })
    );
  }
  strip() {
    return new zr({
      ...this._def,
      unknownKeys: "strip",
    });
  }
  passthrough() {
    return new zr({
      ...this._def,
      unknownKeys: "passthrough",
    });
  }
  extend(e) {
    return new zr({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...e,
      }),
    });
  }
  merge(e) {
    return new zr({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...e._def.shape(),
      }),
      typeName: ut.ZodObject,
    });
  }
  setKey(e, r) {
    return this.augment({
      [e]: r,
    });
  }
  catchall(e) {
    return new zr({
      ...this._def,
      catchall: e,
    });
  }
  pick(e) {
    const r = {};
    return (
      $t.objectKeys(e).forEach((n) => {
        e[n] && this.shape[n] && (r[n] = this.shape[n]);
      }),
      new zr({
        ...this._def,
        shape: () => r,
      })
    );
  }
  omit(e) {
    const r = {};
    return (
      $t.objectKeys(this.shape).forEach((n) => {
        e[n] || (r[n] = this.shape[n]);
      }),
      new zr({
        ...this._def,
        shape: () => r,
      })
    );
  }
  deepPartial() {
    return l0(this);
  }
  partial(e) {
    const r = {};
    return (
      $t.objectKeys(this.shape).forEach((n) => {
        const i = this.shape[n];
        e && !e[n] ? (r[n] = i) : (r[n] = i.optional());
      }),
      new zr({
        ...this._def,
        shape: () => r,
      })
    );
  }
  required(e) {
    const r = {};
    return (
      $t.objectKeys(this.shape).forEach((n) => {
        if (e && !e[n]) r[n] = this.shape[n];
        else {
          let a = this.shape[n];
          for (; a instanceof eo; ) a = a._def.innerType;
          r[n] = a;
        }
      }),
      new zr({
        ...this._def,
        shape: () => r,
      })
    );
  }
  keyof() {
    return rB($t.objectKeys(this.shape));
  }
}
zr.create = (t, e) =>
  new zr({
    shape: () => t,
    unknownKeys: "strip",
    catchall: Vo.create(),
    typeName: ut.ZodObject,
    ...xt(e),
  });
zr.strictCreate = (t, e) =>
  new zr({
    shape: () => t,
    unknownKeys: "strict",
    catchall: Vo.create(),
    typeName: ut.ZodObject,
    ...xt(e),
  });
zr.lazycreate = (t, e) =>
  new zr({
    shape: t,
    unknownKeys: "strip",
    catchall: Vo.create(),
    typeName: ut.ZodObject,
    ...xt(e),
  });
class Cp extends _t {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e),
      n = this._def.options;
    function i(a) {
      for (const o of a) if (o.result.status === "valid") return o.result;
      for (const o of a)
        if (o.result.status === "dirty")
          return r.common.issues.push(...o.ctx.common.issues), o.result;
      const s = a.map((o) => new fa(o.ctx.common.issues));
      return (
        Ye(r, {
          code: Ze.invalid_union,
          unionErrors: s,
        }),
        dt
      );
    }
    if (r.common.async)
      return Promise.all(
        n.map(async (a) => {
          const s = {
            ...r,
            common: {
              ...r.common,
              issues: [],
            },
            parent: null,
          };
          return {
            result: await a._parseAsync({
              data: r.data,
              path: r.path,
              parent: s,
            }),
            ctx: s,
          };
        })
      ).then(i);
    {
      let a;
      const s = [];
      for (const c of n) {
        const u = {
            ...r,
            common: {
              ...r.common,
              issues: [],
            },
            parent: null,
          },
          d = c._parseSync({
            data: r.data,
            path: r.path,
            parent: u,
          });
        if (d.status === "valid") return d;
        d.status === "dirty" &&
          !a &&
          (a = {
            result: d,
            ctx: u,
          }),
          u.common.issues.length && s.push(u.common.issues);
      }
      if (a) return r.common.issues.push(...a.ctx.common.issues), a.result;
      const o = s.map((c) => new fa(c));
      return (
        Ye(r, {
          code: Ze.invalid_union,
          unionErrors: o,
        }),
        dt
      );
    }
  }
  get options() {
    return this._def.options;
  }
}
Cp.create = (t, e) =>
  new Cp({
    options: t,
    typeName: ut.ZodUnion,
    ...xt(e),
  });
const Co = (t) =>
  t instanceof Sp
    ? Co(t.schema)
    : t instanceof vs
    ? Co(t.innerType())
    : t instanceof Mp
    ? [t.value]
    : t instanceof Yc
    ? t.options
    : t instanceof Ip
    ? $t.objectValues(t.enum)
    : t instanceof Rp
    ? Co(t._def.innerType)
    : t instanceof Ep
    ? [void 0]
    : t instanceof Tp
    ? [null]
    : t instanceof eo
    ? [void 0, ...Co(t.unwrap())]
    : t instanceof Xc
    ? [null, ...Co(t.unwrap())]
    : t instanceof U8 || t instanceof Np
    ? Co(t.unwrap())
    : t instanceof Pp
    ? Co(t._def.innerType)
    : [];
class Vb extends _t {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    if (r.parsedType !== tt.object)
      return (
        Ye(r, {
          code: Ze.invalid_type,
          expected: tt.object,
          received: r.parsedType,
        }),
        dt
      );
    const n = this.discriminator,
      i = r.data[n],
      a = this.optionsMap.get(i);
    return a
      ? r.common.async
        ? a._parseAsync({
            data: r.data,
            path: r.path,
            parent: r,
          })
        : a._parseSync({
            data: r.data,
            path: r.path,
            parent: r,
          })
      : (Ye(r, {
          code: Ze.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [n],
        }),
        dt);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(e, r, n) {
    const i = new Map();
    for (const a of r) {
      const s = Co(a.shape[e]);
      if (!s.length)
        throw new Error(
          `A discriminator value for key \`${e}\` could not be extracted from all schema options`
        );
      for (const o of s) {
        if (i.has(o))
          throw new Error(
            `Discriminator property ${String(e)} has duplicate value ${String(
              o
            )}`
          );
        i.set(o, a);
      }
    }
    return new Vb({
      typeName: ut.ZodDiscriminatedUnion,
      discriminator: e,
      options: r,
      optionsMap: i,
      ...xt(n),
    });
  }
}
function e_(t, e) {
  const r = gc(t),
    n = gc(e);
  if (t === e)
    return {
      valid: !0,
      data: t,
    };
  if (r === tt.object && n === tt.object) {
    const i = $t.objectKeys(e),
      a = $t.objectKeys(t).filter((o) => i.indexOf(o) !== -1),
      s = {
        ...t,
        ...e,
      };
    for (const o of a) {
      const c = e_(t[o], e[o]);
      if (!c.valid)
        return {
          valid: !1,
        };
      s[o] = c.data;
    }
    return {
      valid: !0,
      data: s,
    };
  } else if (r === tt.array && n === tt.array) {
    if (t.length !== e.length)
      return {
        valid: !1,
      };
    const i = [];
    for (let a = 0; a < t.length; a++) {
      const s = t[a],
        o = e[a],
        c = e_(s, o);
      if (!c.valid)
        return {
          valid: !1,
        };
      i.push(c.data);
    }
    return {
      valid: !0,
      data: i,
    };
  } else
    return r === tt.date && n === tt.date && +t == +e
      ? {
          valid: !0,
          data: t,
        }
      : {
          valid: !1,
        };
}
class Ap extends _t {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e),
      i = (a, s) => {
        if (Y6(a) || Y6(s)) return dt;
        const o = e_(a.value, s.value);
        return o.valid
          ? ((X6(a) || X6(s)) && r.dirty(),
            {
              status: r.value,
              value: o.data,
            })
          : (Ye(n, {
              code: Ze.invalid_intersection_types,
            }),
            dt);
      };
    return n.common.async
      ? Promise.all([
          this._def.left._parseAsync({
            data: n.data,
            path: n.path,
            parent: n,
          }),
          this._def.right._parseAsync({
            data: n.data,
            path: n.path,
            parent: n,
          }),
        ]).then(([a, s]) => i(a, s))
      : i(
          this._def.left._parseSync({
            data: n.data,
            path: n.path,
            parent: n,
          }),
          this._def.right._parseSync({
            data: n.data,
            path: n.path,
            parent: n,
          })
        );
  }
}
Ap.create = (t, e, r) =>
  new Ap({
    left: t,
    right: e,
    typeName: ut.ZodIntersection,
    ...xt(r),
  });
class oo extends _t {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== tt.array)
      return (
        Ye(n, {
          code: Ze.invalid_type,
          expected: tt.array,
          received: n.parsedType,
        }),
        dt
      );
    if (n.data.length < this._def.items.length)
      return (
        Ye(n, {
          code: Ze.too_small,
          minimum: this._def.items.length,
          inclusive: !0,
          exact: !1,
          type: "array",
        }),
        dt
      );
    !this._def.rest &&
      n.data.length > this._def.items.length &&
      (Ye(n, {
        code: Ze.too_big,
        maximum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array",
      }),
      r.dirty());
    const a = [...n.data]
      .map((s, o) => {
        const c = this._def.items[o] || this._def.rest;
        return c ? c._parse(new so(n, s, n.path, o)) : null;
      })
      .filter((s) => !!s);
    return n.common.async
      ? Promise.all(a).then((s) => yi.mergeArray(r, s))
      : yi.mergeArray(r, a);
  }
  get items() {
    return this._def.items;
  }
  rest(e) {
    return new oo({
      ...this._def,
      rest: e,
    });
  }
}
oo.create = (t, e) => {
  if (!Array.isArray(t))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new oo({
    items: t,
    typeName: ut.ZodTuple,
    rest: null,
    ...xt(e),
  });
};
class kp extends _t {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== tt.object)
      return (
        Ye(n, {
          code: Ze.invalid_type,
          expected: tt.object,
          received: n.parsedType,
        }),
        dt
      );
    const i = [],
      a = this._def.keyType,
      s = this._def.valueType;
    for (const o in n.data)
      i.push({
        key: a._parse(new so(n, o, n.path, o)),
        value: s._parse(new so(n, n.data[o], n.path, o)),
        alwaysSet: o in n.data,
      });
    return n.common.async
      ? yi.mergeObjectAsync(r, i)
      : yi.mergeObjectSync(r, i);
  }
  get element() {
    return this._def.valueType;
  }
  static create(e, r, n) {
    return r instanceof _t
      ? new kp({
          keyType: e,
          valueType: r,
          typeName: ut.ZodRecord,
          ...xt(n),
        })
      : new kp({
          keyType: fs.create(),
          valueType: e,
          typeName: ut.ZodRecord,
          ...xt(r),
        });
  }
}
class jg extends _t {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== tt.map)
      return (
        Ye(n, {
          code: Ze.invalid_type,
          expected: tt.map,
          received: n.parsedType,
        }),
        dt
      );
    const i = this._def.keyType,
      a = this._def.valueType,
      s = [...n.data.entries()].map(([o, c], u) => ({
        key: i._parse(new so(n, o, n.path, [u, "key"])),
        value: a._parse(new so(n, c, n.path, [u, "value"])),
      }));
    if (n.common.async) {
      const o = new Map();
      return Promise.resolve().then(async () => {
        for (const c of s) {
          const u = await c.key,
            d = await c.value;
          if (u.status === "aborted" || d.status === "aborted") return dt;
          (u.status === "dirty" || d.status === "dirty") && r.dirty(),
            o.set(u.value, d.value);
        }
        return {
          status: r.value,
          value: o,
        };
      });
    } else {
      const o = new Map();
      for (const c of s) {
        const u = c.key,
          d = c.value;
        if (u.status === "aborted" || d.status === "aborted") return dt;
        (u.status === "dirty" || d.status === "dirty") && r.dirty(),
          o.set(u.value, d.value);
      }
      return {
        status: r.value,
        value: o,
      };
    }
  }
}
jg.create = (t, e, r) =>
  new jg({
    valueType: e,
    keyType: t,
    typeName: ut.ZodMap,
    ...xt(r),
  });
class hu extends _t {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== tt.set)
      return (
        Ye(n, {
          code: Ze.invalid_type,
          expected: tt.set,
          received: n.parsedType,
        }),
        dt
      );
    const i = this._def;
    i.minSize !== null &&
      n.data.size < i.minSize.value &&
      (Ye(n, {
        code: Ze.too_small,
        minimum: i.minSize.value,
        type: "set",
        inclusive: !0,
        exact: !1,
        message: i.minSize.message,
      }),
      r.dirty()),
      i.maxSize !== null &&
        n.data.size > i.maxSize.value &&
        (Ye(n, {
          code: Ze.too_big,
          maximum: i.maxSize.value,
          type: "set",
          inclusive: !0,
          exact: !1,
          message: i.maxSize.message,
        }),
        r.dirty());
    const a = this._def.valueType;
    function s(c) {
      const u = new Set();
      for (const d of c) {
        if (d.status === "aborted") return dt;
        d.status === "dirty" && r.dirty(), u.add(d.value);
      }
      return {
        status: r.value,
        value: u,
      };
    }
    const o = [...n.data.values()].map((c, u) =>
      a._parse(new so(n, c, n.path, u))
    );
    return n.common.async ? Promise.all(o).then((c) => s(c)) : s(o);
  }
  min(e, r) {
    return new hu({
      ...this._def,
      minSize: {
        value: e,
        message: lt.toString(r),
      },
    });
  }
  max(e, r) {
    return new hu({
      ...this._def,
      maxSize: {
        value: e,
        message: lt.toString(r),
      },
    });
  }
  size(e, r) {
    return this.min(e, r).max(e, r);
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
hu.create = (t, e) =>
  new hu({
    valueType: t,
    minSize: null,
    maxSize: null,
    typeName: ut.ZodSet,
    ...xt(e),
  });
class q0 extends _t {
  constructor() {
    super(...arguments), (this.validate = this.implement);
  }
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    if (r.parsedType !== tt.function)
      return (
        Ye(r, {
          code: Ze.invalid_type,
          expected: tt.function,
          received: r.parsedType,
        }),
        dt
      );
    function n(o, c) {
      return Lg({
        data: o,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          Fg(),
          gf,
        ].filter((u) => !!u),
        issueData: {
          code: Ze.invalid_arguments,
          argumentsError: c,
        },
      });
    }
    function i(o, c) {
      return Lg({
        data: o,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          Fg(),
          gf,
        ].filter((u) => !!u),
        issueData: {
          code: Ze.invalid_return_type,
          returnTypeError: c,
        },
      });
    }
    const a = {
        errorMap: r.common.contextualErrorMap,
      },
      s = r.data;
    if (this._def.returns instanceof vf) {
      const o = this;
      return Si(async function (...c) {
        const u = new fa([]),
          d = await o._def.args.parseAsync(c, a).catch((E) => {
            throw (u.addIssue(n(c, E)), u);
          }),
          m = await Reflect.apply(s, this, d);
        return await o._def.returns._def.type.parseAsync(m, a).catch((E) => {
          throw (u.addIssue(i(m, E)), u);
        });
      });
    } else {
      const o = this;
      return Si(function (...c) {
        const u = o._def.args.safeParse(c, a);
        if (!u.success) throw new fa([n(c, u.error)]);
        const d = Reflect.apply(s, this, u.data),
          m = o._def.returns.safeParse(d, a);
        if (!m.success) throw new fa([i(d, m.error)]);
        return m.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...e) {
    return new q0({
      ...this._def,
      args: oo.create(e).rest(eu.create()),
    });
  }
  returns(e) {
    return new q0({
      ...this._def,
      returns: e,
    });
  }
  implement(e) {
    return this.parse(e);
  }
  strictImplement(e) {
    return this.parse(e);
  }
  static create(e, r, n) {
    return new q0({
      args: e || oo.create([]).rest(eu.create()),
      returns: r || eu.create(),
      typeName: ut.ZodFunction,
      ...xt(n),
    });
  }
}
class Sp extends _t {
  get schema() {
    return this._def.getter();
  }
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    return this._def.getter()._parse({
      data: r.data,
      path: r.path,
      parent: r,
    });
  }
}
Sp.create = (t, e) =>
  new Sp({
    getter: t,
    typeName: ut.ZodLazy,
    ...xt(e),
  });
class Mp extends _t {
  _parse(e) {
    if (e.data !== this._def.value) {
      const r = this._getOrReturnCtx(e);
      return (
        Ye(r, {
          received: r.data,
          code: Ze.invalid_literal,
          expected: this._def.value,
        }),
        dt
      );
    }
    return {
      status: "valid",
      value: e.data,
    };
  }
  get value() {
    return this._def.value;
  }
}
Mp.create = (t, e) =>
  new Mp({
    value: t,
    typeName: ut.ZodLiteral,
    ...xt(e),
  });
function rB(t, e) {
  return new Yc({
    values: t,
    typeName: ut.ZodEnum,
    ...xt(e),
  });
}
class Yc extends _t {
  constructor() {
    super(...arguments), bh.set(this, void 0);
  }
  _parse(e) {
    if (typeof e.data != "string") {
      const r = this._getOrReturnCtx(e),
        n = this._def.values;
      return (
        Ye(r, {
          expected: $t.joinValues(n),
          received: r.parsedType,
          code: Ze.invalid_type,
        }),
        dt
      );
    }
    if (
      ($g(this, bh) || YN(this, bh, new Set(this._def.values)),
      !$g(this, bh).has(e.data))
    ) {
      const r = this._getOrReturnCtx(e),
        n = this._def.values;
      return (
        Ye(r, {
          received: r.data,
          code: Ze.invalid_enum_value,
          options: n,
        }),
        dt
      );
    }
    return Si(e.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e = {};
    for (const r of this._def.values) e[r] = r;
    return e;
  }
  get Values() {
    const e = {};
    for (const r of this._def.values) e[r] = r;
    return e;
  }
  get Enum() {
    const e = {};
    for (const r of this._def.values) e[r] = r;
    return e;
  }
  extract(e, r = this._def) {
    return Yc.create(e, {
      ...this._def,
      ...r,
    });
  }
  exclude(e, r = this._def) {
    return Yc.create(
      this.options.filter((n) => !e.includes(n)),
      {
        ...this._def,
        ...r,
      }
    );
  }
}
bh = new WeakMap();
Yc.create = rB;
class Ip extends _t {
  constructor() {
    super(...arguments), vh.set(this, void 0);
  }
  _parse(e) {
    const r = $t.getValidEnumValues(this._def.values),
      n = this._getOrReturnCtx(e);
    if (n.parsedType !== tt.string && n.parsedType !== tt.number) {
      const i = $t.objectValues(r);
      return (
        Ye(n, {
          expected: $t.joinValues(i),
          received: n.parsedType,
          code: Ze.invalid_type,
        }),
        dt
      );
    }
    if (
      ($g(this, vh) ||
        YN(this, vh, new Set($t.getValidEnumValues(this._def.values))),
      !$g(this, vh).has(e.data))
    ) {
      const i = $t.objectValues(r);
      return (
        Ye(n, {
          received: n.data,
          code: Ze.invalid_enum_value,
          options: i,
        }),
        dt
      );
    }
    return Si(e.data);
  }
  get enum() {
    return this._def.values;
  }
}
vh = new WeakMap();
Ip.create = (t, e) =>
  new Ip({
    values: t,
    typeName: ut.ZodNativeEnum,
    ...xt(e),
  });
class vf extends _t {
  unwrap() {
    return this._def.type;
  }
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    if (r.parsedType !== tt.promise && r.common.async === !1)
      return (
        Ye(r, {
          code: Ze.invalid_type,
          expected: tt.promise,
          received: r.parsedType,
        }),
        dt
      );
    const n = r.parsedType === tt.promise ? r.data : Promise.resolve(r.data);
    return Si(
      n.then((i) =>
        this._def.type.parseAsync(i, {
          path: r.path,
          errorMap: r.common.contextualErrorMap,
        })
      )
    );
  }
}
vf.create = (t, e) =>
  new vf({
    type: t,
    typeName: ut.ZodPromise,
    ...xt(e),
  });
class vs extends _t {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ut.ZodEffects
      ? this._def.schema.sourceType()
      : this._def.schema;
  }
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e),
      i = this._def.effect || null,
      a = {
        addIssue: (s) => {
          Ye(n, s), s.fatal ? r.abort() : r.dirty();
        },
        get path() {
          return n.path;
        },
      };
    if (((a.addIssue = a.addIssue.bind(a)), i.type === "preprocess")) {
      const s = i.transform(n.data, a);
      if (n.common.async)
        return Promise.resolve(s).then(async (o) => {
          if (r.value === "aborted") return dt;
          const c = await this._def.schema._parseAsync({
            data: o,
            path: n.path,
            parent: n,
          });
          return c.status === "aborted"
            ? dt
            : c.status === "dirty" || r.value === "dirty"
            ? I0(c.value)
            : c;
        });
      {
        if (r.value === "aborted") return dt;
        const o = this._def.schema._parseSync({
          data: s,
          path: n.path,
          parent: n,
        });
        return o.status === "aborted"
          ? dt
          : o.status === "dirty" || r.value === "dirty"
          ? I0(o.value)
          : o;
      }
    }
    if (i.type === "refinement") {
      const s = (o) => {
        const c = i.refinement(o, a);
        if (n.common.async) return Promise.resolve(c);
        if (c instanceof Promise)
          throw new Error(
            "Async refinement encountered during synchronous parse operation. Use .parseAsync instead."
          );
        return o;
      };
      if (n.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n,
        });
        return o.status === "aborted"
          ? dt
          : (o.status === "dirty" && r.dirty(),
            s(o.value),
            {
              status: r.value,
              value: o.value,
            });
      } else
        return this._def.schema
          ._parseAsync({
            data: n.data,
            path: n.path,
            parent: n,
          })
          .then((o) =>
            o.status === "aborted"
              ? dt
              : (o.status === "dirty" && r.dirty(),
                s(o.value).then(() => ({
                  status: r.value,
                  value: o.value,
                })))
          );
    }
    if (i.type === "transform")
      if (n.common.async === !1) {
        const s = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n,
        });
        if (!xp(s)) return s;
        const o = i.transform(s.value, a);
        if (o instanceof Promise)
          throw new Error(
            "Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead."
          );
        return {
          status: r.value,
          value: o,
        };
      } else
        return this._def.schema
          ._parseAsync({
            data: n.data,
            path: n.path,
            parent: n,
          })
          .then((s) =>
            xp(s)
              ? Promise.resolve(i.transform(s.value, a)).then((o) => ({
                  status: r.value,
                  value: o,
                }))
              : s
          );
    $t.assertNever(i);
  }
}
vs.create = (t, e, r) =>
  new vs({
    schema: t,
    typeName: ut.ZodEffects,
    effect: e,
    ...xt(r),
  });
vs.createWithPreprocess = (t, e, r) =>
  new vs({
    schema: e,
    effect: {
      type: "preprocess",
      transform: t,
    },
    typeName: ut.ZodEffects,
    ...xt(r),
  });
class eo extends _t {
  _parse(e) {
    return this._getType(e) === tt.undefined
      ? Si(void 0)
      : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
eo.create = (t, e) =>
  new eo({
    innerType: t,
    typeName: ut.ZodOptional,
    ...xt(e),
  });
class Xc extends _t {
  _parse(e) {
    return this._getType(e) === tt.null
      ? Si(null)
      : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Xc.create = (t, e) =>
  new Xc({
    innerType: t,
    typeName: ut.ZodNullable,
    ...xt(e),
  });
class Rp extends _t {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    let n = r.data;
    return (
      r.parsedType === tt.undefined && (n = this._def.defaultValue()),
      this._def.innerType._parse({
        data: n,
        path: r.path,
        parent: r,
      })
    );
  }
  removeDefault() {
    return this._def.innerType;
  }
}
Rp.create = (t, e) =>
  new Rp({
    innerType: t,
    typeName: ut.ZodDefault,
    defaultValue: typeof e.default == "function" ? e.default : () => e.default,
    ...xt(e),
  });
class Pp extends _t {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e),
      n = {
        ...r,
        common: {
          ...r.common,
          issues: [],
        },
      },
      i = this._def.innerType._parse({
        data: n.data,
        path: n.path,
        parent: {
          ...n,
        },
      });
    return wp(i)
      ? i.then((a) => ({
          status: "valid",
          value:
            a.status === "valid"
              ? a.value
              : this._def.catchValue({
                  get error() {
                    return new fa(n.common.issues);
                  },
                  input: n.data,
                }),
        }))
      : {
          status: "valid",
          value:
            i.status === "valid"
              ? i.value
              : this._def.catchValue({
                  get error() {
                    return new fa(n.common.issues);
                  },
                  input: n.data,
                }),
        };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
Pp.create = (t, e) =>
  new Pp({
    innerType: t,
    typeName: ut.ZodCatch,
    catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
    ...xt(e),
  });
class Hg extends _t {
  _parse(e) {
    if (this._getType(e) !== tt.nan) {
      const n = this._getOrReturnCtx(e);
      return (
        Ye(n, {
          code: Ze.invalid_type,
          expected: tt.nan,
          received: n.parsedType,
        }),
        dt
      );
    }
    return {
      status: "valid",
      value: e.data,
    };
  }
}
Hg.create = (t) =>
  new Hg({
    typeName: ut.ZodNaN,
    ...xt(t),
  });
const iJ = Symbol("zod_brand");
class U8 extends _t {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e),
      n = r.data;
    return this._def.type._parse({
      data: n,
      path: r.path,
      parent: r,
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class Pm extends _t {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.common.async)
      return (async () => {
        const a = await this._def.in._parseAsync({
          data: n.data,
          path: n.path,
          parent: n,
        });
        return a.status === "aborted"
          ? dt
          : a.status === "dirty"
          ? (r.dirty(), I0(a.value))
          : this._def.out._parseAsync({
              data: a.value,
              path: n.path,
              parent: n,
            });
      })();
    {
      const i = this._def.in._parseSync({
        data: n.data,
        path: n.path,
        parent: n,
      });
      return i.status === "aborted"
        ? dt
        : i.status === "dirty"
        ? (r.dirty(),
          {
            status: "dirty",
            value: i.value,
          })
        : this._def.out._parseSync({
            data: i.value,
            path: n.path,
            parent: n,
          });
    }
  }
  static create(e, r) {
    return new Pm({
      in: e,
      out: r,
      typeName: ut.ZodPipeline,
    });
  }
}
class Np extends _t {
  _parse(e) {
    const r = this._def.innerType._parse(e),
      n = (i) => (xp(i) && (i.value = Object.freeze(i.value)), i);
    return wp(r) ? r.then((i) => n(i)) : n(r);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Np.create = (t, e) =>
  new Np({
    innerType: t,
    typeName: ut.ZodReadonly,
    ...xt(e),
  });
function nB(t, e = {}, r) {
  return t
    ? bf.create().superRefine((n, i) => {
        var a, s;
        if (!t(n)) {
          const o =
              typeof e == "function"
                ? e(n)
                : typeof e == "string"
                ? {
                    message: e,
                  }
                : e,
            c =
              (s = (a = o.fatal) !== null && a !== void 0 ? a : r) !== null &&
              s !== void 0
                ? s
                : !0,
            u =
              typeof o == "string"
                ? {
                    message: o,
                  }
                : o;
          i.addIssue({
            code: "custom",
            ...u,
            fatal: c,
          });
        }
      })
    : bf.create();
}
const aJ = {
  object: zr.lazycreate,
};
var ut;
(function (t) {
  (t.ZodString = "ZodString"),
    (t.ZodNumber = "ZodNumber"),
    (t.ZodNaN = "ZodNaN"),
    (t.ZodBigInt = "ZodBigInt"),
    (t.ZodBoolean = "ZodBoolean"),
    (t.ZodDate = "ZodDate"),
    (t.ZodSymbol = "ZodSymbol"),
    (t.ZodUndefined = "ZodUndefined"),
    (t.ZodNull = "ZodNull"),
    (t.ZodAny = "ZodAny"),
    (t.ZodUnknown = "ZodUnknown"),
    (t.ZodNever = "ZodNever"),
    (t.ZodVoid = "ZodVoid"),
    (t.ZodArray = "ZodArray"),
    (t.ZodObject = "ZodObject"),
    (t.ZodUnion = "ZodUnion"),
    (t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion"),
    (t.ZodIntersection = "ZodIntersection"),
    (t.ZodTuple = "ZodTuple"),
    (t.ZodRecord = "ZodRecord"),
    (t.ZodMap = "ZodMap"),
    (t.ZodSet = "ZodSet"),
    (t.ZodFunction = "ZodFunction"),
    (t.ZodLazy = "ZodLazy"),
    (t.ZodLiteral = "ZodLiteral"),
    (t.ZodEnum = "ZodEnum"),
    (t.ZodEffects = "ZodEffects"),
    (t.ZodNativeEnum = "ZodNativeEnum"),
    (t.ZodOptional = "ZodOptional"),
    (t.ZodNullable = "ZodNullable"),
    (t.ZodDefault = "ZodDefault"),
    (t.ZodCatch = "ZodCatch"),
    (t.ZodPromise = "ZodPromise"),
    (t.ZodBranded = "ZodBranded"),
    (t.ZodPipeline = "ZodPipeline"),
    (t.ZodReadonly = "ZodReadonly");
})(ut || (ut = {}));
const sJ = (
    t,
    e = {
      message: `Input not instance of ${t.name}`,
    }
  ) => nB((r) => r instanceof t, e),
  iB = fs.create,
  aB = Jc.create,
  oJ = Hg.create,
  cJ = Qc.create,
  sB = _p.create,
  lJ = du.create,
  uJ = Ug.create,
  fJ = Ep.create,
  dJ = Tp.create,
  hJ = bf.create,
  pJ = eu.create,
  mJ = Vo.create,
  yJ = Wg.create,
  gJ = ys.create,
  bJ = zr.create,
  vJ = zr.strictCreate,
  xJ = Cp.create,
  wJ = Vb.create,
  _J = Ap.create,
  EJ = oo.create,
  TJ = kp.create,
  CJ = jg.create,
  AJ = hu.create,
  kJ = q0.create,
  SJ = Sp.create,
  MJ = Mp.create,
  IJ = Yc.create,
  RJ = Ip.create,
  PJ = vf.create,
  nk = vs.create,
  NJ = eo.create,
  BJ = Xc.create,
  DJ = vs.createWithPreprocess,
  OJ = Pm.create,
  FJ = () => iB().optional(),
  LJ = () => aB().optional(),
  $J = () => sB().optional(),
  UJ = {
    string: (t) =>
      fs.create({
        ...t,
        coerce: !0,
      }),
    number: (t) =>
      Jc.create({
        ...t,
        coerce: !0,
      }),
    boolean: (t) =>
      _p.create({
        ...t,
        coerce: !0,
      }),
    bigint: (t) =>
      Qc.create({
        ...t,
        coerce: !0,
      }),
    date: (t) =>
      du.create({
        ...t,
        coerce: !0,
      }),
  },
  WJ = dt;
var ne = Object.freeze({
  __proto__: null,
  defaultErrorMap: gf,
  setErrorMap: WZ,
  getErrorMap: Fg,
  makeIssue: Lg,
  EMPTY_PATH: jZ,
  addIssueToContext: Ye,
  ParseStatus: yi,
  INVALID: dt,
  DIRTY: I0,
  OK: Si,
  isAborted: Y6,
  isDirty: X6,
  isValid: xp,
  isAsync: wp,
  get util() {
    return $t;
  },
  get objectUtil() {
    return Q6;
  },
  ZodParsedType: tt,
  getParsedType: gc,
  ZodType: _t,
  datetimeRegex: tB,
  ZodString: fs,
  ZodNumber: Jc,
  ZodBigInt: Qc,
  ZodBoolean: _p,
  ZodDate: du,
  ZodSymbol: Ug,
  ZodUndefined: Ep,
  ZodNull: Tp,
  ZodAny: bf,
  ZodUnknown: eu,
  ZodNever: Vo,
  ZodVoid: Wg,
  ZodArray: ys,
  ZodObject: zr,
  ZodUnion: Cp,
  ZodDiscriminatedUnion: Vb,
  ZodIntersection: Ap,
  ZodTuple: oo,
  ZodRecord: kp,
  ZodMap: jg,
  ZodSet: hu,
  ZodFunction: q0,
  ZodLazy: Sp,
  ZodLiteral: Mp,
  ZodEnum: Yc,
  ZodNativeEnum: Ip,
  ZodPromise: vf,
  ZodEffects: vs,
  ZodTransformer: vs,
  ZodOptional: eo,
  ZodNullable: Xc,
  ZodDefault: Rp,
  ZodCatch: Pp,
  ZodNaN: Hg,
  BRAND: iJ,
  ZodBranded: U8,
  ZodPipeline: Pm,
  ZodReadonly: Np,
  custom: nB,
  Schema: _t,
  ZodSchema: _t,
  late: aJ,
  get ZodFirstPartyTypeKind() {
    return ut;
  },
  coerce: UJ,
  any: hJ,
  array: gJ,
  bigint: cJ,
  boolean: sB,
  date: lJ,
  discriminatedUnion: wJ,
  effect: nk,
  enum: IJ,
  function: kJ,
  instanceof: sJ,
  intersection: _J,
  lazy: SJ,
  literal: MJ,
  map: CJ,
  nan: oJ,
  nativeEnum: RJ,
  never: mJ,
  null: dJ,
  nullable: BJ,
  number: aB,
  object: bJ,
  oboolean: $J,
  onumber: LJ,
  optional: NJ,
  ostring: FJ,
  pipeline: OJ,
  preprocess: DJ,
  promise: PJ,
  record: TJ,
  set: AJ,
  strictObject: vJ,
  string: iB,
  symbol: uJ,
  transformer: nk,
  tuple: EJ,
  undefined: fJ,
  union: xJ,
  unknown: pJ,
  void: yJ,
  NEVER: WJ,
  ZodIssueCode: Ze,
  quotelessJson: UZ,
  ZodError: fa,
});
let V1;
const jJ = new Uint8Array(16);
function HJ() {
  if (
    !V1 &&
    ((V1 =
      typeof crypto < "u" &&
      crypto.getRandomValues &&
      crypto.getRandomValues.bind(crypto)),
    !V1)
  )
    throw new Error(
      "crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported"
    );
  return V1(jJ);
}
const $n = [];
for (let t = 0; t < 256; ++t) $n.push((t + 256).toString(16).slice(1));
function zJ(t, e = 0) {
  return (
    $n[t[e + 0]] +
    $n[t[e + 1]] +
    $n[t[e + 2]] +
    $n[t[e + 3]] +
    "-" +
    $n[t[e + 4]] +
    $n[t[e + 5]] +
    "-" +
    $n[t[e + 6]] +
    $n[t[e + 7]] +
    "-" +
    $n[t[e + 8]] +
    $n[t[e + 9]] +
    "-" +
    $n[t[e + 10]] +
    $n[t[e + 11]] +
    $n[t[e + 12]] +
    $n[t[e + 13]] +
    $n[t[e + 14]] +
    $n[t[e + 15]]
  );
}
const qJ =
    typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto),
  ik = {
    randomUUID: qJ,
  };
function oB(t, e, r) {
  if (ik.randomUUID && !e && !t) return ik.randomUUID();
  t = t || {};
  const n = t.random || (t.rng || HJ)();
  if (((n[6] = (n[6] & 15) | 64), (n[8] = (n[8] & 63) | 128), e)) {
    r = r || 0;
    for (let i = 0; i < 16; ++i) e[r + i] = n[i];
    return e;
  }
  return zJ(n);
}
var W8 = {
  exports: {},
};
const VJ = {},
  KJ = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        default: VJ,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  Pu = Pt(KJ);
W8.exports;
(function (t) {
  (function (e, r) {
    function n(y, h) {
      if (!y) throw new Error(h || "Assertion failed");
    }
    function i(y, h) {
      y.super_ = h;
      var g = function () {};
      (g.prototype = h.prototype),
        (y.prototype = new g()),
        (y.prototype.constructor = y);
    }
    function a(y, h, g) {
      if (a.isBN(y)) return y;
      (this.negative = 0),
        (this.words = null),
        (this.length = 0),
        (this.red = null),
        y !== null &&
          ((h === "le" || h === "be") && ((g = h), (h = 10)),
          this._init(y || 0, h || 10, g || "be"));
    }
    typeof e == "object" ? (e.exports = a) : (r.BN = a),
      (a.BN = a),
      (a.wordSize = 26);
    var s;
    try {
      typeof window < "u" && typeof window.Buffer < "u"
        ? (s = window.Buffer)
        : (s = Pu.Buffer);
    } catch {}
    (a.isBN = function (h) {
      return h instanceof a
        ? !0
        : h !== null &&
            typeof h == "object" &&
            h.constructor.wordSize === a.wordSize &&
            Array.isArray(h.words);
    }),
      (a.max = function (h, g) {
        return h.cmp(g) > 0 ? h : g;
      }),
      (a.min = function (h, g) {
        return h.cmp(g) < 0 ? h : g;
      }),
      (a.prototype._init = function (h, g, T) {
        if (typeof h == "number") return this._initNumber(h, g, T);
        if (typeof h == "object") return this._initArray(h, g, T);
        g === "hex" && (g = 16),
          n(g === (g | 0) && g >= 2 && g <= 36),
          (h = h.toString().replace(/\s+/g, ""));
        var R = 0;
        h[0] === "-" && (R++, (this.negative = 1)),
          R < h.length &&
            (g === 16
              ? this._parseHex(h, R, T)
              : (this._parseBase(h, g, R),
                T === "le" && this._initArray(this.toArray(), g, T)));
      }),
      (a.prototype._initNumber = function (h, g, T) {
        h < 0 && ((this.negative = 1), (h = -h)),
          h < 67108864
            ? ((this.words = [h & 67108863]), (this.length = 1))
            : h < 4503599627370496
            ? ((this.words = [h & 67108863, (h / 67108864) & 67108863]),
              (this.length = 2))
            : (n(h < 9007199254740992),
              (this.words = [h & 67108863, (h / 67108864) & 67108863, 1]),
              (this.length = 3)),
          T === "le" && this._initArray(this.toArray(), g, T);
      }),
      (a.prototype._initArray = function (h, g, T) {
        if ((n(typeof h.length == "number"), h.length <= 0))
          return (this.words = [0]), (this.length = 1), this;
        (this.length = Math.ceil(h.length / 3)),
          (this.words = new Array(this.length));
        for (var R = 0; R < this.length; R++) this.words[R] = 0;
        var x,
          f,
          _ = 0;
        if (T === "be")
          for (R = h.length - 1, x = 0; R >= 0; R -= 3)
            (f = h[R] | (h[R - 1] << 8) | (h[R - 2] << 16)),
              (this.words[x] |= (f << _) & 67108863),
              (this.words[x + 1] = (f >>> (26 - _)) & 67108863),
              (_ += 24),
              _ >= 26 && ((_ -= 26), x++);
        else if (T === "le")
          for (R = 0, x = 0; R < h.length; R += 3)
            (f = h[R] | (h[R + 1] << 8) | (h[R + 2] << 16)),
              (this.words[x] |= (f << _) & 67108863),
              (this.words[x + 1] = (f >>> (26 - _)) & 67108863),
              (_ += 24),
              _ >= 26 && ((_ -= 26), x++);
        return this._strip();
      });
    function o(y, h) {
      var g = y.charCodeAt(h);
      if (g >= 48 && g <= 57) return g - 48;
      if (g >= 65 && g <= 70) return g - 55;
      if (g >= 97 && g <= 102) return g - 87;
      n(!1, "Invalid character in " + y);
    }
    function c(y, h, g) {
      var T = o(y, g);
      return g - 1 >= h && (T |= o(y, g - 1) << 4), T;
    }
    a.prototype._parseHex = function (h, g, T) {
      (this.length = Math.ceil((h.length - g) / 6)),
        (this.words = new Array(this.length));
      for (var R = 0; R < this.length; R++) this.words[R] = 0;
      var x = 0,
        f = 0,
        _;
      if (T === "be")
        for (R = h.length - 1; R >= g; R -= 2)
          (_ = c(h, g, R) << x),
            (this.words[f] |= _ & 67108863),
            x >= 18
              ? ((x -= 18), (f += 1), (this.words[f] |= _ >>> 26))
              : (x += 8);
      else {
        var P = h.length - g;
        for (R = P % 2 === 0 ? g + 1 : g; R < h.length; R += 2)
          (_ = c(h, g, R) << x),
            (this.words[f] |= _ & 67108863),
            x >= 18
              ? ((x -= 18), (f += 1), (this.words[f] |= _ >>> 26))
              : (x += 8);
      }
      this._strip();
    };
    function u(y, h, g, T) {
      for (var R = 0, x = 0, f = Math.min(y.length, g), _ = h; _ < f; _++) {
        var P = y.charCodeAt(_) - 48;
        (R *= T),
          P >= 49 ? (x = P - 49 + 10) : P >= 17 ? (x = P - 17 + 10) : (x = P),
          n(P >= 0 && x < T, "Invalid character"),
          (R += x);
      }
      return R;
    }
    (a.prototype._parseBase = function (h, g, T) {
      (this.words = [0]), (this.length = 1);
      for (var R = 0, x = 1; x <= 67108863; x *= g) R++;
      R--, (x = (x / g) | 0);
      for (
        var f = h.length - T,
          _ = f % R,
          P = Math.min(f, f - _) + T,
          M = 0,
          D = T;
        D < P;
        D += R
      )
        (M = u(h, D, D + R, g)),
          this.imuln(x),
          this.words[0] + M < 67108864 ? (this.words[0] += M) : this._iaddn(M);
      if (_ !== 0) {
        var q = 1;
        for (M = u(h, D, h.length, g), D = 0; D < _; D++) q *= g;
        this.imuln(q),
          this.words[0] + M < 67108864 ? (this.words[0] += M) : this._iaddn(M);
      }
      this._strip();
    }),
      (a.prototype.copy = function (h) {
        h.words = new Array(this.length);
        for (var g = 0; g < this.length; g++) h.words[g] = this.words[g];
        (h.length = this.length),
          (h.negative = this.negative),
          (h.red = this.red);
      });
    function d(y, h) {
      (y.words = h.words),
        (y.length = h.length),
        (y.negative = h.negative),
        (y.red = h.red);
    }
    if (
      ((a.prototype._move = function (h) {
        d(h, this);
      }),
      (a.prototype.clone = function () {
        var h = new a(null);
        return this.copy(h), h;
      }),
      (a.prototype._expand = function (h) {
        for (; this.length < h; ) this.words[this.length++] = 0;
        return this;
      }),
      (a.prototype._strip = function () {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }),
      (a.prototype._normSign = function () {
        return (
          this.length === 1 && this.words[0] === 0 && (this.negative = 0), this
        );
      }),
      typeof Symbol < "u" && typeof Symbol.for == "function")
    )
      try {
        a.prototype[Symbol.for("nodejs.util.inspect.custom")] = m;
      } catch {
        a.prototype.inspect = m;
      }
    else a.prototype.inspect = m;
    function m() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var v = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000",
      ],
      E = [
        0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
      ],
      A = [
        0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607,
        16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536,
        11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101,
        5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368,
        20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875,
        60466176,
      ];
    (a.prototype.toString = function (h, g) {
      (h = h || 10), (g = g | 0 || 1);
      var T;
      if (h === 16 || h === "hex") {
        T = "";
        for (var R = 0, x = 0, f = 0; f < this.length; f++) {
          var _ = this.words[f],
            P = (((_ << R) | x) & 16777215).toString(16);
          (x = (_ >>> (24 - R)) & 16777215),
            (R += 2),
            R >= 26 && ((R -= 26), f--),
            x !== 0 || f !== this.length - 1
              ? (T = v[6 - P.length] + P + T)
              : (T = P + T);
        }
        for (x !== 0 && (T = x.toString(16) + T); T.length % g !== 0; )
          T = "0" + T;
        return this.negative !== 0 && (T = "-" + T), T;
      }
      if (h === (h | 0) && h >= 2 && h <= 36) {
        var M = E[h],
          D = A[h];
        T = "";
        var q = this.clone();
        for (q.negative = 0; !q.isZero(); ) {
          var B = q.modrn(D).toString(h);
          (q = q.idivn(D)),
            q.isZero() ? (T = B + T) : (T = v[M - B.length] + B + T);
        }
        for (this.isZero() && (T = "0" + T); T.length % g !== 0; ) T = "0" + T;
        return this.negative !== 0 && (T = "-" + T), T;
      }
      n(!1, "Base should be between 2 and 36");
    }),
      (a.prototype.toNumber = function () {
        var h = this.words[0];
        return (
          this.length === 2
            ? (h += this.words[1] * 67108864)
            : this.length === 3 && this.words[2] === 1
            ? (h += 4503599627370496 + this.words[1] * 67108864)
            : this.length > 2 &&
              n(!1, "Number can only safely store up to 53 bits"),
          this.negative !== 0 ? -h : h
        );
      }),
      (a.prototype.toJSON = function () {
        return this.toString(16, 2);
      }),
      s &&
        (a.prototype.toBuffer = function (h, g) {
          return this.toArrayLike(s, h, g);
        }),
      (a.prototype.toArray = function (h, g) {
        return this.toArrayLike(Array, h, g);
      });
    var I = function (h, g) {
      return h.allocUnsafe ? h.allocUnsafe(g) : new h(g);
    };
    (a.prototype.toArrayLike = function (h, g, T) {
      this._strip();
      var R = this.byteLength(),
        x = T || Math.max(1, R);
      n(R <= x, "byte array longer than desired length"),
        n(x > 0, "Requested array length <= 0");
      var f = I(h, x),
        _ = g === "le" ? "LE" : "BE";
      return this["_toArrayLike" + _](f, R), f;
    }),
      (a.prototype._toArrayLikeLE = function (h, g) {
        for (var T = 0, R = 0, x = 0, f = 0; x < this.length; x++) {
          var _ = (this.words[x] << f) | R;
          (h[T++] = _ & 255),
            T < h.length && (h[T++] = (_ >> 8) & 255),
            T < h.length && (h[T++] = (_ >> 16) & 255),
            f === 6
              ? (T < h.length && (h[T++] = (_ >> 24) & 255), (R = 0), (f = 0))
              : ((R = _ >>> 24), (f += 2));
        }
        if (T < h.length) for (h[T++] = R; T < h.length; ) h[T++] = 0;
      }),
      (a.prototype._toArrayLikeBE = function (h, g) {
        for (var T = h.length - 1, R = 0, x = 0, f = 0; x < this.length; x++) {
          var _ = (this.words[x] << f) | R;
          (h[T--] = _ & 255),
            T >= 0 && (h[T--] = (_ >> 8) & 255),
            T >= 0 && (h[T--] = (_ >> 16) & 255),
            f === 6
              ? (T >= 0 && (h[T--] = (_ >> 24) & 255), (R = 0), (f = 0))
              : ((R = _ >>> 24), (f += 2));
        }
        if (T >= 0) for (h[T--] = R; T >= 0; ) h[T--] = 0;
      }),
      Math.clz32
        ? (a.prototype._countBits = function (h) {
            return 32 - Math.clz32(h);
          })
        : (a.prototype._countBits = function (h) {
            var g = h,
              T = 0;
            return (
              g >= 4096 && ((T += 13), (g >>>= 13)),
              g >= 64 && ((T += 7), (g >>>= 7)),
              g >= 8 && ((T += 4), (g >>>= 4)),
              g >= 2 && ((T += 2), (g >>>= 2)),
              T + g
            );
          }),
      (a.prototype._zeroBits = function (h) {
        if (h === 0) return 26;
        var g = h,
          T = 0;
        return (
          g & 8191 || ((T += 13), (g >>>= 13)),
          g & 127 || ((T += 7), (g >>>= 7)),
          g & 15 || ((T += 4), (g >>>= 4)),
          g & 3 || ((T += 2), (g >>>= 2)),
          g & 1 || T++,
          T
        );
      }),
      (a.prototype.bitLength = function () {
        var h = this.words[this.length - 1],
          g = this._countBits(h);
        return (this.length - 1) * 26 + g;
      });
    function b(y) {
      for (var h = new Array(y.bitLength()), g = 0; g < h.length; g++) {
        var T = (g / 26) | 0,
          R = g % 26;
        h[g] = (y.words[T] >>> R) & 1;
      }
      return h;
    }
    (a.prototype.zeroBits = function () {
      if (this.isZero()) return 0;
      for (var h = 0, g = 0; g < this.length; g++) {
        var T = this._zeroBits(this.words[g]);
        if (((h += T), T !== 26)) break;
      }
      return h;
    }),
      (a.prototype.byteLength = function () {
        return Math.ceil(this.bitLength() / 8);
      }),
      (a.prototype.toTwos = function (h) {
        return this.negative !== 0
          ? this.abs().inotn(h).iaddn(1)
          : this.clone();
      }),
      (a.prototype.fromTwos = function (h) {
        return this.testn(h - 1) ? this.notn(h).iaddn(1).ineg() : this.clone();
      }),
      (a.prototype.isNeg = function () {
        return this.negative !== 0;
      }),
      (a.prototype.neg = function () {
        return this.clone().ineg();
      }),
      (a.prototype.ineg = function () {
        return this.isZero() || (this.negative ^= 1), this;
      }),
      (a.prototype.iuor = function (h) {
        for (; this.length < h.length; ) this.words[this.length++] = 0;
        for (var g = 0; g < h.length; g++)
          this.words[g] = this.words[g] | h.words[g];
        return this._strip();
      }),
      (a.prototype.ior = function (h) {
        return n((this.negative | h.negative) === 0), this.iuor(h);
      }),
      (a.prototype.or = function (h) {
        return this.length > h.length
          ? this.clone().ior(h)
          : h.clone().ior(this);
      }),
      (a.prototype.uor = function (h) {
        return this.length > h.length
          ? this.clone().iuor(h)
          : h.clone().iuor(this);
      }),
      (a.prototype.iuand = function (h) {
        var g;
        this.length > h.length ? (g = h) : (g = this);
        for (var T = 0; T < g.length; T++)
          this.words[T] = this.words[T] & h.words[T];
        return (this.length = g.length), this._strip();
      }),
      (a.prototype.iand = function (h) {
        return n((this.negative | h.negative) === 0), this.iuand(h);
      }),
      (a.prototype.and = function (h) {
        return this.length > h.length
          ? this.clone().iand(h)
          : h.clone().iand(this);
      }),
      (a.prototype.uand = function (h) {
        return this.length > h.length
          ? this.clone().iuand(h)
          : h.clone().iuand(this);
      }),
      (a.prototype.iuxor = function (h) {
        var g, T;
        this.length > h.length ? ((g = this), (T = h)) : ((g = h), (T = this));
        for (var R = 0; R < T.length; R++)
          this.words[R] = g.words[R] ^ T.words[R];
        if (this !== g) for (; R < g.length; R++) this.words[R] = g.words[R];
        return (this.length = g.length), this._strip();
      }),
      (a.prototype.ixor = function (h) {
        return n((this.negative | h.negative) === 0), this.iuxor(h);
      }),
      (a.prototype.xor = function (h) {
        return this.length > h.length
          ? this.clone().ixor(h)
          : h.clone().ixor(this);
      }),
      (a.prototype.uxor = function (h) {
        return this.length > h.length
          ? this.clone().iuxor(h)
          : h.clone().iuxor(this);
      }),
      (a.prototype.inotn = function (h) {
        n(typeof h == "number" && h >= 0);
        var g = Math.ceil(h / 26) | 0,
          T = h % 26;
        this._expand(g), T > 0 && g--;
        for (var R = 0; R < g; R++) this.words[R] = ~this.words[R] & 67108863;
        return (
          T > 0 && (this.words[R] = ~this.words[R] & (67108863 >> (26 - T))),
          this._strip()
        );
      }),
      (a.prototype.notn = function (h) {
        return this.clone().inotn(h);
      }),
      (a.prototype.setn = function (h, g) {
        n(typeof h == "number" && h >= 0);
        var T = (h / 26) | 0,
          R = h % 26;
        return (
          this._expand(T + 1),
          g
            ? (this.words[T] = this.words[T] | (1 << R))
            : (this.words[T] = this.words[T] & ~(1 << R)),
          this._strip()
        );
      }),
      (a.prototype.iadd = function (h) {
        var g;
        if (this.negative !== 0 && h.negative === 0)
          return (
            (this.negative = 0),
            (g = this.isub(h)),
            (this.negative ^= 1),
            this._normSign()
          );
        if (this.negative === 0 && h.negative !== 0)
          return (
            (h.negative = 0),
            (g = this.isub(h)),
            (h.negative = 1),
            g._normSign()
          );
        var T, R;
        this.length > h.length ? ((T = this), (R = h)) : ((T = h), (R = this));
        for (var x = 0, f = 0; f < R.length; f++)
          (g = (T.words[f] | 0) + (R.words[f] | 0) + x),
            (this.words[f] = g & 67108863),
            (x = g >>> 26);
        for (; x !== 0 && f < T.length; f++)
          (g = (T.words[f] | 0) + x),
            (this.words[f] = g & 67108863),
            (x = g >>> 26);
        if (((this.length = T.length), x !== 0))
          (this.words[this.length] = x), this.length++;
        else if (T !== this)
          for (; f < T.length; f++) this.words[f] = T.words[f];
        return this;
      }),
      (a.prototype.add = function (h) {
        var g;
        return h.negative !== 0 && this.negative === 0
          ? ((h.negative = 0), (g = this.sub(h)), (h.negative ^= 1), g)
          : h.negative === 0 && this.negative !== 0
          ? ((this.negative = 0), (g = h.sub(this)), (this.negative = 1), g)
          : this.length > h.length
          ? this.clone().iadd(h)
          : h.clone().iadd(this);
      }),
      (a.prototype.isub = function (h) {
        if (h.negative !== 0) {
          h.negative = 0;
          var g = this.iadd(h);
          return (h.negative = 1), g._normSign();
        } else if (this.negative !== 0)
          return (
            (this.negative = 0),
            this.iadd(h),
            (this.negative = 1),
            this._normSign()
          );
        var T = this.cmp(h);
        if (T === 0)
          return (
            (this.negative = 0), (this.length = 1), (this.words[0] = 0), this
          );
        var R, x;
        T > 0 ? ((R = this), (x = h)) : ((R = h), (x = this));
        for (var f = 0, _ = 0; _ < x.length; _++)
          (g = (R.words[_] | 0) - (x.words[_] | 0) + f),
            (f = g >> 26),
            (this.words[_] = g & 67108863);
        for (; f !== 0 && _ < R.length; _++)
          (g = (R.words[_] | 0) + f),
            (f = g >> 26),
            (this.words[_] = g & 67108863);
        if (f === 0 && _ < R.length && R !== this)
          for (; _ < R.length; _++) this.words[_] = R.words[_];
        return (
          (this.length = Math.max(this.length, _)),
          R !== this && (this.negative = 1),
          this._strip()
        );
      }),
      (a.prototype.sub = function (h) {
        return this.clone().isub(h);
      });
    function w(y, h, g) {
      g.negative = h.negative ^ y.negative;
      var T = (y.length + h.length) | 0;
      (g.length = T), (T = (T - 1) | 0);
      var R = y.words[0] | 0,
        x = h.words[0] | 0,
        f = R * x,
        _ = f & 67108863,
        P = (f / 67108864) | 0;
      g.words[0] = _;
      for (var M = 1; M < T; M++) {
        for (
          var D = P >>> 26,
            q = P & 67108863,
            B = Math.min(M, h.length - 1),
            H = Math.max(0, M - y.length + 1);
          H <= B;
          H++
        ) {
          var Q = (M - H) | 0;
          (R = y.words[Q] | 0),
            (x = h.words[H] | 0),
            (f = R * x + q),
            (D += (f / 67108864) | 0),
            (q = f & 67108863);
        }
        (g.words[M] = q | 0), (P = D | 0);
      }
      return P !== 0 ? (g.words[M] = P | 0) : g.length--, g._strip();
    }
    var S = function (h, g, T) {
      var R = h.words,
        x = g.words,
        f = T.words,
        _ = 0,
        P,
        M,
        D,
        q = R[0] | 0,
        B = q & 8191,
        H = q >>> 13,
        Q = R[1] | 0,
        Z = Q & 8191,
        te = Q >>> 13,
        Te = R[2] | 0,
        K = Te & 8191,
        G = Te >>> 13,
        he = R[3] | 0,
        se = he & 8191,
        pe = he >>> 13,
        Y = R[4] | 0,
        $ = Y & 8191,
        W = Y >>> 13,
        re = R[5] | 0,
        ee = re & 8191,
        ce = re >>> 13,
        Ce = R[6] | 0,
        me = Ce & 8191,
        ge = Ce >>> 13,
        it = R[7] | 0,
        ve = it & 8191,
        z = it >>> 13,
        U = R[8] | 0,
        L = U & 8191,
        J = U >>> 13,
        fe = R[9] | 0,
        ie = fe & 8191,
        le = fe >>> 13,
        nt = x[0] | 0,
        Ee = nt & 8191,
        we = nt >>> 13,
        ft = x[1] | 0,
        xe = ft & 8191,
        Pe = ft >>> 13,
        hr = x[2] | 0,
        Ne = hr & 8191,
        Me = hr >>> 13,
        _r = x[3] | 0,
        Be = _r & 8191,
        De = _r >>> 13,
        pr = x[4] | 0,
        Oe = pr & 8191,
        Fe = pr >>> 13,
        mr = x[5] | 0,
        Le = mr & 8191,
        Ie = mr >>> 13,
        At = x[6] | 0,
        Ae = At & 8191,
        Re = At >>> 13,
        Er = x[7] | 0,
        $e = Er & 8191,
        Ue = Er >>> 13,
        Mr = x[8] | 0,
        We = Mr & 8191,
        je = Mr >>> 13,
        ur = x[9] | 0,
        mt = ur & 8191,
        yt = ur >>> 13;
      (T.negative = h.negative ^ g.negative),
        (T.length = 19),
        (P = Math.imul(B, Ee)),
        (M = Math.imul(B, we)),
        (M = (M + Math.imul(H, Ee)) | 0),
        (D = Math.imul(H, we));
      var rr = (((_ + P) | 0) + ((M & 8191) << 13)) | 0;
      (_ = (((D + (M >>> 13)) | 0) + (rr >>> 26)) | 0),
        (rr &= 67108863),
        (P = Math.imul(Z, Ee)),
        (M = Math.imul(Z, we)),
        (M = (M + Math.imul(te, Ee)) | 0),
        (D = Math.imul(te, we)),
        (P = (P + Math.imul(B, xe)) | 0),
        (M = (M + Math.imul(B, Pe)) | 0),
        (M = (M + Math.imul(H, xe)) | 0),
        (D = (D + Math.imul(H, Pe)) | 0);
      var nr = (((_ + P) | 0) + ((M & 8191) << 13)) | 0;
      (_ = (((D + (M >>> 13)) | 0) + (nr >>> 26)) | 0),
        (nr &= 67108863),
        (P = Math.imul(K, Ee)),
        (M = Math.imul(K, we)),
        (M = (M + Math.imul(G, Ee)) | 0),
        (D = Math.imul(G, we)),
        (P = (P + Math.imul(Z, xe)) | 0),
        (M = (M + Math.imul(Z, Pe)) | 0),
        (M = (M + Math.imul(te, xe)) | 0),
        (D = (D + Math.imul(te, Pe)) | 0),
        (P = (P + Math.imul(B, Ne)) | 0),
        (M = (M + Math.imul(B, Me)) | 0),
        (M = (M + Math.imul(H, Ne)) | 0),
        (D = (D + Math.imul(H, Me)) | 0);
      var ir = (((_ + P) | 0) + ((M & 8191) << 13)) | 0;
      (_ = (((D + (M >>> 13)) | 0) + (ir >>> 26)) | 0),
        (ir &= 67108863),
        (P = Math.imul(se, Ee)),
        (M = Math.imul(se, we)),
        (M = (M + Math.imul(pe, Ee)) | 0),
        (D = Math.imul(pe, we)),
        (P = (P + Math.imul(K, xe)) | 0),
        (M = (M + Math.imul(K, Pe)) | 0),
        (M = (M + Math.imul(G, xe)) | 0),
        (D = (D + Math.imul(G, Pe)) | 0),
        (P = (P + Math.imul(Z, Ne)) | 0),
        (M = (M + Math.imul(Z, Me)) | 0),
        (M = (M + Math.imul(te, Ne)) | 0),
        (D = (D + Math.imul(te, Me)) | 0),
        (P = (P + Math.imul(B, Be)) | 0),
        (M = (M + Math.imul(B, De)) | 0),
        (M = (M + Math.imul(H, Be)) | 0),
        (D = (D + Math.imul(H, De)) | 0);
      var ar = (((_ + P) | 0) + ((M & 8191) << 13)) | 0;
      (_ = (((D + (M >>> 13)) | 0) + (ar >>> 26)) | 0),
        (ar &= 67108863),
        (P = Math.imul($, Ee)),
        (M = Math.imul($, we)),
        (M = (M + Math.imul(W, Ee)) | 0),
        (D = Math.imul(W, we)),
        (P = (P + Math.imul(se, xe)) | 0),
        (M = (M + Math.imul(se, Pe)) | 0),
        (M = (M + Math.imul(pe, xe)) | 0),
        (D = (D + Math.imul(pe, Pe)) | 0),
        (P = (P + Math.imul(K, Ne)) | 0),
        (M = (M + Math.imul(K, Me)) | 0),
        (M = (M + Math.imul(G, Ne)) | 0),
        (D = (D + Math.imul(G, Me)) | 0),
        (P = (P + Math.imul(Z, Be)) | 0),
        (M = (M + Math.imul(Z, De)) | 0),
        (M = (M + Math.imul(te, Be)) | 0),
        (D = (D + Math.imul(te, De)) | 0),
        (P = (P + Math.imul(B, Oe)) | 0),
        (M = (M + Math.imul(B, Fe)) | 0),
        (M = (M + Math.imul(H, Oe)) | 0),
        (D = (D + Math.imul(H, Fe)) | 0);
      var sr = (((_ + P) | 0) + ((M & 8191) << 13)) | 0;
      (_ = (((D + (M >>> 13)) | 0) + (sr >>> 26)) | 0),
        (sr &= 67108863),
        (P = Math.imul(ee, Ee)),
        (M = Math.imul(ee, we)),
        (M = (M + Math.imul(ce, Ee)) | 0),
        (D = Math.imul(ce, we)),
        (P = (P + Math.imul($, xe)) | 0),
        (M = (M + Math.imul($, Pe)) | 0),
        (M = (M + Math.imul(W, xe)) | 0),
        (D = (D + Math.imul(W, Pe)) | 0),
        (P = (P + Math.imul(se, Ne)) | 0),
        (M = (M + Math.imul(se, Me)) | 0),
        (M = (M + Math.imul(pe, Ne)) | 0),
        (D = (D + Math.imul(pe, Me)) | 0),
        (P = (P + Math.imul(K, Be)) | 0),
        (M = (M + Math.imul(K, De)) | 0),
        (M = (M + Math.imul(G, Be)) | 0),
        (D = (D + Math.imul(G, De)) | 0),
        (P = (P + Math.imul(Z, Oe)) | 0),
        (M = (M + Math.imul(Z, Fe)) | 0),
        (M = (M + Math.imul(te, Oe)) | 0),
        (D = (D + Math.imul(te, Fe)) | 0),
        (P = (P + Math.imul(B, Le)) | 0),
        (M = (M + Math.imul(B, Ie)) | 0),
        (M = (M + Math.imul(H, Le)) | 0),
        (D = (D + Math.imul(H, Ie)) | 0);
      var Ir = (((_ + P) | 0) + ((M & 8191) << 13)) | 0;
      (_ = (((D + (M >>> 13)) | 0) + (Ir >>> 26)) | 0),
        (Ir &= 67108863),
        (P = Math.imul(me, Ee)),
        (M = Math.imul(me, we)),
        (M = (M + Math.imul(ge, Ee)) | 0),
        (D = Math.imul(ge, we)),
        (P = (P + Math.imul(ee, xe)) | 0),
        (M = (M + Math.imul(ee, Pe)) | 0),
        (M = (M + Math.imul(ce, xe)) | 0),
        (D = (D + Math.imul(ce, Pe)) | 0),
        (P = (P + Math.imul($, Ne)) | 0),
        (M = (M + Math.imul($, Me)) | 0),
        (M = (M + Math.imul(W, Ne)) | 0),
        (D = (D + Math.imul(W, Me)) | 0),
        (P = (P + Math.imul(se, Be)) | 0),
        (M = (M + Math.imul(se, De)) | 0),
        (M = (M + Math.imul(pe, Be)) | 0),
        (D = (D + Math.imul(pe, De)) | 0),
        (P = (P + Math.imul(K, Oe)) | 0),
        (M = (M + Math.imul(K, Fe)) | 0),
        (M = (M + Math.imul(G, Oe)) | 0),
        (D = (D + Math.imul(G, Fe)) | 0),
        (P = (P + Math.imul(Z, Le)) | 0),
        (M = (M + Math.imul(Z, Ie)) | 0),
        (M = (M + Math.imul(te, Le)) | 0),
        (D = (D + Math.imul(te, Ie)) | 0),
        (P = (P + Math.imul(B, Ae)) | 0),
        (M = (M + Math.imul(B, Re)) | 0),
        (M = (M + Math.imul(H, Ae)) | 0),
        (D = (D + Math.imul(H, Re)) | 0);
      var Rr = (((_ + P) | 0) + ((M & 8191) << 13)) | 0;
      (_ = (((D + (M >>> 13)) | 0) + (Rr >>> 26)) | 0),
        (Rr &= 67108863),
        (P = Math.imul(ve, Ee)),
        (M = Math.imul(ve, we)),
        (M = (M + Math.imul(z, Ee)) | 0),
        (D = Math.imul(z, we)),
        (P = (P + Math.imul(me, xe)) | 0),
        (M = (M + Math.imul(me, Pe)) | 0),
        (M = (M + Math.imul(ge, xe)) | 0),
        (D = (D + Math.imul(ge, Pe)) | 0),
        (P = (P + Math.imul(ee, Ne)) | 0),
        (M = (M + Math.imul(ee, Me)) | 0),
        (M = (M + Math.imul(ce, Ne)) | 0),
        (D = (D + Math.imul(ce, Me)) | 0),
        (P = (P + Math.imul($, Be)) | 0),
        (M = (M + Math.imul($, De)) | 0),
        (M = (M + Math.imul(W, Be)) | 0),
        (D = (D + Math.imul(W, De)) | 0),
        (P = (P + Math.imul(se, Oe)) | 0),
        (M = (M + Math.imul(se, Fe)) | 0),
        (M = (M + Math.imul(pe, Oe)) | 0),
        (D = (D + Math.imul(pe, Fe)) | 0),
        (P = (P + Math.imul(K, Le)) | 0),
        (M = (M + Math.imul(K, Ie)) | 0),
        (M = (M + Math.imul(G, Le)) | 0),
        (D = (D + Math.imul(G, Ie)) | 0),
        (P = (P + Math.imul(Z, Ae)) | 0),
        (M = (M + Math.imul(Z, Re)) | 0),
        (M = (M + Math.imul(te, Ae)) | 0),
        (D = (D + Math.imul(te, Re)) | 0),
        (P = (P + Math.imul(B, $e)) | 0),
        (M = (M + Math.imul(B, Ue)) | 0),
        (M = (M + Math.imul(H, $e)) | 0),
        (D = (D + Math.imul(H, Ue)) | 0);
      var Pr = (((_ + P) | 0) + ((M & 8191) << 13)) | 0;
      (_ = (((D + (M >>> 13)) | 0) + (Pr >>> 26)) | 0),
        (Pr &= 67108863),
        (P = Math.imul(L, Ee)),
        (M = Math.imul(L, we)),
        (M = (M + Math.imul(J, Ee)) | 0),
        (D = Math.imul(J, we)),
        (P = (P + Math.imul(ve, xe)) | 0),
        (M = (M + Math.imul(ve, Pe)) | 0),
        (M = (M + Math.imul(z, xe)) | 0),
        (D = (D + Math.imul(z, Pe)) | 0),
        (P = (P + Math.imul(me, Ne)) | 0),
        (M = (M + Math.imul(me, Me)) | 0),
        (M = (M + Math.imul(ge, Ne)) | 0),
        (D = (D + Math.imul(ge, Me)) | 0),
        (P = (P + Math.imul(ee, Be)) | 0),
        (M = (M + Math.imul(ee, De)) | 0),
        (M = (M + Math.imul(ce, Be)) | 0),
        (D = (D + Math.imul(ce, De)) | 0),
        (P = (P + Math.imul($, Oe)) | 0),
        (M = (M + Math.imul($, Fe)) | 0),
        (M = (M + Math.imul(W, Oe)) | 0),
        (D = (D + Math.imul(W, Fe)) | 0),
        (P = (P + Math.imul(se, Le)) | 0),
        (M = (M + Math.imul(se, Ie)) | 0),
        (M = (M + Math.imul(pe, Le)) | 0),
        (D = (D + Math.imul(pe, Ie)) | 0),
        (P = (P + Math.imul(K, Ae)) | 0),
        (M = (M + Math.imul(K, Re)) | 0),
        (M = (M + Math.imul(G, Ae)) | 0),
        (D = (D + Math.imul(G, Re)) | 0),
        (P = (P + Math.imul(Z, $e)) | 0),
        (M = (M + Math.imul(Z, Ue)) | 0),
        (M = (M + Math.imul(te, $e)) | 0),
        (D = (D + Math.imul(te, Ue)) | 0),
        (P = (P + Math.imul(B, We)) | 0),
        (M = (M + Math.imul(B, je)) | 0),
        (M = (M + Math.imul(H, We)) | 0),
        (D = (D + Math.imul(H, je)) | 0);
      var Nr = (((_ + P) | 0) + ((M & 8191) << 13)) | 0;
      (_ = (((D + (M >>> 13)) | 0) + (Nr >>> 26)) | 0),
        (Nr &= 67108863),
        (P = Math.imul(ie, Ee)),
        (M = Math.imul(ie, we)),
        (M = (M + Math.imul(le, Ee)) | 0),
        (D = Math.imul(le, we)),
        (P = (P + Math.imul(L, xe)) | 0),
        (M = (M + Math.imul(L, Pe)) | 0),
        (M = (M + Math.imul(J, xe)) | 0),
        (D = (D + Math.imul(J, Pe)) | 0),
        (P = (P + Math.imul(ve, Ne)) | 0),
        (M = (M + Math.imul(ve, Me)) | 0),
        (M = (M + Math.imul(z, Ne)) | 0),
        (D = (D + Math.imul(z, Me)) | 0),
        (P = (P + Math.imul(me, Be)) | 0),
        (M = (M + Math.imul(me, De)) | 0),
        (M = (M + Math.imul(ge, Be)) | 0),
        (D = (D + Math.imul(ge, De)) | 0),
        (P = (P + Math.imul(ee, Oe)) | 0),
        (M = (M + Math.imul(ee, Fe)) | 0),
        (M = (M + Math.imul(ce, Oe)) | 0),
        (D = (D + Math.imul(ce, Fe)) | 0),
        (P = (P + Math.imul($, Le)) | 0),
        (M = (M + Math.imul($, Ie)) | 0),
        (M = (M + Math.imul(W, Le)) | 0),
        (D = (D + Math.imul(W, Ie)) | 0),
        (P = (P + Math.imul(se, Ae)) | 0),
        (M = (M + Math.imul(se, Re)) | 0),
        (M = (M + Math.imul(pe, Ae)) | 0),
        (D = (D + Math.imul(pe, Re)) | 0),
        (P = (P + Math.imul(K, $e)) | 0),
        (M = (M + Math.imul(K, Ue)) | 0),
        (M = (M + Math.imul(G, $e)) | 0),
        (D = (D + Math.imul(G, Ue)) | 0),
        (P = (P + Math.imul(Z, We)) | 0),
        (M = (M + Math.imul(Z, je)) | 0),
        (M = (M + Math.imul(te, We)) | 0),
        (D = (D + Math.imul(te, je)) | 0),
        (P = (P + Math.imul(B, mt)) | 0),
        (M = (M + Math.imul(B, yt)) | 0),
        (M = (M + Math.imul(H, mt)) | 0),
        (D = (D + Math.imul(H, yt)) | 0);
      var Br = (((_ + P) | 0) + ((M & 8191) << 13)) | 0;
      (_ = (((D + (M >>> 13)) | 0) + (Br >>> 26)) | 0),
        (Br &= 67108863),
        (P = Math.imul(ie, xe)),
        (M = Math.imul(ie, Pe)),
        (M = (M + Math.imul(le, xe)) | 0),
        (D = Math.imul(le, Pe)),
        (P = (P + Math.imul(L, Ne)) | 0),
        (M = (M + Math.imul(L, Me)) | 0),
        (M = (M + Math.imul(J, Ne)) | 0),
        (D = (D + Math.imul(J, Me)) | 0),
        (P = (P + Math.imul(ve, Be)) | 0),
        (M = (M + Math.imul(ve, De)) | 0),
        (M = (M + Math.imul(z, Be)) | 0),
        (D = (D + Math.imul(z, De)) | 0),
        (P = (P + Math.imul(me, Oe)) | 0),
        (M = (M + Math.imul(me, Fe)) | 0),
        (M = (M + Math.imul(ge, Oe)) | 0),
        (D = (D + Math.imul(ge, Fe)) | 0),
        (P = (P + Math.imul(ee, Le)) | 0),
        (M = (M + Math.imul(ee, Ie)) | 0),
        (M = (M + Math.imul(ce, Le)) | 0),
        (D = (D + Math.imul(ce, Ie)) | 0),
        (P = (P + Math.imul($, Ae)) | 0),
        (M = (M + Math.imul($, Re)) | 0),
        (M = (M + Math.imul(W, Ae)) | 0),
        (D = (D + Math.imul(W, Re)) | 0),
        (P = (P + Math.imul(se, $e)) | 0),
        (M = (M + Math.imul(se, Ue)) | 0),
        (M = (M + Math.imul(pe, $e)) | 0),
        (D = (D + Math.imul(pe, Ue)) | 0),
        (P = (P + Math.imul(K, We)) | 0),
        (M = (M + Math.imul(K, je)) | 0),
        (M = (M + Math.imul(G, We)) | 0),
        (D = (D + Math.imul(G, je)) | 0),
        (P = (P + Math.imul(Z, mt)) | 0),
        (M = (M + Math.imul(Z, yt)) | 0),
        (M = (M + Math.imul(te, mt)) | 0),
        (D = (D + Math.imul(te, yt)) | 0);
      var Dr = (((_ + P) | 0) + ((M & 8191) << 13)) | 0;
      (_ = (((D + (M >>> 13)) | 0) + (Dr >>> 26)) | 0),
        (Dr &= 67108863),
        (P = Math.imul(ie, Ne)),
        (M = Math.imul(ie, Me)),
        (M = (M + Math.imul(le, Ne)) | 0),
        (D = Math.imul(le, Me)),
        (P = (P + Math.imul(L, Be)) | 0),
        (M = (M + Math.imul(L, De)) | 0),
        (M = (M + Math.imul(J, Be)) | 0),
        (D = (D + Math.imul(J, De)) | 0),
        (P = (P + Math.imul(ve, Oe)) | 0),
        (M = (M + Math.imul(ve, Fe)) | 0),
        (M = (M + Math.imul(z, Oe)) | 0),
        (D = (D + Math.imul(z, Fe)) | 0),
        (P = (P + Math.imul(me, Le)) | 0),
        (M = (M + Math.imul(me, Ie)) | 0),
        (M = (M + Math.imul(ge, Le)) | 0),
        (D = (D + Math.imul(ge, Ie)) | 0),
        (P = (P + Math.imul(ee, Ae)) | 0),
        (M = (M + Math.imul(ee, Re)) | 0),
        (M = (M + Math.imul(ce, Ae)) | 0),
        (D = (D + Math.imul(ce, Re)) | 0),
        (P = (P + Math.imul($, $e)) | 0),
        (M = (M + Math.imul($, Ue)) | 0),
        (M = (M + Math.imul(W, $e)) | 0),
        (D = (D + Math.imul(W, Ue)) | 0),
        (P = (P + Math.imul(se, We)) | 0),
        (M = (M + Math.imul(se, je)) | 0),
        (M = (M + Math.imul(pe, We)) | 0),
        (D = (D + Math.imul(pe, je)) | 0),
        (P = (P + Math.imul(K, mt)) | 0),
        (M = (M + Math.imul(K, yt)) | 0),
        (M = (M + Math.imul(G, mt)) | 0),
        (D = (D + Math.imul(G, yt)) | 0);
      var Or = (((_ + P) | 0) + ((M & 8191) << 13)) | 0;
      (_ = (((D + (M >>> 13)) | 0) + (Or >>> 26)) | 0),
        (Or &= 67108863),
        (P = Math.imul(ie, Be)),
        (M = Math.imul(ie, De)),
        (M = (M + Math.imul(le, Be)) | 0),
        (D = Math.imul(le, De)),
        (P = (P + Math.imul(L, Oe)) | 0),
        (M = (M + Math.imul(L, Fe)) | 0),
        (M = (M + Math.imul(J, Oe)) | 0),
        (D = (D + Math.imul(J, Fe)) | 0),
        (P = (P + Math.imul(ve, Le)) | 0),
        (M = (M + Math.imul(ve, Ie)) | 0),
        (M = (M + Math.imul(z, Le)) | 0),
        (D = (D + Math.imul(z, Ie)) | 0),
        (P = (P + Math.imul(me, Ae)) | 0),
        (M = (M + Math.imul(me, Re)) | 0),
        (M = (M + Math.imul(ge, Ae)) | 0),
        (D = (D + Math.imul(ge, Re)) | 0),
        (P = (P + Math.imul(ee, $e)) | 0),
        (M = (M + Math.imul(ee, Ue)) | 0),
        (M = (M + Math.imul(ce, $e)) | 0),
        (D = (D + Math.imul(ce, Ue)) | 0),
        (P = (P + Math.imul($, We)) | 0),
        (M = (M + Math.imul($, je)) | 0),
        (M = (M + Math.imul(W, We)) | 0),
        (D = (D + Math.imul(W, je)) | 0),
        (P = (P + Math.imul(se, mt)) | 0),
        (M = (M + Math.imul(se, yt)) | 0),
        (M = (M + Math.imul(pe, mt)) | 0),
        (D = (D + Math.imul(pe, yt)) | 0);
      var Fr = (((_ + P) | 0) + ((M & 8191) << 13)) | 0;
      (_ = (((D + (M >>> 13)) | 0) + (Fr >>> 26)) | 0),
        (Fr &= 67108863),
        (P = Math.imul(ie, Oe)),
        (M = Math.imul(ie, Fe)),
        (M = (M + Math.imul(le, Oe)) | 0),
        (D = Math.imul(le, Fe)),
        (P = (P + Math.imul(L, Le)) | 0),
        (M = (M + Math.imul(L, Ie)) | 0),
        (M = (M + Math.imul(J, Le)) | 0),
        (D = (D + Math.imul(J, Ie)) | 0),
        (P = (P + Math.imul(ve, Ae)) | 0),
        (M = (M + Math.imul(ve, Re)) | 0),
        (M = (M + Math.imul(z, Ae)) | 0),
        (D = (D + Math.imul(z, Re)) | 0),
        (P = (P + Math.imul(me, $e)) | 0),
        (M = (M + Math.imul(me, Ue)) | 0),
        (M = (M + Math.imul(ge, $e)) | 0),
        (D = (D + Math.imul(ge, Ue)) | 0),
        (P = (P + Math.imul(ee, We)) | 0),
        (M = (M + Math.imul(ee, je)) | 0),
        (M = (M + Math.imul(ce, We)) | 0),
        (D = (D + Math.imul(ce, je)) | 0),
        (P = (P + Math.imul($, mt)) | 0),
        (M = (M + Math.imul($, yt)) | 0),
        (M = (M + Math.imul(W, mt)) | 0),
        (D = (D + Math.imul(W, yt)) | 0);
      var Lr = (((_ + P) | 0) + ((M & 8191) << 13)) | 0;
      (_ = (((D + (M >>> 13)) | 0) + (Lr >>> 26)) | 0),
        (Lr &= 67108863),
        (P = Math.imul(ie, Le)),
        (M = Math.imul(ie, Ie)),
        (M = (M + Math.imul(le, Le)) | 0),
        (D = Math.imul(le, Ie)),
        (P = (P + Math.imul(L, Ae)) | 0),
        (M = (M + Math.imul(L, Re)) | 0),
        (M = (M + Math.imul(J, Ae)) | 0),
        (D = (D + Math.imul(J, Re)) | 0),
        (P = (P + Math.imul(ve, $e)) | 0),
        (M = (M + Math.imul(ve, Ue)) | 0),
        (M = (M + Math.imul(z, $e)) | 0),
        (D = (D + Math.imul(z, Ue)) | 0),
        (P = (P + Math.imul(me, We)) | 0),
        (M = (M + Math.imul(me, je)) | 0),
        (M = (M + Math.imul(ge, We)) | 0),
        (D = (D + Math.imul(ge, je)) | 0),
        (P = (P + Math.imul(ee, mt)) | 0),
        (M = (M + Math.imul(ee, yt)) | 0),
        (M = (M + Math.imul(ce, mt)) | 0),
        (D = (D + Math.imul(ce, yt)) | 0);
      var bn = (((_ + P) | 0) + ((M & 8191) << 13)) | 0;
      (_ = (((D + (M >>> 13)) | 0) + (bn >>> 26)) | 0),
        (bn &= 67108863),
        (P = Math.imul(ie, Ae)),
        (M = Math.imul(ie, Re)),
        (M = (M + Math.imul(le, Ae)) | 0),
        (D = Math.imul(le, Re)),
        (P = (P + Math.imul(L, $e)) | 0),
        (M = (M + Math.imul(L, Ue)) | 0),
        (M = (M + Math.imul(J, $e)) | 0),
        (D = (D + Math.imul(J, Ue)) | 0),
        (P = (P + Math.imul(ve, We)) | 0),
        (M = (M + Math.imul(ve, je)) | 0),
        (M = (M + Math.imul(z, We)) | 0),
        (D = (D + Math.imul(z, je)) | 0),
        (P = (P + Math.imul(me, mt)) | 0),
        (M = (M + Math.imul(me, yt)) | 0),
        (M = (M + Math.imul(ge, mt)) | 0),
        (D = (D + Math.imul(ge, yt)) | 0);
      var vn = (((_ + P) | 0) + ((M & 8191) << 13)) | 0;
      (_ = (((D + (M >>> 13)) | 0) + (vn >>> 26)) | 0),
        (vn &= 67108863),
        (P = Math.imul(ie, $e)),
        (M = Math.imul(ie, Ue)),
        (M = (M + Math.imul(le, $e)) | 0),
        (D = Math.imul(le, Ue)),
        (P = (P + Math.imul(L, We)) | 0),
        (M = (M + Math.imul(L, je)) | 0),
        (M = (M + Math.imul(J, We)) | 0),
        (D = (D + Math.imul(J, je)) | 0),
        (P = (P + Math.imul(ve, mt)) | 0),
        (M = (M + Math.imul(ve, yt)) | 0),
        (M = (M + Math.imul(z, mt)) | 0),
        (D = (D + Math.imul(z, yt)) | 0);
      var ow = (((_ + P) | 0) + ((M & 8191) << 13)) | 0;
      (_ = (((D + (M >>> 13)) | 0) + (ow >>> 26)) | 0),
        (ow &= 67108863),
        (P = Math.imul(ie, We)),
        (M = Math.imul(ie, je)),
        (M = (M + Math.imul(le, We)) | 0),
        (D = Math.imul(le, je)),
        (P = (P + Math.imul(L, mt)) | 0),
        (M = (M + Math.imul(L, yt)) | 0),
        (M = (M + Math.imul(J, mt)) | 0),
        (D = (D + Math.imul(J, yt)) | 0);
      var cw = (((_ + P) | 0) + ((M & 8191) << 13)) | 0;
      (_ = (((D + (M >>> 13)) | 0) + (cw >>> 26)) | 0),
        (cw &= 67108863),
        (P = Math.imul(ie, mt)),
        (M = Math.imul(ie, yt)),
        (M = (M + Math.imul(le, mt)) | 0),
        (D = Math.imul(le, yt));
      var lw = (((_ + P) | 0) + ((M & 8191) << 13)) | 0;
      return (
        (_ = (((D + (M >>> 13)) | 0) + (lw >>> 26)) | 0),
        (lw &= 67108863),
        (f[0] = rr),
        (f[1] = nr),
        (f[2] = ir),
        (f[3] = ar),
        (f[4] = sr),
        (f[5] = Ir),
        (f[6] = Rr),
        (f[7] = Pr),
        (f[8] = Nr),
        (f[9] = Br),
        (f[10] = Dr),
        (f[11] = Or),
        (f[12] = Fr),
        (f[13] = Lr),
        (f[14] = bn),
        (f[15] = vn),
        (f[16] = ow),
        (f[17] = cw),
        (f[18] = lw),
        _ !== 0 && ((f[19] = _), T.length++),
        T
      );
    };
    Math.imul || (S = w);
    function k(y, h, g) {
      (g.negative = h.negative ^ y.negative), (g.length = y.length + h.length);
      for (var T = 0, R = 0, x = 0; x < g.length - 1; x++) {
        var f = R;
        R = 0;
        for (
          var _ = T & 67108863,
            P = Math.min(x, h.length - 1),
            M = Math.max(0, x - y.length + 1);
          M <= P;
          M++
        ) {
          var D = x - M,
            q = y.words[D] | 0,
            B = h.words[M] | 0,
            H = q * B,
            Q = H & 67108863;
          (f = (f + ((H / 67108864) | 0)) | 0),
            (Q = (Q + _) | 0),
            (_ = Q & 67108863),
            (f = (f + (Q >>> 26)) | 0),
            (R += f >>> 26),
            (f &= 67108863);
        }
        (g.words[x] = _), (T = f), (f = R);
      }
      return T !== 0 ? (g.words[x] = T) : g.length--, g._strip();
    }
    function N(y, h, g) {
      return k(y, h, g);
    }
    (a.prototype.mulTo = function (h, g) {
      var T,
        R = this.length + h.length;
      return (
        this.length === 10 && h.length === 10
          ? (T = S(this, h, g))
          : R < 63
          ? (T = w(this, h, g))
          : R < 1024
          ? (T = k(this, h, g))
          : (T = N(this, h, g)),
        T
      );
    }),
      (a.prototype.mul = function (h) {
        var g = new a(null);
        return (g.words = new Array(this.length + h.length)), this.mulTo(h, g);
      }),
      (a.prototype.mulf = function (h) {
        var g = new a(null);
        return (g.words = new Array(this.length + h.length)), N(this, h, g);
      }),
      (a.prototype.imul = function (h) {
        return this.clone().mulTo(h, this);
      }),
      (a.prototype.imuln = function (h) {
        var g = h < 0;
        g && (h = -h), n(typeof h == "number"), n(h < 67108864);
        for (var T = 0, R = 0; R < this.length; R++) {
          var x = (this.words[R] | 0) * h,
            f = (x & 67108863) + (T & 67108863);
          (T >>= 26),
            (T += (x / 67108864) | 0),
            (T += f >>> 26),
            (this.words[R] = f & 67108863);
        }
        return (
          T !== 0 && ((this.words[R] = T), this.length++),
          g ? this.ineg() : this
        );
      }),
      (a.prototype.muln = function (h) {
        return this.clone().imuln(h);
      }),
      (a.prototype.sqr = function () {
        return this.mul(this);
      }),
      (a.prototype.isqr = function () {
        return this.imul(this.clone());
      }),
      (a.prototype.pow = function (h) {
        var g = b(h);
        if (g.length === 0) return new a(1);
        for (var T = this, R = 0; R < g.length && g[R] === 0; R++, T = T.sqr());
        if (++R < g.length)
          for (var x = T.sqr(); R < g.length; R++, x = x.sqr())
            g[R] !== 0 && (T = T.mul(x));
        return T;
      }),
      (a.prototype.iushln = function (h) {
        n(typeof h == "number" && h >= 0);
        var g = h % 26,
          T = (h - g) / 26,
          R = (67108863 >>> (26 - g)) << (26 - g),
          x;
        if (g !== 0) {
          var f = 0;
          for (x = 0; x < this.length; x++) {
            var _ = this.words[x] & R,
              P = ((this.words[x] | 0) - _) << g;
            (this.words[x] = P | f), (f = _ >>> (26 - g));
          }
          f && ((this.words[x] = f), this.length++);
        }
        if (T !== 0) {
          for (x = this.length - 1; x >= 0; x--)
            this.words[x + T] = this.words[x];
          for (x = 0; x < T; x++) this.words[x] = 0;
          this.length += T;
        }
        return this._strip();
      }),
      (a.prototype.ishln = function (h) {
        return n(this.negative === 0), this.iushln(h);
      }),
      (a.prototype.iushrn = function (h, g, T) {
        n(typeof h == "number" && h >= 0);
        var R;
        g ? (R = (g - (g % 26)) / 26) : (R = 0);
        var x = h % 26,
          f = Math.min((h - x) / 26, this.length),
          _ = 67108863 ^ ((67108863 >>> x) << x),
          P = T;
        if (((R -= f), (R = Math.max(0, R)), P)) {
          for (var M = 0; M < f; M++) P.words[M] = this.words[M];
          P.length = f;
        }
        if (f !== 0)
          if (this.length > f)
            for (this.length -= f, M = 0; M < this.length; M++)
              this.words[M] = this.words[M + f];
          else (this.words[0] = 0), (this.length = 1);
        var D = 0;
        for (M = this.length - 1; M >= 0 && (D !== 0 || M >= R); M--) {
          var q = this.words[M] | 0;
          (this.words[M] = (D << (26 - x)) | (q >>> x)), (D = q & _);
        }
        return (
          P && D !== 0 && (P.words[P.length++] = D),
          this.length === 0 && ((this.words[0] = 0), (this.length = 1)),
          this._strip()
        );
      }),
      (a.prototype.ishrn = function (h, g, T) {
        return n(this.negative === 0), this.iushrn(h, g, T);
      }),
      (a.prototype.shln = function (h) {
        return this.clone().ishln(h);
      }),
      (a.prototype.ushln = function (h) {
        return this.clone().iushln(h);
      }),
      (a.prototype.shrn = function (h) {
        return this.clone().ishrn(h);
      }),
      (a.prototype.ushrn = function (h) {
        return this.clone().iushrn(h);
      }),
      (a.prototype.testn = function (h) {
        n(typeof h == "number" && h >= 0);
        var g = h % 26,
          T = (h - g) / 26,
          R = 1 << g;
        if (this.length <= T) return !1;
        var x = this.words[T];
        return !!(x & R);
      }),
      (a.prototype.imaskn = function (h) {
        n(typeof h == "number" && h >= 0);
        var g = h % 26,
          T = (h - g) / 26;
        if (
          (n(this.negative === 0, "imaskn works only with positive numbers"),
          this.length <= T)
        )
          return this;
        if (
          (g !== 0 && T++, (this.length = Math.min(T, this.length)), g !== 0)
        ) {
          var R = 67108863 ^ ((67108863 >>> g) << g);
          this.words[this.length - 1] &= R;
        }
        return this._strip();
      }),
      (a.prototype.maskn = function (h) {
        return this.clone().imaskn(h);
      }),
      (a.prototype.iaddn = function (h) {
        return (
          n(typeof h == "number"),
          n(h < 67108864),
          h < 0
            ? this.isubn(-h)
            : this.negative !== 0
            ? this.length === 1 && (this.words[0] | 0) <= h
              ? ((this.words[0] = h - (this.words[0] | 0)),
                (this.negative = 0),
                this)
              : ((this.negative = 0), this.isubn(h), (this.negative = 1), this)
            : this._iaddn(h)
        );
      }),
      (a.prototype._iaddn = function (h) {
        this.words[0] += h;
        for (var g = 0; g < this.length && this.words[g] >= 67108864; g++)
          (this.words[g] -= 67108864),
            g === this.length - 1
              ? (this.words[g + 1] = 1)
              : this.words[g + 1]++;
        return (this.length = Math.max(this.length, g + 1)), this;
      }),
      (a.prototype.isubn = function (h) {
        if ((n(typeof h == "number"), n(h < 67108864), h < 0))
          return this.iaddn(-h);
        if (this.negative !== 0)
          return (this.negative = 0), this.iaddn(h), (this.negative = 1), this;
        if (((this.words[0] -= h), this.length === 1 && this.words[0] < 0))
          (this.words[0] = -this.words[0]), (this.negative = 1);
        else
          for (var g = 0; g < this.length && this.words[g] < 0; g++)
            (this.words[g] += 67108864), (this.words[g + 1] -= 1);
        return this._strip();
      }),
      (a.prototype.addn = function (h) {
        return this.clone().iaddn(h);
      }),
      (a.prototype.subn = function (h) {
        return this.clone().isubn(h);
      }),
      (a.prototype.iabs = function () {
        return (this.negative = 0), this;
      }),
      (a.prototype.abs = function () {
        return this.clone().iabs();
      }),
      (a.prototype._ishlnsubmul = function (h, g, T) {
        var R = h.length + T,
          x;
        this._expand(R);
        var f,
          _ = 0;
        for (x = 0; x < h.length; x++) {
          f = (this.words[x + T] | 0) + _;
          var P = (h.words[x] | 0) * g;
          (f -= P & 67108863),
            (_ = (f >> 26) - ((P / 67108864) | 0)),
            (this.words[x + T] = f & 67108863);
        }
        for (; x < this.length - T; x++)
          (f = (this.words[x + T] | 0) + _),
            (_ = f >> 26),
            (this.words[x + T] = f & 67108863);
        if (_ === 0) return this._strip();
        for (n(_ === -1), _ = 0, x = 0; x < this.length; x++)
          (f = -(this.words[x] | 0) + _),
            (_ = f >> 26),
            (this.words[x] = f & 67108863);
        return (this.negative = 1), this._strip();
      }),
      (a.prototype._wordDiv = function (h, g) {
        var T = this.length - h.length,
          R = this.clone(),
          x = h,
          f = x.words[x.length - 1] | 0,
          _ = this._countBits(f);
        (T = 26 - _),
          T !== 0 &&
            ((x = x.ushln(T)), R.iushln(T), (f = x.words[x.length - 1] | 0));
        var P = R.length - x.length,
          M;
        if (g !== "mod") {
          (M = new a(null)),
            (M.length = P + 1),
            (M.words = new Array(M.length));
          for (var D = 0; D < M.length; D++) M.words[D] = 0;
        }
        var q = R.clone()._ishlnsubmul(x, 1, P);
        q.negative === 0 && ((R = q), M && (M.words[P] = 1));
        for (var B = P - 1; B >= 0; B--) {
          var H =
            (R.words[x.length + B] | 0) * 67108864 +
            (R.words[x.length + B - 1] | 0);
          for (
            H = Math.min((H / f) | 0, 67108863), R._ishlnsubmul(x, H, B);
            R.negative !== 0;

          )
            H--,
              (R.negative = 0),
              R._ishlnsubmul(x, 1, B),
              R.isZero() || (R.negative ^= 1);
          M && (M.words[B] = H);
        }
        return (
          M && M._strip(),
          R._strip(),
          g !== "div" && T !== 0 && R.iushrn(T),
          {
            div: M || null,
            mod: R,
          }
        );
      }),
      (a.prototype.divmod = function (h, g, T) {
        if ((n(!h.isZero()), this.isZero()))
          return {
            div: new a(0),
            mod: new a(0),
          };
        var R, x, f;
        return this.negative !== 0 && h.negative === 0
          ? ((f = this.neg().divmod(h, g)),
            g !== "mod" && (R = f.div.neg()),
            g !== "div" &&
              ((x = f.mod.neg()), T && x.negative !== 0 && x.iadd(h)),
            {
              div: R,
              mod: x,
            })
          : this.negative === 0 && h.negative !== 0
          ? ((f = this.divmod(h.neg(), g)),
            g !== "mod" && (R = f.div.neg()),
            {
              div: R,
              mod: f.mod,
            })
          : this.negative & h.negative
          ? ((f = this.neg().divmod(h.neg(), g)),
            g !== "div" &&
              ((x = f.mod.neg()), T && x.negative !== 0 && x.isub(h)),
            {
              div: f.div,
              mod: x,
            })
          : h.length > this.length || this.cmp(h) < 0
          ? {
              div: new a(0),
              mod: this,
            }
          : h.length === 1
          ? g === "div"
            ? {
                div: this.divn(h.words[0]),
                mod: null,
              }
            : g === "mod"
            ? {
                div: null,
                mod: new a(this.modrn(h.words[0])),
              }
            : {
                div: this.divn(h.words[0]),
                mod: new a(this.modrn(h.words[0])),
              }
          : this._wordDiv(h, g);
      }),
      (a.prototype.div = function (h) {
        return this.divmod(h, "div", !1).div;
      }),
      (a.prototype.mod = function (h) {
        return this.divmod(h, "mod", !1).mod;
      }),
      (a.prototype.umod = function (h) {
        return this.divmod(h, "mod", !0).mod;
      }),
      (a.prototype.divRound = function (h) {
        var g = this.divmod(h);
        if (g.mod.isZero()) return g.div;
        var T = g.div.negative !== 0 ? g.mod.isub(h) : g.mod,
          R = h.ushrn(1),
          x = h.andln(1),
          f = T.cmp(R);
        return f < 0 || (x === 1 && f === 0)
          ? g.div
          : g.div.negative !== 0
          ? g.div.isubn(1)
          : g.div.iaddn(1);
      }),
      (a.prototype.modrn = function (h) {
        var g = h < 0;
        g && (h = -h), n(h <= 67108863);
        for (var T = (1 << 26) % h, R = 0, x = this.length - 1; x >= 0; x--)
          R = (T * R + (this.words[x] | 0)) % h;
        return g ? -R : R;
      }),
      (a.prototype.modn = function (h) {
        return this.modrn(h);
      }),
      (a.prototype.idivn = function (h) {
        var g = h < 0;
        g && (h = -h), n(h <= 67108863);
        for (var T = 0, R = this.length - 1; R >= 0; R--) {
          var x = (this.words[R] | 0) + T * 67108864;
          (this.words[R] = (x / h) | 0), (T = x % h);
        }
        return this._strip(), g ? this.ineg() : this;
      }),
      (a.prototype.divn = function (h) {
        return this.clone().idivn(h);
      }),
      (a.prototype.egcd = function (h) {
        n(h.negative === 0), n(!h.isZero());
        var g = this,
          T = h.clone();
        g.negative !== 0 ? (g = g.umod(h)) : (g = g.clone());
        for (
          var R = new a(1), x = new a(0), f = new a(0), _ = new a(1), P = 0;
          g.isEven() && T.isEven();

        )
          g.iushrn(1), T.iushrn(1), ++P;
        for (var M = T.clone(), D = g.clone(); !g.isZero(); ) {
          for (var q = 0, B = 1; !(g.words[0] & B) && q < 26; ++q, B <<= 1);
          if (q > 0)
            for (g.iushrn(q); q-- > 0; )
              (R.isOdd() || x.isOdd()) && (R.iadd(M), x.isub(D)),
                R.iushrn(1),
                x.iushrn(1);
          for (var H = 0, Q = 1; !(T.words[0] & Q) && H < 26; ++H, Q <<= 1);
          if (H > 0)
            for (T.iushrn(H); H-- > 0; )
              (f.isOdd() || _.isOdd()) && (f.iadd(M), _.isub(D)),
                f.iushrn(1),
                _.iushrn(1);
          g.cmp(T) >= 0
            ? (g.isub(T), R.isub(f), x.isub(_))
            : (T.isub(g), f.isub(R), _.isub(x));
        }
        return {
          a: f,
          b: _,
          gcd: T.iushln(P),
        };
      }),
      (a.prototype._invmp = function (h) {
        n(h.negative === 0), n(!h.isZero());
        var g = this,
          T = h.clone();
        g.negative !== 0 ? (g = g.umod(h)) : (g = g.clone());
        for (
          var R = new a(1), x = new a(0), f = T.clone();
          g.cmpn(1) > 0 && T.cmpn(1) > 0;

        ) {
          for (var _ = 0, P = 1; !(g.words[0] & P) && _ < 26; ++_, P <<= 1);
          if (_ > 0)
            for (g.iushrn(_); _-- > 0; ) R.isOdd() && R.iadd(f), R.iushrn(1);
          for (var M = 0, D = 1; !(T.words[0] & D) && M < 26; ++M, D <<= 1);
          if (M > 0)
            for (T.iushrn(M); M-- > 0; ) x.isOdd() && x.iadd(f), x.iushrn(1);
          g.cmp(T) >= 0 ? (g.isub(T), R.isub(x)) : (T.isub(g), x.isub(R));
        }
        var q;
        return (
          g.cmpn(1) === 0 ? (q = R) : (q = x), q.cmpn(0) < 0 && q.iadd(h), q
        );
      }),
      (a.prototype.gcd = function (h) {
        if (this.isZero()) return h.abs();
        if (h.isZero()) return this.abs();
        var g = this.clone(),
          T = h.clone();
        (g.negative = 0), (T.negative = 0);
        for (var R = 0; g.isEven() && T.isEven(); R++) g.iushrn(1), T.iushrn(1);
        do {
          for (; g.isEven(); ) g.iushrn(1);
          for (; T.isEven(); ) T.iushrn(1);
          var x = g.cmp(T);
          if (x < 0) {
            var f = g;
            (g = T), (T = f);
          } else if (x === 0 || T.cmpn(1) === 0) break;
          g.isub(T);
        } while (!0);
        return T.iushln(R);
      }),
      (a.prototype.invm = function (h) {
        return this.egcd(h).a.umod(h);
      }),
      (a.prototype.isEven = function () {
        return (this.words[0] & 1) === 0;
      }),
      (a.prototype.isOdd = function () {
        return (this.words[0] & 1) === 1;
      }),
      (a.prototype.andln = function (h) {
        return this.words[0] & h;
      }),
      (a.prototype.bincn = function (h) {
        n(typeof h == "number");
        var g = h % 26,
          T = (h - g) / 26,
          R = 1 << g;
        if (this.length <= T)
          return this._expand(T + 1), (this.words[T] |= R), this;
        for (var x = R, f = T; x !== 0 && f < this.length; f++) {
          var _ = this.words[f] | 0;
          (_ += x), (x = _ >>> 26), (_ &= 67108863), (this.words[f] = _);
        }
        return x !== 0 && ((this.words[f] = x), this.length++), this;
      }),
      (a.prototype.isZero = function () {
        return this.length === 1 && this.words[0] === 0;
      }),
      (a.prototype.cmpn = function (h) {
        var g = h < 0;
        if (this.negative !== 0 && !g) return -1;
        if (this.negative === 0 && g) return 1;
        this._strip();
        var T;
        if (this.length > 1) T = 1;
        else {
          g && (h = -h), n(h <= 67108863, "Number is too big");
          var R = this.words[0] | 0;
          T = R === h ? 0 : R < h ? -1 : 1;
        }
        return this.negative !== 0 ? -T | 0 : T;
      }),
      (a.prototype.cmp = function (h) {
        if (this.negative !== 0 && h.negative === 0) return -1;
        if (this.negative === 0 && h.negative !== 0) return 1;
        var g = this.ucmp(h);
        return this.negative !== 0 ? -g | 0 : g;
      }),
      (a.prototype.ucmp = function (h) {
        if (this.length > h.length) return 1;
        if (this.length < h.length) return -1;
        for (var g = 0, T = this.length - 1; T >= 0; T--) {
          var R = this.words[T] | 0,
            x = h.words[T] | 0;
          if (R !== x) {
            R < x ? (g = -1) : R > x && (g = 1);
            break;
          }
        }
        return g;
      }),
      (a.prototype.gtn = function (h) {
        return this.cmpn(h) === 1;
      }),
      (a.prototype.gt = function (h) {
        return this.cmp(h) === 1;
      }),
      (a.prototype.gten = function (h) {
        return this.cmpn(h) >= 0;
      }),
      (a.prototype.gte = function (h) {
        return this.cmp(h) >= 0;
      }),
      (a.prototype.ltn = function (h) {
        return this.cmpn(h) === -1;
      }),
      (a.prototype.lt = function (h) {
        return this.cmp(h) === -1;
      }),
      (a.prototype.lten = function (h) {
        return this.cmpn(h) <= 0;
      }),
      (a.prototype.lte = function (h) {
        return this.cmp(h) <= 0;
      }),
      (a.prototype.eqn = function (h) {
        return this.cmpn(h) === 0;
      }),
      (a.prototype.eq = function (h) {
        return this.cmp(h) === 0;
      }),
      (a.red = function (h) {
        return new l(h);
      }),
      (a.prototype.toRed = function (h) {
        return (
          n(!this.red, "Already a number in reduction context"),
          n(this.negative === 0, "red works only with positives"),
          h.convertTo(this)._forceRed(h)
        );
      }),
      (a.prototype.fromRed = function () {
        return (
          n(this.red, "fromRed works only with numbers in reduction context"),
          this.red.convertFrom(this)
        );
      }),
      (a.prototype._forceRed = function (h) {
        return (this.red = h), this;
      }),
      (a.prototype.forceRed = function (h) {
        return (
          n(!this.red, "Already a number in reduction context"),
          this._forceRed(h)
        );
      }),
      (a.prototype.redAdd = function (h) {
        return (
          n(this.red, "redAdd works only with red numbers"),
          this.red.add(this, h)
        );
      }),
      (a.prototype.redIAdd = function (h) {
        return (
          n(this.red, "redIAdd works only with red numbers"),
          this.red.iadd(this, h)
        );
      }),
      (a.prototype.redSub = function (h) {
        return (
          n(this.red, "redSub works only with red numbers"),
          this.red.sub(this, h)
        );
      }),
      (a.prototype.redISub = function (h) {
        return (
          n(this.red, "redISub works only with red numbers"),
          this.red.isub(this, h)
        );
      }),
      (a.prototype.redShl = function (h) {
        return (
          n(this.red, "redShl works only with red numbers"),
          this.red.shl(this, h)
        );
      }),
      (a.prototype.redMul = function (h) {
        return (
          n(this.red, "redMul works only with red numbers"),
          this.red._verify2(this, h),
          this.red.mul(this, h)
        );
      }),
      (a.prototype.redIMul = function (h) {
        return (
          n(this.red, "redMul works only with red numbers"),
          this.red._verify2(this, h),
          this.red.imul(this, h)
        );
      }),
      (a.prototype.redSqr = function () {
        return (
          n(this.red, "redSqr works only with red numbers"),
          this.red._verify1(this),
          this.red.sqr(this)
        );
      }),
      (a.prototype.redISqr = function () {
        return (
          n(this.red, "redISqr works only with red numbers"),
          this.red._verify1(this),
          this.red.isqr(this)
        );
      }),
      (a.prototype.redSqrt = function () {
        return (
          n(this.red, "redSqrt works only with red numbers"),
          this.red._verify1(this),
          this.red.sqrt(this)
        );
      }),
      (a.prototype.redInvm = function () {
        return (
          n(this.red, "redInvm works only with red numbers"),
          this.red._verify1(this),
          this.red.invm(this)
        );
      }),
      (a.prototype.redNeg = function () {
        return (
          n(this.red, "redNeg works only with red numbers"),
          this.red._verify1(this),
          this.red.neg(this)
        );
      }),
      (a.prototype.redPow = function (h) {
        return (
          n(this.red && !h.red, "redPow(normalNum)"),
          this.red._verify1(this),
          this.red.pow(this, h)
        );
      });
    var O = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null,
    };
    function F(y, h) {
      (this.name = y),
        (this.p = new a(h, 16)),
        (this.n = this.p.bitLength()),
        (this.k = new a(1).iushln(this.n).isub(this.p)),
        (this.tmp = this._tmp());
    }
    (F.prototype._tmp = function () {
      var h = new a(null);
      return (h.words = new Array(Math.ceil(this.n / 13))), h;
    }),
      (F.prototype.ireduce = function (h) {
        var g = h,
          T;
        do
          this.split(g, this.tmp),
            (g = this.imulK(g)),
            (g = g.iadd(this.tmp)),
            (T = g.bitLength());
        while (T > this.n);
        var R = T < this.n ? -1 : g.ucmp(this.p);
        return (
          R === 0
            ? ((g.words[0] = 0), (g.length = 1))
            : R > 0
            ? g.isub(this.p)
            : g.strip !== void 0
            ? g.strip()
            : g._strip(),
          g
        );
      }),
      (F.prototype.split = function (h, g) {
        h.iushrn(this.n, 0, g);
      }),
      (F.prototype.imulK = function (h) {
        return h.imul(this.k);
      });
    function V() {
      F.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    i(V, F),
      (V.prototype.split = function (h, g) {
        for (var T = 4194303, R = Math.min(h.length, 9), x = 0; x < R; x++)
          g.words[x] = h.words[x];
        if (((g.length = R), h.length <= 9)) {
          (h.words[0] = 0), (h.length = 1);
          return;
        }
        var f = h.words[9];
        for (g.words[g.length++] = f & T, x = 10; x < h.length; x++) {
          var _ = h.words[x] | 0;
          (h.words[x - 10] = ((_ & T) << 4) | (f >>> 22)), (f = _);
        }
        (f >>>= 22),
          (h.words[x - 10] = f),
          f === 0 && h.length > 10 ? (h.length -= 10) : (h.length -= 9);
      }),
      (V.prototype.imulK = function (h) {
        (h.words[h.length] = 0), (h.words[h.length + 1] = 0), (h.length += 2);
        for (var g = 0, T = 0; T < h.length; T++) {
          var R = h.words[T] | 0;
          (g += R * 977),
            (h.words[T] = g & 67108863),
            (g = R * 64 + ((g / 67108864) | 0));
        }
        return (
          h.words[h.length - 1] === 0 &&
            (h.length--, h.words[h.length - 1] === 0 && h.length--),
          h
        );
      });
    function j() {
      F.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    i(j, F);
    function X() {
      F.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    i(X, F);
    function C() {
      F.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    i(C, F),
      (C.prototype.imulK = function (h) {
        for (var g = 0, T = 0; T < h.length; T++) {
          var R = (h.words[T] | 0) * 19 + g,
            x = R & 67108863;
          (R >>>= 26), (h.words[T] = x), (g = R);
        }
        return g !== 0 && (h.words[h.length++] = g), h;
      }),
      (a._prime = function (h) {
        if (O[h]) return O[h];
        var g;
        if (h === "k256") g = new V();
        else if (h === "p224") g = new j();
        else if (h === "p192") g = new X();
        else if (h === "p25519") g = new C();
        else throw new Error("Unknown prime " + h);
        return (O[h] = g), g;
      });
    function l(y) {
      if (typeof y == "string") {
        var h = a._prime(y);
        (this.m = h.p), (this.prime = h);
      } else
        n(y.gtn(1), "modulus must be greater than 1"),
          (this.m = y),
          (this.prime = null);
    }
    (l.prototype._verify1 = function (h) {
      n(h.negative === 0, "red works only with positives"),
        n(h.red, "red works only with red numbers");
    }),
      (l.prototype._verify2 = function (h, g) {
        n((h.negative | g.negative) === 0, "red works only with positives"),
          n(h.red && h.red === g.red, "red works only with red numbers");
      }),
      (l.prototype.imod = function (h) {
        return this.prime
          ? this.prime.ireduce(h)._forceRed(this)
          : (d(h, h.umod(this.m)._forceRed(this)), h);
      }),
      (l.prototype.neg = function (h) {
        return h.isZero() ? h.clone() : this.m.sub(h)._forceRed(this);
      }),
      (l.prototype.add = function (h, g) {
        this._verify2(h, g);
        var T = h.add(g);
        return T.cmp(this.m) >= 0 && T.isub(this.m), T._forceRed(this);
      }),
      (l.prototype.iadd = function (h, g) {
        this._verify2(h, g);
        var T = h.iadd(g);
        return T.cmp(this.m) >= 0 && T.isub(this.m), T;
      }),
      (l.prototype.sub = function (h, g) {
        this._verify2(h, g);
        var T = h.sub(g);
        return T.cmpn(0) < 0 && T.iadd(this.m), T._forceRed(this);
      }),
      (l.prototype.isub = function (h, g) {
        this._verify2(h, g);
        var T = h.isub(g);
        return T.cmpn(0) < 0 && T.iadd(this.m), T;
      }),
      (l.prototype.shl = function (h, g) {
        return this._verify1(h), this.imod(h.ushln(g));
      }),
      (l.prototype.imul = function (h, g) {
        return this._verify2(h, g), this.imod(h.imul(g));
      }),
      (l.prototype.mul = function (h, g) {
        return this._verify2(h, g), this.imod(h.mul(g));
      }),
      (l.prototype.isqr = function (h) {
        return this.imul(h, h.clone());
      }),
      (l.prototype.sqr = function (h) {
        return this.mul(h, h);
      }),
      (l.prototype.sqrt = function (h) {
        if (h.isZero()) return h.clone();
        var g = this.m.andln(3);
        if ((n(g % 2 === 1), g === 3)) {
          var T = this.m.add(new a(1)).iushrn(2);
          return this.pow(h, T);
        }
        for (var R = this.m.subn(1), x = 0; !R.isZero() && R.andln(1) === 0; )
          x++, R.iushrn(1);
        n(!R.isZero());
        var f = new a(1).toRed(this),
          _ = f.redNeg(),
          P = this.m.subn(1).iushrn(1),
          M = this.m.bitLength();
        for (M = new a(2 * M * M).toRed(this); this.pow(M, P).cmp(_) !== 0; )
          M.redIAdd(_);
        for (
          var D = this.pow(M, R),
            q = this.pow(h, R.addn(1).iushrn(1)),
            B = this.pow(h, R),
            H = x;
          B.cmp(f) !== 0;

        ) {
          for (var Q = B, Z = 0; Q.cmp(f) !== 0; Z++) Q = Q.redSqr();
          n(Z < H);
          var te = this.pow(D, new a(1).iushln(H - Z - 1));
          (q = q.redMul(te)), (D = te.redSqr()), (B = B.redMul(D)), (H = Z);
        }
        return q;
      }),
      (l.prototype.invm = function (h) {
        var g = h._invmp(this.m);
        return g.negative !== 0
          ? ((g.negative = 0), this.imod(g).redNeg())
          : this.imod(g);
      }),
      (l.prototype.pow = function (h, g) {
        if (g.isZero()) return new a(1).toRed(this);
        if (g.cmpn(1) === 0) return h.clone();
        var T = 4,
          R = new Array(1 << T);
        (R[0] = new a(1).toRed(this)), (R[1] = h);
        for (var x = 2; x < R.length; x++) R[x] = this.mul(R[x - 1], h);
        var f = R[0],
          _ = 0,
          P = 0,
          M = g.bitLength() % 26;
        for (M === 0 && (M = 26), x = g.length - 1; x >= 0; x--) {
          for (var D = g.words[x], q = M - 1; q >= 0; q--) {
            var B = (D >> q) & 1;
            if ((f !== R[0] && (f = this.sqr(f)), B === 0 && _ === 0)) {
              P = 0;
              continue;
            }
            (_ <<= 1),
              (_ |= B),
              P++,
              !(P !== T && (x !== 0 || q !== 0)) &&
                ((f = this.mul(f, R[_])), (P = 0), (_ = 0));
          }
          M = 26;
        }
        return f;
      }),
      (l.prototype.convertTo = function (h) {
        var g = h.umod(this.m);
        return g === h ? g.clone() : g;
      }),
      (l.prototype.convertFrom = function (h) {
        var g = h.clone();
        return (g.red = null), g;
      }),
      (a.mont = function (h) {
        return new p(h);
      });
    function p(y) {
      l.call(this, y),
        (this.shift = this.m.bitLength()),
        this.shift % 26 !== 0 && (this.shift += 26 - (this.shift % 26)),
        (this.r = new a(1).iushln(this.shift)),
        (this.r2 = this.imod(this.r.sqr())),
        (this.rinv = this.r._invmp(this.m)),
        (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
        (this.minv = this.minv.umod(this.r)),
        (this.minv = this.r.sub(this.minv));
    }
    i(p, l),
      (p.prototype.convertTo = function (h) {
        return this.imod(h.ushln(this.shift));
      }),
      (p.prototype.convertFrom = function (h) {
        var g = this.imod(h.mul(this.rinv));
        return (g.red = null), g;
      }),
      (p.prototype.imul = function (h, g) {
        if (h.isZero() || g.isZero())
          return (h.words[0] = 0), (h.length = 1), h;
        var T = h.imul(g),
          R = T.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
          x = T.isub(R).iushrn(this.shift),
          f = x;
        return (
          x.cmp(this.m) >= 0
            ? (f = x.isub(this.m))
            : x.cmpn(0) < 0 && (f = x.iadd(this.m)),
          f._forceRed(this)
        );
      }),
      (p.prototype.mul = function (h, g) {
        if (h.isZero() || g.isZero()) return new a(0)._forceRed(this);
        var T = h.mul(g),
          R = T.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
          x = T.isub(R).iushrn(this.shift),
          f = x;
        return (
          x.cmp(this.m) >= 0
            ? (f = x.isub(this.m))
            : x.cmpn(0) < 0 && (f = x.iadd(this.m)),
          f._forceRed(this)
        );
      }),
      (p.prototype.invm = function (h) {
        var g = this.imod(h._invmp(this.m).mul(this.r2));
        return g._forceRed(this);
      });
  })(t, ke);
})(W8);
var Nm = W8.exports;
const pt = mn(Nm),
  GJ = "logger/5.7.0";
let ak = !1,
  sk = !1;
const zy = {
  debug: 1,
  default: 2,
  info: 2,
  warning: 3,
  error: 4,
  off: 5,
};
let ok = zy.default,
  Uw = null;
function ZJ() {
  try {
    const t = [];
    if (
      (["NFD", "NFC", "NFKD", "NFKC"].forEach((e) => {
        try {
          if ("test".normalize(e) !== "test") throw new Error("bad normalize");
        } catch {
          t.push(e);
        }
      }),
      t.length)
    )
      throw new Error("missing " + t.join(", "));
    if ("é".normalize("NFD") !== "é") throw new Error("broken implementation");
  } catch (t) {
    return t.message;
  }
  return null;
}
const ck = ZJ();
var zg;
(function (t) {
  (t.DEBUG = "DEBUG"),
    (t.INFO = "INFO"),
    (t.WARNING = "WARNING"),
    (t.ERROR = "ERROR"),
    (t.OFF = "OFF");
})(zg || (zg = {}));
var Ra;
(function (t) {
  (t.UNKNOWN_ERROR = "UNKNOWN_ERROR"),
    (t.NOT_IMPLEMENTED = "NOT_IMPLEMENTED"),
    (t.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION"),
    (t.NETWORK_ERROR = "NETWORK_ERROR"),
    (t.SERVER_ERROR = "SERVER_ERROR"),
    (t.TIMEOUT = "TIMEOUT"),
    (t.BUFFER_OVERRUN = "BUFFER_OVERRUN"),
    (t.NUMERIC_FAULT = "NUMERIC_FAULT"),
    (t.MISSING_NEW = "MISSING_NEW"),
    (t.INVALID_ARGUMENT = "INVALID_ARGUMENT"),
    (t.MISSING_ARGUMENT = "MISSING_ARGUMENT"),
    (t.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT"),
    (t.CALL_EXCEPTION = "CALL_EXCEPTION"),
    (t.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS"),
    (t.NONCE_EXPIRED = "NONCE_EXPIRED"),
    (t.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED"),
    (t.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT"),
    (t.TRANSACTION_REPLACED = "TRANSACTION_REPLACED"),
    (t.ACTION_REJECTED = "ACTION_REJECTED");
})(Ra || (Ra = {}));
const lk = "0123456789abcdef";
class ue {
  constructor(e) {
    Object.defineProperty(this, "version", {
      enumerable: !0,
      value: e,
      writable: !1,
    });
  }
  _log(e, r) {
    const n = e.toLowerCase();
    zy[n] == null &&
      this.throwArgumentError("invalid log level name", "logLevel", e),
      !(ok > zy[n]) && console.log.apply(console, r);
  }
  debug(...e) {
    this._log(ue.levels.DEBUG, e);
  }
  info(...e) {
    this._log(ue.levels.INFO, e);
  }
  warn(...e) {
    this._log(ue.levels.WARNING, e);
  }
  makeError(e, r, n) {
    if (sk) return this.makeError("censored error", r, {});
    r || (r = ue.errors.UNKNOWN_ERROR), n || (n = {});
    const i = [];
    Object.keys(n).forEach((c) => {
      const u = n[c];
      try {
        if (u instanceof Uint8Array) {
          let d = "";
          for (let m = 0; m < u.length; m++)
            (d += lk[u[m] >> 4]), (d += lk[u[m] & 15]);
          i.push(c + "=Uint8Array(0x" + d + ")");
        } else i.push(c + "=" + JSON.stringify(u));
      } catch {
        i.push(c + "=" + JSON.stringify(n[c].toString()));
      }
    }),
      i.push(`code=${r}`),
      i.push(`version=${this.version}`);
    const a = e;
    let s = "";
    switch (r) {
      case Ra.NUMERIC_FAULT: {
        s = "NUMERIC_FAULT";
        const c = e;
        switch (c) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            s += "-" + c;
            break;
          case "negative-power":
          case "negative-width":
            s += "-unsupported";
            break;
          case "unbound-bitwise-result":
            s += "-unbound-result";
            break;
        }
        break;
      }
      case Ra.CALL_EXCEPTION:
      case Ra.INSUFFICIENT_FUNDS:
      case Ra.MISSING_NEW:
      case Ra.NONCE_EXPIRED:
      case Ra.REPLACEMENT_UNDERPRICED:
      case Ra.TRANSACTION_REPLACED:
      case Ra.UNPREDICTABLE_GAS_LIMIT:
        s = r;
        break;
    }
    s && (e += " [ See: https://links.ethers.org/v5-errors-" + s + " ]"),
      i.length && (e += " (" + i.join(", ") + ")");
    const o = new Error(e);
    return (
      (o.reason = a),
      (o.code = r),
      Object.keys(n).forEach(function (c) {
        o[c] = n[c];
      }),
      o
    );
  }
  throwError(e, r, n) {
    throw this.makeError(e, r, n);
  }
  throwArgumentError(e, r, n) {
    return this.throwError(e, ue.errors.INVALID_ARGUMENT, {
      argument: r,
      value: n,
    });
  }
  assert(e, r, n, i) {
    e || this.throwError(r, n, i);
  }
  assertArgument(e, r, n, i) {
    e || this.throwArgumentError(r, n, i);
  }
  checkNormalize(e) {
    ck &&
      this.throwError(
        "platform missing String.prototype.normalize",
        ue.errors.UNSUPPORTED_OPERATION,
        {
          operation: "String.prototype.normalize",
          form: ck,
        }
      );
  }
  checkSafeUint53(e, r) {
    typeof e == "number" &&
      (r == null && (r = "value not safe"),
      (e < 0 || e >= 9007199254740991) &&
        this.throwError(r, ue.errors.NUMERIC_FAULT, {
          operation: "checkSafeInteger",
          fault: "out-of-safe-range",
          value: e,
        }),
      e % 1 &&
        this.throwError(r, ue.errors.NUMERIC_FAULT, {
          operation: "checkSafeInteger",
          fault: "non-integer",
          value: e,
        }));
  }
  checkArgumentCount(e, r, n) {
    n ? (n = ": " + n) : (n = ""),
      e < r &&
        this.throwError("missing argument" + n, ue.errors.MISSING_ARGUMENT, {
          count: e,
          expectedCount: r,
        }),
      e > r &&
        this.throwError(
          "too many arguments" + n,
          ue.errors.UNEXPECTED_ARGUMENT,
          {
            count: e,
            expectedCount: r,
          }
        );
  }
  checkNew(e, r) {
    (e === Object || e == null) &&
      this.throwError("missing new", ue.errors.MISSING_NEW, {
        name: r.name,
      });
  }
  checkAbstract(e, r) {
    e === r
      ? this.throwError(
          "cannot instantiate abstract class " +
            JSON.stringify(r.name) +
            " directly; use a sub-class",
          ue.errors.UNSUPPORTED_OPERATION,
          {
            name: e.name,
            operation: "new",
          }
        )
      : (e === Object || e == null) &&
        this.throwError("missing new", ue.errors.MISSING_NEW, {
          name: r.name,
        });
  }
  static globalLogger() {
    return Uw || (Uw = new ue(GJ)), Uw;
  }
  static setCensorship(e, r) {
    if (
      (!e &&
        r &&
        this.globalLogger().throwError(
          "cannot permanently disable censorship",
          ue.errors.UNSUPPORTED_OPERATION,
          {
            operation: "setCensorship",
          }
        ),
      ak)
    ) {
      if (!e) return;
      this.globalLogger().throwError(
        "error censorship permanent",
        ue.errors.UNSUPPORTED_OPERATION,
        {
          operation: "setCensorship",
        }
      );
    }
    (sk = !!e), (ak = !!r);
  }
  static setLogLevel(e) {
    const r = zy[e.toLowerCase()];
    if (r == null) {
      ue.globalLogger().warn("invalid log level - " + e);
      return;
    }
    ok = r;
  }
  static from(e) {
    return new ue(e);
  }
}
ue.errors = Ra;
ue.levels = zg;
const JJ = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        get ErrorCode() {
          return Ra;
        },
        get LogLevel() {
          return zg;
        },
        Logger: ue,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  QJ = "bytes/5.7.0",
  Xr = new ue(QJ);
function cB(t) {
  return !!t.toHexString;
}
function V0(t) {
  return (
    t.slice ||
      (t.slice = function () {
        const e = Array.prototype.slice.call(arguments);
        return V0(new Uint8Array(Array.prototype.slice.apply(t, e)));
      }),
    t
  );
}
function Bm(t) {
  return (gt(t) && !(t.length % 2)) || hl(t);
}
function uk(t) {
  return typeof t == "number" && t == t && t % 1 === 0;
}
function hl(t) {
  if (t == null) return !1;
  if (t.constructor === Uint8Array) return !0;
  if (typeof t == "string" || !uk(t.length) || t.length < 0) return !1;
  for (let e = 0; e < t.length; e++) {
    const r = t[e];
    if (!uk(r) || r < 0 || r >= 256) return !1;
  }
  return !0;
}
function qe(t, e) {
  if ((e || (e = {}), typeof t == "number")) {
    Xr.checkSafeUint53(t, "invalid arrayify value");
    const r = [];
    for (; t; ) r.unshift(t & 255), (t = parseInt(String(t / 256)));
    return r.length === 0 && r.push(0), V0(new Uint8Array(r));
  }
  if (
    (e.allowMissingPrefix &&
      typeof t == "string" &&
      t.substring(0, 2) !== "0x" &&
      (t = "0x" + t),
    cB(t) && (t = t.toHexString()),
    gt(t))
  ) {
    let r = t.substring(2);
    r.length % 2 &&
      (e.hexPad === "left"
        ? (r = "0" + r)
        : e.hexPad === "right"
        ? (r += "0")
        : Xr.throwArgumentError("hex data is odd-length", "value", t));
    const n = [];
    for (let i = 0; i < r.length; i += 2)
      n.push(parseInt(r.substring(i, i + 2), 16));
    return V0(new Uint8Array(n));
  }
  return hl(t)
    ? V0(new Uint8Array(t))
    : Xr.throwArgumentError("invalid arrayify value", "value", t);
}
function cr(t) {
  const e = t.map((i) => qe(i)),
    r = e.reduce((i, a) => i + a.length, 0),
    n = new Uint8Array(r);
  return e.reduce((i, a) => (n.set(a, i), i + a.length), 0), V0(n);
}
function zi(t) {
  let e = qe(t);
  if (e.length === 0) return e;
  let r = 0;
  for (; r < e.length && e[r] === 0; ) r++;
  return r && (e = e.slice(r)), e;
}
function Dh(t, e) {
  (t = qe(t)),
    t.length > e &&
      Xr.throwArgumentError("value out of range", "value", arguments[0]);
  const r = new Uint8Array(e);
  return r.set(t, e - t.length), V0(r);
}
function gt(t, e) {
  return !(
    typeof t != "string" ||
    !t.match(/^0x[0-9A-Fa-f]*$/) ||
    (e && t.length !== 2 + 2 * e)
  );
}
const Ww = "0123456789abcdef";
function Ke(t, e) {
  if ((e || (e = {}), typeof t == "number")) {
    Xr.checkSafeUint53(t, "invalid hexlify value");
    let r = "";
    for (; t; ) (r = Ww[t & 15] + r), (t = Math.floor(t / 16));
    return r.length ? (r.length % 2 && (r = "0" + r), "0x" + r) : "0x00";
  }
  if (typeof t == "bigint")
    return (t = t.toString(16)), t.length % 2 ? "0x0" + t : "0x" + t;
  if (
    (e.allowMissingPrefix &&
      typeof t == "string" &&
      t.substring(0, 2) !== "0x" &&
      (t = "0x" + t),
    cB(t))
  )
    return t.toHexString();
  if (gt(t))
    return (
      t.length % 2 &&
        (e.hexPad === "left"
          ? (t = "0x0" + t.substring(2))
          : e.hexPad === "right"
          ? (t += "0")
          : Xr.throwArgumentError("hex data is odd-length", "value", t)),
      t.toLowerCase()
    );
  if (hl(t)) {
    let r = "0x";
    for (let n = 0; n < t.length; n++) {
      let i = t[n];
      r += Ww[(i & 240) >> 4] + Ww[i & 15];
    }
    return r;
  }
  return Xr.throwArgumentError("invalid hexlify value", "value", t);
}
function za(t) {
  if (typeof t != "string") t = Ke(t);
  else if (!gt(t) || t.length % 2) return null;
  return (t.length - 2) / 2;
}
function sn(t, e, r) {
  return (
    typeof t != "string"
      ? (t = Ke(t))
      : (!gt(t) || t.length % 2) &&
        Xr.throwArgumentError("invalid hexData", "value", t),
    (e = 2 + 2 * e),
    r != null ? "0x" + t.substring(e, 2 + 2 * r) : "0x" + t.substring(e)
  );
}
function Ti(t) {
  let e = "0x";
  return (
    t.forEach((r) => {
      e += Ke(r).substring(2);
    }),
    e
  );
}
function Dm(t) {
  const e = lB(
    Ke(t, {
      hexPad: "left",
    })
  );
  return e === "0x" ? "0x0" : e;
}
function lB(t) {
  typeof t != "string" && (t = Ke(t)),
    gt(t) || Xr.throwArgumentError("invalid hex string", "value", t),
    (t = t.substring(2));
  let e = 0;
  for (; e < t.length && t[e] === "0"; ) e++;
  return "0x" + t.substring(e);
}
function Rt(t, e) {
  for (
    typeof t != "string"
      ? (t = Ke(t))
      : gt(t) || Xr.throwArgumentError("invalid hex string", "value", t),
      t.length > 2 * e + 2 &&
        Xr.throwArgumentError("value out of range", "value", arguments[1]);
    t.length < 2 * e + 2;

  )
    t = "0x0" + t.substring(2);
  return t;
}
function yo(t) {
  const e = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x",
  };
  if (Bm(t)) {
    let r = qe(t);
    r.length === 64
      ? ((e.v = 27 + (r[32] >> 7)),
        (r[32] &= 127),
        (e.r = Ke(r.slice(0, 32))),
        (e.s = Ke(r.slice(32, 64))))
      : r.length === 65
      ? ((e.r = Ke(r.slice(0, 32))), (e.s = Ke(r.slice(32, 64))), (e.v = r[64]))
      : Xr.throwArgumentError("invalid signature string", "signature", t),
      e.v < 27 &&
        (e.v === 0 || e.v === 1
          ? (e.v += 27)
          : Xr.throwArgumentError("signature invalid v byte", "signature", t)),
      (e.recoveryParam = 1 - (e.v % 2)),
      e.recoveryParam && (r[32] |= 128),
      (e._vs = Ke(r.slice(32, 64)));
  } else {
    if (
      ((e.r = t.r),
      (e.s = t.s),
      (e.v = t.v),
      (e.recoveryParam = t.recoveryParam),
      (e._vs = t._vs),
      e._vs != null)
    ) {
      const i = Dh(qe(e._vs), 32);
      e._vs = Ke(i);
      const a = i[0] >= 128 ? 1 : 0;
      e.recoveryParam == null
        ? (e.recoveryParam = a)
        : e.recoveryParam !== a &&
          Xr.throwArgumentError(
            "signature recoveryParam mismatch _vs",
            "signature",
            t
          ),
        (i[0] &= 127);
      const s = Ke(i);
      e.s == null
        ? (e.s = s)
        : e.s !== s &&
          Xr.throwArgumentError("signature v mismatch _vs", "signature", t);
    }
    if (e.recoveryParam == null)
      e.v == null
        ? Xr.throwArgumentError(
            "signature missing v and recoveryParam",
            "signature",
            t
          )
        : e.v === 0 || e.v === 1
        ? (e.recoveryParam = e.v)
        : (e.recoveryParam = 1 - (e.v % 2));
    else if (e.v == null) e.v = 27 + e.recoveryParam;
    else {
      const i = e.v === 0 || e.v === 1 ? e.v : 1 - (e.v % 2);
      e.recoveryParam !== i &&
        Xr.throwArgumentError(
          "signature recoveryParam mismatch v",
          "signature",
          t
        );
    }
    e.r == null || !gt(e.r)
      ? Xr.throwArgumentError("signature missing or invalid r", "signature", t)
      : (e.r = Rt(e.r, 32)),
      e.s == null || !gt(e.s)
        ? Xr.throwArgumentError(
            "signature missing or invalid s",
            "signature",
            t
          )
        : (e.s = Rt(e.s, 32));
    const r = qe(e.s);
    r[0] >= 128 &&
      Xr.throwArgumentError("signature s out of range", "signature", t),
      e.recoveryParam && (r[0] |= 128);
    const n = Ke(r);
    e._vs &&
      (gt(e._vs) ||
        Xr.throwArgumentError("signature invalid _vs", "signature", t),
      (e._vs = Rt(e._vs, 32))),
      e._vs == null
        ? (e._vs = n)
        : e._vs !== n &&
          Xr.throwArgumentError(
            "signature _vs mismatch v and s",
            "signature",
            t
          );
  }
  return (
    (e.yParityAndS = e._vs), (e.compact = e.r + e.yParityAndS.substring(2)), e
  );
}
function Bp(t) {
  return (t = yo(t)), Ke(cr([t.r, t.s, t.recoveryParam ? "0x1c" : "0x1b"]));
}
const YJ = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        arrayify: qe,
        concat: cr,
        hexConcat: Ti,
        hexDataLength: za,
        hexDataSlice: sn,
        hexStripZeros: lB,
        hexValue: Dm,
        hexZeroPad: Rt,
        hexlify: Ke,
        isBytes: hl,
        isBytesLike: Bm,
        isHexString: gt,
        joinSignature: Bp,
        splitSignature: yo,
        stripZeros: zi,
        zeroPad: Dh,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  uB = "bignumber/5.7.0";
var Dp = pt.BN;
const ko = new ue(uB),
  jw = {},
  fk = 9007199254740991;
function XJ(t) {
  return (
    t != null &&
    (ae.isBigNumber(t) ||
      (typeof t == "number" && t % 1 === 0) ||
      (typeof t == "string" && !!t.match(/^-?[0-9]+$/)) ||
      gt(t) ||
      typeof t == "bigint" ||
      hl(t))
  );
}
let dk = !1;
class ae {
  constructor(e, r) {
    e !== jw &&
      ko.throwError(
        "cannot call constructor directly; use BigNumber.from",
        ue.errors.UNSUPPORTED_OPERATION,
        {
          operation: "new (BigNumber)",
        }
      ),
      (this._hex = r),
      (this._isBigNumber = !0),
      Object.freeze(this);
  }
  fromTwos(e) {
    return Ni(St(this).fromTwos(e));
  }
  toTwos(e) {
    return Ni(St(this).toTwos(e));
  }
  abs() {
    return this._hex[0] === "-" ? ae.from(this._hex.substring(1)) : this;
  }
  add(e) {
    return Ni(St(this).add(St(e)));
  }
  sub(e) {
    return Ni(St(this).sub(St(e)));
  }
  div(e) {
    return (
      ae.from(e).isZero() && Ea("division-by-zero", "div"),
      Ni(St(this).div(St(e)))
    );
  }
  mul(e) {
    return Ni(St(this).mul(St(e)));
  }
  mod(e) {
    const r = St(e);
    return r.isNeg() && Ea("division-by-zero", "mod"), Ni(St(this).umod(r));
  }
  pow(e) {
    const r = St(e);
    return r.isNeg() && Ea("negative-power", "pow"), Ni(St(this).pow(r));
  }
  and(e) {
    const r = St(e);
    return (
      (this.isNegative() || r.isNeg()) && Ea("unbound-bitwise-result", "and"),
      Ni(St(this).and(r))
    );
  }
  or(e) {
    const r = St(e);
    return (
      (this.isNegative() || r.isNeg()) && Ea("unbound-bitwise-result", "or"),
      Ni(St(this).or(r))
    );
  }
  xor(e) {
    const r = St(e);
    return (
      (this.isNegative() || r.isNeg()) && Ea("unbound-bitwise-result", "xor"),
      Ni(St(this).xor(r))
    );
  }
  mask(e) {
    return (
      (this.isNegative() || e < 0) && Ea("negative-width", "mask"),
      Ni(St(this).maskn(e))
    );
  }
  shl(e) {
    return (
      (this.isNegative() || e < 0) && Ea("negative-width", "shl"),
      Ni(St(this).shln(e))
    );
  }
  shr(e) {
    return (
      (this.isNegative() || e < 0) && Ea("negative-width", "shr"),
      Ni(St(this).shrn(e))
    );
  }
  eq(e) {
    return St(this).eq(St(e));
  }
  lt(e) {
    return St(this).lt(St(e));
  }
  lte(e) {
    return St(this).lte(St(e));
  }
  gt(e) {
    return St(this).gt(St(e));
  }
  gte(e) {
    return St(this).gte(St(e));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return St(this).isZero();
  }
  toNumber() {
    try {
      return St(this).toNumber();
    } catch {
      Ea("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch {}
    return ko.throwError(
      "this platform does not support BigInt",
      ue.errors.UNSUPPORTED_OPERATION,
      {
        value: this.toString(),
      }
    );
  }
  toString() {
    return (
      arguments.length > 0 &&
        (arguments[0] === 10
          ? dk ||
            ((dk = !0),
            ko.warn(
              "BigNumber.toString does not accept any parameters; base-10 is assumed"
            ))
          : arguments[0] === 16
          ? ko.throwError(
              "BigNumber.toString does not accept any parameters; use bigNumber.toHexString()",
              ue.errors.UNEXPECTED_ARGUMENT,
              {}
            )
          : ko.throwError(
              "BigNumber.toString does not accept parameters",
              ue.errors.UNEXPECTED_ARGUMENT,
              {}
            )),
      St(this).toString(10)
    );
  }
  toHexString() {
    return this._hex;
  }
  toJSON(e) {
    return {
      type: "BigNumber",
      hex: this.toHexString(),
    };
  }
  static from(e) {
    if (e instanceof ae) return e;
    if (typeof e == "string")
      return e.match(/^-?0x[0-9a-f]+$/i)
        ? new ae(jw, Op(e))
        : e.match(/^-?[0-9]+$/)
        ? new ae(jw, Op(new Dp(e)))
        : ko.throwArgumentError("invalid BigNumber string", "value", e);
    if (typeof e == "number")
      return (
        e % 1 && Ea("underflow", "BigNumber.from", e),
        (e >= fk || e <= -fk) && Ea("overflow", "BigNumber.from", e),
        ae.from(String(e))
      );
    const r = e;
    if (typeof r == "bigint") return ae.from(r.toString());
    if (hl(r)) return ae.from(Ke(r));
    if (r)
      if (r.toHexString) {
        const n = r.toHexString();
        if (typeof n == "string") return ae.from(n);
      } else {
        let n = r._hex;
        if (
          (n == null && r.type === "BigNumber" && (n = r.hex),
          typeof n == "string" &&
            (gt(n) || (n[0] === "-" && gt(n.substring(1)))))
        )
          return ae.from(n);
      }
    return ko.throwArgumentError("invalid BigNumber value", "value", e);
  }
  static isBigNumber(e) {
    return !!(e && e._isBigNumber);
  }
}
function Op(t) {
  if (typeof t != "string") return Op(t.toString(16));
  if (t[0] === "-")
    return (
      (t = t.substring(1)),
      t[0] === "-" && ko.throwArgumentError("invalid hex", "value", t),
      (t = Op(t)),
      t === "0x00" ? t : "-" + t
    );
  if ((t.substring(0, 2) !== "0x" && (t = "0x" + t), t === "0x")) return "0x00";
  for (
    t.length % 2 && (t = "0x0" + t.substring(2));
    t.length > 4 && t.substring(0, 4) === "0x00";

  )
    t = "0x" + t.substring(4);
  return t;
}
function Ni(t) {
  return ae.from(Op(t));
}
function St(t) {
  const e = ae.from(t).toHexString();
  return e[0] === "-"
    ? new Dp("-" + e.substring(3), 16)
    : new Dp(e.substring(2), 16);
}
function Ea(t, e, r) {
  const n = {
    fault: t,
    operation: e,
  };
  return (
    r != null && (n.value = r), ko.throwError(t, ue.errors.NUMERIC_FAULT, n)
  );
}
function eQ(t) {
  return new Dp(t, 36).toString(16);
}
function tQ(t) {
  return new Dp(t, 16).toString(36);
}
const Ci = new ue(uB),
  Oh = {},
  fB = ae.from(0),
  dB = ae.from(-1);
function hB(t, e, r, n) {
  const i = {
    fault: e,
    operation: r,
  };
  return (
    n !== void 0 && (i.value = n), Ci.throwError(t, ue.errors.NUMERIC_FAULT, i)
  );
}
let Fh = "0";
for (; Fh.length < 256; ) Fh += Fh;
function j8(t) {
  if (typeof t != "number")
    try {
      t = ae.from(t).toNumber();
    } catch {}
  return typeof t == "number" && t >= 0 && t <= 256 && !(t % 1)
    ? "1" + Fh.substring(0, t)
    : Ci.throwArgumentError("invalid decimal size", "decimals", t);
}
function qy(t, e) {
  e == null && (e = 0);
  const r = j8(e);
  t = ae.from(t);
  const n = t.lt(fB);
  n && (t = t.mul(dB));
  let i = t.mod(r).toString();
  for (; i.length < r.length - 1; ) i = "0" + i;
  i = i.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const a = t.div(r).toString();
  return r.length === 1 ? (t = a) : (t = a + "." + i), n && (t = "-" + t), t;
}
function Rs(t, e) {
  e == null && (e = 0);
  const r = j8(e);
  (typeof t != "string" || !t.match(/^-?[0-9.]+$/)) &&
    Ci.throwArgumentError("invalid decimal value", "value", t);
  const n = t.substring(0, 1) === "-";
  n && (t = t.substring(1)),
    t === "." && Ci.throwArgumentError("missing value", "value", t);
  const i = t.split(".");
  i.length > 2 && Ci.throwArgumentError("too many decimal points", "value", t);
  let a = i[0],
    s = i[1];
  for (a || (a = "0"), s || (s = "0"); s[s.length - 1] === "0"; )
    s = s.substring(0, s.length - 1);
  for (
    s.length > r.length - 1 &&
      hB("fractional component exceeds decimals", "underflow", "parseFixed"),
      s === "" && (s = "0");
    s.length < r.length - 1;

  )
    s += "0";
  const o = ae.from(a),
    c = ae.from(s);
  let u = o.mul(r).add(c);
  return n && (u = u.mul(dB)), u;
}
class K0 {
  constructor(e, r, n, i) {
    e !== Oh &&
      Ci.throwError(
        "cannot use FixedFormat constructor; use FixedFormat.from",
        ue.errors.UNSUPPORTED_OPERATION,
        {
          operation: "new FixedFormat",
        }
      ),
      (this.signed = r),
      (this.width = n),
      (this.decimals = i),
      (this.name = (r ? "" : "u") + "fixed" + String(n) + "x" + String(i)),
      (this._multiplier = j8(i)),
      Object.freeze(this);
  }
  static from(e) {
    if (e instanceof K0) return e;
    typeof e == "number" && (e = `fixed128x${e}`);
    let r = !0,
      n = 128,
      i = 18;
    if (typeof e == "string") {
      if (e !== "fixed")
        if (e === "ufixed") r = !1;
        else {
          const a = e.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
          a || Ci.throwArgumentError("invalid fixed format", "format", e),
            (r = a[1] !== "u"),
            (n = parseInt(a[2])),
            (i = parseInt(a[3]));
        }
    } else if (e) {
      const a = (s, o, c) =>
        e[s] == null
          ? c
          : (typeof e[s] !== o &&
              Ci.throwArgumentError(
                "invalid fixed format (" + s + " not " + o + ")",
                "format." + s,
                e[s]
              ),
            e[s]);
      (r = a("signed", "boolean", r)),
        (n = a("width", "number", n)),
        (i = a("decimals", "number", i));
    }
    return (
      n % 8 &&
        Ci.throwArgumentError(
          "invalid fixed format width (not byte aligned)",
          "format.width",
          n
        ),
      i > 80 &&
        Ci.throwArgumentError(
          "invalid fixed format (decimals too large)",
          "format.decimals",
          i
        ),
      new K0(Oh, r, n, i)
    );
  }
}
class Un {
  constructor(e, r, n, i) {
    e !== Oh &&
      Ci.throwError(
        "cannot use FixedNumber constructor; use FixedNumber.from",
        ue.errors.UNSUPPORTED_OPERATION,
        {
          operation: "new FixedFormat",
        }
      ),
      (this.format = i),
      (this._hex = r),
      (this._value = n),
      (this._isFixedNumber = !0),
      Object.freeze(this);
  }
  _checkFormat(e) {
    this.format.name !== e.format.name &&
      Ci.throwArgumentError(
        "incompatible format; use fixedNumber.toFormat",
        "other",
        e
      );
  }
  addUnsafe(e) {
    this._checkFormat(e);
    const r = Rs(this._value, this.format.decimals),
      n = Rs(e._value, e.format.decimals);
    return Un.fromValue(r.add(n), this.format.decimals, this.format);
  }
  subUnsafe(e) {
    this._checkFormat(e);
    const r = Rs(this._value, this.format.decimals),
      n = Rs(e._value, e.format.decimals);
    return Un.fromValue(r.sub(n), this.format.decimals, this.format);
  }
  mulUnsafe(e) {
    this._checkFormat(e);
    const r = Rs(this._value, this.format.decimals),
      n = Rs(e._value, e.format.decimals);
    return Un.fromValue(
      r.mul(n).div(this.format._multiplier),
      this.format.decimals,
      this.format
    );
  }
  divUnsafe(e) {
    this._checkFormat(e);
    const r = Rs(this._value, this.format.decimals),
      n = Rs(e._value, e.format.decimals);
    return Un.fromValue(
      r.mul(this.format._multiplier).div(n),
      this.format.decimals,
      this.format
    );
  }
  floor() {
    const e = this.toString().split(".");
    e.length === 1 && e.push("0");
    let r = Un.from(e[0], this.format);
    const n = !e[1].match(/^(0*)$/);
    return (
      this.isNegative() && n && (r = r.subUnsafe(hk.toFormat(r.format))), r
    );
  }
  ceiling() {
    const e = this.toString().split(".");
    e.length === 1 && e.push("0");
    let r = Un.from(e[0], this.format);
    const n = !e[1].match(/^(0*)$/);
    return (
      !this.isNegative() && n && (r = r.addUnsafe(hk.toFormat(r.format))), r
    );
  }
  round(e) {
    e == null && (e = 0);
    const r = this.toString().split(".");
    if (
      (r.length === 1 && r.push("0"),
      (e < 0 || e > 80 || e % 1) &&
        Ci.throwArgumentError("invalid decimal count", "decimals", e),
      r[1].length <= e)
    )
      return this;
    const n = Un.from("1" + Fh.substring(0, e), this.format),
      i = rQ.toFormat(this.format);
    return this.mulUnsafe(n).addUnsafe(i).floor().divUnsafe(n);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(e) {
    if (e == null) return this._hex;
    e % 8 && Ci.throwArgumentError("invalid byte width", "width", e);
    const r = ae
      .from(this._hex)
      .fromTwos(this.format.width)
      .toTwos(e)
      .toHexString();
    return Rt(r, e / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(e) {
    return Un.fromString(this._value, e);
  }
  static fromValue(e, r, n) {
    return (
      n == null && r != null && !XJ(r) && ((n = r), (r = null)),
      r == null && (r = 0),
      n == null && (n = "fixed"),
      Un.fromString(qy(e, r), K0.from(n))
    );
  }
  static fromString(e, r) {
    r == null && (r = "fixed");
    const n = K0.from(r),
      i = Rs(e, n.decimals);
    !n.signed &&
      i.lt(fB) &&
      hB("unsigned value cannot be negative", "overflow", "value", e);
    let a = null;
    n.signed
      ? (a = i.toTwos(n.width).toHexString())
      : ((a = i.toHexString()), (a = Rt(a, n.width / 8)));
    const s = qy(i, n.decimals);
    return new Un(Oh, a, s, n);
  }
  static fromBytes(e, r) {
    r == null && (r = "fixed");
    const n = K0.from(r);
    if (qe(e).length > n.width / 8) throw new Error("overflow");
    let i = ae.from(e);
    n.signed && (i = i.fromTwos(n.width));
    const a = i.toTwos((n.signed ? 0 : 1) + n.width).toHexString(),
      s = qy(i, n.decimals);
    return new Un(Oh, a, s, n);
  }
  static from(e, r) {
    if (typeof e == "string") return Un.fromString(e, r);
    if (hl(e)) return Un.fromBytes(e, r);
    try {
      return Un.fromValue(e, 0, r);
    } catch (n) {
      if (n.code !== ue.errors.INVALID_ARGUMENT) throw n;
    }
    return Ci.throwArgumentError("invalid FixedNumber value", "value", e);
  }
  static isFixedNumber(e) {
    return !!(e && e._isFixedNumber);
  }
}
const hk = Un.from(1),
  rQ = Un.from("0.5"),
  nQ = "properties/5.7.0";
var iQ = function (t, e, r, n) {
  function i(a) {
    return a instanceof r
      ? a
      : new r(function (s) {
          s(a);
        });
  }
  return new (r || (r = Promise))(function (a, s) {
    function o(d) {
      try {
        u(n.next(d));
      } catch (m) {
        s(m);
      }
    }
    function c(d) {
      try {
        u(n.throw(d));
      } catch (m) {
        s(m);
      }
    }
    function u(d) {
      d.done ? a(d.value) : i(d.value).then(o, c);
    }
    u((n = n.apply(t, e || [])).next());
  });
};
const qg = new ue(nQ);
function _e(t, e, r) {
  Object.defineProperty(t, e, {
    enumerable: !0,
    value: r,
    writable: !1,
  });
}
function qn(t, e) {
  for (let r = 0; r < 32; r++) {
    if (t[e]) return t[e];
    if (!t.prototype || typeof t.prototype != "object") break;
    t = Object.getPrototypeOf(t.prototype).constructor;
  }
  return null;
}
function en(t) {
  return iQ(this, void 0, void 0, function* () {
    const e = Object.keys(t).map((n) => {
      const i = t[n];
      return Promise.resolve(i).then((a) => ({
        key: n,
        value: a,
      }));
    });
    return (yield Promise.all(e)).reduce(
      (n, i) => ((n[i.key] = i.value), n),
      {}
    );
  });
}
function H8(t, e) {
  (!t || typeof t != "object") &&
    qg.throwArgumentError("invalid object", "object", t),
    Object.keys(t).forEach((r) => {
      e[r] ||
        qg.throwArgumentError(
          "invalid object key - " + r,
          "transaction:" + r,
          t
        );
    });
}
function vr(t) {
  const e = {};
  for (const r in t) e[r] = t[r];
  return e;
}
const aQ = {
  bigint: !0,
  boolean: !0,
  function: !0,
  number: !0,
  string: !0,
};
function pB(t) {
  if (t == null || aQ[typeof t]) return !0;
  if (Array.isArray(t) || typeof t == "object") {
    if (!Object.isFrozen(t)) return !1;
    const e = Object.keys(t);
    for (let r = 0; r < e.length; r++) {
      let n = null;
      try {
        n = t[e[r]];
      } catch {
        continue;
      }
      if (!pB(n)) return !1;
    }
    return !0;
  }
  return qg.throwArgumentError(`Cannot deepCopy ${typeof t}`, "object", t);
}
function sQ(t) {
  if (pB(t)) return t;
  if (Array.isArray(t)) return Object.freeze(t.map((e) => fi(e)));
  if (typeof t == "object") {
    const e = {};
    for (const r in t) {
      const n = t[r];
      n !== void 0 && _e(e, r, fi(n));
    }
    return e;
  }
  return qg.throwArgumentError(`Cannot deepCopy ${typeof t}`, "object", t);
}
function fi(t) {
  return sQ(t);
}
class pl {
  constructor(e) {
    for (const r in e) this[r] = fi(e[r]);
  }
}
const oQ = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        Description: pl,
        checkProperties: H8,
        deepCopy: fi,
        defineReadOnly: _e,
        getStatic: qn,
        resolveProperties: en,
        shallowCopy: vr,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  Om = "abi/5.7.0",
  Ot = new ue(Om),
  pu = {};
let pk = {
    calldata: !0,
    memory: !0,
    storage: !0,
  },
  cQ = {
    calldata: !0,
    memory: !0,
  };
function K1(t, e) {
  if (t === "bytes" || t === "string") {
    if (pk[e]) return !0;
  } else if (t === "address") {
    if (e === "payable") return !0;
  } else if ((t.indexOf("[") >= 0 || t === "tuple") && cQ[e]) return !0;
  return (
    (pk[e] || e === "payable") &&
      Ot.throwArgumentError("invalid modifier", "name", e),
    !1
  );
}
function lQ(t, e) {
  let r = t;
  function n(o) {
    Ot.throwArgumentError(`unexpected character at position ${o}`, "param", t);
  }
  t = t.replace(/\s/g, " ");
  function i(o) {
    let c = {
      type: "",
      name: "",
      parent: o,
      state: {
        allowType: !0,
      },
    };
    return e && (c.indexed = !1), c;
  }
  let a = {
      type: "",
      name: "",
      state: {
        allowType: !0,
      },
    },
    s = a;
  for (let o = 0; o < t.length; o++) {
    let c = t[o];
    switch (c) {
      case "(":
        s.state.allowType && s.type === ""
          ? (s.type = "tuple")
          : s.state.allowParams || n(o),
          (s.state.allowType = !1),
          (s.type = u0(s.type)),
          (s.components = [i(s)]),
          (s = s.components[0]);
        break;
      case ")":
        delete s.state,
          s.name === "indexed" && (e || n(o), (s.indexed = !0), (s.name = "")),
          K1(s.type, s.name) && (s.name = ""),
          (s.type = u0(s.type));
        let u = s;
        (s = s.parent),
          s || n(o),
          delete u.parent,
          (s.state.allowParams = !1),
          (s.state.allowName = !0),
          (s.state.allowArray = !0);
        break;
      case ",":
        delete s.state,
          s.name === "indexed" && (e || n(o), (s.indexed = !0), (s.name = "")),
          K1(s.type, s.name) && (s.name = ""),
          (s.type = u0(s.type));
        let d = i(s.parent);
        s.parent.components.push(d), delete s.parent, (s = d);
        break;
      case " ":
        s.state.allowType &&
          s.type !== "" &&
          ((s.type = u0(s.type)),
          delete s.state.allowType,
          (s.state.allowName = !0),
          (s.state.allowParams = !0)),
          s.state.allowName &&
            s.name !== "" &&
            (s.name === "indexed"
              ? (e || n(o), s.indexed && n(o), (s.indexed = !0), (s.name = ""))
              : K1(s.type, s.name)
              ? (s.name = "")
              : (s.state.allowName = !1));
        break;
      case "[":
        s.state.allowArray || n(o),
          (s.type += c),
          (s.state.allowArray = !1),
          (s.state.allowName = !1),
          (s.state.readArray = !0);
        break;
      case "]":
        s.state.readArray || n(o),
          (s.type += c),
          (s.state.readArray = !1),
          (s.state.allowArray = !0),
          (s.state.allowName = !0);
        break;
      default:
        s.state.allowType
          ? ((s.type += c),
            (s.state.allowParams = !0),
            (s.state.allowArray = !0))
          : s.state.allowName
          ? ((s.name += c), delete s.state.allowArray)
          : s.state.readArray
          ? (s.type += c)
          : n(o);
    }
  }
  return (
    s.parent && Ot.throwArgumentError("unexpected eof", "param", t),
    delete a.state,
    s.name === "indexed"
      ? (e || n(r.length - 7),
        s.indexed && n(r.length - 7),
        (s.indexed = !0),
        (s.name = ""))
      : K1(s.type, s.name) && (s.name = ""),
    (a.type = u0(a.type)),
    a
  );
}
function Vy(t, e) {
  for (let r in e) _e(t, r, e[r]);
}
const zt = Object.freeze({
    sighash: "sighash",
    minimal: "minimal",
    full: "full",
    json: "json",
  }),
  uQ = new RegExp(/^(.*)\[([0-9]*)\]$/);
class rn {
  constructor(e, r) {
    e !== pu &&
      Ot.throwError("use fromString", ue.errors.UNSUPPORTED_OPERATION, {
        operation: "new ParamType()",
      }),
      Vy(this, r);
    let n = this.type.match(uQ);
    n
      ? Vy(this, {
          arrayLength: parseInt(n[2] || "-1"),
          arrayChildren: rn.fromObject({
            type: n[1],
            components: this.components,
          }),
          baseType: "array",
        })
      : Vy(this, {
          arrayLength: null,
          arrayChildren: null,
          baseType: this.components != null ? "tuple" : this.type,
        }),
      (this._isParamType = !0),
      Object.freeze(this);
  }
  format(e) {
    if (
      (e || (e = zt.sighash),
      zt[e] || Ot.throwArgumentError("invalid format type", "format", e),
      e === zt.json)
    ) {
      let n = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: this.name || void 0,
      };
      return (
        typeof this.indexed == "boolean" && (n.indexed = this.indexed),
        this.components &&
          (n.components = this.components.map((i) => JSON.parse(i.format(e)))),
        JSON.stringify(n)
      );
    }
    let r = "";
    return (
      this.baseType === "array"
        ? ((r += this.arrayChildren.format(e)),
          (r +=
            "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]"))
        : this.baseType === "tuple"
        ? (e !== zt.sighash && (r += this.type),
          (r +=
            "(" +
            this.components
              .map((n) => n.format(e))
              .join(e === zt.full ? ", " : ",") +
            ")"))
        : (r += this.type),
      e !== zt.sighash &&
        (this.indexed === !0 && (r += " indexed"),
        e === zt.full && this.name && (r += " " + this.name)),
      r
    );
  }
  static from(e, r) {
    return typeof e == "string" ? rn.fromString(e, r) : rn.fromObject(e);
  }
  static fromObject(e) {
    return rn.isParamType(e)
      ? e
      : new rn(pu, {
          name: e.name || null,
          type: u0(e.type),
          indexed: e.indexed == null ? null : !!e.indexed,
          components: e.components ? e.components.map(rn.fromObject) : null,
        });
  }
  static fromString(e, r) {
    function n(i) {
      return rn.fromObject({
        name: i.name,
        type: i.type,
        indexed: i.indexed,
        components: i.components,
      });
    }
    return n(lQ(e, !!r));
  }
  static isParamType(e) {
    return !!(e != null && e._isParamType);
  }
}
function Fp(t, e) {
  return dQ(t).map((r) => rn.fromString(r, e));
}
class qs {
  constructor(e, r) {
    e !== pu &&
      Ot.throwError(
        "use a static from method",
        ue.errors.UNSUPPORTED_OPERATION,
        {
          operation: "new Fragment()",
        }
      ),
      Vy(this, r),
      (this._isFragment = !0),
      Object.freeze(this);
  }
  static from(e) {
    return qs.isFragment(e)
      ? e
      : typeof e == "string"
      ? qs.fromString(e)
      : qs.fromObject(e);
  }
  static fromObject(e) {
    if (qs.isFragment(e)) return e;
    switch (e.type) {
      case "function":
        return cs.fromObject(e);
      case "event":
        return js.fromObject(e);
      case "constructor":
        return os.fromObject(e);
      case "error":
        return Bo.fromObject(e);
      case "fallback":
      case "receive":
        return null;
    }
    return Ot.throwArgumentError("invalid fragment object", "value", e);
  }
  static fromString(e) {
    return (
      (e = e.replace(/\s/g, " ")),
      (e = e.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ")),
      (e = e.trim()),
      e.split(" ")[0] === "event"
        ? js.fromString(e.substring(5).trim())
        : e.split(" ")[0] === "function"
        ? cs.fromString(e.substring(8).trim())
        : e.split("(")[0].trim() === "constructor"
        ? os.fromString(e.trim())
        : e.split(" ")[0] === "error"
        ? Bo.fromString(e.substring(5).trim())
        : Ot.throwArgumentError("unsupported fragment", "value", e)
    );
  }
  static isFragment(e) {
    return !!(e && e._isFragment);
  }
}
class js extends qs {
  format(e) {
    if (
      (e || (e = zt.sighash),
      zt[e] || Ot.throwArgumentError("invalid format type", "format", e),
      e === zt.json)
    )
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((n) => JSON.parse(n.format(e))),
      });
    let r = "";
    return (
      e !== zt.sighash && (r += "event "),
      (r +=
        this.name +
        "(" +
        this.inputs.map((n) => n.format(e)).join(e === zt.full ? ", " : ",") +
        ") "),
      e !== zt.sighash && this.anonymous && (r += "anonymous "),
      r.trim()
    );
  }
  static from(e) {
    return typeof e == "string" ? js.fromString(e) : js.fromObject(e);
  }
  static fromObject(e) {
    if (js.isEventFragment(e)) return e;
    e.type !== "event" &&
      Ot.throwArgumentError("invalid event object", "value", e);
    const r = {
      name: Lp(e.name),
      anonymous: e.anonymous,
      inputs: e.inputs ? e.inputs.map(rn.fromObject) : [],
      type: "event",
    };
    return new js(pu, r);
  }
  static fromString(e) {
    let r = e.match($p);
    r || Ot.throwArgumentError("invalid event string", "value", e);
    let n = !1;
    return (
      r[3].split(" ").forEach((i) => {
        switch (i.trim()) {
          case "anonymous":
            n = !0;
            break;
          case "":
            break;
          default:
            Ot.warn("unknown modifier: " + i);
        }
      }),
      js.fromObject({
        name: r[1].trim(),
        anonymous: n,
        inputs: Fp(r[2], !0),
        type: "event",
      })
    );
  }
  static isEventFragment(e) {
    return e && e._isFragment && e.type === "event";
  }
}
function mB(t, e) {
  e.gas = null;
  let r = t.split("@");
  return r.length !== 1
    ? (r.length > 2 &&
        Ot.throwArgumentError(
          "invalid human-readable ABI signature",
          "value",
          t
        ),
      r[1].match(/^[0-9]+$/) ||
        Ot.throwArgumentError(
          "invalid human-readable ABI signature gas",
          "value",
          t
        ),
      (e.gas = ae.from(r[1])),
      r[0])
    : t;
}
function yB(t, e) {
  (e.constant = !1),
    (e.payable = !1),
    (e.stateMutability = "nonpayable"),
    t.split(" ").forEach((r) => {
      switch (r.trim()) {
        case "constant":
          e.constant = !0;
          break;
        case "payable":
          (e.payable = !0), (e.stateMutability = "payable");
          break;
        case "nonpayable":
          (e.payable = !1), (e.stateMutability = "nonpayable");
          break;
        case "pure":
          (e.constant = !0), (e.stateMutability = "pure");
          break;
        case "view":
          (e.constant = !0), (e.stateMutability = "view");
          break;
        case "external":
        case "public":
        case "":
          break;
        default:
          console.log("unknown modifier: " + r);
      }
    });
}
function gB(t) {
  let e = {
    constant: !1,
    payable: !0,
    stateMutability: "payable",
  };
  return (
    t.stateMutability != null
      ? ((e.stateMutability = t.stateMutability),
        (e.constant =
          e.stateMutability === "view" || e.stateMutability === "pure"),
        t.constant != null &&
          !!t.constant !== e.constant &&
          Ot.throwArgumentError(
            "cannot have constant function with mutability " +
              e.stateMutability,
            "value",
            t
          ),
        (e.payable = e.stateMutability === "payable"),
        t.payable != null &&
          !!t.payable !== e.payable &&
          Ot.throwArgumentError(
            "cannot have payable function with mutability " + e.stateMutability,
            "value",
            t
          ))
      : t.payable != null
      ? ((e.payable = !!t.payable),
        t.constant == null &&
          !e.payable &&
          t.type !== "constructor" &&
          Ot.throwArgumentError(
            "unable to determine stateMutability",
            "value",
            t
          ),
        (e.constant = !!t.constant),
        e.constant
          ? (e.stateMutability = "view")
          : (e.stateMutability = e.payable ? "payable" : "nonpayable"),
        e.payable &&
          e.constant &&
          Ot.throwArgumentError(
            "cannot have constant payable function",
            "value",
            t
          ))
      : t.constant != null
      ? ((e.constant = !!t.constant),
        (e.payable = !e.constant),
        (e.stateMutability = e.constant ? "view" : "payable"))
      : t.type !== "constructor" &&
        Ot.throwArgumentError(
          "unable to determine stateMutability",
          "value",
          t
        ),
    e
  );
}
class os extends qs {
  format(e) {
    if (
      (e || (e = zt.sighash),
      zt[e] || Ot.throwArgumentError("invalid format type", "format", e),
      e === zt.json)
    )
      return JSON.stringify({
        type: "constructor",
        stateMutability:
          this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((n) => JSON.parse(n.format(e))),
      });
    e === zt.sighash &&
      Ot.throwError(
        "cannot format a constructor for sighash",
        ue.errors.UNSUPPORTED_OPERATION,
        {
          operation: "format(sighash)",
        }
      );
    let r =
      "constructor(" +
      this.inputs.map((n) => n.format(e)).join(e === zt.full ? ", " : ",") +
      ") ";
    return (
      this.stateMutability &&
        this.stateMutability !== "nonpayable" &&
        (r += this.stateMutability + " "),
      r.trim()
    );
  }
  static from(e) {
    return typeof e == "string" ? os.fromString(e) : os.fromObject(e);
  }
  static fromObject(e) {
    if (os.isConstructorFragment(e)) return e;
    e.type !== "constructor" &&
      Ot.throwArgumentError("invalid constructor object", "value", e);
    let r = gB(e);
    r.constant &&
      Ot.throwArgumentError("constructor cannot be constant", "value", e);
    const n = {
      name: null,
      type: e.type,
      inputs: e.inputs ? e.inputs.map(rn.fromObject) : [],
      payable: r.payable,
      stateMutability: r.stateMutability,
      gas: e.gas ? ae.from(e.gas) : null,
    };
    return new os(pu, n);
  }
  static fromString(e) {
    let r = {
      type: "constructor",
    };
    e = mB(e, r);
    let n = e.match($p);
    return (
      (!n || n[1].trim() !== "constructor") &&
        Ot.throwArgumentError("invalid constructor string", "value", e),
      (r.inputs = Fp(n[2].trim(), !1)),
      yB(n[3].trim(), r),
      os.fromObject(r)
    );
  }
  static isConstructorFragment(e) {
    return e && e._isFragment && e.type === "constructor";
  }
}
class cs extends os {
  format(e) {
    if (
      (e || (e = zt.sighash),
      zt[e] || Ot.throwArgumentError("invalid format type", "format", e),
      e === zt.json)
    )
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability:
          this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((n) => JSON.parse(n.format(e))),
        outputs: this.outputs.map((n) => JSON.parse(n.format(e))),
      });
    let r = "";
    return (
      e !== zt.sighash && (r += "function "),
      (r +=
        this.name +
        "(" +
        this.inputs.map((n) => n.format(e)).join(e === zt.full ? ", " : ",") +
        ") "),
      e !== zt.sighash &&
        (this.stateMutability
          ? this.stateMutability !== "nonpayable" &&
            (r += this.stateMutability + " ")
          : this.constant && (r += "view "),
        this.outputs &&
          this.outputs.length &&
          (r +=
            "returns (" +
            this.outputs.map((n) => n.format(e)).join(", ") +
            ") "),
        this.gas != null && (r += "@" + this.gas.toString() + " ")),
      r.trim()
    );
  }
  static from(e) {
    return typeof e == "string" ? cs.fromString(e) : cs.fromObject(e);
  }
  static fromObject(e) {
    if (cs.isFunctionFragment(e)) return e;
    e.type !== "function" &&
      Ot.throwArgumentError("invalid function object", "value", e);
    let r = gB(e);
    const n = {
      type: e.type,
      name: Lp(e.name),
      constant: r.constant,
      inputs: e.inputs ? e.inputs.map(rn.fromObject) : [],
      outputs: e.outputs ? e.outputs.map(rn.fromObject) : [],
      payable: r.payable,
      stateMutability: r.stateMutability,
      gas: e.gas ? ae.from(e.gas) : null,
    };
    return new cs(pu, n);
  }
  static fromString(e) {
    let r = {
      type: "function",
    };
    e = mB(e, r);
    let n = e.split(" returns ");
    n.length > 2 &&
      Ot.throwArgumentError("invalid function string", "value", e);
    let i = n[0].match($p);
    if (
      (i || Ot.throwArgumentError("invalid function signature", "value", e),
      (r.name = i[1].trim()),
      r.name && Lp(r.name),
      (r.inputs = Fp(i[2], !1)),
      yB(i[3].trim(), r),
      n.length > 1)
    ) {
      let a = n[1].match($p);
      (a[1].trim() != "" || a[3].trim() != "") &&
        Ot.throwArgumentError("unexpected tokens", "value", e),
        (r.outputs = Fp(a[2], !1));
    } else r.outputs = [];
    return cs.fromObject(r);
  }
  static isFunctionFragment(e) {
    return e && e._isFragment && e.type === "function";
  }
}
function mk(t) {
  const e = t.format();
  return (
    (e === "Error(string)" || e === "Panic(uint256)") &&
      Ot.throwArgumentError(
        `cannot specify user defined ${e} error`,
        "fragment",
        t
      ),
    t
  );
}
class Bo extends qs {
  format(e) {
    if (
      (e || (e = zt.sighash),
      zt[e] || Ot.throwArgumentError("invalid format type", "format", e),
      e === zt.json)
    )
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((n) => JSON.parse(n.format(e))),
      });
    let r = "";
    return (
      e !== zt.sighash && (r += "error "),
      (r +=
        this.name +
        "(" +
        this.inputs.map((n) => n.format(e)).join(e === zt.full ? ", " : ",") +
        ") "),
      r.trim()
    );
  }
  static from(e) {
    return typeof e == "string" ? Bo.fromString(e) : Bo.fromObject(e);
  }
  static fromObject(e) {
    if (Bo.isErrorFragment(e)) return e;
    e.type !== "error" &&
      Ot.throwArgumentError("invalid error object", "value", e);
    const r = {
      type: e.type,
      name: Lp(e.name),
      inputs: e.inputs ? e.inputs.map(rn.fromObject) : [],
    };
    return mk(new Bo(pu, r));
  }
  static fromString(e) {
    let r = {
        type: "error",
      },
      n = e.match($p);
    return (
      n || Ot.throwArgumentError("invalid error signature", "value", e),
      (r.name = n[1].trim()),
      r.name && Lp(r.name),
      (r.inputs = Fp(n[2], !1)),
      mk(Bo.fromObject(r))
    );
  }
  static isErrorFragment(e) {
    return e && e._isFragment && e.type === "error";
  }
}
function u0(t) {
  return (
    t.match(/^uint($|[^1-9])/)
      ? (t = "uint256" + t.substring(4))
      : t.match(/^int($|[^1-9])/) && (t = "int256" + t.substring(3)),
    t
  );
}
const fQ = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function Lp(t) {
  return (
    (!t || !t.match(fQ)) &&
      Ot.throwArgumentError(`invalid identifier "${t}"`, "value", t),
    t
  );
}
const $p = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function dQ(t) {
  t = t.trim();
  let e = [],
    r = "",
    n = 0;
  for (let i = 0; i < t.length; i++) {
    let a = t[i];
    a === "," && n === 0
      ? (e.push(r), (r = ""))
      : ((r += a),
        a === "("
          ? n++
          : a === ")" &&
            (n--,
            n === -1 &&
              Ot.throwArgumentError("unbalanced parenthesis", "value", t)));
  }
  return r && e.push(r), e;
}
const z8 = new ue(Om);
function bB(t) {
  const e = [],
    r = function (n, i) {
      if (Array.isArray(i))
        for (let a in i) {
          const s = n.slice();
          s.push(a);
          try {
            r(s, i[a]);
          } catch (o) {
            e.push({
              path: s,
              error: o,
            });
          }
        }
    };
  return r([], t), e;
}
class ec {
  constructor(e, r, n, i) {
    (this.name = e), (this.type = r), (this.localName = n), (this.dynamic = i);
  }
  _throwError(e, r) {
    z8.throwArgumentError(e, this.localName, r);
  }
}
class t_ {
  constructor(e) {
    _e(this, "wordSize", e || 32),
      (this._data = []),
      (this._dataLength = 0),
      (this._padding = new Uint8Array(e));
  }
  get data() {
    return Ti(this._data);
  }
  get length() {
    return this._dataLength;
  }
  _writeData(e) {
    return this._data.push(e), (this._dataLength += e.length), e.length;
  }
  appendWriter(e) {
    return this._writeData(cr(e._data));
  }
  writeBytes(e) {
    let r = qe(e);
    const n = r.length % this.wordSize;
    return n && (r = cr([r, this._padding.slice(n)])), this._writeData(r);
  }
  _getValue(e) {
    let r = qe(ae.from(e));
    return (
      r.length > this.wordSize &&
        z8.throwError("value out-of-bounds", ue.errors.BUFFER_OVERRUN, {
          length: this.wordSize,
          offset: r.length,
        }),
      r.length % this.wordSize &&
        (r = cr([this._padding.slice(r.length % this.wordSize), r])),
      r
    );
  }
  writeValue(e) {
    return this._writeData(this._getValue(e));
  }
  writeUpdatableValue() {
    const e = this._data.length;
    return (
      this._data.push(this._padding),
      (this._dataLength += this.wordSize),
      (r) => {
        this._data[e] = this._getValue(r);
      }
    );
  }
}
class Vg {
  constructor(e, r, n, i) {
    _e(this, "_data", qe(e)),
      _e(this, "wordSize", r || 32),
      _e(this, "_coerceFunc", n),
      _e(this, "allowLoose", i),
      (this._offset = 0);
  }
  get data() {
    return Ke(this._data);
  }
  get consumed() {
    return this._offset;
  }
  static coerce(e, r) {
    let n = e.match("^u?int([0-9]+)$");
    return n && parseInt(n[1]) <= 48 && (r = r.toNumber()), r;
  }
  coerce(e, r) {
    return this._coerceFunc ? this._coerceFunc(e, r) : Vg.coerce(e, r);
  }
  _peekBytes(e, r, n) {
    let i = Math.ceil(r / this.wordSize) * this.wordSize;
    return (
      this._offset + i > this._data.length &&
        (this.allowLoose && n && this._offset + r <= this._data.length
          ? (i = r)
          : z8.throwError("data out-of-bounds", ue.errors.BUFFER_OVERRUN, {
              length: this._data.length,
              offset: this._offset + i,
            })),
      this._data.slice(this._offset, this._offset + i)
    );
  }
  subReader(e) {
    return new Vg(
      this._data.slice(this._offset + e),
      this.wordSize,
      this._coerceFunc,
      this.allowLoose
    );
  }
  readBytes(e, r) {
    let n = this._peekBytes(0, e, !!r);
    return (this._offset += n.length), n.slice(0, e);
  }
  readValue() {
    return ae.from(this.readBytes(this.wordSize));
  }
}
var vB = {
  exports: {},
};
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
(function (t) {
  (function () {
    var e = "input is invalid type",
      r = "finalize already called",
      n = typeof window == "object",
      i = n ? window : {};
    i.JS_SHA3_NO_WINDOW && (n = !1);
    var a = !n && typeof self == "object",
      s =
        !i.JS_SHA3_NO_NODE_JS &&
        typeof process == "object" &&
        process.versions &&
        process.versions.node;
    s ? (i = ke) : a && (i = self);
    var o = !i.JS_SHA3_NO_COMMON_JS && !0 && t.exports,
      c = !i.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u",
      u = "0123456789abcdef".split(""),
      d = [31, 7936, 2031616, 520093696],
      m = [4, 1024, 262144, 67108864],
      v = [1, 256, 65536, 16777216],
      E = [6, 1536, 393216, 100663296],
      A = [0, 8, 16, 24],
      I = [
        1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0,
        2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136,
        0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905,
        2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648,
        32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896,
        2147483648, 2147483649, 0, 2147516424, 2147483648,
      ],
      b = [224, 256, 384, 512],
      w = [128, 256],
      S = ["hex", "buffer", "arrayBuffer", "array", "digest"],
      k = {
        128: 168,
        256: 136,
      };
    (i.JS_SHA3_NO_NODE_JS || !Array.isArray) &&
      (Array.isArray = function (B) {
        return Object.prototype.toString.call(B) === "[object Array]";
      }),
      c &&
        (i.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) &&
        (ArrayBuffer.isView = function (B) {
          return (
            typeof B == "object" &&
            B.buffer &&
            B.buffer.constructor === ArrayBuffer
          );
        });
    for (
      var N = function (B, H, Q) {
          return function (Z) {
            return new M(B, H, B).update(Z)[Q]();
          };
        },
        O = function (B, H, Q) {
          return function (Z, te) {
            return new M(B, H, te).update(Z)[Q]();
          };
        },
        F = function (B, H, Q) {
          return function (Z, te, Te, K) {
            return h["cshake" + B].update(Z, te, Te, K)[Q]();
          };
        },
        V = function (B, H, Q) {
          return function (Z, te, Te, K) {
            return h["kmac" + B].update(Z, te, Te, K)[Q]();
          };
        },
        j = function (B, H, Q, Z) {
          for (var te = 0; te < S.length; ++te) {
            var Te = S[te];
            B[Te] = H(Q, Z, Te);
          }
          return B;
        },
        X = function (B, H) {
          var Q = N(B, H, "hex");
          return (
            (Q.create = function () {
              return new M(B, H, B);
            }),
            (Q.update = function (Z) {
              return Q.create().update(Z);
            }),
            j(Q, N, B, H)
          );
        },
        C = function (B, H) {
          var Q = O(B, H, "hex");
          return (
            (Q.create = function (Z) {
              return new M(B, H, Z);
            }),
            (Q.update = function (Z, te) {
              return Q.create(te).update(Z);
            }),
            j(Q, O, B, H)
          );
        },
        l = function (B, H) {
          var Q = k[B],
            Z = F(B, H, "hex");
          return (
            (Z.create = function (te, Te, K) {
              return !Te && !K
                ? h["shake" + B].create(te)
                : new M(B, H, te).bytepad([Te, K], Q);
            }),
            (Z.update = function (te, Te, K, G) {
              return Z.create(Te, K, G).update(te);
            }),
            j(Z, F, B, H)
          );
        },
        p = function (B, H) {
          var Q = k[B],
            Z = V(B, H, "hex");
          return (
            (Z.create = function (te, Te, K) {
              return new D(B, H, Te).bytepad(["KMAC", K], Q).bytepad([te], Q);
            }),
            (Z.update = function (te, Te, K, G) {
              return Z.create(te, K, G).update(Te);
            }),
            j(Z, V, B, H)
          );
        },
        y = [
          {
            name: "keccak",
            padding: v,
            bits: b,
            createMethod: X,
          },
          {
            name: "sha3",
            padding: E,
            bits: b,
            createMethod: X,
          },
          {
            name: "shake",
            padding: d,
            bits: w,
            createMethod: C,
          },
          {
            name: "cshake",
            padding: m,
            bits: w,
            createMethod: l,
          },
          {
            name: "kmac",
            padding: m,
            bits: w,
            createMethod: p,
          },
        ],
        h = {},
        g = [],
        T = 0;
      T < y.length;
      ++T
    )
      for (var R = y[T], x = R.bits, f = 0; f < x.length; ++f) {
        var _ = R.name + "_" + x[f];
        if (
          (g.push(_),
          (h[_] = R.createMethod(x[f], R.padding)),
          R.name !== "sha3")
        ) {
          var P = R.name + x[f];
          g.push(P), (h[P] = h[_]);
        }
      }
    function M(B, H, Q) {
      (this.blocks = []),
        (this.s = []),
        (this.padding = H),
        (this.outputBits = Q),
        (this.reset = !0),
        (this.finalized = !1),
        (this.block = 0),
        (this.start = 0),
        (this.blockCount = (1600 - (B << 1)) >> 5),
        (this.byteCount = this.blockCount << 2),
        (this.outputBlocks = Q >> 5),
        (this.extraBytes = (Q & 31) >> 3);
      for (var Z = 0; Z < 50; ++Z) this.s[Z] = 0;
    }
    (M.prototype.update = function (B) {
      if (this.finalized) throw new Error(r);
      var H,
        Q = typeof B;
      if (Q !== "string") {
        if (Q === "object") {
          if (B === null) throw new Error(e);
          if (c && B.constructor === ArrayBuffer) B = new Uint8Array(B);
          else if (!Array.isArray(B) && (!c || !ArrayBuffer.isView(B)))
            throw new Error(e);
        } else throw new Error(e);
        H = !0;
      }
      for (
        var Z = this.blocks,
          te = this.byteCount,
          Te = B.length,
          K = this.blockCount,
          G = 0,
          he = this.s,
          se,
          pe;
        G < Te;

      ) {
        if (this.reset)
          for (this.reset = !1, Z[0] = this.block, se = 1; se < K + 1; ++se)
            Z[se] = 0;
        if (H)
          for (se = this.start; G < Te && se < te; ++G)
            Z[se >> 2] |= B[G] << A[se++ & 3];
        else
          for (se = this.start; G < Te && se < te; ++G)
            (pe = B.charCodeAt(G)),
              pe < 128
                ? (Z[se >> 2] |= pe << A[se++ & 3])
                : pe < 2048
                ? ((Z[se >> 2] |= (192 | (pe >> 6)) << A[se++ & 3]),
                  (Z[se >> 2] |= (128 | (pe & 63)) << A[se++ & 3]))
                : pe < 55296 || pe >= 57344
                ? ((Z[se >> 2] |= (224 | (pe >> 12)) << A[se++ & 3]),
                  (Z[se >> 2] |= (128 | ((pe >> 6) & 63)) << A[se++ & 3]),
                  (Z[se >> 2] |= (128 | (pe & 63)) << A[se++ & 3]))
                : ((pe =
                    65536 + (((pe & 1023) << 10) | (B.charCodeAt(++G) & 1023))),
                  (Z[se >> 2] |= (240 | (pe >> 18)) << A[se++ & 3]),
                  (Z[se >> 2] |= (128 | ((pe >> 12) & 63)) << A[se++ & 3]),
                  (Z[se >> 2] |= (128 | ((pe >> 6) & 63)) << A[se++ & 3]),
                  (Z[se >> 2] |= (128 | (pe & 63)) << A[se++ & 3]));
        if (((this.lastByteIndex = se), se >= te)) {
          for (this.start = se - te, this.block = Z[K], se = 0; se < K; ++se)
            he[se] ^= Z[se];
          q(he), (this.reset = !0);
        } else this.start = se;
      }
      return this;
    }),
      (M.prototype.encode = function (B, H) {
        var Q = B & 255,
          Z = 1,
          te = [Q];
        for (B = B >> 8, Q = B & 255; Q > 0; )
          te.unshift(Q), (B = B >> 8), (Q = B & 255), ++Z;
        return H ? te.push(Z) : te.unshift(Z), this.update(te), te.length;
      }),
      (M.prototype.encodeString = function (B) {
        var H,
          Q = typeof B;
        if (Q !== "string") {
          if (Q === "object") {
            if (B === null) throw new Error(e);
            if (c && B.constructor === ArrayBuffer) B = new Uint8Array(B);
            else if (!Array.isArray(B) && (!c || !ArrayBuffer.isView(B)))
              throw new Error(e);
          } else throw new Error(e);
          H = !0;
        }
        var Z = 0,
          te = B.length;
        if (H) Z = te;
        else
          for (var Te = 0; Te < B.length; ++Te) {
            var K = B.charCodeAt(Te);
            K < 128
              ? (Z += 1)
              : K < 2048
              ? (Z += 2)
              : K < 55296 || K >= 57344
              ? (Z += 3)
              : ((K =
                  65536 + (((K & 1023) << 10) | (B.charCodeAt(++Te) & 1023))),
                (Z += 4));
          }
        return (Z += this.encode(Z * 8)), this.update(B), Z;
      }),
      (M.prototype.bytepad = function (B, H) {
        for (var Q = this.encode(H), Z = 0; Z < B.length; ++Z)
          Q += this.encodeString(B[Z]);
        var te = H - (Q % H),
          Te = [];
        return (Te.length = te), this.update(Te), this;
      }),
      (M.prototype.finalize = function () {
        if (!this.finalized) {
          this.finalized = !0;
          var B = this.blocks,
            H = this.lastByteIndex,
            Q = this.blockCount,
            Z = this.s;
          if (
            ((B[H >> 2] |= this.padding[H & 3]),
            this.lastByteIndex === this.byteCount)
          )
            for (B[0] = B[Q], H = 1; H < Q + 1; ++H) B[H] = 0;
          for (B[Q - 1] |= 2147483648, H = 0; H < Q; ++H) Z[H] ^= B[H];
          q(Z);
        }
      }),
      (M.prototype.toString = M.prototype.hex =
        function () {
          this.finalize();
          for (
            var B = this.blockCount,
              H = this.s,
              Q = this.outputBlocks,
              Z = this.extraBytes,
              te = 0,
              Te = 0,
              K = "",
              G;
            Te < Q;

          ) {
            for (te = 0; te < B && Te < Q; ++te, ++Te)
              (G = H[te]),
                (K +=
                  u[(G >> 4) & 15] +
                  u[G & 15] +
                  u[(G >> 12) & 15] +
                  u[(G >> 8) & 15] +
                  u[(G >> 20) & 15] +
                  u[(G >> 16) & 15] +
                  u[(G >> 28) & 15] +
                  u[(G >> 24) & 15]);
            Te % B === 0 && (q(H), (te = 0));
          }
          return (
            Z &&
              ((G = H[te]),
              (K += u[(G >> 4) & 15] + u[G & 15]),
              Z > 1 && (K += u[(G >> 12) & 15] + u[(G >> 8) & 15]),
              Z > 2 && (K += u[(G >> 20) & 15] + u[(G >> 16) & 15])),
            K
          );
        }),
      (M.prototype.arrayBuffer = function () {
        this.finalize();
        var B = this.blockCount,
          H = this.s,
          Q = this.outputBlocks,
          Z = this.extraBytes,
          te = 0,
          Te = 0,
          K = this.outputBits >> 3,
          G;
        Z ? (G = new ArrayBuffer((Q + 1) << 2)) : (G = new ArrayBuffer(K));
        for (var he = new Uint32Array(G); Te < Q; ) {
          for (te = 0; te < B && Te < Q; ++te, ++Te) he[Te] = H[te];
          Te % B === 0 && q(H);
        }
        return Z && ((he[te] = H[te]), (G = G.slice(0, K))), G;
      }),
      (M.prototype.buffer = M.prototype.arrayBuffer),
      (M.prototype.digest = M.prototype.array =
        function () {
          this.finalize();
          for (
            var B = this.blockCount,
              H = this.s,
              Q = this.outputBlocks,
              Z = this.extraBytes,
              te = 0,
              Te = 0,
              K = [],
              G,
              he;
            Te < Q;

          ) {
            for (te = 0; te < B && Te < Q; ++te, ++Te)
              (G = Te << 2),
                (he = H[te]),
                (K[G] = he & 255),
                (K[G + 1] = (he >> 8) & 255),
                (K[G + 2] = (he >> 16) & 255),
                (K[G + 3] = (he >> 24) & 255);
            Te % B === 0 && q(H);
          }
          return (
            Z &&
              ((G = Te << 2),
              (he = H[te]),
              (K[G] = he & 255),
              Z > 1 && (K[G + 1] = (he >> 8) & 255),
              Z > 2 && (K[G + 2] = (he >> 16) & 255)),
            K
          );
        });
    function D(B, H, Q) {
      M.call(this, B, H, Q);
    }
    (D.prototype = new M()),
      (D.prototype.finalize = function () {
        return (
          this.encode(this.outputBits, !0), M.prototype.finalize.call(this)
        );
      });
    var q = function (B) {
      var H,
        Q,
        Z,
        te,
        Te,
        K,
        G,
        he,
        se,
        pe,
        Y,
        $,
        W,
        re,
        ee,
        ce,
        Ce,
        me,
        ge,
        it,
        ve,
        z,
        U,
        L,
        J,
        fe,
        ie,
        le,
        nt,
        Ee,
        we,
        ft,
        xe,
        Pe,
        hr,
        Ne,
        Me,
        _r,
        Be,
        De,
        pr,
        Oe,
        Fe,
        mr,
        Le,
        Ie,
        At,
        Ae,
        Re,
        Er,
        $e,
        Ue,
        Mr,
        We,
        je,
        ur,
        mt,
        yt,
        rr,
        nr,
        ir,
        ar,
        sr;
      for (Z = 0; Z < 48; Z += 2)
        (te = B[0] ^ B[10] ^ B[20] ^ B[30] ^ B[40]),
          (Te = B[1] ^ B[11] ^ B[21] ^ B[31] ^ B[41]),
          (K = B[2] ^ B[12] ^ B[22] ^ B[32] ^ B[42]),
          (G = B[3] ^ B[13] ^ B[23] ^ B[33] ^ B[43]),
          (he = B[4] ^ B[14] ^ B[24] ^ B[34] ^ B[44]),
          (se = B[5] ^ B[15] ^ B[25] ^ B[35] ^ B[45]),
          (pe = B[6] ^ B[16] ^ B[26] ^ B[36] ^ B[46]),
          (Y = B[7] ^ B[17] ^ B[27] ^ B[37] ^ B[47]),
          ($ = B[8] ^ B[18] ^ B[28] ^ B[38] ^ B[48]),
          (W = B[9] ^ B[19] ^ B[29] ^ B[39] ^ B[49]),
          (H = $ ^ ((K << 1) | (G >>> 31))),
          (Q = W ^ ((G << 1) | (K >>> 31))),
          (B[0] ^= H),
          (B[1] ^= Q),
          (B[10] ^= H),
          (B[11] ^= Q),
          (B[20] ^= H),
          (B[21] ^= Q),
          (B[30] ^= H),
          (B[31] ^= Q),
          (B[40] ^= H),
          (B[41] ^= Q),
          (H = te ^ ((he << 1) | (se >>> 31))),
          (Q = Te ^ ((se << 1) | (he >>> 31))),
          (B[2] ^= H),
          (B[3] ^= Q),
          (B[12] ^= H),
          (B[13] ^= Q),
          (B[22] ^= H),
          (B[23] ^= Q),
          (B[32] ^= H),
          (B[33] ^= Q),
          (B[42] ^= H),
          (B[43] ^= Q),
          (H = K ^ ((pe << 1) | (Y >>> 31))),
          (Q = G ^ ((Y << 1) | (pe >>> 31))),
          (B[4] ^= H),
          (B[5] ^= Q),
          (B[14] ^= H),
          (B[15] ^= Q),
          (B[24] ^= H),
          (B[25] ^= Q),
          (B[34] ^= H),
          (B[35] ^= Q),
          (B[44] ^= H),
          (B[45] ^= Q),
          (H = he ^ (($ << 1) | (W >>> 31))),
          (Q = se ^ ((W << 1) | ($ >>> 31))),
          (B[6] ^= H),
          (B[7] ^= Q),
          (B[16] ^= H),
          (B[17] ^= Q),
          (B[26] ^= H),
          (B[27] ^= Q),
          (B[36] ^= H),
          (B[37] ^= Q),
          (B[46] ^= H),
          (B[47] ^= Q),
          (H = pe ^ ((te << 1) | (Te >>> 31))),
          (Q = Y ^ ((Te << 1) | (te >>> 31))),
          (B[8] ^= H),
          (B[9] ^= Q),
          (B[18] ^= H),
          (B[19] ^= Q),
          (B[28] ^= H),
          (B[29] ^= Q),
          (B[38] ^= H),
          (B[39] ^= Q),
          (B[48] ^= H),
          (B[49] ^= Q),
          (re = B[0]),
          (ee = B[1]),
          (Ie = (B[11] << 4) | (B[10] >>> 28)),
          (At = (B[10] << 4) | (B[11] >>> 28)),
          (le = (B[20] << 3) | (B[21] >>> 29)),
          (nt = (B[21] << 3) | (B[20] >>> 29)),
          (nr = (B[31] << 9) | (B[30] >>> 23)),
          (ir = (B[30] << 9) | (B[31] >>> 23)),
          (Oe = (B[40] << 18) | (B[41] >>> 14)),
          (Fe = (B[41] << 18) | (B[40] >>> 14)),
          (Pe = (B[2] << 1) | (B[3] >>> 31)),
          (hr = (B[3] << 1) | (B[2] >>> 31)),
          (ce = (B[13] << 12) | (B[12] >>> 20)),
          (Ce = (B[12] << 12) | (B[13] >>> 20)),
          (Ae = (B[22] << 10) | (B[23] >>> 22)),
          (Re = (B[23] << 10) | (B[22] >>> 22)),
          (Ee = (B[33] << 13) | (B[32] >>> 19)),
          (we = (B[32] << 13) | (B[33] >>> 19)),
          (ar = (B[42] << 2) | (B[43] >>> 30)),
          (sr = (B[43] << 2) | (B[42] >>> 30)),
          (We = (B[5] << 30) | (B[4] >>> 2)),
          (je = (B[4] << 30) | (B[5] >>> 2)),
          (Ne = (B[14] << 6) | (B[15] >>> 26)),
          (Me = (B[15] << 6) | (B[14] >>> 26)),
          (me = (B[25] << 11) | (B[24] >>> 21)),
          (ge = (B[24] << 11) | (B[25] >>> 21)),
          (Er = (B[34] << 15) | (B[35] >>> 17)),
          ($e = (B[35] << 15) | (B[34] >>> 17)),
          (ft = (B[45] << 29) | (B[44] >>> 3)),
          (xe = (B[44] << 29) | (B[45] >>> 3)),
          (L = (B[6] << 28) | (B[7] >>> 4)),
          (J = (B[7] << 28) | (B[6] >>> 4)),
          (ur = (B[17] << 23) | (B[16] >>> 9)),
          (mt = (B[16] << 23) | (B[17] >>> 9)),
          (_r = (B[26] << 25) | (B[27] >>> 7)),
          (Be = (B[27] << 25) | (B[26] >>> 7)),
          (it = (B[36] << 21) | (B[37] >>> 11)),
          (ve = (B[37] << 21) | (B[36] >>> 11)),
          (Ue = (B[47] << 24) | (B[46] >>> 8)),
          (Mr = (B[46] << 24) | (B[47] >>> 8)),
          (mr = (B[8] << 27) | (B[9] >>> 5)),
          (Le = (B[9] << 27) | (B[8] >>> 5)),
          (fe = (B[18] << 20) | (B[19] >>> 12)),
          (ie = (B[19] << 20) | (B[18] >>> 12)),
          (yt = (B[29] << 7) | (B[28] >>> 25)),
          (rr = (B[28] << 7) | (B[29] >>> 25)),
          (De = (B[38] << 8) | (B[39] >>> 24)),
          (pr = (B[39] << 8) | (B[38] >>> 24)),
          (z = (B[48] << 14) | (B[49] >>> 18)),
          (U = (B[49] << 14) | (B[48] >>> 18)),
          (B[0] = re ^ (~ce & me)),
          (B[1] = ee ^ (~Ce & ge)),
          (B[10] = L ^ (~fe & le)),
          (B[11] = J ^ (~ie & nt)),
          (B[20] = Pe ^ (~Ne & _r)),
          (B[21] = hr ^ (~Me & Be)),
          (B[30] = mr ^ (~Ie & Ae)),
          (B[31] = Le ^ (~At & Re)),
          (B[40] = We ^ (~ur & yt)),
          (B[41] = je ^ (~mt & rr)),
          (B[2] = ce ^ (~me & it)),
          (B[3] = Ce ^ (~ge & ve)),
          (B[12] = fe ^ (~le & Ee)),
          (B[13] = ie ^ (~nt & we)),
          (B[22] = Ne ^ (~_r & De)),
          (B[23] = Me ^ (~Be & pr)),
          (B[32] = Ie ^ (~Ae & Er)),
          (B[33] = At ^ (~Re & $e)),
          (B[42] = ur ^ (~yt & nr)),
          (B[43] = mt ^ (~rr & ir)),
          (B[4] = me ^ (~it & z)),
          (B[5] = ge ^ (~ve & U)),
          (B[14] = le ^ (~Ee & ft)),
          (B[15] = nt ^ (~we & xe)),
          (B[24] = _r ^ (~De & Oe)),
          (B[25] = Be ^ (~pr & Fe)),
          (B[34] = Ae ^ (~Er & Ue)),
          (B[35] = Re ^ (~$e & Mr)),
          (B[44] = yt ^ (~nr & ar)),
          (B[45] = rr ^ (~ir & sr)),
          (B[6] = it ^ (~z & re)),
          (B[7] = ve ^ (~U & ee)),
          (B[16] = Ee ^ (~ft & L)),
          (B[17] = we ^ (~xe & J)),
          (B[26] = De ^ (~Oe & Pe)),
          (B[27] = pr ^ (~Fe & hr)),
          (B[36] = Er ^ (~Ue & mr)),
          (B[37] = $e ^ (~Mr & Le)),
          (B[46] = nr ^ (~ar & We)),
          (B[47] = ir ^ (~sr & je)),
          (B[8] = z ^ (~re & ce)),
          (B[9] = U ^ (~ee & Ce)),
          (B[18] = ft ^ (~L & fe)),
          (B[19] = xe ^ (~J & ie)),
          (B[28] = Oe ^ (~Pe & Ne)),
          (B[29] = Fe ^ (~hr & Me)),
          (B[38] = Ue ^ (~mr & Ie)),
          (B[39] = Mr ^ (~Le & At)),
          (B[48] = ar ^ (~We & ur)),
          (B[49] = sr ^ (~je & mt)),
          (B[0] ^= I[Z]),
          (B[1] ^= I[Z + 1]);
    };
    if (o) t.exports = h;
    else for (T = 0; T < g.length; ++T) i[g[T]] = h[g[T]];
  })();
})(vB);
var xB = vB.exports;
const hQ = mn(xB);
function Ut(t) {
  return "0x" + hQ.keccak_256(qe(t));
}
const pQ = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        keccak256: Ut,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  mQ = "rlp/5.7.0",
  Ds = new ue(mQ);
function yk(t) {
  const e = [];
  for (; t; ) e.unshift(t & 255), (t >>= 8);
  return e;
}
function gk(t, e, r) {
  let n = 0;
  for (let i = 0; i < r; i++) n = n * 256 + t[e + i];
  return n;
}
function wB(t) {
  if (Array.isArray(t)) {
    let n = [];
    if (
      (t.forEach(function (a) {
        n = n.concat(wB(a));
      }),
      n.length <= 55)
    )
      return n.unshift(192 + n.length), n;
    const i = yk(n.length);
    return i.unshift(247 + i.length), i.concat(n);
  }
  Bm(t) || Ds.throwArgumentError("RLP object must be BytesLike", "object", t);
  const e = Array.prototype.slice.call(qe(t));
  if (e.length === 1 && e[0] <= 127) return e;
  if (e.length <= 55) return e.unshift(128 + e.length), e;
  const r = yk(e.length);
  return r.unshift(183 + r.length), r.concat(e);
}
function mu(t) {
  return Ke(wB(t));
}
function bk(t, e, r, n) {
  const i = [];
  for (; r < e + 1 + n; ) {
    const a = _B(t, r);
    i.push(a.result),
      (r += a.consumed),
      r > e + 1 + n &&
        Ds.throwError("child data too short", ue.errors.BUFFER_OVERRUN, {});
  }
  return {
    consumed: 1 + n,
    result: i,
  };
}
function _B(t, e) {
  if (
    (t.length === 0 &&
      Ds.throwError("data too short", ue.errors.BUFFER_OVERRUN, {}),
    t[e] >= 248)
  ) {
    const r = t[e] - 247;
    e + 1 + r > t.length &&
      Ds.throwError(
        "data short segment too short",
        ue.errors.BUFFER_OVERRUN,
        {}
      );
    const n = gk(t, e + 1, r);
    return (
      e + 1 + r + n > t.length &&
        Ds.throwError(
          "data long segment too short",
          ue.errors.BUFFER_OVERRUN,
          {}
        ),
      bk(t, e, e + 1 + r, r + n)
    );
  } else if (t[e] >= 192) {
    const r = t[e] - 192;
    return (
      e + 1 + r > t.length &&
        Ds.throwError("data array too short", ue.errors.BUFFER_OVERRUN, {}),
      bk(t, e, e + 1, r)
    );
  } else if (t[e] >= 184) {
    const r = t[e] - 183;
    e + 1 + r > t.length &&
      Ds.throwError("data array too short", ue.errors.BUFFER_OVERRUN, {});
    const n = gk(t, e + 1, r);
    e + 1 + r + n > t.length &&
      Ds.throwError("data array too short", ue.errors.BUFFER_OVERRUN, {});
    const i = Ke(t.slice(e + 1 + r, e + 1 + r + n));
    return {
      consumed: 1 + r + n,
      result: i,
    };
  } else if (t[e] >= 128) {
    const r = t[e] - 128;
    e + 1 + r > t.length &&
      Ds.throwError("data too short", ue.errors.BUFFER_OVERRUN, {});
    const n = Ke(t.slice(e + 1, e + 1 + r));
    return {
      consumed: 1 + r,
      result: n,
    };
  }
  return {
    consumed: 1,
    result: Ke(t[e]),
  };
}
function Kb(t) {
  const e = qe(t),
    r = _B(e, 0);
  return (
    r.consumed !== e.length &&
      Ds.throwArgumentError("invalid rlp data", "data", t),
    r.result
  );
}
const yQ = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        decode: Kb,
        encode: mu,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  gQ = "address/5.7.0",
  Tc = new ue(gQ);
function vk(t) {
  gt(t, 20) || Tc.throwArgumentError("invalid address", "address", t),
    (t = t.toLowerCase());
  const e = t.substring(2).split(""),
    r = new Uint8Array(40);
  for (let i = 0; i < 40; i++) r[i] = e[i].charCodeAt(0);
  const n = qe(Ut(r));
  for (let i = 0; i < 40; i += 2)
    n[i >> 1] >> 4 >= 8 && (e[i] = e[i].toUpperCase()),
      (n[i >> 1] & 15) >= 8 && (e[i + 1] = e[i + 1].toUpperCase());
  return "0x" + e.join("");
}
const bQ = 9007199254740991;
function vQ(t) {
  return Math.log10 ? Math.log10(t) : Math.log(t) / Math.LN10;
}
const q8 = {};
for (let t = 0; t < 10; t++) q8[String(t)] = String(t);
for (let t = 0; t < 26; t++) q8[String.fromCharCode(65 + t)] = String(10 + t);
const xk = Math.floor(vQ(bQ));
function EB(t) {
  (t = t.toUpperCase()), (t = t.substring(4) + t.substring(0, 2) + "00");
  let e = t
    .split("")
    .map((n) => q8[n])
    .join("");
  for (; e.length >= xk; ) {
    let n = e.substring(0, xk);
    e = (parseInt(n, 10) % 97) + e.substring(n.length);
  }
  let r = String(98 - (parseInt(e, 10) % 97));
  for (; r.length < 2; ) r = "0" + r;
  return r;
}
function Xt(t) {
  let e = null;
  if (
    (typeof t != "string" &&
      Tc.throwArgumentError("invalid address", "address", t),
    t.match(/^(0x)?[0-9a-fA-F]{40}$/))
  )
    t.substring(0, 2) !== "0x" && (t = "0x" + t),
      (e = vk(t)),
      t.match(/([A-F].*[a-f])|([a-f].*[A-F])/) &&
        e !== t &&
        Tc.throwArgumentError("bad address checksum", "address", t);
  else if (t.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    for (
      t.substring(2, 4) !== EB(t) &&
        Tc.throwArgumentError("bad icap checksum", "address", t),
        e = eQ(t.substring(4));
      e.length < 40;

    )
      e = "0" + e;
    e = vk("0x" + e);
  } else Tc.throwArgumentError("invalid address", "address", t);
  return e;
}
function ud(t) {
  try {
    return Xt(t), !0;
  } catch {}
  return !1;
}
function xQ(t) {
  let e = tQ(Xt(t).substring(2)).toUpperCase();
  for (; e.length < 30; ) e = "0" + e;
  return "XE" + EB("XE00" + e) + e;
}
function fd(t) {
  let e = null;
  try {
    e = Xt(t.from);
  } catch {
    Tc.throwArgumentError("missing from address", "transaction", t);
  }
  const r = zi(qe(ae.from(t.nonce).toHexString()));
  return Xt(sn(Ut(mu([e, r])), 12));
}
function wQ(t, e, r) {
  return (
    za(e) !== 32 && Tc.throwArgumentError("salt must be 32 bytes", "salt", e),
    za(r) !== 32 &&
      Tc.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", r),
    Xt(sn(Ut(cr(["0xff", Xt(t), e, r])), 12))
  );
}
const _Q = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      getAddress: Xt,
      getContractAddress: fd,
      getCreate2Address: wQ,
      getIcapAddress: xQ,
      isAddress: ud,
    },
    Symbol.toStringTag,
    {
      value: "Module",
    }
  )
);
class EQ extends ec {
  constructor(e) {
    super("address", "address", e, !1);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(e, r) {
    try {
      r = Xt(r);
    } catch (n) {
      this._throwError(n.message, r);
    }
    return e.writeValue(r);
  }
  decode(e) {
    return Xt(Rt(e.readValue().toHexString(), 20));
  }
}
class TQ extends ec {
  constructor(e) {
    super(e.name, e.type, void 0, e.dynamic), (this.coder = e);
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(e, r) {
    return this.coder.encode(e, r);
  }
  decode(e) {
    return this.coder.decode(e);
  }
}
const R0 = new ue(Om);
function TB(t, e, r) {
  let n = null;
  if (Array.isArray(r)) n = r;
  else if (r && typeof r == "object") {
    let c = {};
    n = e.map((u) => {
      const d = u.localName;
      return (
        d ||
          R0.throwError(
            "cannot encode object for signature with missing names",
            ue.errors.INVALID_ARGUMENT,
            {
              argument: "values",
              coder: u,
              value: r,
            }
          ),
        c[d] &&
          R0.throwError(
            "cannot encode object for signature with duplicate names",
            ue.errors.INVALID_ARGUMENT,
            {
              argument: "values",
              coder: u,
              value: r,
            }
          ),
        (c[d] = !0),
        r[d]
      );
    });
  } else R0.throwArgumentError("invalid tuple value", "tuple", r);
  e.length !== n.length &&
    R0.throwArgumentError("types/value length mismatch", "tuple", r);
  let i = new t_(t.wordSize),
    a = new t_(t.wordSize),
    s = [];
  e.forEach((c, u) => {
    let d = n[u];
    if (c.dynamic) {
      let m = a.length;
      c.encode(a, d);
      let v = i.writeUpdatableValue();
      s.push((E) => {
        v(E + m);
      });
    } else c.encode(i, d);
  }),
    s.forEach((c) => {
      c(i.length);
    });
  let o = t.appendWriter(i);
  return (o += t.appendWriter(a)), o;
}
function CB(t, e) {
  let r = [],
    n = t.subReader(0);
  e.forEach((a) => {
    let s = null;
    if (a.dynamic) {
      let o = t.readValue(),
        c = n.subReader(o.toNumber());
      try {
        s = a.decode(c);
      } catch (u) {
        if (u.code === ue.errors.BUFFER_OVERRUN) throw u;
        (s = u),
          (s.baseType = a.name),
          (s.name = a.localName),
          (s.type = a.type);
      }
    } else
      try {
        s = a.decode(t);
      } catch (o) {
        if (o.code === ue.errors.BUFFER_OVERRUN) throw o;
        (s = o),
          (s.baseType = a.name),
          (s.name = a.localName),
          (s.type = a.type);
      }
    s != null && r.push(s);
  });
  const i = e.reduce((a, s) => {
    const o = s.localName;
    return o && (a[o] || (a[o] = 0), a[o]++), a;
  }, {});
  e.forEach((a, s) => {
    let o = a.localName;
    if (!o || i[o] !== 1 || (o === "length" && (o = "_length"), r[o] != null))
      return;
    const c = r[s];
    c instanceof Error
      ? Object.defineProperty(r, o, {
          enumerable: !0,
          get: () => {
            throw c;
          },
        })
      : (r[o] = c);
  });
  for (let a = 0; a < r.length; a++) {
    const s = r[a];
    s instanceof Error &&
      Object.defineProperty(r, a, {
        enumerable: !0,
        get: () => {
          throw s;
        },
      });
  }
  return Object.freeze(r);
}
class CQ extends ec {
  constructor(e, r, n) {
    const i = e.type + "[" + (r >= 0 ? r : "") + "]",
      a = r === -1 || e.dynamic;
    super("array", i, n, a), (this.coder = e), (this.length = r);
  }
  defaultValue() {
    const e = this.coder.defaultValue(),
      r = [];
    for (let n = 0; n < this.length; n++) r.push(e);
    return r;
  }
  encode(e, r) {
    Array.isArray(r) || this._throwError("expected array value", r);
    let n = this.length;
    n === -1 && ((n = r.length), e.writeValue(r.length)),
      R0.checkArgumentCount(
        r.length,
        n,
        "coder array" + (this.localName ? " " + this.localName : "")
      );
    let i = [];
    for (let a = 0; a < r.length; a++) i.push(this.coder);
    return TB(e, i, r);
  }
  decode(e) {
    let r = this.length;
    r === -1 &&
      ((r = e.readValue().toNumber()),
      r * 32 > e._data.length &&
        R0.throwError("insufficient data length", ue.errors.BUFFER_OVERRUN, {
          length: e._data.length,
          count: r,
        }));
    let n = [];
    for (let i = 0; i < r; i++) n.push(new TQ(this.coder));
    return e.coerce(this.name, CB(e, n));
  }
}
class AQ extends ec {
  constructor(e) {
    super("bool", "bool", e, !1);
  }
  defaultValue() {
    return !1;
  }
  encode(e, r) {
    return e.writeValue(r ? 1 : 0);
  }
  decode(e) {
    return e.coerce(this.type, !e.readValue().isZero());
  }
}
class AB extends ec {
  constructor(e, r) {
    super(e, e, r, !0);
  }
  defaultValue() {
    return "0x";
  }
  encode(e, r) {
    r = qe(r);
    let n = e.writeValue(r.length);
    return (n += e.writeBytes(r)), n;
  }
  decode(e) {
    return e.readBytes(e.readValue().toNumber(), !0);
  }
}
class kQ extends AB {
  constructor(e) {
    super("bytes", e);
  }
  decode(e) {
    return e.coerce(this.name, Ke(super.decode(e)));
  }
}
class SQ extends ec {
  constructor(e, r) {
    let n = "bytes" + String(e);
    super(n, n, r, !1), (this.size = e);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(
      0,
      2 + this.size * 2
    );
  }
  encode(e, r) {
    let n = qe(r);
    return (
      n.length !== this.size && this._throwError("incorrect data length", r),
      e.writeBytes(n)
    );
  }
  decode(e) {
    return e.coerce(this.name, Ke(e.readBytes(this.size)));
  }
}
class MQ extends ec {
  constructor(e) {
    super("null", "", e, !1);
  }
  defaultValue() {
    return null;
  }
  encode(e, r) {
    return r != null && this._throwError("not null", r), e.writeBytes([]);
  }
  decode(e) {
    return e.readBytes(0), e.coerce(this.name, null);
  }
}
const Ft = "0x0000000000000000000000000000000000000000",
  IQ = ae.from(-1),
  kB = ae.from(0),
  RQ = ae.from(1),
  da = ae.from(
    "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
  ),
  SB = "0x0000000000000000000000000000000000000000000000000000000000000000";
class PQ extends ec {
  constructor(e, r, n) {
    const i = (r ? "int" : "uint") + e * 8;
    super(i, i, n, !1), (this.size = e), (this.signed = r);
  }
  defaultValue() {
    return 0;
  }
  encode(e, r) {
    let n = ae.from(r),
      i = da.mask(e.wordSize * 8);
    if (this.signed) {
      let a = i.mask(this.size * 8 - 1);
      (n.gt(a) || n.lt(a.add(RQ).mul(IQ))) &&
        this._throwError("value out-of-bounds", r);
    } else
      (n.lt(kB) || n.gt(i.mask(this.size * 8))) &&
        this._throwError("value out-of-bounds", r);
    return (
      (n = n.toTwos(this.size * 8).mask(this.size * 8)),
      this.signed && (n = n.fromTwos(this.size * 8).toTwos(8 * e.wordSize)),
      e.writeValue(n)
    );
  }
  decode(e) {
    let r = e.readValue().mask(this.size * 8);
    return (
      this.signed && (r = r.fromTwos(this.size * 8)), e.coerce(this.name, r)
    );
  }
}
const NQ = "strings/5.7.0",
  MB = new ue(NQ);
var co;
(function (t) {
  (t.current = ""),
    (t.NFC = "NFC"),
    (t.NFD = "NFD"),
    (t.NFKC = "NFKC"),
    (t.NFKD = "NFKD");
})(co || (co = {}));
var Oi;
(function (t) {
  (t.UNEXPECTED_CONTINUE = "unexpected continuation byte"),
    (t.BAD_PREFIX = "bad codepoint prefix"),
    (t.OVERRUN = "string overrun"),
    (t.MISSING_CONTINUE = "missing continuation byte"),
    (t.OUT_OF_RANGE = "out of UTF-8 range"),
    (t.UTF16_SURROGATE = "UTF-16 surrogate"),
    (t.OVERLONG = "overlong representation");
})(Oi || (Oi = {}));
function BQ(t, e, r, n, i) {
  return MB.throwArgumentError(
    `invalid codepoint at offset ${e}; ${t}`,
    "bytes",
    r
  );
}
function IB(t, e, r, n, i) {
  if (t === Oi.BAD_PREFIX || t === Oi.UNEXPECTED_CONTINUE) {
    let a = 0;
    for (let s = e + 1; s < r.length && r[s] >> 6 === 2; s++) a++;
    return a;
  }
  return t === Oi.OVERRUN ? r.length - e - 1 : 0;
}
function DQ(t, e, r, n, i) {
  return t === Oi.OVERLONG ? (n.push(i), 0) : (n.push(65533), IB(t, e, r));
}
const RB = Object.freeze({
  error: BQ,
  ignore: IB,
  replace: DQ,
});
function V8(t, e) {
  e == null && (e = RB.error), (t = qe(t));
  const r = [];
  let n = 0;
  for (; n < t.length; ) {
    const i = t[n++];
    if (!(i >> 7)) {
      r.push(i);
      continue;
    }
    let a = null,
      s = null;
    if ((i & 224) === 192) (a = 1), (s = 127);
    else if ((i & 240) === 224) (a = 2), (s = 2047);
    else if ((i & 248) === 240) (a = 3), (s = 65535);
    else {
      (i & 192) === 128
        ? (n += e(Oi.UNEXPECTED_CONTINUE, n - 1, t, r))
        : (n += e(Oi.BAD_PREFIX, n - 1, t, r));
      continue;
    }
    if (n - 1 + a >= t.length) {
      n += e(Oi.OVERRUN, n - 1, t, r);
      continue;
    }
    let o = i & ((1 << (8 - a - 1)) - 1);
    for (let c = 0; c < a; c++) {
      let u = t[n];
      if ((u & 192) != 128) {
        (n += e(Oi.MISSING_CONTINUE, n, t, r)), (o = null);
        break;
      }
      (o = (o << 6) | (u & 63)), n++;
    }
    if (o !== null) {
      if (o > 1114111) {
        n += e(Oi.OUT_OF_RANGE, n - 1 - a, t, r, o);
        continue;
      }
      if (o >= 55296 && o <= 57343) {
        n += e(Oi.UTF16_SURROGATE, n - 1 - a, t, r, o);
        continue;
      }
      if (o <= s) {
        n += e(Oi.OVERLONG, n - 1 - a, t, r, o);
        continue;
      }
      r.push(o);
    }
  }
  return r;
}
function Lt(t, e = co.current) {
  e != co.current && (MB.checkNormalize(), (t = t.normalize(e)));
  let r = [];
  for (let n = 0; n < t.length; n++) {
    const i = t.charCodeAt(n);
    if (i < 128) r.push(i);
    else if (i < 2048) r.push((i >> 6) | 192), r.push((i & 63) | 128);
    else if ((i & 64512) == 55296) {
      n++;
      const a = t.charCodeAt(n);
      if (n >= t.length || (a & 64512) !== 56320)
        throw new Error("invalid utf-8 string");
      const s = 65536 + ((i & 1023) << 10) + (a & 1023);
      r.push((s >> 18) | 240),
        r.push(((s >> 12) & 63) | 128),
        r.push(((s >> 6) & 63) | 128),
        r.push((s & 63) | 128);
    } else
      r.push((i >> 12) | 224),
        r.push(((i >> 6) & 63) | 128),
        r.push((i & 63) | 128);
  }
  return qe(r);
}
function Hw(t) {
  const e = "0000" + t.toString(16);
  return "\\u" + e.substring(e.length - 4);
}
function OQ(t, e) {
  return (
    '"' +
    V8(t, e)
      .map((r) => {
        if (r < 256) {
          switch (r) {
            case 8:
              return "\\b";
            case 9:
              return "\\t";
            case 10:
              return "\\n";
            case 13:
              return "\\r";
            case 34:
              return '\\"';
            case 92:
              return "\\\\";
          }
          if (r >= 32 && r < 127) return String.fromCharCode(r);
        }
        return r <= 65535
          ? Hw(r)
          : ((r -= 65536),
            Hw(((r >> 10) & 1023) + 55296) + Hw((r & 1023) + 56320));
      })
      .join("") +
    '"'
  );
}
function r_(t) {
  return t
    .map((e) =>
      e <= 65535
        ? String.fromCharCode(e)
        : ((e -= 65536),
          String.fromCharCode(((e >> 10) & 1023) + 55296, (e & 1023) + 56320))
    )
    .join("");
}
function go(t, e) {
  return r_(V8(t, e));
}
function Kg(t, e = co.current) {
  return V8(Lt(t, e));
}
function xh(t) {
  const e = Lt(t);
  if (e.length > 31)
    throw new Error("bytes32 string must be less than 32 bytes");
  return Ke(cr([e, SB]).slice(0, 32));
}
function FQ(t) {
  const e = qe(t);
  if (e.length !== 32) throw new Error("invalid bytes32 - not 32 bytes long");
  if (e[31] !== 0)
    throw new Error("invalid bytes32 string - no null terminator");
  let r = 31;
  for (; e[r - 1] === 0; ) r--;
  return go(e.slice(0, r));
}
function LQ(t) {
  if (t.length % 4 !== 0) throw new Error("bad data");
  let e = [];
  for (let r = 0; r < t.length; r += 4)
    e.push(parseInt(t.substring(r, r + 4), 16));
  return e;
}
function K8(t, e) {
  e ||
    (e = function (i) {
      return [parseInt(i, 16)];
    });
  let r = 0,
    n = {};
  return (
    t.split(",").forEach((i) => {
      let a = i.split(":");
      (r += parseInt(a[0], 16)), (n[r] = e(a[1]));
    }),
    n
  );
}
function PB(t) {
  let e = 0;
  return t.split(",").map((r) => {
    let n = r.split("-");
    n.length === 1 ? (n[1] = "0") : n[1] === "" && (n[1] = "1");
    let i = e + parseInt(n[0], 16);
    return (
      (e = parseInt(n[1], 16)),
      {
        l: i,
        h: e,
      }
    );
  });
}
function G8(t, e) {
  let r = 0;
  for (let n = 0; n < e.length; n++) {
    let i = e[n];
    if (((r += i.l), t >= r && t <= r + i.h && (t - r) % (i.d || 1) === 0)) {
      if (i.e && i.e.indexOf(t - r) !== -1) continue;
      return i;
    }
  }
  return null;
}
const $Q = PB(
    "221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d"
  ),
  UQ = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff"
    .split(",")
    .map((t) => parseInt(t, 16)),
  WQ = [
    {
      h: 25,
      s: 32,
      l: 65,
    },
    {
      h: 30,
      s: 32,
      e: [23],
      l: 127,
    },
    {
      h: 54,
      s: 1,
      e: [48],
      l: 64,
      d: 2,
    },
    {
      h: 14,
      s: 1,
      l: 57,
      d: 2,
    },
    {
      h: 44,
      s: 1,
      l: 17,
      d: 2,
    },
    {
      h: 10,
      s: 1,
      e: [2, 6, 8],
      l: 61,
      d: 2,
    },
    {
      h: 16,
      s: 1,
      l: 68,
      d: 2,
    },
    {
      h: 84,
      s: 1,
      e: [18, 24, 66],
      l: 19,
      d: 2,
    },
    {
      h: 26,
      s: 32,
      e: [17],
      l: 435,
    },
    {
      h: 22,
      s: 1,
      l: 71,
      d: 2,
    },
    {
      h: 15,
      s: 80,
      l: 40,
    },
    {
      h: 31,
      s: 32,
      l: 16,
    },
    {
      h: 32,
      s: 1,
      l: 80,
      d: 2,
    },
    {
      h: 52,
      s: 1,
      l: 42,
      d: 2,
    },
    {
      h: 12,
      s: 1,
      l: 55,
      d: 2,
    },
    {
      h: 40,
      s: 1,
      e: [38],
      l: 15,
      d: 2,
    },
    {
      h: 14,
      s: 1,
      l: 48,
      d: 2,
    },
    {
      h: 37,
      s: 48,
      l: 49,
    },
    {
      h: 148,
      s: 1,
      l: 6351,
      d: 2,
    },
    {
      h: 88,
      s: 1,
      l: 160,
      d: 2,
    },
    {
      h: 15,
      s: 16,
      l: 704,
    },
    {
      h: 25,
      s: 26,
      l: 854,
    },
    {
      h: 25,
      s: 32,
      l: 55915,
    },
    {
      h: 37,
      s: 40,
      l: 1247,
    },
    {
      h: 25,
      s: -119711,
      l: 53248,
    },
    {
      h: 25,
      s: -119763,
      l: 52,
    },
    {
      h: 25,
      s: -119815,
      l: 52,
    },
    {
      h: 25,
      s: -119867,
      e: [1, 4, 5, 7, 8, 11, 12, 17],
      l: 52,
    },
    {
      h: 25,
      s: -119919,
      l: 52,
    },
    {
      h: 24,
      s: -119971,
      e: [2, 7, 8, 17],
      l: 52,
    },
    {
      h: 24,
      s: -120023,
      e: [2, 7, 13, 15, 16, 17],
      l: 52,
    },
    {
      h: 25,
      s: -120075,
      l: 52,
    },
    {
      h: 25,
      s: -120127,
      l: 52,
    },
    {
      h: 25,
      s: -120179,
      l: 52,
    },
    {
      h: 25,
      s: -120231,
      l: 52,
    },
    {
      h: 25,
      s: -120283,
      l: 52,
    },
    {
      h: 25,
      s: -120335,
      l: 52,
    },
    {
      h: 24,
      s: -119543,
      e: [17],
      l: 56,
    },
    {
      h: 24,
      s: -119601,
      e: [17],
      l: 58,
    },
    {
      h: 24,
      s: -119659,
      e: [17],
      l: 58,
    },
    {
      h: 24,
      s: -119717,
      e: [17],
      l: 58,
    },
    {
      h: 24,
      s: -119775,
      e: [17],
      l: 58,
    },
  ],
  jQ = K8(
    "b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3"
  ),
  HQ = K8(
    "179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7"
  ),
  zQ = K8(
    "df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D",
    LQ
  ),
  qQ = PB(
    "80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001"
  );
function VQ(t) {
  return t.reduce(
    (e, r) => (
      r.forEach((n) => {
        e.push(n);
      }),
      e
    ),
    []
  );
}
function KQ(t) {
  return !!G8(t, $Q);
}
function GQ(t) {
  let e = G8(t, WQ);
  if (e) return [t + e.s];
  let r = jQ[t];
  if (r) return r;
  let n = HQ[t];
  if (n) return [t + n[0]];
  let i = zQ[t];
  return i || null;
}
function ZQ(t) {
  return !!G8(t, qQ);
}
function JQ(t) {
  if (t.match(/^[a-z0-9-]*$/i) && t.length <= 59) return t.toLowerCase();
  let e = Kg(t);
  (e = VQ(
    e.map((n) => {
      if (UQ.indexOf(n) >= 0) return [];
      if (n >= 65024 && n <= 65039) return [];
      let i = GQ(n);
      return i || [n];
    })
  )),
    (e = Kg(r_(e), co.NFKC)),
    e.forEach((n) => {
      if (ZQ(n)) throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
    }),
    e.forEach((n) => {
      if (KQ(n)) throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
    });
  let r = r_(e);
  if (
    r.substring(0, 1) === "-" ||
    r.substring(2, 4) === "--" ||
    r.substring(r.length - 1) === "-"
  )
    throw new Error("invalid hyphen");
  return r;
}
const QQ = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      get UnicodeNormalizationForm() {
        return co;
      },
      Utf8ErrorFuncs: RB,
      get Utf8ErrorReason() {
        return Oi;
      },
      _toEscapedUtf8String: OQ,
      formatBytes32String: xh,
      nameprep: JQ,
      parseBytes32String: FQ,
      toUtf8Bytes: Lt,
      toUtf8CodePoints: Kg,
      toUtf8String: go,
    },
    Symbol.toStringTag,
    {
      value: "Module",
    }
  )
);
class YQ extends AB {
  constructor(e) {
    super("string", e);
  }
  defaultValue() {
    return "";
  }
  encode(e, r) {
    return super.encode(e, Lt(r));
  }
  decode(e) {
    return go(super.decode(e));
  }
}
class G1 extends ec {
  constructor(e, r) {
    let n = !1;
    const i = [];
    e.forEach((s) => {
      s.dynamic && (n = !0), i.push(s.type);
    });
    const a = "tuple(" + i.join(",") + ")";
    super("tuple", a, r, n), (this.coders = e);
  }
  defaultValue() {
    const e = [];
    this.coders.forEach((n) => {
      e.push(n.defaultValue());
    });
    const r = this.coders.reduce((n, i) => {
      const a = i.localName;
      return a && (n[a] || (n[a] = 0), n[a]++), n;
    }, {});
    return (
      this.coders.forEach((n, i) => {
        let a = n.localName;
        !a ||
          r[a] !== 1 ||
          (a === "length" && (a = "_length"), e[a] == null && (e[a] = e[i]));
      }),
      Object.freeze(e)
    );
  }
  encode(e, r) {
    return TB(e, this.coders, r);
  }
  decode(e) {
    return e.coerce(this.name, CB(e, this.coders));
  }
}
const Z1 = new ue(Om),
  XQ = new RegExp(/^bytes([0-9]*)$/),
  eY = new RegExp(/^(u?int)([0-9]*)$/);
class NB {
  constructor(e) {
    _e(this, "coerceFunc", e || null);
  }
  _getCoder(e) {
    switch (e.baseType) {
      case "address":
        return new EQ(e.name);
      case "bool":
        return new AQ(e.name);
      case "string":
        return new YQ(e.name);
      case "bytes":
        return new kQ(e.name);
      case "array":
        return new CQ(this._getCoder(e.arrayChildren), e.arrayLength, e.name);
      case "tuple":
        return new G1(
          (e.components || []).map((n) => this._getCoder(n)),
          e.name
        );
      case "":
        return new MQ(e.name);
    }
    let r = e.type.match(eY);
    if (r) {
      let n = parseInt(r[2] || "256");
      return (
        (n === 0 || n > 256 || n % 8 !== 0) &&
          Z1.throwArgumentError("invalid " + r[1] + " bit length", "param", e),
        new PQ(n / 8, r[1] === "int", e.name)
      );
    }
    if (((r = e.type.match(XQ)), r)) {
      let n = parseInt(r[1]);
      return (
        (n === 0 || n > 32) &&
          Z1.throwArgumentError("invalid bytes length", "param", e),
        new SQ(n, e.name)
      );
    }
    return Z1.throwArgumentError("invalid type", "type", e.type);
  }
  _getWordSize() {
    return 32;
  }
  _getReader(e, r) {
    return new Vg(e, this._getWordSize(), this.coerceFunc, r);
  }
  _getWriter() {
    return new t_(this._getWordSize());
  }
  getDefaultValue(e) {
    const r = e.map((i) => this._getCoder(rn.from(i)));
    return new G1(r, "_").defaultValue();
  }
  encode(e, r) {
    e.length !== r.length &&
      Z1.throwError(
        "types/values length mismatch",
        ue.errors.INVALID_ARGUMENT,
        {
          count: {
            types: e.length,
            values: r.length,
          },
          value: {
            types: e,
            values: r,
          },
        }
      );
    const n = e.map((s) => this._getCoder(rn.from(s))),
      i = new G1(n, "_"),
      a = this._getWriter();
    return i.encode(a, r), a.data;
  }
  decode(e, r, n) {
    const i = e.map((s) => this._getCoder(rn.from(s)));
    return new G1(i, "_").decode(this._getReader(qe(r), n));
  }
}
const xs = new NB();
function ui(t) {
  return Ut(Lt(t));
}
const BB = "hash/5.7.0";
function Z8(t) {
  t = atob(t);
  const e = [];
  for (let r = 0; r < t.length; r++) e.push(t.charCodeAt(r));
  return qe(e);
}
function J8(t) {
  t = qe(t);
  let e = "";
  for (let r = 0; r < t.length; r++) e += String.fromCharCode(t[r]);
  return btoa(e);
}
const tY = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      decode: Z8,
      encode: J8,
    },
    Symbol.toStringTag,
    {
      value: "Module",
    }
  )
);
function DB(t, e) {
  e == null && (e = 1);
  const r = [],
    n = r.forEach,
    i = function (a, s) {
      n.call(a, function (o) {
        s > 0 && Array.isArray(o) ? i(o, s - 1) : r.push(o);
      });
    };
  return i(t, e), r;
}
function rY(t) {
  const e = {};
  for (let r = 0; r < t.length; r++) {
    const n = t[r];
    e[n[0]] = n[1];
  }
  return e;
}
function nY(t) {
  let e = 0;
  function r() {
    return (t[e++] << 8) | t[e++];
  }
  let n = r(),
    i = 1,
    a = [0, 1];
  for (let O = 1; O < n; O++) a.push((i += r()));
  let s = r(),
    o = e;
  e += s;
  let c = 0,
    u = 0;
  function d() {
    return c == 0 && ((u = (u << 8) | t[e++]), (c = 8)), (u >> --c) & 1;
  }
  const m = 31,
    v = Math.pow(2, m),
    E = v >>> 1,
    A = E >> 1,
    I = v - 1;
  let b = 0;
  for (let O = 0; O < m; O++) b = (b << 1) | d();
  let w = [],
    S = 0,
    k = v;
  for (;;) {
    let O = Math.floor(((b - S + 1) * i - 1) / k),
      F = 0,
      V = n;
    for (; V - F > 1; ) {
      let C = (F + V) >>> 1;
      O < a[C] ? (V = C) : (F = C);
    }
    if (F == 0) break;
    w.push(F);
    let j = S + Math.floor((k * a[F]) / i),
      X = S + Math.floor((k * a[F + 1]) / i) - 1;
    for (; !((j ^ X) & E); )
      (b = ((b << 1) & I) | d()), (j = (j << 1) & I), (X = ((X << 1) & I) | 1);
    for (; j & ~X & A; )
      (b = (b & E) | ((b << 1) & (I >>> 1)) | d()),
        (j = (j << 1) ^ E),
        (X = ((X ^ E) << 1) | E | 1);
    (S = j), (k = 1 + X - j);
  }
  let N = n - 4;
  return w.map((O) => {
    switch (O - N) {
      case 3:
        return N + 65792 + ((t[o++] << 16) | (t[o++] << 8) | t[o++]);
      case 2:
        return N + 256 + ((t[o++] << 8) | t[o++]);
      case 1:
        return N + t[o++];
      default:
        return O - 1;
    }
  });
}
function iY(t) {
  let e = 0;
  return () => t[e++];
}
function aY(t) {
  return iY(nY(t));
}
function sY(t) {
  return t & 1 ? ~t >> 1 : t >> 1;
}
function oY(t, e) {
  let r = Array(t);
  for (let n = 0; n < t; n++) r[n] = 1 + e();
  return r;
}
function wk(t, e) {
  let r = Array(t);
  for (let n = 0, i = -1; n < t; n++) r[n] = i += 1 + e();
  return r;
}
function cY(t, e) {
  let r = Array(t);
  for (let n = 0, i = 0; n < t; n++) r[n] = i += sY(e());
  return r;
}
function Gg(t, e) {
  let r = wk(t(), t),
    n = t(),
    i = wk(n, t),
    a = oY(n, t);
  for (let s = 0; s < n; s++) for (let o = 0; o < a[s]; o++) r.push(i[s] + o);
  return e ? r.map((s) => e[s]) : r;
}
function lY(t) {
  let e = [];
  for (;;) {
    let r = t();
    if (r == 0) break;
    e.push(fY(r, t));
  }
  for (;;) {
    let r = t() - 1;
    if (r < 0) break;
    e.push(dY(r, t));
  }
  return rY(DB(e));
}
function uY(t) {
  let e = [];
  for (;;) {
    let r = t();
    if (r == 0) break;
    e.push(r);
  }
  return e;
}
function OB(t, e, r) {
  let n = Array(t)
    .fill(void 0)
    .map(() => []);
  for (let i = 0; i < e; i++) cY(t, r).forEach((a, s) => n[s].push(a));
  return n;
}
function fY(t, e) {
  let r = 1 + e(),
    n = e(),
    i = uY(e),
    a = OB(i.length, 1 + t, e);
  return DB(
    a.map((s, o) => {
      const c = s[0],
        u = s.slice(1);
      return Array(i[o])
        .fill(void 0)
        .map((d, m) => {
          let v = m * n;
          return [c + m * r, u.map((E) => E + v)];
        });
    })
  );
}
function dY(t, e) {
  let r = 1 + e();
  return OB(r, 1 + t, e).map((i) => [i[0], i.slice(1)]);
}
function hY(t) {
  let e = Gg(t).sort((n, i) => n - i);
  return r();
  function r() {
    let n = [];
    for (;;) {
      let u = Gg(t, e);
      if (u.length == 0) break;
      n.push({
        set: new Set(u),
        node: r(),
      });
    }
    n.sort((u, d) => d.set.size - u.set.size);
    let i = t(),
      a = i % 3;
    i = (i / 3) | 0;
    let s = !!(i & 1);
    i >>= 1;
    let o = i == 1,
      c = i == 2;
    return {
      branches: n,
      valid: a,
      fe0f: s,
      save: o,
      check: c,
    };
  }
}
function pY() {
  return aY(
    Z8(
      "AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=="
    )
  );
}
const Gb = pY(),
  mY = new Set(Gg(Gb)),
  yY = new Set(Gg(Gb)),
  gY = lY(Gb),
  bY = hY(Gb),
  _k = 45,
  Ek = 95;
function FB(t) {
  return Kg(t);
}
function vY(t) {
  return t.filter((e) => e != 65039);
}
function LB(t) {
  for (let e of t.split(".")) {
    let r = FB(e);
    try {
      for (let n = r.lastIndexOf(Ek) - 1; n >= 0; n--)
        if (r[n] !== Ek) throw new Error("underscore only allowed at start");
      if (
        r.length >= 4 &&
        r.every((n) => n < 128) &&
        r[2] === _k &&
        r[3] === _k
      )
        throw new Error("invalid label extension");
    } catch (n) {
      throw new Error(`Invalid label "${e}": ${n.message}`);
    }
  }
  return t;
}
function xY(t) {
  return LB(wY(t, vY));
}
function wY(t, e) {
  let r = FB(t).reverse(),
    n = [];
  for (; r.length; ) {
    let i = EY(r);
    if (i) {
      n.push(...e(i));
      continue;
    }
    let a = r.pop();
    if (mY.has(a)) {
      n.push(a);
      continue;
    }
    if (yY.has(a)) continue;
    let s = gY[a];
    if (s) {
      n.push(...s);
      continue;
    }
    throw new Error(`Disallowed codepoint: 0x${a.toString(16).toUpperCase()}`);
  }
  return LB(_Y(String.fromCodePoint(...n)));
}
function _Y(t) {
  return t.normalize("NFC");
}
function EY(t, e) {
  var r;
  let n = bY,
    i,
    a,
    s = [],
    o = t.length;
  for (; o; ) {
    let c = t[--o];
    if (
      ((n =
        (r = n.branches.find((u) => u.set.has(c))) === null || r === void 0
          ? void 0
          : r.node),
      !n)
    )
      break;
    if (n.save) a = c;
    else if (n.check && c === a) break;
    s.push(c),
      n.fe0f && (s.push(65039), o > 0 && t[o - 1] == 65039 && o--),
      n.valid &&
        ((i = s.slice()), n.valid == 2 && i.splice(1, 1), (t.length = o));
  }
  return i;
}
const TY = new ue(BB),
  $B = new Uint8Array(32);
$B.fill(0);
function Tk(t) {
  if (t.length === 0) throw new Error("invalid ENS name; empty component");
  return t;
}
function Zb(t) {
  const e = Lt(xY(t)),
    r = [];
  if (t.length === 0) return r;
  let n = 0;
  for (let i = 0; i < e.length; i++)
    e[i] === 46 && (r.push(Tk(e.slice(n, i))), (n = i + 1));
  if (n >= e.length) throw new Error("invalid ENS name; empty component");
  return r.push(Tk(e.slice(n))), r;
}
function CY(t) {
  return Zb(t)
    .map((e) => go(e))
    .join(".");
}
function AY(t) {
  try {
    return Zb(t).length !== 0;
  } catch {}
  return !1;
}
function Lh(t) {
  typeof t != "string" &&
    TY.throwArgumentError("invalid ENS name; not a string", "name", t);
  let e = $B;
  const r = Zb(t);
  for (; r.length; ) e = Ut(cr([e, Ut(r.pop())]));
  return Ke(e);
}
function UB(t) {
  return (
    Ke(
      cr(
        Zb(t).map((e) => {
          if (e.length > 63)
            throw new Error(
              "invalid DNS encoded entry; length exceeds 63 bytes"
            );
          const r = new Uint8Array(e.length + 1);
          return r.set(e, 1), (r[0] = r.length - 1), r;
        })
      )
    ) + "00"
  );
}
const WB = `Ethereum Signed Message:
`;
function Jb(t) {
  return (
    typeof t == "string" && (t = Lt(t)),
    Ut(cr([Lt(WB), Lt(String(t.length)), t]))
  );
}
var kY = function (t, e, r, n) {
  function i(a) {
    return a instanceof r
      ? a
      : new r(function (s) {
          s(a);
        });
  }
  return new (r || (r = Promise))(function (a, s) {
    function o(d) {
      try {
        u(n.next(d));
      } catch (m) {
        s(m);
      }
    }
    function c(d) {
      try {
        u(n.throw(d));
      } catch (m) {
        s(m);
      }
    }
    function u(d) {
      d.done ? a(d.value) : i(d.value).then(o, c);
    }
    u((n = n.apply(t, e || [])).next());
  });
};
const Hr = new ue(BB),
  jB = new Uint8Array(32);
jB.fill(0);
const SY = ae.from(-1),
  HB = ae.from(0),
  zB = ae.from(1),
  MY = ae.from(
    "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
  );
function IY(t) {
  const e = qe(t),
    r = e.length % 32;
  return r ? Ti([e, jB.slice(r)]) : Ke(e);
}
const RY = Rt(zB.toHexString(), 32),
  PY = Rt(HB.toHexString(), 32),
  Ck = {
    name: "string",
    version: "string",
    chainId: "uint256",
    verifyingContract: "address",
    salt: "bytes32",
  },
  zw = ["name", "version", "chainId", "verifyingContract", "salt"];
function Ak(t) {
  return function (e) {
    return (
      typeof e != "string" &&
        Hr.throwArgumentError(
          `invalid domain value for ${JSON.stringify(t)}`,
          `domain.${t}`,
          e
        ),
      e
    );
  };
}
const NY = {
  name: Ak("name"),
  version: Ak("version"),
  chainId: function (t) {
    try {
      return ae.from(t).toString();
    } catch {}
    return Hr.throwArgumentError(
      'invalid domain value for "chainId"',
      "domain.chainId",
      t
    );
  },
  verifyingContract: function (t) {
    try {
      return Xt(t).toLowerCase();
    } catch {}
    return Hr.throwArgumentError(
      'invalid domain value "verifyingContract"',
      "domain.verifyingContract",
      t
    );
  },
  salt: function (t) {
    try {
      const e = qe(t);
      if (e.length !== 32) throw new Error("bad length");
      return Ke(e);
    } catch {}
    return Hr.throwArgumentError(
      'invalid domain value "salt"',
      "domain.salt",
      t
    );
  },
};
function qw(t) {
  {
    const e = t.match(/^(u?)int(\d*)$/);
    if (e) {
      const r = e[1] === "",
        n = parseInt(e[2] || "256");
      (n % 8 !== 0 || n > 256 || (e[2] && e[2] !== String(n))) &&
        Hr.throwArgumentError("invalid numeric width", "type", t);
      const i = MY.mask(r ? n - 1 : n),
        a = r ? i.add(zB).mul(SY) : HB;
      return function (s) {
        const o = ae.from(s);
        return (
          (o.lt(a) || o.gt(i)) &&
            Hr.throwArgumentError(`value out-of-bounds for ${t}`, "value", s),
          Rt(o.toTwos(256).toHexString(), 32)
        );
      };
    }
  }
  {
    const e = t.match(/^bytes(\d+)$/);
    if (e) {
      const r = parseInt(e[1]);
      return (
        (r === 0 || r > 32 || e[1] !== String(r)) &&
          Hr.throwArgumentError("invalid bytes width", "type", t),
        function (n) {
          return (
            qe(n).length !== r &&
              Hr.throwArgumentError(`invalid length for ${t}`, "value", n),
            IY(n)
          );
        }
      );
    }
  }
  switch (t) {
    case "address":
      return function (e) {
        return Rt(Xt(e), 32);
      };
    case "bool":
      return function (e) {
        return e ? RY : PY;
      };
    case "bytes":
      return function (e) {
        return Ut(e);
      };
    case "string":
      return function (e) {
        return ui(e);
      };
  }
  return null;
}
function kk(t, e) {
  return `${t}(${e.map(({ name: r, type: n }) => n + " " + r).join(",")})`;
}
class wn {
  constructor(e) {
    _e(this, "types", Object.freeze(fi(e))),
      _e(this, "_encoderCache", {}),
      _e(this, "_types", {});
    const r = {},
      n = {},
      i = {};
    Object.keys(e).forEach((o) => {
      (r[o] = {}), (n[o] = []), (i[o] = {});
    });
    for (const o in e) {
      const c = {};
      e[o].forEach((u) => {
        c[u.name] &&
          Hr.throwArgumentError(
            `duplicate variable name ${JSON.stringify(
              u.name
            )} in ${JSON.stringify(o)}`,
            "types",
            e
          ),
          (c[u.name] = !0);
        const d = u.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
        d === o &&
          Hr.throwArgumentError(
            `circular type reference to ${JSON.stringify(d)}`,
            "types",
            e
          ),
          !qw(d) &&
            (n[d] ||
              Hr.throwArgumentError(
                `unknown type ${JSON.stringify(d)}`,
                "types",
                e
              ),
            n[d].push(o),
            (r[o][d] = !0));
      });
    }
    const a = Object.keys(n).filter((o) => n[o].length === 0);
    a.length === 0
      ? Hr.throwArgumentError("missing primary type", "types", e)
      : a.length > 1 &&
        Hr.throwArgumentError(
          `ambiguous primary types or unused types: ${a
            .map((o) => JSON.stringify(o))
            .join(", ")}`,
          "types",
          e
        ),
      _e(this, "primaryType", a[0]);
    function s(o, c) {
      c[o] &&
        Hr.throwArgumentError(
          `circular type reference to ${JSON.stringify(o)}`,
          "types",
          e
        ),
        (c[o] = !0),
        Object.keys(r[o]).forEach((u) => {
          n[u] &&
            (s(u, c),
            Object.keys(c).forEach((d) => {
              i[d][u] = !0;
            }));
        }),
        delete c[o];
    }
    s(this.primaryType, {});
    for (const o in i) {
      const c = Object.keys(i[o]);
      c.sort(),
        (this._types[o] = kk(o, e[o]) + c.map((u) => kk(u, e[u])).join(""));
    }
  }
  getEncoder(e) {
    let r = this._encoderCache[e];
    return r || (r = this._encoderCache[e] = this._getEncoder(e)), r;
  }
  _getEncoder(e) {
    {
      const i = qw(e);
      if (i) return i;
    }
    const r = e.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (r) {
      const i = r[1],
        a = this.getEncoder(i),
        s = parseInt(r[3]);
      return (o) => {
        s >= 0 &&
          o.length !== s &&
          Hr.throwArgumentError(
            "array length mismatch; expected length ${ arrayLength }",
            "value",
            o
          );
        let c = o.map(a);
        return this._types[i] && (c = c.map(Ut)), Ut(Ti(c));
      };
    }
    const n = this.types[e];
    if (n) {
      const i = ui(this._types[e]);
      return (a) => {
        const s = n.map(({ name: o, type: c }) => {
          const u = this.getEncoder(c)(a[o]);
          return this._types[c] ? Ut(u) : u;
        });
        return s.unshift(i), Ti(s);
      };
    }
    return Hr.throwArgumentError(`unknown type: ${e}`, "type", e);
  }
  encodeType(e) {
    const r = this._types[e];
    return (
      r ||
        Hr.throwArgumentError(`unknown type: ${JSON.stringify(e)}`, "name", e),
      r
    );
  }
  encodeData(e, r) {
    return this.getEncoder(e)(r);
  }
  hashStruct(e, r) {
    return Ut(this.encodeData(e, r));
  }
  encode(e) {
    return this.encodeData(this.primaryType, e);
  }
  hash(e) {
    return this.hashStruct(this.primaryType, e);
  }
  _visit(e, r, n) {
    if (qw(e)) return n(e, r);
    const i = e.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (i) {
      const s = i[1],
        o = parseInt(i[3]);
      return (
        o >= 0 &&
          r.length !== o &&
          Hr.throwArgumentError(
            "array length mismatch; expected length ${ arrayLength }",
            "value",
            r
          ),
        r.map((c) => this._visit(s, c, n))
      );
    }
    const a = this.types[e];
    return a
      ? a.reduce(
          (s, { name: o, type: c }) => ((s[o] = this._visit(c, r[o], n)), s),
          {}
        )
      : Hr.throwArgumentError(`unknown type: ${e}`, "type", e);
  }
  visit(e, r) {
    return this._visit(this.primaryType, e, r);
  }
  static from(e) {
    return new wn(e);
  }
  static getPrimaryType(e) {
    return wn.from(e).primaryType;
  }
  static hashStruct(e, r, n) {
    return wn.from(r).hashStruct(e, n);
  }
  static hashDomain(e) {
    const r = [];
    for (const n in e) {
      const i = Ck[n];
      i ||
        Hr.throwArgumentError(
          `invalid typed-data domain key: ${JSON.stringify(n)}`,
          "domain",
          e
        ),
        r.push({
          name: n,
          type: i,
        });
    }
    return (
      r.sort((n, i) => zw.indexOf(n.name) - zw.indexOf(i.name)),
      wn.hashStruct(
        "EIP712Domain",
        {
          EIP712Domain: r,
        },
        e
      )
    );
  }
  static encode(e, r, n) {
    return Ti(["0x1901", wn.hashDomain(e), wn.from(r).hash(n)]);
  }
  static hash(e, r, n) {
    return Ut(wn.encode(e, r, n));
  }
  static resolveNames(e, r, n, i) {
    return kY(this, void 0, void 0, function* () {
      e = vr(e);
      const a = {};
      e.verifyingContract &&
        !gt(e.verifyingContract, 20) &&
        (a[e.verifyingContract] = "0x");
      const s = wn.from(r);
      s.visit(n, (o, c) => (o === "address" && !gt(c, 20) && (a[c] = "0x"), c));
      for (const o in a) a[o] = yield i(o);
      return (
        e.verifyingContract &&
          a[e.verifyingContract] &&
          (e.verifyingContract = a[e.verifyingContract]),
        (n = s.visit(n, (o, c) => (o === "address" && a[c] ? a[c] : c))),
        {
          domain: e,
          value: n,
        }
      );
    });
  }
  static getPayload(e, r, n) {
    wn.hashDomain(e);
    const i = {},
      a = [];
    zw.forEach((c) => {
      const u = e[c];
      u != null &&
        ((i[c] = NY[c](u)),
        a.push({
          name: c,
          type: Ck[c],
        }));
    });
    const s = wn.from(r),
      o = vr(r);
    return (
      o.EIP712Domain
        ? Hr.throwArgumentError(
            "types must not contain EIP712Domain type",
            "types.EIP712Domain",
            r
          )
        : (o.EIP712Domain = a),
      s.encode(n),
      {
        types: o,
        domain: i,
        primaryType: s.primaryType,
        message: s.visit(n, (c, u) => {
          if (c.match(/^bytes(\d*)/)) return Ke(qe(u));
          if (c.match(/^u?int/)) return ae.from(u).toString();
          switch (c) {
            case "address":
              return u.toLowerCase();
            case "bool":
              return !!u;
            case "string":
              return (
                typeof u != "string" &&
                  Hr.throwArgumentError("invalid string", "value", u),
                u
              );
          }
          return Hr.throwArgumentError("unsupported type", "type", c);
        }),
      }
    );
  }
}
const BY = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        _TypedDataEncoder: wn,
        dnsEncode: UB,
        ensNormalize: CY,
        hashMessage: Jb,
        id: ui,
        isValidName: AY,
        messagePrefix: WB,
        namehash: Lh,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  $r = new ue(Om);
class qB extends pl {}
class VB extends pl {}
class DY extends pl {}
class Zg extends pl {
  static isIndexed(e) {
    return !!(e && e._isIndexed);
  }
}
const OY = {
  "0x08c379a0": {
    signature: "Error(string)",
    name: "Error",
    inputs: ["string"],
    reason: !0,
  },
  "0x4e487b71": {
    signature: "Panic(uint256)",
    name: "Panic",
    inputs: ["uint256"],
  },
};
function Sk(t, e) {
  const r = new Error(
    `deferred error during ABI decoding triggered accessing ${t}`
  );
  return (r.error = e), r;
}
class ls {
  constructor(e) {
    let r = [];
    typeof e == "string" ? (r = JSON.parse(e)) : (r = e),
      _e(
        this,
        "fragments",
        r.map((n) => qs.from(n)).filter((n) => n != null)
      ),
      _e(this, "_abiCoder", qn(new.target, "getAbiCoder")()),
      _e(this, "functions", {}),
      _e(this, "errors", {}),
      _e(this, "events", {}),
      _e(this, "structs", {}),
      this.fragments.forEach((n) => {
        let i = null;
        switch (n.type) {
          case "constructor":
            if (this.deploy) {
              $r.warn("duplicate definition - constructor");
              return;
            }
            _e(this, "deploy", n);
            return;
          case "function":
            i = this.functions;
            break;
          case "event":
            i = this.events;
            break;
          case "error":
            i = this.errors;
            break;
          default:
            return;
        }
        let a = n.format();
        if (i[a]) {
          $r.warn("duplicate definition - " + a);
          return;
        }
        i[a] = n;
      }),
      this.deploy ||
        _e(
          this,
          "deploy",
          os.from({
            payable: !1,
            type: "constructor",
          })
        ),
      _e(this, "_isInterface", !0);
  }
  format(e) {
    e || (e = zt.full),
      e === zt.sighash &&
        $r.throwArgumentError(
          "interface does not support formatting sighash",
          "format",
          e
        );
    const r = this.fragments.map((n) => n.format(e));
    return e === zt.json ? JSON.stringify(r.map((n) => JSON.parse(n))) : r;
  }
  static getAbiCoder() {
    return xs;
  }
  static getAddress(e) {
    return Xt(e);
  }
  static getSighash(e) {
    return sn(ui(e.format()), 0, 4);
  }
  static getEventTopic(e) {
    return ui(e.format());
  }
  getFunction(e) {
    if (gt(e)) {
      for (const n in this.functions)
        if (e === this.getSighash(n)) return this.functions[n];
      $r.throwArgumentError("no matching function", "sighash", e);
    }
    if (e.indexOf("(") === -1) {
      const n = e.trim(),
        i = Object.keys(this.functions).filter((a) => a.split("(")[0] === n);
      return (
        i.length === 0
          ? $r.throwArgumentError("no matching function", "name", n)
          : i.length > 1 &&
            $r.throwArgumentError("multiple matching functions", "name", n),
        this.functions[i[0]]
      );
    }
    const r = this.functions[cs.fromString(e).format()];
    return (
      r || $r.throwArgumentError("no matching function", "signature", e), r
    );
  }
  getEvent(e) {
    if (gt(e)) {
      const n = e.toLowerCase();
      for (const i in this.events)
        if (n === this.getEventTopic(i)) return this.events[i];
      $r.throwArgumentError("no matching event", "topichash", n);
    }
    if (e.indexOf("(") === -1) {
      const n = e.trim(),
        i = Object.keys(this.events).filter((a) => a.split("(")[0] === n);
      return (
        i.length === 0
          ? $r.throwArgumentError("no matching event", "name", n)
          : i.length > 1 &&
            $r.throwArgumentError("multiple matching events", "name", n),
        this.events[i[0]]
      );
    }
    const r = this.events[js.fromString(e).format()];
    return r || $r.throwArgumentError("no matching event", "signature", e), r;
  }
  getError(e) {
    if (gt(e)) {
      const n = qn(this.constructor, "getSighash");
      for (const i in this.errors) {
        const a = this.errors[i];
        if (e === n(a)) return this.errors[i];
      }
      $r.throwArgumentError("no matching error", "sighash", e);
    }
    if (e.indexOf("(") === -1) {
      const n = e.trim(),
        i = Object.keys(this.errors).filter((a) => a.split("(")[0] === n);
      return (
        i.length === 0
          ? $r.throwArgumentError("no matching error", "name", n)
          : i.length > 1 &&
            $r.throwArgumentError("multiple matching errors", "name", n),
        this.errors[i[0]]
      );
    }
    const r = this.errors[cs.fromString(e).format()];
    return r || $r.throwArgumentError("no matching error", "signature", e), r;
  }
  getSighash(e) {
    if (typeof e == "string")
      try {
        e = this.getFunction(e);
      } catch (r) {
        try {
          e = this.getError(e);
        } catch {
          throw r;
        }
      }
    return qn(this.constructor, "getSighash")(e);
  }
  getEventTopic(e) {
    return (
      typeof e == "string" && (e = this.getEvent(e)),
      qn(this.constructor, "getEventTopic")(e)
    );
  }
  _decodeParams(e, r) {
    return this._abiCoder.decode(e, r);
  }
  _encodeParams(e, r) {
    return this._abiCoder.encode(e, r);
  }
  encodeDeploy(e) {
    return this._encodeParams(this.deploy.inputs, e || []);
  }
  decodeErrorResult(e, r) {
    typeof e == "string" && (e = this.getError(e));
    const n = qe(r);
    return (
      Ke(n.slice(0, 4)) !== this.getSighash(e) &&
        $r.throwArgumentError(
          `data signature does not match error ${e.name}.`,
          "data",
          Ke(n)
        ),
      this._decodeParams(e.inputs, n.slice(4))
    );
  }
  encodeErrorResult(e, r) {
    return (
      typeof e == "string" && (e = this.getError(e)),
      Ke(cr([this.getSighash(e), this._encodeParams(e.inputs, r || [])]))
    );
  }
  decodeFunctionData(e, r) {
    typeof e == "string" && (e = this.getFunction(e));
    const n = qe(r);
    return (
      Ke(n.slice(0, 4)) !== this.getSighash(e) &&
        $r.throwArgumentError(
          `data signature does not match function ${e.name}.`,
          "data",
          Ke(n)
        ),
      this._decodeParams(e.inputs, n.slice(4))
    );
  }
  encodeFunctionData(e, r) {
    return (
      typeof e == "string" && (e = this.getFunction(e)),
      Ke(cr([this.getSighash(e), this._encodeParams(e.inputs, r || [])]))
    );
  }
  decodeFunctionResult(e, r) {
    typeof e == "string" && (e = this.getFunction(e));
    let n = qe(r),
      i = null,
      a = "",
      s = null,
      o = null,
      c = null;
    switch (n.length % this._abiCoder._getWordSize()) {
      case 0:
        try {
          return this._abiCoder.decode(e.outputs, n);
        } catch {}
        break;
      case 4: {
        const u = Ke(n.slice(0, 4)),
          d = OY[u];
        if (d)
          (s = this._abiCoder.decode(d.inputs, n.slice(4))),
            (o = d.name),
            (c = d.signature),
            d.reason && (i = s[0]),
            o === "Error"
              ? (a = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(
                  s[0]
                )}`)
              : o === "Panic" &&
                (a = `; VM Exception while processing transaction: reverted with panic code ${s[0]}`);
        else
          try {
            const m = this.getError(u);
            (s = this._abiCoder.decode(m.inputs, n.slice(4))),
              (o = m.name),
              (c = m.format());
          } catch {}
        break;
      }
    }
    return $r.throwError(
      "call revert exception" + a,
      ue.errors.CALL_EXCEPTION,
      {
        method: e.format(),
        data: Ke(r),
        errorArgs: s,
        errorName: o,
        errorSignature: c,
        reason: i,
      }
    );
  }
  encodeFunctionResult(e, r) {
    return (
      typeof e == "string" && (e = this.getFunction(e)),
      Ke(this._abiCoder.encode(e.outputs, r || []))
    );
  }
  encodeFilterTopics(e, r) {
    typeof e == "string" && (e = this.getEvent(e)),
      r.length > e.inputs.length &&
        $r.throwError(
          "too many arguments for " + e.format(),
          ue.errors.UNEXPECTED_ARGUMENT,
          {
            argument: "values",
            value: r,
          }
        );
    let n = [];
    e.anonymous || n.push(this.getEventTopic(e));
    const i = (a, s) =>
      a.type === "string"
        ? ui(s)
        : a.type === "bytes"
        ? Ut(Ke(s))
        : (a.type === "bool" &&
            typeof s == "boolean" &&
            (s = s ? "0x01" : "0x00"),
          a.type.match(/^u?int/) && (s = ae.from(s).toHexString()),
          a.type === "address" && this._abiCoder.encode(["address"], [s]),
          Rt(Ke(s), 32));
    for (
      r.forEach((a, s) => {
        let o = e.inputs[s];
        if (!o.indexed) {
          a != null &&
            $r.throwArgumentError(
              "cannot filter non-indexed parameters; must be null",
              "contract." + o.name,
              a
            );
          return;
        }
        a == null
          ? n.push(null)
          : o.baseType === "array" || o.baseType === "tuple"
          ? $r.throwArgumentError(
              "filtering with tuples or arrays not supported",
              "contract." + o.name,
              a
            )
          : Array.isArray(a)
          ? n.push(a.map((c) => i(o, c)))
          : n.push(i(o, a));
      });
      n.length && n[n.length - 1] === null;

    )
      n.pop();
    return n;
  }
  encodeEventLog(e, r) {
    typeof e == "string" && (e = this.getEvent(e));
    const n = [],
      i = [],
      a = [];
    return (
      e.anonymous || n.push(this.getEventTopic(e)),
      r.length !== e.inputs.length &&
        $r.throwArgumentError("event arguments/values mismatch", "values", r),
      e.inputs.forEach((s, o) => {
        const c = r[o];
        if (s.indexed)
          if (s.type === "string") n.push(ui(c));
          else if (s.type === "bytes") n.push(Ut(c));
          else {
            if (s.baseType === "tuple" || s.baseType === "array")
              throw new Error("not implemented");
            n.push(this._abiCoder.encode([s.type], [c]));
          }
        else i.push(s), a.push(c);
      }),
      {
        data: this._abiCoder.encode(i, a),
        topics: n,
      }
    );
  }
  decodeEventLog(e, r, n) {
    if (
      (typeof e == "string" && (e = this.getEvent(e)),
      n != null && !e.anonymous)
    ) {
      let v = this.getEventTopic(e);
      (!gt(n[0], 32) || n[0].toLowerCase() !== v) &&
        $r.throwError("fragment/topic mismatch", ue.errors.INVALID_ARGUMENT, {
          argument: "topics[0]",
          expected: v,
          value: n[0],
        }),
        (n = n.slice(1));
    }
    let i = [],
      a = [],
      s = [];
    e.inputs.forEach((v, E) => {
      v.indexed
        ? v.type === "string" ||
          v.type === "bytes" ||
          v.baseType === "tuple" ||
          v.baseType === "array"
          ? (i.push(
              rn.fromObject({
                type: "bytes32",
                name: v.name,
              })
            ),
            s.push(!0))
          : (i.push(v), s.push(!1))
        : (a.push(v), s.push(!1));
    });
    let o = n != null ? this._abiCoder.decode(i, cr(n)) : null,
      c = this._abiCoder.decode(a, r, !0),
      u = [],
      d = 0,
      m = 0;
    e.inputs.forEach((v, E) => {
      if (v.indexed)
        if (o == null)
          u[E] = new Zg({
            _isIndexed: !0,
            hash: null,
          });
        else if (s[E])
          u[E] = new Zg({
            _isIndexed: !0,
            hash: o[m++],
          });
        else
          try {
            u[E] = o[m++];
          } catch (A) {
            u[E] = A;
          }
      else
        try {
          u[E] = c[d++];
        } catch (A) {
          u[E] = A;
        }
      if (v.name && u[v.name] == null) {
        const A = u[E];
        A instanceof Error
          ? Object.defineProperty(u, v.name, {
              enumerable: !0,
              get: () => {
                throw Sk(`property ${JSON.stringify(v.name)}`, A);
              },
            })
          : (u[v.name] = A);
      }
    });
    for (let v = 0; v < u.length; v++) {
      const E = u[v];
      E instanceof Error &&
        Object.defineProperty(u, v, {
          enumerable: !0,
          get: () => {
            throw Sk(`index ${v}`, E);
          },
        });
    }
    return Object.freeze(u);
  }
  parseTransaction(e) {
    let r = this.getFunction(e.data.substring(0, 10).toLowerCase());
    return r
      ? new VB({
          args: this._abiCoder.decode(r.inputs, "0x" + e.data.substring(10)),
          functionFragment: r,
          name: r.name,
          signature: r.format(),
          sighash: this.getSighash(r),
          value: ae.from(e.value || "0"),
        })
      : null;
  }
  parseLog(e) {
    let r = this.getEvent(e.topics[0]);
    return !r || r.anonymous
      ? null
      : new qB({
          eventFragment: r,
          name: r.name,
          signature: r.format(),
          topic: this.getEventTopic(r),
          args: this.decodeEventLog(r, e.data, e.topics),
        });
  }
  parseError(e) {
    const r = Ke(e);
    let n = this.getError(r.substring(0, 10).toLowerCase());
    return n
      ? new DY({
          args: this._abiCoder.decode(n.inputs, "0x" + r.substring(10)),
          errorFragment: n,
          name: n.name,
          signature: n.format(),
          sighash: this.getSighash(n),
        })
      : null;
  }
  static isInterface(e) {
    return !!(e && e._isInterface);
  }
}
const FY = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        AbiCoder: NB,
        ConstructorFragment: os,
        ErrorFragment: Bo,
        EventFragment: js,
        FormatTypes: zt,
        Fragment: qs,
        FunctionFragment: cs,
        Indexed: Zg,
        Interface: ls,
        LogDescription: qB,
        ParamType: rn,
        TransactionDescription: VB,
        checkResultErrors: bB,
        defaultAbiCoder: xs,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  LY = "abstract-provider/5.7.0";
var $Y = function (t, e, r, n) {
  function i(a) {
    return a instanceof r
      ? a
      : new r(function (s) {
          s(a);
        });
  }
  return new (r || (r = Promise))(function (a, s) {
    function o(d) {
      try {
        u(n.next(d));
      } catch (m) {
        s(m);
      }
    }
    function c(d) {
      try {
        u(n.throw(d));
      } catch (m) {
        s(m);
      }
    }
    function u(d) {
      d.done ? a(d.value) : i(d.value).then(o, c);
    }
    u((n = n.apply(t, e || [])).next());
  });
};
const UY = new ue(LY);
class WY extends pl {
  static isForkEvent(e) {
    return !!(e && e._isForkEvent);
  }
}
let Qb = class KB {
  constructor() {
    UY.checkAbstract(new.target, KB), _e(this, "_isProvider", !0);
  }
  getFeeData() {
    return $Y(this, void 0, void 0, function* () {
      const { block: e, gasPrice: r } = yield en({
        block: this.getBlock("latest"),
        gasPrice: this.getGasPrice().catch((s) => null),
      });
      let n = null,
        i = null,
        a = null;
      return (
        e &&
          e.baseFeePerGas &&
          ((n = e.baseFeePerGas),
          (a = ae.from("1500000000")),
          (i = e.baseFeePerGas.mul(2).add(a))),
        {
          lastBaseFeePerGas: n,
          maxFeePerGas: i,
          maxPriorityFeePerGas: a,
          gasPrice: r,
        }
      );
    });
  }
  addListener(e, r) {
    return this.on(e, r);
  }
  removeListener(e, r) {
    return this.off(e, r);
  }
  static isProvider(e) {
    return !!(e && e._isProvider);
  }
};
const jY = "abstract-signer/5.7.0";
var Xa = function (t, e, r, n) {
  function i(a) {
    return a instanceof r
      ? a
      : new r(function (s) {
          s(a);
        });
  }
  return new (r || (r = Promise))(function (a, s) {
    function o(d) {
      try {
        u(n.next(d));
      } catch (m) {
        s(m);
      }
    }
    function c(d) {
      try {
        u(n.throw(d));
      } catch (m) {
        s(m);
      }
    }
    function u(d) {
      d.done ? a(d.value) : i(d.value).then(o, c);
    }
    u((n = n.apply(t, e || [])).next());
  });
};
const Sa = new ue(jY),
  HY = [
    "accessList",
    "ccipReadEnabled",
    "chainId",
    "customData",
    "data",
    "from",
    "gasLimit",
    "gasPrice",
    "maxFeePerGas",
    "maxPriorityFeePerGas",
    "nonce",
    "to",
    "type",
    "value",
  ],
  zY = [
    ue.errors.INSUFFICIENT_FUNDS,
    ue.errors.NONCE_EXPIRED,
    ue.errors.REPLACEMENT_UNDERPRICED,
  ];
class Nu {
  constructor() {
    Sa.checkAbstract(new.target, Nu), _e(this, "_isSigner", !0);
  }
  getBalance(e) {
    return Xa(this, void 0, void 0, function* () {
      return (
        this._checkProvider("getBalance"),
        yield this.provider.getBalance(this.getAddress(), e)
      );
    });
  }
  getTransactionCount(e) {
    return Xa(this, void 0, void 0, function* () {
      return (
        this._checkProvider("getTransactionCount"),
        yield this.provider.getTransactionCount(this.getAddress(), e)
      );
    });
  }
  estimateGas(e) {
    return Xa(this, void 0, void 0, function* () {
      this._checkProvider("estimateGas");
      const r = yield en(this.checkTransaction(e));
      return yield this.provider.estimateGas(r);
    });
  }
  call(e, r) {
    return Xa(this, void 0, void 0, function* () {
      this._checkProvider("call");
      const n = yield en(this.checkTransaction(e));
      return yield this.provider.call(n, r);
    });
  }
  sendTransaction(e) {
    return Xa(this, void 0, void 0, function* () {
      this._checkProvider("sendTransaction");
      const r = yield this.populateTransaction(e),
        n = yield this.signTransaction(r);
      return yield this.provider.sendTransaction(n);
    });
  }
  getChainId() {
    return Xa(this, void 0, void 0, function* () {
      return (
        this._checkProvider("getChainId"),
        (yield this.provider.getNetwork()).chainId
      );
    });
  }
  getGasPrice() {
    return Xa(this, void 0, void 0, function* () {
      return (
        this._checkProvider("getGasPrice"), yield this.provider.getGasPrice()
      );
    });
  }
  getFeeData() {
    return Xa(this, void 0, void 0, function* () {
      return (
        this._checkProvider("getFeeData"), yield this.provider.getFeeData()
      );
    });
  }
  resolveName(e) {
    return Xa(this, void 0, void 0, function* () {
      return (
        this._checkProvider("resolveName"), yield this.provider.resolveName(e)
      );
    });
  }
  checkTransaction(e) {
    for (const n in e)
      HY.indexOf(n) === -1 &&
        Sa.throwArgumentError(
          "invalid transaction key: " + n,
          "transaction",
          e
        );
    const r = vr(e);
    return (
      r.from == null
        ? (r.from = this.getAddress())
        : (r.from = Promise.all([
            Promise.resolve(r.from),
            this.getAddress(),
          ]).then(
            (n) => (
              n[0].toLowerCase() !== n[1].toLowerCase() &&
                Sa.throwArgumentError(
                  "from address mismatch",
                  "transaction",
                  e
                ),
              n[0]
            )
          )),
      r
    );
  }
  populateTransaction(e) {
    return Xa(this, void 0, void 0, function* () {
      const r = yield en(this.checkTransaction(e));
      r.to != null &&
        ((r.to = Promise.resolve(r.to).then((i) =>
          Xa(this, void 0, void 0, function* () {
            if (i == null) return null;
            const a = yield this.resolveName(i);
            return (
              a == null &&
                Sa.throwArgumentError(
                  "provided ENS name resolves to null",
                  "tx.to",
                  i
                ),
              a
            );
          })
        )),
        r.to.catch((i) => {}));
      const n = r.maxFeePerGas != null || r.maxPriorityFeePerGas != null;
      if (
        (r.gasPrice != null && (r.type === 2 || n)
          ? Sa.throwArgumentError(
              "eip-1559 transaction do not support gasPrice",
              "transaction",
              e
            )
          : (r.type === 0 || r.type === 1) &&
            n &&
            Sa.throwArgumentError(
              "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas",
              "transaction",
              e
            ),
        (r.type === 2 || r.type == null) &&
          r.maxFeePerGas != null &&
          r.maxPriorityFeePerGas != null)
      )
        r.type = 2;
      else if (r.type === 0 || r.type === 1)
        r.gasPrice == null && (r.gasPrice = this.getGasPrice());
      else {
        const i = yield this.getFeeData();
        if (r.type == null)
          if (i.maxFeePerGas != null && i.maxPriorityFeePerGas != null)
            if (((r.type = 2), r.gasPrice != null)) {
              const a = r.gasPrice;
              delete r.gasPrice,
                (r.maxFeePerGas = a),
                (r.maxPriorityFeePerGas = a);
            } else
              r.maxFeePerGas == null && (r.maxFeePerGas = i.maxFeePerGas),
                r.maxPriorityFeePerGas == null &&
                  (r.maxPriorityFeePerGas = i.maxPriorityFeePerGas);
          else
            i.gasPrice != null
              ? (n &&
                  Sa.throwError(
                    "network does not support EIP-1559",
                    ue.errors.UNSUPPORTED_OPERATION,
                    {
                      operation: "populateTransaction",
                    }
                  ),
                r.gasPrice == null && (r.gasPrice = i.gasPrice),
                (r.type = 0))
              : Sa.throwError(
                  "failed to get consistent fee data",
                  ue.errors.UNSUPPORTED_OPERATION,
                  {
                    operation: "signer.getFeeData",
                  }
                );
        else
          r.type === 2 &&
            (r.maxFeePerGas == null && (r.maxFeePerGas = i.maxFeePerGas),
            r.maxPriorityFeePerGas == null &&
              (r.maxPriorityFeePerGas = i.maxPriorityFeePerGas));
      }
      return (
        r.nonce == null && (r.nonce = this.getTransactionCount("pending")),
        r.gasLimit == null &&
          (r.gasLimit = this.estimateGas(r).catch((i) => {
            if (zY.indexOf(i.code) >= 0) throw i;
            return Sa.throwError(
              "cannot estimate gas; transaction may fail or may require manual gas limit",
              ue.errors.UNPREDICTABLE_GAS_LIMIT,
              {
                error: i,
                tx: r,
              }
            );
          })),
        r.chainId == null
          ? (r.chainId = this.getChainId())
          : (r.chainId = Promise.all([
              Promise.resolve(r.chainId),
              this.getChainId(),
            ]).then(
              (i) => (
                i[1] !== 0 &&
                  i[0] !== i[1] &&
                  Sa.throwArgumentError(
                    "chainId address mismatch",
                    "transaction",
                    e
                  ),
                i[0]
              )
            )),
        yield en(r)
      );
    });
  }
  _checkProvider(e) {
    this.provider ||
      Sa.throwError("missing provider", ue.errors.UNSUPPORTED_OPERATION, {
        operation: e || "_checkProvider",
      });
  }
  static isSigner(e) {
    return !!(e && e._isSigner);
  }
}
class Q8 extends Nu {
  constructor(e, r) {
    super(), _e(this, "address", e), _e(this, "provider", r || null);
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  _fail(e, r) {
    return Promise.resolve().then(() => {
      Sa.throwError(e, ue.errors.UNSUPPORTED_OPERATION, {
        operation: r,
      });
    });
  }
  signMessage(e) {
    return this._fail("VoidSigner cannot sign messages", "signMessage");
  }
  signTransaction(e) {
    return this._fail("VoidSigner cannot sign transactions", "signTransaction");
  }
  _signTypedData(e, r, n) {
    return this._fail("VoidSigner cannot sign typed data", "signTypedData");
  }
  connect(e) {
    return new Q8(this.address, e);
  }
}
var GB = {},
  Nt = {},
  Fm = ZB;
function ZB(t, e) {
  if (!t) throw new Error(e || "Assertion failed");
}
ZB.equal = function (e, r, n) {
  if (e != r) throw new Error(n || "Assertion failed: " + e + " != " + r);
};
var n_ = {
  exports: {},
};
typeof Object.create == "function"
  ? (n_.exports = function (e, r) {
      r &&
        ((e.super_ = r),
        (e.prototype = Object.create(r.prototype, {
          constructor: {
            value: e,
            enumerable: !1,
            writable: !0,
            configurable: !0,
          },
        })));
    })
  : (n_.exports = function (e, r) {
      if (r) {
        e.super_ = r;
        var n = function () {};
        (n.prototype = r.prototype),
          (e.prototype = new n()),
          (e.prototype.constructor = e);
      }
    });
var Ka = n_.exports,
  qY = Fm,
  VY = Ka;
Nt.inherits = VY;
function KY(t, e) {
  return (t.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= t.length
    ? !1
    : (t.charCodeAt(e + 1) & 64512) === 56320;
}
function GY(t, e) {
  if (Array.isArray(t)) return t.slice();
  if (!t) return [];
  var r = [];
  if (typeof t == "string")
    if (e) {
      if (e === "hex")
        for (
          t = t.replace(/[^a-z0-9]+/gi, ""),
            t.length % 2 !== 0 && (t = "0" + t),
            i = 0;
          i < t.length;
          i += 2
        )
          r.push(parseInt(t[i] + t[i + 1], 16));
    } else
      for (var n = 0, i = 0; i < t.length; i++) {
        var a = t.charCodeAt(i);
        a < 128
          ? (r[n++] = a)
          : a < 2048
          ? ((r[n++] = (a >> 6) | 192), (r[n++] = (a & 63) | 128))
          : KY(t, i)
          ? ((a = 65536 + ((a & 1023) << 10) + (t.charCodeAt(++i) & 1023)),
            (r[n++] = (a >> 18) | 240),
            (r[n++] = ((a >> 12) & 63) | 128),
            (r[n++] = ((a >> 6) & 63) | 128),
            (r[n++] = (a & 63) | 128))
          : ((r[n++] = (a >> 12) | 224),
            (r[n++] = ((a >> 6) & 63) | 128),
            (r[n++] = (a & 63) | 128));
      }
  else for (i = 0; i < t.length; i++) r[i] = t[i] | 0;
  return r;
}
Nt.toArray = GY;
function ZY(t) {
  for (var e = "", r = 0; r < t.length; r++) e += QB(t[r].toString(16));
  return e;
}
Nt.toHex = ZY;
function JB(t) {
  var e =
    (t >>> 24) |
    ((t >>> 8) & 65280) |
    ((t << 8) & 16711680) |
    ((t & 255) << 24);
  return e >>> 0;
}
Nt.htonl = JB;
function JY(t, e) {
  for (var r = "", n = 0; n < t.length; n++) {
    var i = t[n];
    e === "little" && (i = JB(i)), (r += YB(i.toString(16)));
  }
  return r;
}
Nt.toHex32 = JY;
function QB(t) {
  return t.length === 1 ? "0" + t : t;
}
Nt.zero2 = QB;
function YB(t) {
  return t.length === 7
    ? "0" + t
    : t.length === 6
    ? "00" + t
    : t.length === 5
    ? "000" + t
    : t.length === 4
    ? "0000" + t
    : t.length === 3
    ? "00000" + t
    : t.length === 2
    ? "000000" + t
    : t.length === 1
    ? "0000000" + t
    : t;
}
Nt.zero8 = YB;
function QY(t, e, r, n) {
  var i = r - e;
  qY(i % 4 === 0);
  for (var a = new Array(i / 4), s = 0, o = e; s < a.length; s++, o += 4) {
    var c;
    n === "big"
      ? (c = (t[o] << 24) | (t[o + 1] << 16) | (t[o + 2] << 8) | t[o + 3])
      : (c = (t[o + 3] << 24) | (t[o + 2] << 16) | (t[o + 1] << 8) | t[o]),
      (a[s] = c >>> 0);
  }
  return a;
}
Nt.join32 = QY;
function YY(t, e) {
  for (
    var r = new Array(t.length * 4), n = 0, i = 0;
    n < t.length;
    n++, i += 4
  ) {
    var a = t[n];
    e === "big"
      ? ((r[i] = a >>> 24),
        (r[i + 1] = (a >>> 16) & 255),
        (r[i + 2] = (a >>> 8) & 255),
        (r[i + 3] = a & 255))
      : ((r[i + 3] = a >>> 24),
        (r[i + 2] = (a >>> 16) & 255),
        (r[i + 1] = (a >>> 8) & 255),
        (r[i] = a & 255));
  }
  return r;
}
Nt.split32 = YY;
function XY(t, e) {
  return (t >>> e) | (t << (32 - e));
}
Nt.rotr32 = XY;
function eX(t, e) {
  return (t << e) | (t >>> (32 - e));
}
Nt.rotl32 = eX;
function tX(t, e) {
  return (t + e) >>> 0;
}
Nt.sum32 = tX;
function rX(t, e, r) {
  return (t + e + r) >>> 0;
}
Nt.sum32_3 = rX;
function nX(t, e, r, n) {
  return (t + e + r + n) >>> 0;
}
Nt.sum32_4 = nX;
function iX(t, e, r, n, i) {
  return (t + e + r + n + i) >>> 0;
}
Nt.sum32_5 = iX;
function aX(t, e, r, n) {
  var i = t[e],
    a = t[e + 1],
    s = (n + a) >>> 0,
    o = (s < n ? 1 : 0) + r + i;
  (t[e] = o >>> 0), (t[e + 1] = s);
}
Nt.sum64 = aX;
function sX(t, e, r, n) {
  var i = (e + n) >>> 0,
    a = (i < e ? 1 : 0) + t + r;
  return a >>> 0;
}
Nt.sum64_hi = sX;
function oX(t, e, r, n) {
  var i = e + n;
  return i >>> 0;
}
Nt.sum64_lo = oX;
function cX(t, e, r, n, i, a, s, o) {
  var c = 0,
    u = e;
  (u = (u + n) >>> 0),
    (c += u < e ? 1 : 0),
    (u = (u + a) >>> 0),
    (c += u < a ? 1 : 0),
    (u = (u + o) >>> 0),
    (c += u < o ? 1 : 0);
  var d = t + r + i + s + c;
  return d >>> 0;
}
Nt.sum64_4_hi = cX;
function lX(t, e, r, n, i, a, s, o) {
  var c = e + n + a + o;
  return c >>> 0;
}
Nt.sum64_4_lo = lX;
function uX(t, e, r, n, i, a, s, o, c, u) {
  var d = 0,
    m = e;
  (m = (m + n) >>> 0),
    (d += m < e ? 1 : 0),
    (m = (m + a) >>> 0),
    (d += m < a ? 1 : 0),
    (m = (m + o) >>> 0),
    (d += m < o ? 1 : 0),
    (m = (m + u) >>> 0),
    (d += m < u ? 1 : 0);
  var v = t + r + i + s + c + d;
  return v >>> 0;
}
Nt.sum64_5_hi = uX;
function fX(t, e, r, n, i, a, s, o, c, u) {
  var d = e + n + a + o + u;
  return d >>> 0;
}
Nt.sum64_5_lo = fX;
function dX(t, e, r) {
  var n = (e << (32 - r)) | (t >>> r);
  return n >>> 0;
}
Nt.rotr64_hi = dX;
function hX(t, e, r) {
  var n = (t << (32 - r)) | (e >>> r);
  return n >>> 0;
}
Nt.rotr64_lo = hX;
function pX(t, e, r) {
  return t >>> r;
}
Nt.shr64_hi = pX;
function mX(t, e, r) {
  var n = (t << (32 - r)) | (e >>> r);
  return n >>> 0;
}
Nt.shr64_lo = mX;
var dd = {},
  Mk = Nt,
  yX = Fm;
function Yb() {
  (this.pending = null),
    (this.pendingTotal = 0),
    (this.blockSize = this.constructor.blockSize),
    (this.outSize = this.constructor.outSize),
    (this.hmacStrength = this.constructor.hmacStrength),
    (this.padLength = this.constructor.padLength / 8),
    (this.endian = "big"),
    (this._delta8 = this.blockSize / 8),
    (this._delta32 = this.blockSize / 32);
}
dd.BlockHash = Yb;
Yb.prototype.update = function (e, r) {
  if (
    ((e = Mk.toArray(e, r)),
    this.pending ? (this.pending = this.pending.concat(e)) : (this.pending = e),
    (this.pendingTotal += e.length),
    this.pending.length >= this._delta8)
  ) {
    e = this.pending;
    var n = e.length % this._delta8;
    (this.pending = e.slice(e.length - n, e.length)),
      this.pending.length === 0 && (this.pending = null),
      (e = Mk.join32(e, 0, e.length - n, this.endian));
    for (var i = 0; i < e.length; i += this._delta32)
      this._update(e, i, i + this._delta32);
  }
  return this;
};
Yb.prototype.digest = function (e) {
  return this.update(this._pad()), yX(this.pending === null), this._digest(e);
};
Yb.prototype._pad = function () {
  var e = this.pendingTotal,
    r = this._delta8,
    n = r - ((e + this.padLength) % r),
    i = new Array(n + this.padLength);
  i[0] = 128;
  for (var a = 1; a < n; a++) i[a] = 0;
  if (((e <<= 3), this.endian === "big")) {
    for (var s = 8; s < this.padLength; s++) i[a++] = 0;
    (i[a++] = 0),
      (i[a++] = 0),
      (i[a++] = 0),
      (i[a++] = 0),
      (i[a++] = (e >>> 24) & 255),
      (i[a++] = (e >>> 16) & 255),
      (i[a++] = (e >>> 8) & 255),
      (i[a++] = e & 255);
  } else
    for (
      i[a++] = e & 255,
        i[a++] = (e >>> 8) & 255,
        i[a++] = (e >>> 16) & 255,
        i[a++] = (e >>> 24) & 255,
        i[a++] = 0,
        i[a++] = 0,
        i[a++] = 0,
        i[a++] = 0,
        s = 8;
      s < this.padLength;
      s++
    )
      i[a++] = 0;
  return i;
};
var hd = {},
  bo = {},
  gX = Nt,
  to = gX.rotr32;
function bX(t, e, r, n) {
  if (t === 0) return XB(e, r, n);
  if (t === 1 || t === 3) return tD(e, r, n);
  if (t === 2) return eD(e, r, n);
}
bo.ft_1 = bX;
function XB(t, e, r) {
  return (t & e) ^ (~t & r);
}
bo.ch32 = XB;
function eD(t, e, r) {
  return (t & e) ^ (t & r) ^ (e & r);
}
bo.maj32 = eD;
function tD(t, e, r) {
  return t ^ e ^ r;
}
bo.p32 = tD;
function vX(t) {
  return to(t, 2) ^ to(t, 13) ^ to(t, 22);
}
bo.s0_256 = vX;
function xX(t) {
  return to(t, 6) ^ to(t, 11) ^ to(t, 25);
}
bo.s1_256 = xX;
function wX(t) {
  return to(t, 7) ^ to(t, 18) ^ (t >>> 3);
}
bo.g0_256 = wX;
function _X(t) {
  return to(t, 17) ^ to(t, 19) ^ (t >>> 10);
}
bo.g1_256 = _X;
var xf = Nt,
  EX = dd,
  TX = bo,
  Vw = xf.rotl32,
  Gd = xf.sum32,
  CX = xf.sum32_5,
  AX = TX.ft_1,
  rD = EX.BlockHash,
  kX = [1518500249, 1859775393, 2400959708, 3395469782];
function lo() {
  if (!(this instanceof lo)) return new lo();
  rD.call(this),
    (this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520]),
    (this.W = new Array(80));
}
xf.inherits(lo, rD);
var SX = lo;
lo.blockSize = 512;
lo.outSize = 160;
lo.hmacStrength = 80;
lo.padLength = 64;
lo.prototype._update = function (e, r) {
  for (var n = this.W, i = 0; i < 16; i++) n[i] = e[r + i];
  for (; i < n.length; i++)
    n[i] = Vw(n[i - 3] ^ n[i - 8] ^ n[i - 14] ^ n[i - 16], 1);
  var a = this.h[0],
    s = this.h[1],
    o = this.h[2],
    c = this.h[3],
    u = this.h[4];
  for (i = 0; i < n.length; i++) {
    var d = ~~(i / 20),
      m = CX(Vw(a, 5), AX(d, s, o, c), u, n[i], kX[d]);
    (u = c), (c = o), (o = Vw(s, 30)), (s = a), (a = m);
  }
  (this.h[0] = Gd(this.h[0], a)),
    (this.h[1] = Gd(this.h[1], s)),
    (this.h[2] = Gd(this.h[2], o)),
    (this.h[3] = Gd(this.h[3], c)),
    (this.h[4] = Gd(this.h[4], u));
};
lo.prototype._digest = function (e) {
  return e === "hex" ? xf.toHex32(this.h, "big") : xf.split32(this.h, "big");
};
var wf = Nt,
  MX = dd,
  pd = bo,
  IX = Fm,
  es = wf.sum32,
  RX = wf.sum32_4,
  PX = wf.sum32_5,
  NX = pd.ch32,
  BX = pd.maj32,
  DX = pd.s0_256,
  OX = pd.s1_256,
  FX = pd.g0_256,
  LX = pd.g1_256,
  nD = MX.BlockHash,
  $X = [
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
    2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
    1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
    264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711,
    113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
    1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
    3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
    1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424,
    2428436474, 2756734187, 3204031479, 3329325298,
  ];
function uo() {
  if (!(this instanceof uo)) return new uo();
  nD.call(this),
    (this.h = [
      1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924,
      528734635, 1541459225,
    ]),
    (this.k = $X),
    (this.W = new Array(64));
}
wf.inherits(uo, nD);
var iD = uo;
uo.blockSize = 512;
uo.outSize = 256;
uo.hmacStrength = 192;
uo.padLength = 64;
uo.prototype._update = function (e, r) {
  for (var n = this.W, i = 0; i < 16; i++) n[i] = e[r + i];
  for (; i < n.length; i++)
    n[i] = RX(LX(n[i - 2]), n[i - 7], FX(n[i - 15]), n[i - 16]);
  var a = this.h[0],
    s = this.h[1],
    o = this.h[2],
    c = this.h[3],
    u = this.h[4],
    d = this.h[5],
    m = this.h[6],
    v = this.h[7];
  for (IX(this.k.length === n.length), i = 0; i < n.length; i++) {
    var E = PX(v, OX(u), NX(u, d, m), this.k[i], n[i]),
      A = es(DX(a), BX(a, s, o));
    (v = m),
      (m = d),
      (d = u),
      (u = es(c, E)),
      (c = o),
      (o = s),
      (s = a),
      (a = es(E, A));
  }
  (this.h[0] = es(this.h[0], a)),
    (this.h[1] = es(this.h[1], s)),
    (this.h[2] = es(this.h[2], o)),
    (this.h[3] = es(this.h[3], c)),
    (this.h[4] = es(this.h[4], u)),
    (this.h[5] = es(this.h[5], d)),
    (this.h[6] = es(this.h[6], m)),
    (this.h[7] = es(this.h[7], v));
};
uo.prototype._digest = function (e) {
  return e === "hex" ? wf.toHex32(this.h, "big") : wf.split32(this.h, "big");
};
var i_ = Nt,
  aD = iD;
function Ko() {
  if (!(this instanceof Ko)) return new Ko();
  aD.call(this),
    (this.h = [
      3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025,
      1694076839, 3204075428,
    ]);
}
i_.inherits(Ko, aD);
var UX = Ko;
Ko.blockSize = 512;
Ko.outSize = 224;
Ko.hmacStrength = 192;
Ko.padLength = 64;
Ko.prototype._digest = function (e) {
  return e === "hex"
    ? i_.toHex32(this.h.slice(0, 7), "big")
    : i_.split32(this.h.slice(0, 7), "big");
};
var Ki = Nt,
  WX = dd,
  jX = Fm,
  ro = Ki.rotr64_hi,
  no = Ki.rotr64_lo,
  sD = Ki.shr64_hi,
  oD = Ki.shr64_lo,
  nc = Ki.sum64,
  Kw = Ki.sum64_hi,
  Gw = Ki.sum64_lo,
  HX = Ki.sum64_4_hi,
  zX = Ki.sum64_4_lo,
  qX = Ki.sum64_5_hi,
  VX = Ki.sum64_5_lo,
  cD = WX.BlockHash,
  KX = [
    1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399,
    3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265,
    2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394,
    310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994,
    1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317,
    3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139,
    264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901,
    1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837,
    2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879,
    3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901,
    113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964,
    773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823,
    1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142,
    2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273,
    3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344,
    3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720,
    430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593,
    883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403,
    1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012,
    2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044,
    2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573,
    3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711,
    3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554,
    174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315,
    685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100,
    1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866,
    1607167915, 987167468, 1816402316, 1246189591,
  ];
function ws() {
  if (!(this instanceof ws)) return new ws();
  cD.call(this),
    (this.h = [
      1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723,
      2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199,
      528734635, 4215389547, 1541459225, 327033209,
    ]),
    (this.k = KX),
    (this.W = new Array(160));
}
Ki.inherits(ws, cD);
var lD = ws;
ws.blockSize = 1024;
ws.outSize = 512;
ws.hmacStrength = 192;
ws.padLength = 128;
ws.prototype._prepareBlock = function (e, r) {
  for (var n = this.W, i = 0; i < 32; i++) n[i] = e[r + i];
  for (; i < n.length; i += 2) {
    var a = iee(n[i - 4], n[i - 3]),
      s = aee(n[i - 4], n[i - 3]),
      o = n[i - 14],
      c = n[i - 13],
      u = ree(n[i - 30], n[i - 29]),
      d = nee(n[i - 30], n[i - 29]),
      m = n[i - 32],
      v = n[i - 31];
    (n[i] = HX(a, s, o, c, u, d, m, v)),
      (n[i + 1] = zX(a, s, o, c, u, d, m, v));
  }
};
ws.prototype._update = function (e, r) {
  this._prepareBlock(e, r);
  var n = this.W,
    i = this.h[0],
    a = this.h[1],
    s = this.h[2],
    o = this.h[3],
    c = this.h[4],
    u = this.h[5],
    d = this.h[6],
    m = this.h[7],
    v = this.h[8],
    E = this.h[9],
    A = this.h[10],
    I = this.h[11],
    b = this.h[12],
    w = this.h[13],
    S = this.h[14],
    k = this.h[15];
  jX(this.k.length === n.length);
  for (var N = 0; N < n.length; N += 2) {
    var O = S,
      F = k,
      V = eee(v, E),
      j = tee(v, E),
      X = GX(v, E, A, I, b),
      C = ZX(v, E, A, I, b, w),
      l = this.k[N],
      p = this.k[N + 1],
      y = n[N],
      h = n[N + 1],
      g = qX(O, F, V, j, X, C, l, p, y, h),
      T = VX(O, F, V, j, X, C, l, p, y, h);
    (O = YX(i, a)),
      (F = XX(i, a)),
      (V = JX(i, a, s, o, c)),
      (j = QX(i, a, s, o, c, u));
    var R = Kw(O, F, V, j),
      x = Gw(O, F, V, j);
    (S = b),
      (k = w),
      (b = A),
      (w = I),
      (A = v),
      (I = E),
      (v = Kw(d, m, g, T)),
      (E = Gw(m, m, g, T)),
      (d = c),
      (m = u),
      (c = s),
      (u = o),
      (s = i),
      (o = a),
      (i = Kw(g, T, R, x)),
      (a = Gw(g, T, R, x));
  }
  nc(this.h, 0, i, a),
    nc(this.h, 2, s, o),
    nc(this.h, 4, c, u),
    nc(this.h, 6, d, m),
    nc(this.h, 8, v, E),
    nc(this.h, 10, A, I),
    nc(this.h, 12, b, w),
    nc(this.h, 14, S, k);
};
ws.prototype._digest = function (e) {
  return e === "hex" ? Ki.toHex32(this.h, "big") : Ki.split32(this.h, "big");
};
function GX(t, e, r, n, i) {
  var a = (t & r) ^ (~t & i);
  return a < 0 && (a += 4294967296), a;
}
function ZX(t, e, r, n, i, a) {
  var s = (e & n) ^ (~e & a);
  return s < 0 && (s += 4294967296), s;
}
function JX(t, e, r, n, i) {
  var a = (t & r) ^ (t & i) ^ (r & i);
  return a < 0 && (a += 4294967296), a;
}
function QX(t, e, r, n, i, a) {
  var s = (e & n) ^ (e & a) ^ (n & a);
  return s < 0 && (s += 4294967296), s;
}
function YX(t, e) {
  var r = ro(t, e, 28),
    n = ro(e, t, 2),
    i = ro(e, t, 7),
    a = r ^ n ^ i;
  return a < 0 && (a += 4294967296), a;
}
function XX(t, e) {
  var r = no(t, e, 28),
    n = no(e, t, 2),
    i = no(e, t, 7),
    a = r ^ n ^ i;
  return a < 0 && (a += 4294967296), a;
}
function eee(t, e) {
  var r = ro(t, e, 14),
    n = ro(t, e, 18),
    i = ro(e, t, 9),
    a = r ^ n ^ i;
  return a < 0 && (a += 4294967296), a;
}
function tee(t, e) {
  var r = no(t, e, 14),
    n = no(t, e, 18),
    i = no(e, t, 9),
    a = r ^ n ^ i;
  return a < 0 && (a += 4294967296), a;
}
function ree(t, e) {
  var r = ro(t, e, 1),
    n = ro(t, e, 8),
    i = sD(t, e, 7),
    a = r ^ n ^ i;
  return a < 0 && (a += 4294967296), a;
}
function nee(t, e) {
  var r = no(t, e, 1),
    n = no(t, e, 8),
    i = oD(t, e, 7),
    a = r ^ n ^ i;
  return a < 0 && (a += 4294967296), a;
}
function iee(t, e) {
  var r = ro(t, e, 19),
    n = ro(e, t, 29),
    i = sD(t, e, 6),
    a = r ^ n ^ i;
  return a < 0 && (a += 4294967296), a;
}
function aee(t, e) {
  var r = no(t, e, 19),
    n = no(e, t, 29),
    i = oD(t, e, 6),
    a = r ^ n ^ i;
  return a < 0 && (a += 4294967296), a;
}
var a_ = Nt,
  uD = lD;
function Go() {
  if (!(this instanceof Go)) return new Go();
  uD.call(this),
    (this.h = [
      3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999,
      355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025,
      3675008525, 1694076839, 1203062813, 3204075428,
    ]);
}
a_.inherits(Go, uD);
var see = Go;
Go.blockSize = 1024;
Go.outSize = 384;
Go.hmacStrength = 192;
Go.padLength = 128;
Go.prototype._digest = function (e) {
  return e === "hex"
    ? a_.toHex32(this.h.slice(0, 12), "big")
    : a_.split32(this.h.slice(0, 12), "big");
};
hd.sha1 = SX;
hd.sha224 = UX;
hd.sha256 = iD;
hd.sha384 = see;
hd.sha512 = lD;
var fD = {},
  yu = Nt,
  oee = dd,
  J1 = yu.rotl32,
  Ik = yu.sum32,
  Zd = yu.sum32_3,
  Rk = yu.sum32_4,
  dD = oee.BlockHash;
function fo() {
  if (!(this instanceof fo)) return new fo();
  dD.call(this),
    (this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520]),
    (this.endian = "little");
}
yu.inherits(fo, dD);
fD.ripemd160 = fo;
fo.blockSize = 512;
fo.outSize = 160;
fo.hmacStrength = 192;
fo.padLength = 64;
fo.prototype._update = function (e, r) {
  for (
    var n = this.h[0],
      i = this.h[1],
      a = this.h[2],
      s = this.h[3],
      o = this.h[4],
      c = n,
      u = i,
      d = a,
      m = s,
      v = o,
      E = 0;
    E < 80;
    E++
  ) {
    var A = Ik(J1(Rk(n, Pk(E, i, a, s), e[uee[E] + r], cee(E)), dee[E]), o);
    (n = o),
      (o = s),
      (s = J1(a, 10)),
      (a = i),
      (i = A),
      (A = Ik(
        J1(Rk(c, Pk(79 - E, u, d, m), e[fee[E] + r], lee(E)), hee[E]),
        v
      )),
      (c = v),
      (v = m),
      (m = J1(d, 10)),
      (d = u),
      (u = A);
  }
  (A = Zd(this.h[1], a, m)),
    (this.h[1] = Zd(this.h[2], s, v)),
    (this.h[2] = Zd(this.h[3], o, c)),
    (this.h[3] = Zd(this.h[4], n, u)),
    (this.h[4] = Zd(this.h[0], i, d)),
    (this.h[0] = A);
};
fo.prototype._digest = function (e) {
  return e === "hex"
    ? yu.toHex32(this.h, "little")
    : yu.split32(this.h, "little");
};
function Pk(t, e, r, n) {
  return t <= 15
    ? e ^ r ^ n
    : t <= 31
    ? (e & r) | (~e & n)
    : t <= 47
    ? (e | ~r) ^ n
    : t <= 63
    ? (e & n) | (r & ~n)
    : e ^ (r | ~n);
}
function cee(t) {
  return t <= 15
    ? 0
    : t <= 31
    ? 1518500249
    : t <= 47
    ? 1859775393
    : t <= 63
    ? 2400959708
    : 2840853838;
}
function lee(t) {
  return t <= 15
    ? 1352829926
    : t <= 31
    ? 1548603684
    : t <= 47
    ? 1836072691
    : t <= 63
    ? 2053994217
    : 0;
}
var uee = [
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6,
    15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13,
    11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9,
    7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13,
  ],
  fee = [
    5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5,
    10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10,
    0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10,
    4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11,
  ],
  dee = [
    11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9,
    7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13,
    6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9,
    15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6,
  ],
  hee = [
    8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8,
    9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14,
    13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5,
    12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11,
  ],
  pee = Nt,
  mee = Fm;
function _f(t, e, r) {
  if (!(this instanceof _f)) return new _f(t, e, r);
  (this.Hash = t),
    (this.blockSize = t.blockSize / 8),
    (this.outSize = t.outSize / 8),
    (this.inner = null),
    (this.outer = null),
    this._init(pee.toArray(e, r));
}
var yee = _f;
_f.prototype._init = function (e) {
  e.length > this.blockSize && (e = new this.Hash().update(e).digest()),
    mee(e.length <= this.blockSize);
  for (var r = e.length; r < this.blockSize; r++) e.push(0);
  for (r = 0; r < e.length; r++) e[r] ^= 54;
  for (this.inner = new this.Hash().update(e), r = 0; r < e.length; r++)
    e[r] ^= 106;
  this.outer = new this.Hash().update(e);
};
_f.prototype.update = function (e, r) {
  return this.inner.update(e, r), this;
};
_f.prototype.digest = function (e) {
  return this.outer.update(this.inner.digest()), this.outer.digest(e);
};
(function (t) {
  var e = t;
  (e.utils = Nt),
    (e.common = dd),
    (e.sha = hd),
    (e.ripemd = fD),
    (e.hmac = yee),
    (e.sha1 = e.sha.sha1),
    (e.sha256 = e.sha.sha256),
    (e.sha224 = e.sha.sha224),
    (e.sha384 = e.sha.sha384),
    (e.sha512 = e.sha.sha512),
    (e.ripemd160 = e.ripemd.ripemd160);
})(GB);
const Di = mn(GB);
function md(t, e, r) {
  return (
    (r = {
      path: e,
      exports: {},
      require: function (n, i) {
        return gee(n, i ?? r.path);
      },
    }),
    t(r, r.exports),
    r.exports
  );
}
function gee() {
  throw new Error(
    "Dynamic requires are not currently supported by @rollup/plugin-commonjs"
  );
}
var Y8 = hD;
function hD(t, e) {
  if (!t) throw new Error(e || "Assertion failed");
}
hD.equal = function (e, r, n) {
  if (e != r) throw new Error(n || "Assertion failed: " + e + " != " + r);
};
var ds = md(function (t, e) {
    var r = e;
    function n(s, o) {
      if (Array.isArray(s)) return s.slice();
      if (!s) return [];
      var c = [];
      if (typeof s != "string") {
        for (var u = 0; u < s.length; u++) c[u] = s[u] | 0;
        return c;
      }
      if (o === "hex") {
        (s = s.replace(/[^a-z0-9]+/gi, "")),
          s.length % 2 !== 0 && (s = "0" + s);
        for (var u = 0; u < s.length; u += 2)
          c.push(parseInt(s[u] + s[u + 1], 16));
      } else
        for (var u = 0; u < s.length; u++) {
          var d = s.charCodeAt(u),
            m = d >> 8,
            v = d & 255;
          m ? c.push(m, v) : c.push(v);
        }
      return c;
    }
    r.toArray = n;
    function i(s) {
      return s.length === 1 ? "0" + s : s;
    }
    r.zero2 = i;
    function a(s) {
      for (var o = "", c = 0; c < s.length; c++) o += i(s[c].toString(16));
      return o;
    }
    (r.toHex = a),
      (r.encode = function (o, c) {
        return c === "hex" ? a(o) : o;
      });
  }),
  va = md(function (t, e) {
    var r = e;
    (r.assert = Y8),
      (r.toArray = ds.toArray),
      (r.zero2 = ds.zero2),
      (r.toHex = ds.toHex),
      (r.encode = ds.encode);
    function n(c, u, d) {
      var m = new Array(Math.max(c.bitLength(), d) + 1);
      m.fill(0);
      for (var v = 1 << (u + 1), E = c.clone(), A = 0; A < m.length; A++) {
        var I,
          b = E.andln(v - 1);
        E.isOdd()
          ? (b > (v >> 1) - 1 ? (I = (v >> 1) - b) : (I = b), E.isubn(I))
          : (I = 0),
          (m[A] = I),
          E.iushrn(1);
      }
      return m;
    }
    r.getNAF = n;
    function i(c, u) {
      var d = [[], []];
      (c = c.clone()), (u = u.clone());
      for (var m = 0, v = 0, E; c.cmpn(-m) > 0 || u.cmpn(-v) > 0; ) {
        var A = (c.andln(3) + m) & 3,
          I = (u.andln(3) + v) & 3;
        A === 3 && (A = -1), I === 3 && (I = -1);
        var b;
        A & 1
          ? ((E = (c.andln(7) + m) & 7),
            (E === 3 || E === 5) && I === 2 ? (b = -A) : (b = A))
          : (b = 0),
          d[0].push(b);
        var w;
        I & 1
          ? ((E = (u.andln(7) + v) & 7),
            (E === 3 || E === 5) && A === 2 ? (w = -I) : (w = I))
          : (w = 0),
          d[1].push(w),
          2 * m === b + 1 && (m = 1 - m),
          2 * v === w + 1 && (v = 1 - v),
          c.iushrn(1),
          u.iushrn(1);
      }
      return d;
    }
    r.getJSF = i;
    function a(c, u, d) {
      var m = "_" + u;
      c.prototype[u] = function () {
        return this[m] !== void 0 ? this[m] : (this[m] = d.call(this));
      };
    }
    r.cachedProperty = a;
    function s(c) {
      return typeof c == "string" ? r.toArray(c, "hex") : c;
    }
    r.parseBytes = s;
    function o(c) {
      return new pt(c, "hex", "le");
    }
    r.intFromLE = o;
  }),
  Jg = va.getNAF,
  bee = va.getJSF,
  Qg = va.assert;
function ml(t, e) {
  (this.type = t),
    (this.p = new pt(e.p, 16)),
    (this.red = e.prime ? pt.red(e.prime) : pt.mont(this.p)),
    (this.zero = new pt(0).toRed(this.red)),
    (this.one = new pt(1).toRed(this.red)),
    (this.two = new pt(2).toRed(this.red)),
    (this.n = e.n && new pt(e.n, 16)),
    (this.g = e.g && this.pointFromJSON(e.g, e.gRed)),
    (this._wnafT1 = new Array(4)),
    (this._wnafT2 = new Array(4)),
    (this._wnafT3 = new Array(4)),
    (this._wnafT4 = new Array(4)),
    (this._bitLength = this.n ? this.n.bitLength() : 0);
  var r = this.n && this.p.div(this.n);
  !r || r.cmpn(100) > 0
    ? (this.redN = null)
    : ((this._maxwellTrick = !0), (this.redN = this.n.toRed(this.red)));
}
var Bu = ml;
ml.prototype.point = function () {
  throw new Error("Not implemented");
};
ml.prototype.validate = function () {
  throw new Error("Not implemented");
};
ml.prototype._fixedNafMul = function (e, r) {
  Qg(e.precomputed);
  var n = e._getDoubles(),
    i = Jg(r, 1, this._bitLength),
    a = (1 << (n.step + 1)) - (n.step % 2 === 0 ? 2 : 1);
  a /= 3;
  var s = [],
    o,
    c;
  for (o = 0; o < i.length; o += n.step) {
    c = 0;
    for (var u = o + n.step - 1; u >= o; u--) c = (c << 1) + i[u];
    s.push(c);
  }
  for (
    var d = this.jpoint(null, null, null),
      m = this.jpoint(null, null, null),
      v = a;
    v > 0;
    v--
  ) {
    for (o = 0; o < s.length; o++)
      (c = s[o]),
        c === v
          ? (m = m.mixedAdd(n.points[o]))
          : c === -v && (m = m.mixedAdd(n.points[o].neg()));
    d = d.add(m);
  }
  return d.toP();
};
ml.prototype._wnafMul = function (e, r) {
  var n = 4,
    i = e._getNAFPoints(n);
  n = i.wnd;
  for (
    var a = i.points,
      s = Jg(r, n, this._bitLength),
      o = this.jpoint(null, null, null),
      c = s.length - 1;
    c >= 0;
    c--
  ) {
    for (var u = 0; c >= 0 && s[c] === 0; c--) u++;
    if ((c >= 0 && u++, (o = o.dblp(u)), c < 0)) break;
    var d = s[c];
    Qg(d !== 0),
      e.type === "affine"
        ? d > 0
          ? (o = o.mixedAdd(a[(d - 1) >> 1]))
          : (o = o.mixedAdd(a[(-d - 1) >> 1].neg()))
        : d > 0
        ? (o = o.add(a[(d - 1) >> 1]))
        : (o = o.add(a[(-d - 1) >> 1].neg()));
  }
  return e.type === "affine" ? o.toP() : o;
};
ml.prototype._wnafMulAdd = function (e, r, n, i, a) {
  var s = this._wnafT1,
    o = this._wnafT2,
    c = this._wnafT3,
    u = 0,
    d,
    m,
    v;
  for (d = 0; d < i; d++) {
    v = r[d];
    var E = v._getNAFPoints(e);
    (s[d] = E.wnd), (o[d] = E.points);
  }
  for (d = i - 1; d >= 1; d -= 2) {
    var A = d - 1,
      I = d;
    if (s[A] !== 1 || s[I] !== 1) {
      (c[A] = Jg(n[A], s[A], this._bitLength)),
        (c[I] = Jg(n[I], s[I], this._bitLength)),
        (u = Math.max(c[A].length, u)),
        (u = Math.max(c[I].length, u));
      continue;
    }
    var b = [r[A], null, null, r[I]];
    r[A].y.cmp(r[I].y) === 0
      ? ((b[1] = r[A].add(r[I])), (b[2] = r[A].toJ().mixedAdd(r[I].neg())))
      : r[A].y.cmp(r[I].y.redNeg()) === 0
      ? ((b[1] = r[A].toJ().mixedAdd(r[I])), (b[2] = r[A].add(r[I].neg())))
      : ((b[1] = r[A].toJ().mixedAdd(r[I])),
        (b[2] = r[A].toJ().mixedAdd(r[I].neg())));
    var w = [-3, -1, -5, -7, 0, 7, 5, 1, 3],
      S = bee(n[A], n[I]);
    for (
      u = Math.max(S[0].length, u),
        c[A] = new Array(u),
        c[I] = new Array(u),
        m = 0;
      m < u;
      m++
    ) {
      var k = S[0][m] | 0,
        N = S[1][m] | 0;
      (c[A][m] = w[(k + 1) * 3 + (N + 1)]), (c[I][m] = 0), (o[A] = b);
    }
  }
  var O = this.jpoint(null, null, null),
    F = this._wnafT4;
  for (d = u; d >= 0; d--) {
    for (var V = 0; d >= 0; ) {
      var j = !0;
      for (m = 0; m < i; m++) (F[m] = c[m][d] | 0), F[m] !== 0 && (j = !1);
      if (!j) break;
      V++, d--;
    }
    if ((d >= 0 && V++, (O = O.dblp(V)), d < 0)) break;
    for (m = 0; m < i; m++) {
      var X = F[m];
      X !== 0 &&
        (X > 0
          ? (v = o[m][(X - 1) >> 1])
          : X < 0 && (v = o[m][(-X - 1) >> 1].neg()),
        v.type === "affine" ? (O = O.mixedAdd(v)) : (O = O.add(v)));
    }
  }
  for (d = 0; d < i; d++) o[d] = null;
  return a ? O : O.toP();
};
function Ga(t, e) {
  (this.curve = t), (this.type = e), (this.precomputed = null);
}
ml.BasePoint = Ga;
Ga.prototype.eq = function () {
  throw new Error("Not implemented");
};
Ga.prototype.validate = function () {
  return this.curve.validate(this);
};
ml.prototype.decodePoint = function (e, r) {
  e = va.toArray(e, r);
  var n = this.p.byteLength();
  if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * n) {
    e[0] === 6
      ? Qg(e[e.length - 1] % 2 === 0)
      : e[0] === 7 && Qg(e[e.length - 1] % 2 === 1);
    var i = this.point(e.slice(1, 1 + n), e.slice(1 + n, 1 + 2 * n));
    return i;
  } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === n)
    return this.pointFromX(e.slice(1, 1 + n), e[0] === 3);
  throw new Error("Unknown point format");
};
Ga.prototype.encodeCompressed = function (e) {
  return this.encode(e, !0);
};
Ga.prototype._encode = function (e) {
  var r = this.curve.p.byteLength(),
    n = this.getX().toArray("be", r);
  return e
    ? [this.getY().isEven() ? 2 : 3].concat(n)
    : [4].concat(n, this.getY().toArray("be", r));
};
Ga.prototype.encode = function (e, r) {
  return va.encode(this._encode(r), e);
};
Ga.prototype.precompute = function (e) {
  if (this.precomputed) return this;
  var r = {
    doubles: null,
    naf: null,
    beta: null,
  };
  return (
    (r.naf = this._getNAFPoints(8)),
    (r.doubles = this._getDoubles(4, e)),
    (r.beta = this._getBeta()),
    (this.precomputed = r),
    this
  );
};
Ga.prototype._hasDoubles = function (e) {
  if (!this.precomputed) return !1;
  var r = this.precomputed.doubles;
  return r ? r.points.length >= Math.ceil((e.bitLength() + 1) / r.step) : !1;
};
Ga.prototype._getDoubles = function (e, r) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var n = [this], i = this, a = 0; a < r; a += e) {
    for (var s = 0; s < e; s++) i = i.dbl();
    n.push(i);
  }
  return {
    step: e,
    points: n,
  };
};
Ga.prototype._getNAFPoints = function (e) {
  if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
  for (
    var r = [this], n = (1 << e) - 1, i = n === 1 ? null : this.dbl(), a = 1;
    a < n;
    a++
  )
    r[a] = r[a - 1].add(i);
  return {
    wnd: e,
    points: r,
  };
};
Ga.prototype._getBeta = function () {
  return null;
};
Ga.prototype.dblp = function (e) {
  for (var r = this, n = 0; n < e; n++) r = r.dbl();
  return r;
};
var X8 = md(function (t) {
    typeof Object.create == "function"
      ? (t.exports = function (r, n) {
          n &&
            ((r.super_ = n),
            (r.prototype = Object.create(n.prototype, {
              constructor: {
                value: r,
                enumerable: !1,
                writable: !0,
                configurable: !0,
              },
            })));
        })
      : (t.exports = function (r, n) {
          if (n) {
            r.super_ = n;
            var i = function () {};
            (i.prototype = n.prototype),
              (r.prototype = new i()),
              (r.prototype.constructor = r);
          }
        });
  }),
  vee = va.assert;
function Za(t) {
  Bu.call(this, "short", t),
    (this.a = new pt(t.a, 16).toRed(this.red)),
    (this.b = new pt(t.b, 16).toRed(this.red)),
    (this.tinv = this.two.redInvm()),
    (this.zeroA = this.a.fromRed().cmpn(0) === 0),
    (this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0),
    (this.endo = this._getEndomorphism(t)),
    (this._endoWnafT1 = new Array(4)),
    (this._endoWnafT2 = new Array(4));
}
X8(Za, Bu);
var xee = Za;
Za.prototype._getEndomorphism = function (e) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var r, n;
    if (e.beta) r = new pt(e.beta, 16).toRed(this.red);
    else {
      var i = this._getEndoRoots(this.p);
      (r = i[0].cmp(i[1]) < 0 ? i[0] : i[1]), (r = r.toRed(this.red));
    }
    if (e.lambda) n = new pt(e.lambda, 16);
    else {
      var a = this._getEndoRoots(this.n);
      this.g.mul(a[0]).x.cmp(this.g.x.redMul(r)) === 0
        ? (n = a[0])
        : ((n = a[1]), vee(this.g.mul(n).x.cmp(this.g.x.redMul(r)) === 0));
    }
    var s;
    return (
      e.basis
        ? (s = e.basis.map(function (o) {
            return {
              a: new pt(o.a, 16),
              b: new pt(o.b, 16),
            };
          }))
        : (s = this._getEndoBasis(n)),
      {
        beta: r,
        lambda: n,
        basis: s,
      }
    );
  }
};
Za.prototype._getEndoRoots = function (e) {
  var r = e === this.p ? this.red : pt.mont(e),
    n = new pt(2).toRed(r).redInvm(),
    i = n.redNeg(),
    a = new pt(3).toRed(r).redNeg().redSqrt().redMul(n),
    s = i.redAdd(a).fromRed(),
    o = i.redSub(a).fromRed();
  return [s, o];
};
Za.prototype._getEndoBasis = function (e) {
  for (
    var r = this.n.ushrn(Math.floor(this.n.bitLength() / 2)),
      n = e,
      i = this.n.clone(),
      a = new pt(1),
      s = new pt(0),
      o = new pt(0),
      c = new pt(1),
      u,
      d,
      m,
      v,
      E,
      A,
      I,
      b = 0,
      w,
      S;
    n.cmpn(0) !== 0;

  ) {
    var k = i.div(n);
    (w = i.sub(k.mul(n))), (S = o.sub(k.mul(a)));
    var N = c.sub(k.mul(s));
    if (!m && w.cmp(r) < 0) (u = I.neg()), (d = a), (m = w.neg()), (v = S);
    else if (m && ++b === 2) break;
    (I = w), (i = n), (n = w), (o = a), (a = S), (c = s), (s = N);
  }
  (E = w.neg()), (A = S);
  var O = m.sqr().add(v.sqr()),
    F = E.sqr().add(A.sqr());
  return (
    F.cmp(O) >= 0 && ((E = u), (A = d)),
    m.negative && ((m = m.neg()), (v = v.neg())),
    E.negative && ((E = E.neg()), (A = A.neg())),
    [
      {
        a: m,
        b: v,
      },
      {
        a: E,
        b: A,
      },
    ]
  );
};
Za.prototype._endoSplit = function (e) {
  var r = this.endo.basis,
    n = r[0],
    i = r[1],
    a = i.b.mul(e).divRound(this.n),
    s = n.b.neg().mul(e).divRound(this.n),
    o = a.mul(n.a),
    c = s.mul(i.a),
    u = a.mul(n.b),
    d = s.mul(i.b),
    m = e.sub(o).sub(c),
    v = u.add(d).neg();
  return {
    k1: m,
    k2: v,
  };
};
Za.prototype.pointFromX = function (e, r) {
  (e = new pt(e, 16)), e.red || (e = e.toRed(this.red));
  var n = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b),
    i = n.redSqrt();
  if (i.redSqr().redSub(n).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var a = i.fromRed().isOdd();
  return ((r && !a) || (!r && a)) && (i = i.redNeg()), this.point(e, i);
};
Za.prototype.validate = function (e) {
  if (e.inf) return !0;
  var r = e.x,
    n = e.y,
    i = this.a.redMul(r),
    a = r.redSqr().redMul(r).redIAdd(i).redIAdd(this.b);
  return n.redSqr().redISub(a).cmpn(0) === 0;
};
Za.prototype._endoWnafMulAdd = function (e, r, n) {
  for (
    var i = this._endoWnafT1, a = this._endoWnafT2, s = 0;
    s < e.length;
    s++
  ) {
    var o = this._endoSplit(r[s]),
      c = e[s],
      u = c._getBeta();
    o.k1.negative && (o.k1.ineg(), (c = c.neg(!0))),
      o.k2.negative && (o.k2.ineg(), (u = u.neg(!0))),
      (i[s * 2] = c),
      (i[s * 2 + 1] = u),
      (a[s * 2] = o.k1),
      (a[s * 2 + 1] = o.k2);
  }
  for (var d = this._wnafMulAdd(1, i, a, s * 2, n), m = 0; m < s * 2; m++)
    (i[m] = null), (a[m] = null);
  return d;
};
function Dn(t, e, r, n) {
  Bu.BasePoint.call(this, t, "affine"),
    e === null && r === null
      ? ((this.x = null), (this.y = null), (this.inf = !0))
      : ((this.x = new pt(e, 16)),
        (this.y = new pt(r, 16)),
        n && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)),
        this.x.red || (this.x = this.x.toRed(this.curve.red)),
        this.y.red || (this.y = this.y.toRed(this.curve.red)),
        (this.inf = !1));
}
X8(Dn, Bu.BasePoint);
Za.prototype.point = function (e, r, n) {
  return new Dn(this, e, r, n);
};
Za.prototype.pointFromJSON = function (e, r) {
  return Dn.fromJSON(this, e, r);
};
Dn.prototype._getBeta = function () {
  if (this.curve.endo) {
    var e = this.precomputed;
    if (e && e.beta) return e.beta;
    var r = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (e) {
      var n = this.curve,
        i = function (a) {
          return n.point(a.x.redMul(n.endo.beta), a.y);
        };
      (e.beta = r),
        (r.precomputed = {
          beta: null,
          naf: e.naf && {
            wnd: e.naf.wnd,
            points: e.naf.points.map(i),
          },
          doubles: e.doubles && {
            step: e.doubles.step,
            points: e.doubles.points.map(i),
          },
        });
    }
    return r;
  }
};
Dn.prototype.toJSON = function () {
  return this.precomputed
    ? [
        this.x,
        this.y,
        this.precomputed && {
          doubles: this.precomputed.doubles && {
            step: this.precomputed.doubles.step,
            points: this.precomputed.doubles.points.slice(1),
          },
          naf: this.precomputed.naf && {
            wnd: this.precomputed.naf.wnd,
            points: this.precomputed.naf.points.slice(1),
          },
        },
      ]
    : [this.x, this.y];
};
Dn.fromJSON = function (e, r, n) {
  typeof r == "string" && (r = JSON.parse(r));
  var i = e.point(r[0], r[1], n);
  if (!r[2]) return i;
  function a(o) {
    return e.point(o[0], o[1], n);
  }
  var s = r[2];
  return (
    (i.precomputed = {
      beta: null,
      doubles: s.doubles && {
        step: s.doubles.step,
        points: [i].concat(s.doubles.points.map(a)),
      },
      naf: s.naf && {
        wnd: s.naf.wnd,
        points: [i].concat(s.naf.points.map(a)),
      },
    }),
    i
  );
};
Dn.prototype.inspect = function () {
  return this.isInfinity()
    ? "<EC Point Infinity>"
    : "<EC Point x: " +
        this.x.fromRed().toString(16, 2) +
        " y: " +
        this.y.fromRed().toString(16, 2) +
        ">";
};
Dn.prototype.isInfinity = function () {
  return this.inf;
};
Dn.prototype.add = function (e) {
  if (this.inf) return e;
  if (e.inf) return this;
  if (this.eq(e)) return this.dbl();
  if (this.neg().eq(e)) return this.curve.point(null, null);
  if (this.x.cmp(e.x) === 0) return this.curve.point(null, null);
  var r = this.y.redSub(e.y);
  r.cmpn(0) !== 0 && (r = r.redMul(this.x.redSub(e.x).redInvm()));
  var n = r.redSqr().redISub(this.x).redISub(e.x),
    i = r.redMul(this.x.redSub(n)).redISub(this.y);
  return this.curve.point(n, i);
};
Dn.prototype.dbl = function () {
  if (this.inf) return this;
  var e = this.y.redAdd(this.y);
  if (e.cmpn(0) === 0) return this.curve.point(null, null);
  var r = this.curve.a,
    n = this.x.redSqr(),
    i = e.redInvm(),
    a = n.redAdd(n).redIAdd(n).redIAdd(r).redMul(i),
    s = a.redSqr().redISub(this.x.redAdd(this.x)),
    o = a.redMul(this.x.redSub(s)).redISub(this.y);
  return this.curve.point(s, o);
};
Dn.prototype.getX = function () {
  return this.x.fromRed();
};
Dn.prototype.getY = function () {
  return this.y.fromRed();
};
Dn.prototype.mul = function (e) {
  return (
    (e = new pt(e, 16)),
    this.isInfinity()
      ? this
      : this._hasDoubles(e)
      ? this.curve._fixedNafMul(this, e)
      : this.curve.endo
      ? this.curve._endoWnafMulAdd([this], [e])
      : this.curve._wnafMul(this, e)
  );
};
Dn.prototype.mulAdd = function (e, r, n) {
  var i = [this, r],
    a = [e, n];
  return this.curve.endo
    ? this.curve._endoWnafMulAdd(i, a)
    : this.curve._wnafMulAdd(1, i, a, 2);
};
Dn.prototype.jmulAdd = function (e, r, n) {
  var i = [this, r],
    a = [e, n];
  return this.curve.endo
    ? this.curve._endoWnafMulAdd(i, a, !0)
    : this.curve._wnafMulAdd(1, i, a, 2, !0);
};
Dn.prototype.eq = function (e) {
  return (
    this === e ||
    (this.inf === e.inf &&
      (this.inf || (this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0)))
  );
};
Dn.prototype.neg = function (e) {
  if (this.inf) return this;
  var r = this.curve.point(this.x, this.y.redNeg());
  if (e && this.precomputed) {
    var n = this.precomputed,
      i = function (a) {
        return a.neg();
      };
    r.precomputed = {
      naf: n.naf && {
        wnd: n.naf.wnd,
        points: n.naf.points.map(i),
      },
      doubles: n.doubles && {
        step: n.doubles.step,
        points: n.doubles.points.map(i),
      },
    };
  }
  return r;
};
Dn.prototype.toJ = function () {
  if (this.inf) return this.curve.jpoint(null, null, null);
  var e = this.curve.jpoint(this.x, this.y, this.curve.one);
  return e;
};
function Yn(t, e, r, n) {
  Bu.BasePoint.call(this, t, "jacobian"),
    e === null && r === null && n === null
      ? ((this.x = this.curve.one),
        (this.y = this.curve.one),
        (this.z = new pt(0)))
      : ((this.x = new pt(e, 16)),
        (this.y = new pt(r, 16)),
        (this.z = new pt(n, 16))),
    this.x.red || (this.x = this.x.toRed(this.curve.red)),
    this.y.red || (this.y = this.y.toRed(this.curve.red)),
    this.z.red || (this.z = this.z.toRed(this.curve.red)),
    (this.zOne = this.z === this.curve.one);
}
X8(Yn, Bu.BasePoint);
Za.prototype.jpoint = function (e, r, n) {
  return new Yn(this, e, r, n);
};
Yn.prototype.toP = function () {
  if (this.isInfinity()) return this.curve.point(null, null);
  var e = this.z.redInvm(),
    r = e.redSqr(),
    n = this.x.redMul(r),
    i = this.y.redMul(r).redMul(e);
  return this.curve.point(n, i);
};
Yn.prototype.neg = function () {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
Yn.prototype.add = function (e) {
  if (this.isInfinity()) return e;
  if (e.isInfinity()) return this;
  var r = e.z.redSqr(),
    n = this.z.redSqr(),
    i = this.x.redMul(r),
    a = e.x.redMul(n),
    s = this.y.redMul(r.redMul(e.z)),
    o = e.y.redMul(n.redMul(this.z)),
    c = i.redSub(a),
    u = s.redSub(o);
  if (c.cmpn(0) === 0)
    return u.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var d = c.redSqr(),
    m = d.redMul(c),
    v = i.redMul(d),
    E = u.redSqr().redIAdd(m).redISub(v).redISub(v),
    A = u.redMul(v.redISub(E)).redISub(s.redMul(m)),
    I = this.z.redMul(e.z).redMul(c);
  return this.curve.jpoint(E, A, I);
};
Yn.prototype.mixedAdd = function (e) {
  if (this.isInfinity()) return e.toJ();
  if (e.isInfinity()) return this;
  var r = this.z.redSqr(),
    n = this.x,
    i = e.x.redMul(r),
    a = this.y,
    s = e.y.redMul(r).redMul(this.z),
    o = n.redSub(i),
    c = a.redSub(s);
  if (o.cmpn(0) === 0)
    return c.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var u = o.redSqr(),
    d = u.redMul(o),
    m = n.redMul(u),
    v = c.redSqr().redIAdd(d).redISub(m).redISub(m),
    E = c.redMul(m.redISub(v)).redISub(a.redMul(d)),
    A = this.z.redMul(o);
  return this.curve.jpoint(v, E, A);
};
Yn.prototype.dblp = function (e) {
  if (e === 0) return this;
  if (this.isInfinity()) return this;
  if (!e) return this.dbl();
  var r;
  if (this.curve.zeroA || this.curve.threeA) {
    var n = this;
    for (r = 0; r < e; r++) n = n.dbl();
    return n;
  }
  var i = this.curve.a,
    a = this.curve.tinv,
    s = this.x,
    o = this.y,
    c = this.z,
    u = c.redSqr().redSqr(),
    d = o.redAdd(o);
  for (r = 0; r < e; r++) {
    var m = s.redSqr(),
      v = d.redSqr(),
      E = v.redSqr(),
      A = m.redAdd(m).redIAdd(m).redIAdd(i.redMul(u)),
      I = s.redMul(v),
      b = A.redSqr().redISub(I.redAdd(I)),
      w = I.redISub(b),
      S = A.redMul(w);
    S = S.redIAdd(S).redISub(E);
    var k = d.redMul(c);
    r + 1 < e && (u = u.redMul(E)), (s = b), (c = k), (d = S);
  }
  return this.curve.jpoint(s, d.redMul(a), c);
};
Yn.prototype.dbl = function () {
  return this.isInfinity()
    ? this
    : this.curve.zeroA
    ? this._zeroDbl()
    : this.curve.threeA
    ? this._threeDbl()
    : this._dbl();
};
Yn.prototype._zeroDbl = function () {
  var e, r, n;
  if (this.zOne) {
    var i = this.x.redSqr(),
      a = this.y.redSqr(),
      s = a.redSqr(),
      o = this.x.redAdd(a).redSqr().redISub(i).redISub(s);
    o = o.redIAdd(o);
    var c = i.redAdd(i).redIAdd(i),
      u = c.redSqr().redISub(o).redISub(o),
      d = s.redIAdd(s);
    (d = d.redIAdd(d)),
      (d = d.redIAdd(d)),
      (e = u),
      (r = c.redMul(o.redISub(u)).redISub(d)),
      (n = this.y.redAdd(this.y));
  } else {
    var m = this.x.redSqr(),
      v = this.y.redSqr(),
      E = v.redSqr(),
      A = this.x.redAdd(v).redSqr().redISub(m).redISub(E);
    A = A.redIAdd(A);
    var I = m.redAdd(m).redIAdd(m),
      b = I.redSqr(),
      w = E.redIAdd(E);
    (w = w.redIAdd(w)),
      (w = w.redIAdd(w)),
      (e = b.redISub(A).redISub(A)),
      (r = I.redMul(A.redISub(e)).redISub(w)),
      (n = this.y.redMul(this.z)),
      (n = n.redIAdd(n));
  }
  return this.curve.jpoint(e, r, n);
};
Yn.prototype._threeDbl = function () {
  var e, r, n;
  if (this.zOne) {
    var i = this.x.redSqr(),
      a = this.y.redSqr(),
      s = a.redSqr(),
      o = this.x.redAdd(a).redSqr().redISub(i).redISub(s);
    o = o.redIAdd(o);
    var c = i.redAdd(i).redIAdd(i).redIAdd(this.curve.a),
      u = c.redSqr().redISub(o).redISub(o);
    e = u;
    var d = s.redIAdd(s);
    (d = d.redIAdd(d)),
      (d = d.redIAdd(d)),
      (r = c.redMul(o.redISub(u)).redISub(d)),
      (n = this.y.redAdd(this.y));
  } else {
    var m = this.z.redSqr(),
      v = this.y.redSqr(),
      E = this.x.redMul(v),
      A = this.x.redSub(m).redMul(this.x.redAdd(m));
    A = A.redAdd(A).redIAdd(A);
    var I = E.redIAdd(E);
    I = I.redIAdd(I);
    var b = I.redAdd(I);
    (e = A.redSqr().redISub(b)),
      (n = this.y.redAdd(this.z).redSqr().redISub(v).redISub(m));
    var w = v.redSqr();
    (w = w.redIAdd(w)),
      (w = w.redIAdd(w)),
      (w = w.redIAdd(w)),
      (r = A.redMul(I.redISub(e)).redISub(w));
  }
  return this.curve.jpoint(e, r, n);
};
Yn.prototype._dbl = function () {
  var e = this.curve.a,
    r = this.x,
    n = this.y,
    i = this.z,
    a = i.redSqr().redSqr(),
    s = r.redSqr(),
    o = n.redSqr(),
    c = s.redAdd(s).redIAdd(s).redIAdd(e.redMul(a)),
    u = r.redAdd(r);
  u = u.redIAdd(u);
  var d = u.redMul(o),
    m = c.redSqr().redISub(d.redAdd(d)),
    v = d.redISub(m),
    E = o.redSqr();
  (E = E.redIAdd(E)), (E = E.redIAdd(E)), (E = E.redIAdd(E));
  var A = c.redMul(v).redISub(E),
    I = n.redAdd(n).redMul(i);
  return this.curve.jpoint(m, A, I);
};
Yn.prototype.trpl = function () {
  if (!this.curve.zeroA) return this.dbl().add(this);
  var e = this.x.redSqr(),
    r = this.y.redSqr(),
    n = this.z.redSqr(),
    i = r.redSqr(),
    a = e.redAdd(e).redIAdd(e),
    s = a.redSqr(),
    o = this.x.redAdd(r).redSqr().redISub(e).redISub(i);
  (o = o.redIAdd(o)), (o = o.redAdd(o).redIAdd(o)), (o = o.redISub(s));
  var c = o.redSqr(),
    u = i.redIAdd(i);
  (u = u.redIAdd(u)), (u = u.redIAdd(u)), (u = u.redIAdd(u));
  var d = a.redIAdd(o).redSqr().redISub(s).redISub(c).redISub(u),
    m = r.redMul(d);
  (m = m.redIAdd(m)), (m = m.redIAdd(m));
  var v = this.x.redMul(c).redISub(m);
  (v = v.redIAdd(v)), (v = v.redIAdd(v));
  var E = this.y.redMul(d.redMul(u.redISub(d)).redISub(o.redMul(c)));
  (E = E.redIAdd(E)), (E = E.redIAdd(E)), (E = E.redIAdd(E));
  var A = this.z.redAdd(o).redSqr().redISub(n).redISub(c);
  return this.curve.jpoint(v, E, A);
};
Yn.prototype.mul = function (e, r) {
  return (e = new pt(e, r)), this.curve._wnafMul(this, e);
};
Yn.prototype.eq = function (e) {
  if (e.type === "affine") return this.eq(e.toJ());
  if (this === e) return !0;
  var r = this.z.redSqr(),
    n = e.z.redSqr();
  if (this.x.redMul(n).redISub(e.x.redMul(r)).cmpn(0) !== 0) return !1;
  var i = r.redMul(this.z),
    a = n.redMul(e.z);
  return this.y.redMul(a).redISub(e.y.redMul(i)).cmpn(0) === 0;
};
Yn.prototype.eqXToP = function (e) {
  var r = this.z.redSqr(),
    n = e.toRed(this.curve.red).redMul(r);
  if (this.x.cmp(n) === 0) return !0;
  for (var i = e.clone(), a = this.curve.redN.redMul(r); ; ) {
    if ((i.iadd(this.curve.n), i.cmp(this.curve.p) >= 0)) return !1;
    if ((n.redIAdd(a), this.x.cmp(n) === 0)) return !0;
  }
};
Yn.prototype.inspect = function () {
  return this.isInfinity()
    ? "<EC JPoint Infinity>"
    : "<EC JPoint x: " +
        this.x.toString(16, 2) +
        " y: " +
        this.y.toString(16, 2) +
        " z: " +
        this.z.toString(16, 2) +
        ">";
};
Yn.prototype.isInfinity = function () {
  return this.z.cmpn(0) === 0;
};
var Ky = md(function (t, e) {
    var r = e;
    (r.base = Bu), (r.short = xee), (r.mont = null), (r.edwards = null);
  }),
  Gy = md(function (t, e) {
    var r = e,
      n = va.assert;
    function i(o) {
      o.type === "short"
        ? (this.curve = new Ky.short(o))
        : o.type === "edwards"
        ? (this.curve = new Ky.edwards(o))
        : (this.curve = new Ky.mont(o)),
        (this.g = this.curve.g),
        (this.n = this.curve.n),
        (this.hash = o.hash),
        n(this.g.validate(), "Invalid curve"),
        n(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    r.PresetCurve = i;
    function a(o, c) {
      Object.defineProperty(r, o, {
        configurable: !0,
        enumerable: !0,
        get: function () {
          var u = new i(c);
          return (
            Object.defineProperty(r, o, {
              configurable: !0,
              enumerable: !0,
              value: u,
            }),
            u
          );
        },
      });
    }
    a("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: Di.sha256,
      gRed: !1,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811",
      ],
    }),
      a("p224", {
        type: "short",
        prime: "p224",
        p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
        b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
        n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
        hash: Di.sha256,
        gRed: !1,
        g: [
          "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
          "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34",
        ],
      }),
      a("p256", {
        type: "short",
        prime: null,
        p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
        a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
        b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
        n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
        hash: Di.sha256,
        gRed: !1,
        g: [
          "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
          "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5",
        ],
      }),
      a("p384", {
        type: "short",
        prime: null,
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
        a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
        b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
        n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
        hash: Di.sha384,
        gRed: !1,
        g: [
          "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
          "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f",
        ],
      }),
      a("p521", {
        type: "short",
        prime: null,
        p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
        a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
        b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
        n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
        hash: Di.sha512,
        gRed: !1,
        g: [
          "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
          "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650",
        ],
      }),
      a("curve25519", {
        type: "mont",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "76d06",
        b: "1",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: Di.sha256,
        gRed: !1,
        g: ["9"],
      }),
      a("ed25519", {
        type: "edwards",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "-1",
        c: "1",
        d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: Di.sha256,
        gRed: !1,
        g: [
          "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
          "6666666666666666666666666666666666666666666666666666666666666658",
        ],
      });
    var s;
    try {
      s = null.crash();
    } catch {
      s = void 0;
    }
    a("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: Di.sha256,
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda:
        "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3",
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15",
        },
      ],
      gRed: !1,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        s,
      ],
    });
  });
function el(t) {
  if (!(this instanceof el)) return new el(t);
  (this.hash = t.hash),
    (this.predResist = !!t.predResist),
    (this.outLen = this.hash.outSize),
    (this.minEntropy = t.minEntropy || this.hash.hmacStrength),
    (this._reseed = null),
    (this.reseedInterval = null),
    (this.K = null),
    (this.V = null);
  var e = ds.toArray(t.entropy, t.entropyEnc || "hex"),
    r = ds.toArray(t.nonce, t.nonceEnc || "hex"),
    n = ds.toArray(t.pers, t.persEnc || "hex");
  Y8(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ),
    this._init(e, r, n);
}
var pD = el;
el.prototype._init = function (e, r, n) {
  var i = e.concat(r).concat(n);
  (this.K = new Array(this.outLen / 8)), (this.V = new Array(this.outLen / 8));
  for (var a = 0; a < this.V.length; a++) (this.K[a] = 0), (this.V[a] = 1);
  this._update(i), (this._reseed = 1), (this.reseedInterval = 281474976710656);
};
el.prototype._hmac = function () {
  return new Di.hmac(this.hash, this.K);
};
el.prototype._update = function (e) {
  var r = this._hmac().update(this.V).update([0]);
  e && (r = r.update(e)),
    (this.K = r.digest()),
    (this.V = this._hmac().update(this.V).digest()),
    e &&
      ((this.K = this._hmac().update(this.V).update([1]).update(e).digest()),
      (this.V = this._hmac().update(this.V).digest()));
};
el.prototype.reseed = function (e, r, n, i) {
  typeof r != "string" && ((i = n), (n = r), (r = null)),
    (e = ds.toArray(e, r)),
    (n = ds.toArray(n, i)),
    Y8(
      e.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ),
    this._update(e.concat(n || [])),
    (this._reseed = 1);
};
el.prototype.generate = function (e, r, n, i) {
  if (this._reseed > this.reseedInterval) throw new Error("Reseed is required");
  typeof r != "string" && ((i = n), (n = r), (r = null)),
    n && ((n = ds.toArray(n, i || "hex")), this._update(n));
  for (var a = []; a.length < e; )
    (this.V = this._hmac().update(this.V).digest()), (a = a.concat(this.V));
  var s = a.slice(0, e);
  return this._update(n), this._reseed++, ds.encode(s, r);
};
var s_ = va.assert;
function di(t, e) {
  (this.ec = t),
    (this.priv = null),
    (this.pub = null),
    e.priv && this._importPrivate(e.priv, e.privEnc),
    e.pub && this._importPublic(e.pub, e.pubEnc);
}
var eE = di;
di.fromPublic = function (e, r, n) {
  return r instanceof di
    ? r
    : new di(e, {
        pub: r,
        pubEnc: n,
      });
};
di.fromPrivate = function (e, r, n) {
  return r instanceof di
    ? r
    : new di(e, {
        priv: r,
        privEnc: n,
      });
};
di.prototype.validate = function () {
  var e = this.getPublic();
  return e.isInfinity()
    ? {
        result: !1,
        reason: "Invalid public key",
      }
    : e.validate()
    ? e.mul(this.ec.curve.n).isInfinity()
      ? {
          result: !0,
          reason: null,
        }
      : {
          result: !1,
          reason: "Public key * N != O",
        }
    : {
        result: !1,
        reason: "Public key is not a point",
      };
};
di.prototype.getPublic = function (e, r) {
  return (
    typeof e == "string" && ((r = e), (e = null)),
    this.pub || (this.pub = this.ec.g.mul(this.priv)),
    r ? this.pub.encode(r, e) : this.pub
  );
};
di.prototype.getPrivate = function (e) {
  return e === "hex" ? this.priv.toString(16, 2) : this.priv;
};
di.prototype._importPrivate = function (e, r) {
  (this.priv = new pt(e, r || 16)),
    (this.priv = this.priv.umod(this.ec.curve.n));
};
di.prototype._importPublic = function (e, r) {
  if (e.x || e.y) {
    this.ec.curve.type === "mont"
      ? s_(e.x, "Need x coordinate")
      : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") &&
        s_(e.x && e.y, "Need both x and y coordinate"),
      (this.pub = this.ec.curve.point(e.x, e.y));
    return;
  }
  this.pub = this.ec.curve.decodePoint(e, r);
};
di.prototype.derive = function (e) {
  return (
    e.validate() || s_(e.validate(), "public point not validated"),
    e.mul(this.priv).getX()
  );
};
di.prototype.sign = function (e, r, n) {
  return this.ec.sign(e, this, r, n);
};
di.prototype.verify = function (e, r) {
  return this.ec.verify(e, r, this);
};
di.prototype.inspect = function () {
  return (
    "<Key priv: " +
    (this.priv && this.priv.toString(16, 2)) +
    " pub: " +
    (this.pub && this.pub.inspect()) +
    " >"
  );
};
var wee = va.assert;
function Xb(t, e) {
  if (t instanceof Xb) return t;
  this._importDER(t, e) ||
    (wee(t.r && t.s, "Signature without r or s"),
    (this.r = new pt(t.r, 16)),
    (this.s = new pt(t.s, 16)),
    t.recoveryParam === void 0
      ? (this.recoveryParam = null)
      : (this.recoveryParam = t.recoveryParam));
}
var ev = Xb;
function _ee() {
  this.place = 0;
}
function Zw(t, e) {
  var r = t[e.place++];
  if (!(r & 128)) return r;
  var n = r & 15;
  if (n === 0 || n > 4) return !1;
  for (var i = 0, a = 0, s = e.place; a < n; a++, s++)
    (i <<= 8), (i |= t[s]), (i >>>= 0);
  return i <= 127 ? !1 : ((e.place = s), i);
}
function Nk(t) {
  for (var e = 0, r = t.length - 1; !t[e] && !(t[e + 1] & 128) && e < r; ) e++;
  return e === 0 ? t : t.slice(e);
}
Xb.prototype._importDER = function (e, r) {
  e = va.toArray(e, r);
  var n = new _ee();
  if (e[n.place++] !== 48) return !1;
  var i = Zw(e, n);
  if (i === !1 || i + n.place !== e.length || e[n.place++] !== 2) return !1;
  var a = Zw(e, n);
  if (a === !1) return !1;
  var s = e.slice(n.place, a + n.place);
  if (((n.place += a), e[n.place++] !== 2)) return !1;
  var o = Zw(e, n);
  if (o === !1 || e.length !== o + n.place) return !1;
  var c = e.slice(n.place, o + n.place);
  if (s[0] === 0)
    if (s[1] & 128) s = s.slice(1);
    else return !1;
  if (c[0] === 0)
    if (c[1] & 128) c = c.slice(1);
    else return !1;
  return (
    (this.r = new pt(s)), (this.s = new pt(c)), (this.recoveryParam = null), !0
  );
};
function Jw(t, e) {
  if (e < 128) {
    t.push(e);
    return;
  }
  var r = 1 + ((Math.log(e) / Math.LN2) >>> 3);
  for (t.push(r | 128); --r; ) t.push((e >>> (r << 3)) & 255);
  t.push(e);
}
Xb.prototype.toDER = function (e) {
  var r = this.r.toArray(),
    n = this.s.toArray();
  for (
    r[0] & 128 && (r = [0].concat(r)),
      n[0] & 128 && (n = [0].concat(n)),
      r = Nk(r),
      n = Nk(n);
    !n[0] && !(n[1] & 128);

  )
    n = n.slice(1);
  var i = [2];
  Jw(i, r.length), (i = i.concat(r)), i.push(2), Jw(i, n.length);
  var a = i.concat(n),
    s = [48];
  return Jw(s, a.length), (s = s.concat(a)), va.encode(s, e);
};
var Eee = function () {
    throw new Error("unsupported");
  },
  mD = va.assert;
function qa(t) {
  if (!(this instanceof qa)) return new qa(t);
  typeof t == "string" &&
    (mD(Object.prototype.hasOwnProperty.call(Gy, t), "Unknown curve " + t),
    (t = Gy[t])),
    t instanceof Gy.PresetCurve &&
      (t = {
        curve: t,
      }),
    (this.curve = t.curve.curve),
    (this.n = this.curve.n),
    (this.nh = this.n.ushrn(1)),
    (this.g = this.curve.g),
    (this.g = t.curve.g),
    this.g.precompute(t.curve.n.bitLength() + 1),
    (this.hash = t.hash || t.curve.hash);
}
var Tee = qa;
qa.prototype.keyPair = function (e) {
  return new eE(this, e);
};
qa.prototype.keyFromPrivate = function (e, r) {
  return eE.fromPrivate(this, e, r);
};
qa.prototype.keyFromPublic = function (e, r) {
  return eE.fromPublic(this, e, r);
};
qa.prototype.genKeyPair = function (e) {
  e || (e = {});
  for (
    var r = new pD({
        hash: this.hash,
        pers: e.pers,
        persEnc: e.persEnc || "utf8",
        entropy: e.entropy || Eee(this.hash.hmacStrength),
        entropyEnc: (e.entropy && e.entropyEnc) || "utf8",
        nonce: this.n.toArray(),
      }),
      n = this.n.byteLength(),
      i = this.n.sub(new pt(2));
    ;

  ) {
    var a = new pt(r.generate(n));
    if (!(a.cmp(i) > 0)) return a.iaddn(1), this.keyFromPrivate(a);
  }
};
qa.prototype._truncateToN = function (e, r) {
  var n = e.byteLength() * 8 - this.n.bitLength();
  return (
    n > 0 && (e = e.ushrn(n)), !r && e.cmp(this.n) >= 0 ? e.sub(this.n) : e
  );
};
qa.prototype.sign = function (e, r, n, i) {
  typeof n == "object" && ((i = n), (n = null)),
    i || (i = {}),
    (r = this.keyFromPrivate(r, n)),
    (e = this._truncateToN(new pt(e, 16)));
  for (
    var a = this.n.byteLength(),
      s = r.getPrivate().toArray("be", a),
      o = e.toArray("be", a),
      c = new pD({
        hash: this.hash,
        entropy: s,
        nonce: o,
        pers: i.pers,
        persEnc: i.persEnc || "utf8",
      }),
      u = this.n.sub(new pt(1)),
      d = 0;
    ;
    d++
  ) {
    var m = i.k ? i.k(d) : new pt(c.generate(this.n.byteLength()));
    if (((m = this._truncateToN(m, !0)), !(m.cmpn(1) <= 0 || m.cmp(u) >= 0))) {
      var v = this.g.mul(m);
      if (!v.isInfinity()) {
        var E = v.getX(),
          A = E.umod(this.n);
        if (A.cmpn(0) !== 0) {
          var I = m.invm(this.n).mul(A.mul(r.getPrivate()).iadd(e));
          if (((I = I.umod(this.n)), I.cmpn(0) !== 0)) {
            var b = (v.getY().isOdd() ? 1 : 0) | (E.cmp(A) !== 0 ? 2 : 0);
            return (
              i.canonical &&
                I.cmp(this.nh) > 0 &&
                ((I = this.n.sub(I)), (b ^= 1)),
              new ev({
                r: A,
                s: I,
                recoveryParam: b,
              })
            );
          }
        }
      }
    }
  }
};
qa.prototype.verify = function (e, r, n, i) {
  (e = this._truncateToN(new pt(e, 16))),
    (n = this.keyFromPublic(n, i)),
    (r = new ev(r, "hex"));
  var a = r.r,
    s = r.s;
  if (
    a.cmpn(1) < 0 ||
    a.cmp(this.n) >= 0 ||
    s.cmpn(1) < 0 ||
    s.cmp(this.n) >= 0
  )
    return !1;
  var o = s.invm(this.n),
    c = o.mul(e).umod(this.n),
    u = o.mul(a).umod(this.n),
    d;
  return this.curve._maxwellTrick
    ? ((d = this.g.jmulAdd(c, n.getPublic(), u)),
      d.isInfinity() ? !1 : d.eqXToP(a))
    : ((d = this.g.mulAdd(c, n.getPublic(), u)),
      d.isInfinity() ? !1 : d.getX().umod(this.n).cmp(a) === 0);
};
qa.prototype.recoverPubKey = function (t, e, r, n) {
  mD((3 & r) === r, "The recovery param is more than two bits"),
    (e = new ev(e, n));
  var i = this.n,
    a = new pt(t),
    s = e.r,
    o = e.s,
    c = r & 1,
    u = r >> 1;
  if (s.cmp(this.curve.p.umod(this.curve.n)) >= 0 && u)
    throw new Error("Unable to find sencond key candinate");
  u
    ? (s = this.curve.pointFromX(s.add(this.curve.n), c))
    : (s = this.curve.pointFromX(s, c));
  var d = e.r.invm(i),
    m = i.sub(a).mul(d).umod(i),
    v = o.mul(d).umod(i);
  return this.g.mulAdd(m, s, v);
};
qa.prototype.getKeyRecoveryParam = function (t, e, r, n) {
  if (((e = new ev(e, n)), e.recoveryParam !== null)) return e.recoveryParam;
  for (var i = 0; i < 4; i++) {
    var a;
    try {
      a = this.recoverPubKey(t, e, i);
    } catch {
      continue;
    }
    if (a.eq(r)) return i;
  }
  throw new Error("Unable to find valid recovery factor");
};
var Cee = md(function (t, e) {
    var r = e;
    (r.version = "6.5.4"),
      (r.utils = va),
      (r.rand = function () {
        throw new Error("unsupported");
      }),
      (r.curve = Ky),
      (r.curves = Gy),
      (r.ec = Tee),
      (r.eddsa = null);
  }),
  Aee = Cee.ec;
const kee = "signing-key/5.7.0",
  o_ = new ue(kee);
let Qw = null;
function Fs() {
  return Qw || (Qw = new Aee("secp256k1")), Qw;
}
class tu {
  constructor(e) {
    _e(this, "curve", "secp256k1"),
      _e(this, "privateKey", Ke(e)),
      za(this.privateKey) !== 32 &&
        o_.throwArgumentError(
          "invalid private key",
          "privateKey",
          "[[ REDACTED ]]"
        );
    const r = Fs().keyFromPrivate(qe(this.privateKey));
    _e(this, "publicKey", "0x" + r.getPublic(!1, "hex")),
      _e(this, "compressedPublicKey", "0x" + r.getPublic(!0, "hex")),
      _e(this, "_isSigningKey", !0);
  }
  _addPoint(e) {
    const r = Fs().keyFromPublic(qe(this.publicKey)),
      n = Fs().keyFromPublic(qe(e));
    return "0x" + r.pub.add(n.pub).encodeCompressed("hex");
  }
  signDigest(e) {
    const r = Fs().keyFromPrivate(qe(this.privateKey)),
      n = qe(e);
    n.length !== 32 && o_.throwArgumentError("bad digest length", "digest", e);
    const i = r.sign(n, {
      canonical: !0,
    });
    return yo({
      recoveryParam: i.recoveryParam,
      r: Rt("0x" + i.r.toString(16), 32),
      s: Rt("0x" + i.s.toString(16), 32),
    });
  }
  computeSharedSecret(e) {
    const r = Fs().keyFromPrivate(qe(this.privateKey)),
      n = Fs().keyFromPublic(qe(tE(e)));
    return Rt("0x" + r.derive(n.getPublic()).toString(16), 32);
  }
  static isSigningKey(e) {
    return !!(e && e._isSigningKey);
  }
}
function yD(t, e) {
  const r = yo(e),
    n = {
      r: qe(r.r),
      s: qe(r.s),
    };
  return "0x" + Fs().recoverPubKey(qe(t), n, r.recoveryParam).encode("hex", !1);
}
function tE(t, e) {
  const r = qe(t);
  if (r.length === 32) {
    const n = new tu(r);
    return e ? "0x" + Fs().keyFromPrivate(r).getPublic(!0, "hex") : n.publicKey;
  } else {
    if (r.length === 33)
      return e ? Ke(r) : "0x" + Fs().keyFromPublic(r).getPublic(!1, "hex");
    if (r.length === 65)
      return e ? "0x" + Fs().keyFromPublic(r).getPublic(!0, "hex") : Ke(r);
  }
  return o_.throwArgumentError(
    "invalid public or private key",
    "key",
    "[REDACTED]"
  );
}
const See = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        SigningKey: tu,
        computePublicKey: tE,
        recoverPublicKey: yD,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  Mee = "transactions/5.7.0",
  li = new ue(Mee);
var c_;
(function (t) {
  (t[(t.legacy = 0)] = "legacy"),
    (t[(t.eip2930 = 1)] = "eip2930"),
    (t[(t.eip1559 = 2)] = "eip1559");
})(c_ || (c_ = {}));
function rE(t) {
  return t === "0x" ? null : Xt(t);
}
function ci(t) {
  return t === "0x" ? kB : ae.from(t);
}
const Iee = [
    {
      name: "nonce",
      maxLength: 32,
      numeric: !0,
    },
    {
      name: "gasPrice",
      maxLength: 32,
      numeric: !0,
    },
    {
      name: "gasLimit",
      maxLength: 32,
      numeric: !0,
    },
    {
      name: "to",
      length: 20,
    },
    {
      name: "value",
      maxLength: 32,
      numeric: !0,
    },
    {
      name: "data",
    },
  ],
  Ree = {
    chainId: !0,
    data: !0,
    gasLimit: !0,
    gasPrice: !0,
    nonce: !0,
    to: !0,
    type: !0,
    value: !0,
  };
function Fc(t) {
  const e = tE(t);
  return Xt(sn(Ut(sn(e, 1)), 12));
}
function Du(t, e) {
  return Fc(yD(qe(t), e));
}
function ra(t, e) {
  const r = zi(ae.from(t).toHexString());
  return (
    r.length > 32 &&
      li.throwArgumentError("invalid length for " + e, "transaction:" + e, t),
    r
  );
}
function Yw(t, e) {
  return {
    address: Xt(t),
    storageKeys: (e || []).map(
      (r, n) => (
        za(r) !== 32 &&
          li.throwArgumentError(
            "invalid access list storageKey",
            `accessList[${t}:${n}]`,
            r
          ),
        r.toLowerCase()
      )
    ),
  };
}
function yl(t) {
  if (Array.isArray(t))
    return t.map((r, n) =>
      Array.isArray(r)
        ? (r.length > 2 &&
            li.throwArgumentError(
              "access list expected to be [ address, storageKeys[] ]",
              `value[${n}]`,
              r
            ),
          Yw(r[0], r[1]))
        : Yw(r.address, r.storageKeys)
    );
  const e = Object.keys(t).map((r) => {
    const n = t[r].reduce((i, a) => ((i[a] = !0), i), {});
    return Yw(r, Object.keys(n).sort());
  });
  return e.sort((r, n) => r.address.localeCompare(n.address)), e;
}
function gD(t) {
  return yl(t).map((e) => [e.address, e.storageKeys]);
}
function bD(t, e) {
  if (t.gasPrice != null) {
    const n = ae.from(t.gasPrice),
      i = ae.from(t.maxFeePerGas || 0);
    n.eq(i) ||
      li.throwArgumentError(
        "mismatch EIP-1559 gasPrice != maxFeePerGas",
        "tx",
        {
          gasPrice: n,
          maxFeePerGas: i,
        }
      );
  }
  const r = [
    ra(t.chainId || 0, "chainId"),
    ra(t.nonce || 0, "nonce"),
    ra(t.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    ra(t.maxFeePerGas || 0, "maxFeePerGas"),
    ra(t.gasLimit || 0, "gasLimit"),
    t.to != null ? Xt(t.to) : "0x",
    ra(t.value || 0, "value"),
    t.data || "0x",
    gD(t.accessList || []),
  ];
  if (e) {
    const n = yo(e);
    r.push(ra(n.recoveryParam, "recoveryParam")),
      r.push(zi(n.r)),
      r.push(zi(n.s));
  }
  return Ti(["0x02", mu(r)]);
}
function vD(t, e) {
  const r = [
    ra(t.chainId || 0, "chainId"),
    ra(t.nonce || 0, "nonce"),
    ra(t.gasPrice || 0, "gasPrice"),
    ra(t.gasLimit || 0, "gasLimit"),
    t.to != null ? Xt(t.to) : "0x",
    ra(t.value || 0, "value"),
    t.data || "0x",
    gD(t.accessList || []),
  ];
  if (e) {
    const n = yo(e);
    r.push(ra(n.recoveryParam, "recoveryParam")),
      r.push(zi(n.r)),
      r.push(zi(n.s));
  }
  return Ti(["0x01", mu(r)]);
}
function Pee(t, e) {
  H8(t, Ree);
  const r = [];
  Iee.forEach(function (s) {
    let o = t[s.name] || [];
    const c = {};
    s.numeric && (c.hexPad = "left"),
      (o = qe(Ke(o, c))),
      s.length &&
        o.length !== s.length &&
        o.length > 0 &&
        li.throwArgumentError(
          "invalid length for " + s.name,
          "transaction:" + s.name,
          o
        ),
      s.maxLength &&
        ((o = zi(o)),
        o.length > s.maxLength &&
          li.throwArgumentError(
            "invalid length for " + s.name,
            "transaction:" + s.name,
            o
          )),
      r.push(Ke(o));
  });
  let n = 0;
  if (
    (t.chainId != null
      ? ((n = t.chainId),
        typeof n != "number" &&
          li.throwArgumentError(
            "invalid transaction.chainId",
            "transaction",
            t
          ))
      : e && !Bm(e) && e.v > 28 && (n = Math.floor((e.v - 35) / 2)),
    n !== 0 && (r.push(Ke(n)), r.push("0x"), r.push("0x")),
    !e)
  )
    return mu(r);
  const i = yo(e);
  let a = 27 + i.recoveryParam;
  return (
    n !== 0
      ? (r.pop(),
        r.pop(),
        r.pop(),
        (a += n * 2 + 8),
        i.v > 28 &&
          i.v !== a &&
          li.throwArgumentError(
            "transaction.chainId/signature.v mismatch",
            "signature",
            e
          ))
      : i.v !== a &&
        li.throwArgumentError(
          "transaction.chainId/signature.v mismatch",
          "signature",
          e
        ),
    r.push(Ke(a)),
    r.push(zi(qe(i.r))),
    r.push(zi(qe(i.s))),
    mu(r)
  );
}
function Up(t, e) {
  if (t.type == null || t.type === 0)
    return (
      t.accessList != null &&
        li.throwArgumentError(
          "untyped transactions do not support accessList; include type: 1",
          "transaction",
          t
        ),
      Pee(t, e)
    );
  switch (t.type) {
    case 1:
      return vD(t, e);
    case 2:
      return bD(t, e);
  }
  return li.throwError(
    `unsupported transaction type: ${t.type}`,
    ue.errors.UNSUPPORTED_OPERATION,
    {
      operation: "serializeTransaction",
      transactionType: t.type,
    }
  );
}
function xD(t, e, r) {
  try {
    const n = ci(e[0]).toNumber();
    if (n !== 0 && n !== 1) throw new Error("bad recid");
    t.v = n;
  } catch {
    li.throwArgumentError("invalid v for transaction type: 1", "v", e[0]);
  }
  (t.r = Rt(e[1], 32)), (t.s = Rt(e[2], 32));
  try {
    const n = Ut(r(t));
    t.from = Du(n, {
      r: t.r,
      s: t.s,
      recoveryParam: t.v,
    });
  } catch {}
}
function Nee(t) {
  const e = Kb(t.slice(1));
  e.length !== 9 &&
    e.length !== 12 &&
    li.throwArgumentError(
      "invalid component count for transaction type: 2",
      "payload",
      Ke(t)
    );
  const r = ci(e[2]),
    n = ci(e[3]),
    i = {
      type: 2,
      chainId: ci(e[0]).toNumber(),
      nonce: ci(e[1]).toNumber(),
      maxPriorityFeePerGas: r,
      maxFeePerGas: n,
      gasPrice: null,
      gasLimit: ci(e[4]),
      to: rE(e[5]),
      value: ci(e[6]),
      data: e[7],
      accessList: yl(e[8]),
    };
  return e.length === 9 || ((i.hash = Ut(t)), xD(i, e.slice(9), bD)), i;
}
function Bee(t) {
  const e = Kb(t.slice(1));
  e.length !== 8 &&
    e.length !== 11 &&
    li.throwArgumentError(
      "invalid component count for transaction type: 1",
      "payload",
      Ke(t)
    );
  const r = {
    type: 1,
    chainId: ci(e[0]).toNumber(),
    nonce: ci(e[1]).toNumber(),
    gasPrice: ci(e[2]),
    gasLimit: ci(e[3]),
    to: rE(e[4]),
    value: ci(e[5]),
    data: e[6],
    accessList: yl(e[7]),
  };
  return e.length === 8 || ((r.hash = Ut(t)), xD(r, e.slice(8), vD)), r;
}
function Dee(t) {
  const e = Kb(t);
  e.length !== 9 &&
    e.length !== 6 &&
    li.throwArgumentError("invalid raw transaction", "rawTransaction", t);
  const r = {
    nonce: ci(e[0]).toNumber(),
    gasPrice: ci(e[1]),
    gasLimit: ci(e[2]),
    to: rE(e[3]),
    value: ci(e[4]),
    data: e[5],
    chainId: 0,
  };
  if (e.length === 6) return r;
  try {
    r.v = ae.from(e[6]).toNumber();
  } catch {
    return r;
  }
  if (
    ((r.r = Rt(e[7], 32)),
    (r.s = Rt(e[8], 32)),
    ae.from(r.r).isZero() && ae.from(r.s).isZero())
  )
    (r.chainId = r.v), (r.v = 0);
  else {
    (r.chainId = Math.floor((r.v - 35) / 2)), r.chainId < 0 && (r.chainId = 0);
    let n = r.v - 27;
    const i = e.slice(0, 6);
    r.chainId !== 0 &&
      (i.push(Ke(r.chainId)),
      i.push("0x"),
      i.push("0x"),
      (n -= r.chainId * 2 + 8));
    const a = Ut(mu(i));
    try {
      r.from = Du(a, {
        r: Ke(r.r),
        s: Ke(r.s),
        recoveryParam: n,
      });
    } catch {}
    r.hash = Ut(t);
  }
  return (r.type = null), r;
}
function wD(t) {
  const e = qe(t);
  if (e[0] > 127) return Dee(e);
  switch (e[0]) {
    case 1:
      return Bee(e);
    case 2:
      return Nee(e);
  }
  return li.throwError(
    `unsupported transaction type: ${e[0]}`,
    ue.errors.UNSUPPORTED_OPERATION,
    {
      operation: "parseTransaction",
      transactionType: e[0],
    }
  );
}
const Oee = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        get TransactionTypes() {
          return c_;
        },
        accessListify: yl,
        computeAddress: Fc,
        parse: wD,
        recoverAddress: Du,
        serialize: Up,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  Fee = "contracts/5.7.0";
var tl = function (t, e, r, n) {
  function i(a) {
    return a instanceof r
      ? a
      : new r(function (s) {
          s(a);
        });
  }
  return new (r || (r = Promise))(function (a, s) {
    function o(d) {
      try {
        u(n.next(d));
      } catch (m) {
        s(m);
      }
    }
    function c(d) {
      try {
        u(n.throw(d));
      } catch (m) {
        s(m);
      }
    }
    function u(d) {
      d.done ? a(d.value) : i(d.value).then(o, c);
    }
    u((n = n.apply(t, e || [])).next());
  });
};
const or = new ue(Fee),
  Lee = {
    chainId: !0,
    data: !0,
    from: !0,
    gasLimit: !0,
    gasPrice: !0,
    nonce: !0,
    to: !0,
    value: !0,
    type: !0,
    accessList: !0,
    maxFeePerGas: !0,
    maxPriorityFeePerGas: !0,
    customData: !0,
    ccipReadEnabled: !0,
  };
function Yg(t, e) {
  return tl(this, void 0, void 0, function* () {
    const r = yield e;
    typeof r != "string" &&
      or.throwArgumentError("invalid address or ENS name", "name", r);
    try {
      return Xt(r);
    } catch {}
    t ||
      or.throwError(
        "a provider or signer is needed to resolve ENS names",
        ue.errors.UNSUPPORTED_OPERATION,
        {
          operation: "resolveName",
        }
      );
    const n = yield t.resolveName(r);
    return (
      n == null &&
        or.throwArgumentError(
          "resolver or addr is not configured for ENS name",
          "name",
          r
        ),
      n
    );
  });
}
function $h(t, e, r) {
  return tl(this, void 0, void 0, function* () {
    return Array.isArray(r)
      ? yield Promise.all(
          r.map((n, i) => $h(t, Array.isArray(e) ? e[i] : e[n.name], n))
        )
      : r.type === "address"
      ? yield Yg(t, e)
      : r.type === "tuple"
      ? yield $h(t, e, r.components)
      : r.baseType === "array"
      ? Array.isArray(e)
        ? yield Promise.all(e.map((n) => $h(t, n, r.arrayChildren)))
        : Promise.reject(
            or.makeError(
              "invalid value for array",
              ue.errors.INVALID_ARGUMENT,
              {
                argument: "value",
                value: e,
              }
            )
          )
      : e;
  });
}
function tv(t, e, r) {
  return tl(this, void 0, void 0, function* () {
    let n = {};
    r.length === e.inputs.length + 1 &&
      typeof r[r.length - 1] == "object" &&
      (n = vr(r.pop())),
      or.checkArgumentCount(r.length, e.inputs.length, "passed to contract"),
      t.signer
        ? n.from
          ? (n.from = en({
              override: Yg(t.signer, n.from),
              signer: t.signer.getAddress(),
            }).then((u) =>
              tl(this, void 0, void 0, function* () {
                return (
                  Xt(u.signer) !== u.override &&
                    or.throwError(
                      "Contract with a Signer cannot override from",
                      ue.errors.UNSUPPORTED_OPERATION,
                      {
                        operation: "overrides.from",
                      }
                    ),
                  u.override
                );
              })
            ))
          : (n.from = t.signer.getAddress())
        : n.from && (n.from = Yg(t.provider, n.from));
    const i = yield en({
        args: $h(t.signer || t.provider, r, e.inputs),
        address: t.resolvedAddress,
        overrides: en(n) || {},
      }),
      a = t.interface.encodeFunctionData(e, i.args),
      s = {
        data: a,
        to: i.address,
      },
      o = i.overrides;
    if (
      (o.nonce != null && (s.nonce = ae.from(o.nonce).toNumber()),
      o.gasLimit != null && (s.gasLimit = ae.from(o.gasLimit)),
      o.gasPrice != null && (s.gasPrice = ae.from(o.gasPrice)),
      o.maxFeePerGas != null && (s.maxFeePerGas = ae.from(o.maxFeePerGas)),
      o.maxPriorityFeePerGas != null &&
        (s.maxPriorityFeePerGas = ae.from(o.maxPriorityFeePerGas)),
      o.from != null && (s.from = o.from),
      o.type != null && (s.type = o.type),
      o.accessList != null && (s.accessList = yl(o.accessList)),
      s.gasLimit == null && e.gas != null)
    ) {
      let u = 21e3;
      const d = qe(a);
      for (let m = 0; m < d.length; m++) (u += 4), d[m] && (u += 64);
      s.gasLimit = ae.from(e.gas).add(u);
    }
    if (o.value) {
      const u = ae.from(o.value);
      !u.isZero() &&
        !e.payable &&
        or.throwError(
          "non-payable method cannot override value",
          ue.errors.UNSUPPORTED_OPERATION,
          {
            operation: "overrides.value",
            value: n.value,
          }
        ),
        (s.value = u);
    }
    o.customData && (s.customData = vr(o.customData)),
      o.ccipReadEnabled && (s.ccipReadEnabled = !!o.ccipReadEnabled),
      delete n.nonce,
      delete n.gasLimit,
      delete n.gasPrice,
      delete n.from,
      delete n.value,
      delete n.type,
      delete n.accessList,
      delete n.maxFeePerGas,
      delete n.maxPriorityFeePerGas,
      delete n.customData,
      delete n.ccipReadEnabled;
    const c = Object.keys(n).filter((u) => n[u] != null);
    return (
      c.length &&
        or.throwError(
          `cannot override ${c.map((u) => JSON.stringify(u)).join(",")}`,
          ue.errors.UNSUPPORTED_OPERATION,
          {
            operation: "overrides",
            overrides: c,
          }
        ),
      s
    );
  });
}
function $ee(t, e) {
  return function (...r) {
    return tv(t, e, r);
  };
}
function Uee(t, e) {
  const r = t.signer || t.provider;
  return function (...n) {
    return tl(this, void 0, void 0, function* () {
      r ||
        or.throwError(
          "estimate require a provider or signer",
          ue.errors.UNSUPPORTED_OPERATION,
          {
            operation: "estimateGas",
          }
        );
      const i = yield tv(t, e, n);
      return yield r.estimateGas(i);
    });
  };
}
function _D(t, e) {
  const r = e.wait.bind(e);
  e.wait = (n) =>
    r(n).then(
      (i) => (
        (i.events = i.logs.map((a) => {
          let s = fi(a),
            o = null;
          try {
            o = t.interface.parseLog(a);
          } catch {}
          return (
            o &&
              ((s.args = o.args),
              (s.decode = (c, u) =>
                t.interface.decodeEventLog(o.eventFragment, c, u)),
              (s.event = o.name),
              (s.eventSignature = o.signature)),
            (s.removeListener = () => t.provider),
            (s.getBlock = () => t.provider.getBlock(i.blockHash)),
            (s.getTransaction = () =>
              t.provider.getTransaction(i.transactionHash)),
            (s.getTransactionReceipt = () => Promise.resolve(i)),
            s
          );
        })),
        i
      )
    );
}
function ED(t, e, r) {
  const n = t.signer || t.provider;
  return function (...i) {
    return tl(this, void 0, void 0, function* () {
      let a;
      if (
        i.length === e.inputs.length + 1 &&
        typeof i[i.length - 1] == "object"
      ) {
        const c = vr(i.pop());
        c.blockTag != null && (a = yield c.blockTag),
          delete c.blockTag,
          i.push(c);
      }
      t.deployTransaction != null && (yield t._deployed(a));
      const s = yield tv(t, e, i),
        o = yield n.call(s, a);
      try {
        let c = t.interface.decodeFunctionResult(e, o);
        return r && e.outputs.length === 1 && (c = c[0]), c;
      } catch (c) {
        throw (
          (c.code === ue.errors.CALL_EXCEPTION &&
            ((c.address = t.address), (c.args = i), (c.transaction = s)),
          c)
        );
      }
    });
  };
}
function Wee(t, e) {
  return function (...r) {
    return tl(this, void 0, void 0, function* () {
      t.signer ||
        or.throwError(
          "sending a transaction requires a signer",
          ue.errors.UNSUPPORTED_OPERATION,
          {
            operation: "sendTransaction",
          }
        ),
        t.deployTransaction != null && (yield t._deployed());
      const n = yield tv(t, e, r),
        i = yield t.signer.sendTransaction(n);
      return _D(t, i), i;
    });
  };
}
function Bk(t, e, r) {
  return e.constant ? ED(t, e, r) : Wee(t, e);
}
function TD(t) {
  return t.address && (t.topics == null || t.topics.length === 0)
    ? "*"
    : (t.address || "*") +
        "@" +
        (t.topics
          ? t.topics.map((e) => (Array.isArray(e) ? e.join("|") : e)).join(":")
          : "");
}
class Wp {
  constructor(e, r) {
    _e(this, "tag", e), _e(this, "filter", r), (this._listeners = []);
  }
  addListener(e, r) {
    this._listeners.push({
      listener: e,
      once: r,
    });
  }
  removeListener(e) {
    let r = !1;
    this._listeners = this._listeners.filter((n) =>
      r || n.listener !== e ? !0 : ((r = !0), !1)
    );
  }
  removeAllListeners() {
    this._listeners = [];
  }
  listeners() {
    return this._listeners.map((e) => e.listener);
  }
  listenerCount() {
    return this._listeners.length;
  }
  run(e) {
    const r = this.listenerCount();
    return (
      (this._listeners = this._listeners.filter((n) => {
        const i = e.slice();
        return (
          setTimeout(() => {
            n.listener.apply(this, i);
          }, 0),
          !n.once
        );
      })),
      r
    );
  }
  prepareEvent(e) {}
  getEmit(e) {
    return [e];
  }
}
class jee extends Wp {
  constructor() {
    super("error", null);
  }
}
class Dk extends Wp {
  constructor(e, r, n, i) {
    const a = {
      address: e,
    };
    let s = r.getEventTopic(n);
    i
      ? (s !== i[0] && or.throwArgumentError("topic mismatch", "topics", i),
        (a.topics = i.slice()))
      : (a.topics = [s]),
      super(TD(a), a),
      _e(this, "address", e),
      _e(this, "interface", r),
      _e(this, "fragment", n);
  }
  prepareEvent(e) {
    super.prepareEvent(e),
      (e.event = this.fragment.name),
      (e.eventSignature = this.fragment.format()),
      (e.decode = (r, n) => this.interface.decodeEventLog(this.fragment, r, n));
    try {
      e.args = this.interface.decodeEventLog(this.fragment, e.data, e.topics);
    } catch (r) {
      (e.args = null), (e.decodeError = r);
    }
  }
  getEmit(e) {
    const r = bB(e.args);
    if (r.length) throw r[0].error;
    const n = (e.args || []).slice();
    return n.push(e), n;
  }
}
class Ok extends Wp {
  constructor(e, r) {
    super("*", {
      address: e,
    }),
      _e(this, "address", e),
      _e(this, "interface", r);
  }
  prepareEvent(e) {
    super.prepareEvent(e);
    try {
      const r = this.interface.parseLog(e);
      (e.event = r.name),
        (e.eventSignature = r.signature),
        (e.decode = (n, i) =>
          this.interface.decodeEventLog(r.eventFragment, n, i)),
        (e.args = r.args);
    } catch {}
  }
}
class Hee {
  constructor(e, r, n) {
    _e(this, "interface", qn(new.target, "getInterface")(r)),
      n == null
        ? (_e(this, "provider", null), _e(this, "signer", null))
        : Nu.isSigner(n)
        ? (_e(this, "provider", n.provider || null), _e(this, "signer", n))
        : Qb.isProvider(n)
        ? (_e(this, "provider", n), _e(this, "signer", null))
        : or.throwArgumentError(
            "invalid signer or provider",
            "signerOrProvider",
            n
          ),
      _e(this, "callStatic", {}),
      _e(this, "estimateGas", {}),
      _e(this, "functions", {}),
      _e(this, "populateTransaction", {}),
      _e(this, "filters", {});
    {
      const s = {};
      Object.keys(this.interface.events).forEach((o) => {
        const c = this.interface.events[o];
        _e(this.filters, o, (...u) => ({
          address: this.address,
          topics: this.interface.encodeFilterTopics(c, u),
        })),
          s[c.name] || (s[c.name] = []),
          s[c.name].push(o);
      }),
        Object.keys(s).forEach((o) => {
          const c = s[o];
          c.length === 1
            ? _e(this.filters, o, this.filters[c[0]])
            : or.warn(`Duplicate definition of ${o} (${c.join(", ")})`);
        });
    }
    if (
      (_e(this, "_runningEvents", {}),
      _e(this, "_wrappedEmits", {}),
      e == null &&
        or.throwArgumentError(
          "invalid contract address or ENS name",
          "addressOrName",
          e
        ),
      _e(this, "address", e),
      this.provider)
    )
      _e(this, "resolvedAddress", Yg(this.provider, e));
    else
      try {
        _e(this, "resolvedAddress", Promise.resolve(Xt(e)));
      } catch {
        or.throwError(
          "provider is required to use ENS name as contract address",
          ue.errors.UNSUPPORTED_OPERATION,
          {
            operation: "new Contract",
          }
        );
      }
    this.resolvedAddress.catch((s) => {});
    const i = {},
      a = {};
    Object.keys(this.interface.functions).forEach((s) => {
      const o = this.interface.functions[s];
      if (a[s]) {
        or.warn(`Duplicate ABI entry for ${JSON.stringify(s)}`);
        return;
      }
      a[s] = !0;
      {
        const c = o.name;
        i[`%${c}`] || (i[`%${c}`] = []), i[`%${c}`].push(s);
      }
      this[s] == null && _e(this, s, Bk(this, o, !0)),
        this.functions[s] == null && _e(this.functions, s, Bk(this, o, !1)),
        this.callStatic[s] == null && _e(this.callStatic, s, ED(this, o, !0)),
        this.populateTransaction[s] == null &&
          _e(this.populateTransaction, s, $ee(this, o)),
        this.estimateGas[s] == null && _e(this.estimateGas, s, Uee(this, o));
    }),
      Object.keys(i).forEach((s) => {
        const o = i[s];
        if (o.length > 1) return;
        s = s.substring(1);
        const c = o[0];
        try {
          this[s] == null && _e(this, s, this[c]);
        } catch {}
        this.functions[s] == null && _e(this.functions, s, this.functions[c]),
          this.callStatic[s] == null &&
            _e(this.callStatic, s, this.callStatic[c]),
          this.populateTransaction[s] == null &&
            _e(this.populateTransaction, s, this.populateTransaction[c]),
          this.estimateGas[s] == null &&
            _e(this.estimateGas, s, this.estimateGas[c]);
      });
  }
  static getContractAddress(e) {
    return fd(e);
  }
  static getInterface(e) {
    return ls.isInterface(e) ? e : new ls(e);
  }
  deployed() {
    return this._deployed();
  }
  _deployed(e) {
    return (
      this._deployedPromise ||
        (this.deployTransaction
          ? (this._deployedPromise = this.deployTransaction
              .wait()
              .then(() => this))
          : (this._deployedPromise = this.provider
              .getCode(this.address, e)
              .then(
                (r) => (
                  r === "0x" &&
                    or.throwError(
                      "contract not deployed",
                      ue.errors.UNSUPPORTED_OPERATION,
                      {
                        contractAddress: this.address,
                        operation: "getDeployed",
                      }
                    ),
                  this
                )
              ))),
      this._deployedPromise
    );
  }
  fallback(e) {
    this.signer ||
      or.throwError(
        "sending a transactions require a signer",
        ue.errors.UNSUPPORTED_OPERATION,
        {
          operation: "sendTransaction(fallback)",
        }
      );
    const r = vr(e || {});
    return (
      ["from", "to"].forEach(function (n) {
        r[n] != null &&
          or.throwError(
            "cannot override " + n,
            ue.errors.UNSUPPORTED_OPERATION,
            {
              operation: n,
            }
          );
      }),
      (r.to = this.resolvedAddress),
      this.deployed().then(() => this.signer.sendTransaction(r))
    );
  }
  connect(e) {
    typeof e == "string" && (e = new Q8(e, this.provider));
    const r = new this.constructor(this.address, this.interface, e);
    return (
      this.deployTransaction &&
        _e(r, "deployTransaction", this.deployTransaction),
      r
    );
  }
  attach(e) {
    return new this.constructor(
      e,
      this.interface,
      this.signer || this.provider
    );
  }
  static isIndexed(e) {
    return Zg.isIndexed(e);
  }
  _normalizeRunningEvent(e) {
    return this._runningEvents[e.tag] ? this._runningEvents[e.tag] : e;
  }
  _getRunningEvent(e) {
    if (typeof e == "string") {
      if (e === "error") return this._normalizeRunningEvent(new jee());
      if (e === "event")
        return this._normalizeRunningEvent(new Wp("event", null));
      if (e === "*")
        return this._normalizeRunningEvent(
          new Ok(this.address, this.interface)
        );
      const r = this.interface.getEvent(e);
      return this._normalizeRunningEvent(
        new Dk(this.address, this.interface, r)
      );
    }
    if (e.topics && e.topics.length > 0) {
      try {
        const n = e.topics[0];
        if (typeof n != "string") throw new Error("invalid topic");
        const i = this.interface.getEvent(n);
        return this._normalizeRunningEvent(
          new Dk(this.address, this.interface, i, e.topics)
        );
      } catch {}
      const r = {
        address: this.address,
        topics: e.topics,
      };
      return this._normalizeRunningEvent(new Wp(TD(r), r));
    }
    return this._normalizeRunningEvent(new Ok(this.address, this.interface));
  }
  _checkRunningEvents(e) {
    if (e.listenerCount() === 0) {
      delete this._runningEvents[e.tag];
      const r = this._wrappedEmits[e.tag];
      r &&
        e.filter &&
        (this.provider.off(e.filter, r), delete this._wrappedEmits[e.tag]);
    }
  }
  _wrapEvent(e, r, n) {
    const i = fi(r);
    return (
      (i.removeListener = () => {
        n && (e.removeListener(n), this._checkRunningEvents(e));
      }),
      (i.getBlock = () => this.provider.getBlock(r.blockHash)),
      (i.getTransaction = () =>
        this.provider.getTransaction(r.transactionHash)),
      (i.getTransactionReceipt = () =>
        this.provider.getTransactionReceipt(r.transactionHash)),
      e.prepareEvent(i),
      i
    );
  }
  _addEventListener(e, r, n) {
    if (
      (this.provider ||
        or.throwError(
          "events require a provider or a signer with a provider",
          ue.errors.UNSUPPORTED_OPERATION,
          {
            operation: "once",
          }
        ),
      e.addListener(r, n),
      (this._runningEvents[e.tag] = e),
      !this._wrappedEmits[e.tag])
    ) {
      const i = (a) => {
        let s = this._wrapEvent(e, a, r);
        if (s.decodeError == null)
          try {
            const o = e.getEmit(s);
            this.emit(e.filter, ...o);
          } catch (o) {
            s.decodeError = o.error;
          }
        e.filter != null && this.emit("event", s),
          s.decodeError != null && this.emit("error", s.decodeError, s);
      };
      (this._wrappedEmits[e.tag] = i),
        e.filter != null && this.provider.on(e.filter, i);
    }
  }
  queryFilter(e, r, n) {
    const i = this._getRunningEvent(e),
      a = vr(i.filter);
    return (
      typeof r == "string" && gt(r, 32)
        ? (n != null &&
            or.throwArgumentError(
              "cannot specify toBlock with blockhash",
              "toBlock",
              n
            ),
          (a.blockHash = r))
        : ((a.fromBlock = r ?? 0), (a.toBlock = n ?? "latest")),
      this.provider
        .getLogs(a)
        .then((s) => s.map((o) => this._wrapEvent(i, o, null)))
    );
  }
  on(e, r) {
    return this._addEventListener(this._getRunningEvent(e), r, !1), this;
  }
  once(e, r) {
    return this._addEventListener(this._getRunningEvent(e), r, !0), this;
  }
  emit(e, ...r) {
    if (!this.provider) return !1;
    const n = this._getRunningEvent(e),
      i = n.run(r) > 0;
    return this._checkRunningEvents(n), i;
  }
  listenerCount(e) {
    return this.provider
      ? e == null
        ? Object.keys(this._runningEvents).reduce(
            (r, n) => r + this._runningEvents[n].listenerCount(),
            0
          )
        : this._getRunningEvent(e).listenerCount()
      : 0;
  }
  listeners(e) {
    if (!this.provider) return [];
    if (e == null) {
      const r = [];
      for (let n in this._runningEvents)
        this._runningEvents[n].listeners().forEach((i) => {
          r.push(i);
        });
      return r;
    }
    return this._getRunningEvent(e).listeners();
  }
  removeAllListeners(e) {
    if (!this.provider) return this;
    if (e == null) {
      for (const n in this._runningEvents) {
        const i = this._runningEvents[n];
        i.removeAllListeners(), this._checkRunningEvents(i);
      }
      return this;
    }
    const r = this._getRunningEvent(e);
    return r.removeAllListeners(), this._checkRunningEvents(r), this;
  }
  off(e, r) {
    if (!this.provider) return this;
    const n = this._getRunningEvent(e);
    return n.removeListener(r), this._checkRunningEvents(n), this;
  }
  removeListener(e, r) {
    return this.off(e, r);
  }
}
class Yt extends Hee {}
let CD = class {
  constructor(e, r, n) {
    let i = null;
    typeof r == "string"
      ? (i = r)
      : hl(r)
      ? (i = Ke(r))
      : r && typeof r.object == "string"
      ? (i = r.object)
      : (i = "!"),
      i.substring(0, 2) !== "0x" && (i = "0x" + i),
      (!gt(i) || i.length % 2) &&
        or.throwArgumentError("invalid bytecode", "bytecode", r),
      n &&
        !Nu.isSigner(n) &&
        or.throwArgumentError("invalid signer", "signer", n),
      _e(this, "bytecode", i),
      _e(this, "interface", qn(new.target, "getInterface")(e)),
      _e(this, "signer", n || null);
  }
  getDeployTransaction(...e) {
    let r = {};
    if (
      e.length === this.interface.deploy.inputs.length + 1 &&
      typeof e[e.length - 1] == "object"
    ) {
      r = vr(e.pop());
      for (const n in r)
        if (!Lee[n]) throw new Error("unknown transaction override " + n);
    }
    return (
      ["data", "from", "to"].forEach((n) => {
        r[n] != null &&
          or.throwError(
            "cannot override " + n,
            ue.errors.UNSUPPORTED_OPERATION,
            {
              operation: n,
            }
          );
      }),
      r.value &&
        !ae.from(r.value).isZero() &&
        !this.interface.deploy.payable &&
        or.throwError(
          "non-payable constructor cannot override value",
          ue.errors.UNSUPPORTED_OPERATION,
          {
            operation: "overrides.value",
            value: r.value,
          }
        ),
      or.checkArgumentCount(
        e.length,
        this.interface.deploy.inputs.length,
        " in Contract constructor"
      ),
      (r.data = Ke(cr([this.bytecode, this.interface.encodeDeploy(e)]))),
      r
    );
  }
  deploy(...e) {
    return tl(this, void 0, void 0, function* () {
      let r = {};
      e.length === this.interface.deploy.inputs.length + 1 && (r = e.pop()),
        or.checkArgumentCount(
          e.length,
          this.interface.deploy.inputs.length,
          " in Contract constructor"
        );
      const n = yield $h(this.signer, e, this.interface.deploy.inputs);
      n.push(r);
      const i = this.getDeployTransaction(...n),
        a = yield this.signer.sendTransaction(i),
        s = qn(this.constructor, "getContractAddress")(a),
        o = qn(this.constructor, "getContract")(s, this.interface, this.signer);
      return _D(o, a), _e(o, "deployTransaction", a), o;
    });
  }
  attach(e) {
    return this.constructor.getContract(e, this.interface, this.signer);
  }
  connect(e) {
    return new this.constructor(this.interface, this.bytecode, e);
  }
  static fromSolidity(e, r) {
    e == null &&
      or.throwError("missing compiler output", ue.errors.MISSING_ARGUMENT, {
        argument: "compilerOutput",
      }),
      typeof e == "string" && (e = JSON.parse(e));
    const n = e.abi;
    let i = null;
    return (
      e.bytecode
        ? (i = e.bytecode)
        : e.evm && e.evm.bytecode && (i = e.evm.bytecode),
      new this(n, i, r)
    );
  }
  static getInterface(e) {
    return Yt.getInterface(e);
  }
  static getContractAddress(e) {
    return fd(e);
  }
  static getContract(e, r, n) {
    return new Yt(e, r, n);
  }
};
class nE {
  constructor(e) {
    _e(this, "alphabet", e),
      _e(this, "base", e.length),
      _e(this, "_alphabetMap", {}),
      _e(this, "_leader", e.charAt(0));
    for (let r = 0; r < e.length; r++) this._alphabetMap[e.charAt(r)] = r;
  }
  encode(e) {
    let r = qe(e);
    if (r.length === 0) return "";
    let n = [0];
    for (let a = 0; a < r.length; ++a) {
      let s = r[a];
      for (let o = 0; o < n.length; ++o)
        (s += n[o] << 8), (n[o] = s % this.base), (s = (s / this.base) | 0);
      for (; s > 0; ) n.push(s % this.base), (s = (s / this.base) | 0);
    }
    let i = "";
    for (let a = 0; r[a] === 0 && a < r.length - 1; ++a) i += this._leader;
    for (let a = n.length - 1; a >= 0; --a) i += this.alphabet[n[a]];
    return i;
  }
  decode(e) {
    if (typeof e != "string") throw new TypeError("Expected String");
    let r = [];
    if (e.length === 0) return new Uint8Array(r);
    r.push(0);
    for (let n = 0; n < e.length; n++) {
      let i = this._alphabetMap[e[n]];
      if (i === void 0) throw new Error("Non-base" + this.base + " character");
      let a = i;
      for (let s = 0; s < r.length; ++s)
        (a += r[s] * this.base), (r[s] = a & 255), (a >>= 8);
      for (; a > 0; ) r.push(a & 255), (a >>= 8);
    }
    for (let n = 0; e[n] === this._leader && n < e.length - 1; ++n) r.push(0);
    return qe(new Uint8Array(r.reverse()));
  }
}
const zee = new nE("abcdefghijklmnopqrstuvwxyz234567"),
  Ef = new nE("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),
  qee = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        Base32: zee,
        Base58: Ef,
        BaseX: nE,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  );
var Tf;
(function (t) {
  (t.sha256 = "sha256"), (t.sha512 = "sha512");
})(Tf || (Tf = {}));
const Vee = "sha2/5.7.0",
  Kee = new ue(Vee);
function AD(t) {
  return "0x" + Di.ripemd160().update(qe(t)).digest("hex");
}
function Zo(t) {
  return "0x" + Di.sha256().update(qe(t)).digest("hex");
}
function Gee(t) {
  return "0x" + Di.sha512().update(qe(t)).digest("hex");
}
function jp(t, e, r) {
  return (
    Tf[t] ||
      Kee.throwError(
        "unsupported algorithm " + t,
        ue.errors.UNSUPPORTED_OPERATION,
        {
          operation: "hmac",
          algorithm: t,
        }
      ),
    "0x" + Di.hmac(Di[t], qe(e)).update(qe(r)).digest("hex")
  );
}
const Zee = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      get SupportedAlgorithm() {
        return Tf;
      },
      computeHmac: jp,
      ripemd160: AD,
      sha256: Zo,
      sha512: Gee,
    },
    Symbol.toStringTag,
    {
      value: "Module",
    }
  )
);
function iE(t, e, r, n, i) {
  (t = qe(t)), (e = qe(e));
  let a,
    s = 1;
  const o = new Uint8Array(n),
    c = new Uint8Array(e.length + 4);
  c.set(e);
  let u, d;
  for (let m = 1; m <= s; m++) {
    (c[e.length] = (m >> 24) & 255),
      (c[e.length + 1] = (m >> 16) & 255),
      (c[e.length + 2] = (m >> 8) & 255),
      (c[e.length + 3] = m & 255);
    let v = qe(jp(i, t, c));
    a ||
      ((a = v.length),
      (d = new Uint8Array(a)),
      (s = Math.ceil(n / a)),
      (u = n - (s - 1) * a)),
      d.set(v);
    for (let I = 1; I < r; I++) {
      v = qe(jp(i, t, v));
      for (let b = 0; b < a; b++) d[b] ^= v[b];
    }
    const E = (m - 1) * a,
      A = m === s ? u : a;
    o.set(qe(d).slice(0, A), E);
  }
  return Ke(o);
}
const Jee = "wordlists/5.7.0",
  Qee = new ue(Jee);
class Lm {
  constructor(e) {
    Qee.checkAbstract(new.target, Lm), _e(this, "locale", e);
  }
  split(e) {
    return e.toLowerCase().split(/ +/g);
  }
  join(e) {
    return e.join(" ");
  }
  static check(e) {
    const r = [];
    for (let n = 0; n < 2048; n++) {
      const i = e.getWord(n);
      if (n !== e.getWordIndex(i)) return "0x";
      r.push(i);
    }
    return ui(
      r.join(`
`) +
        `
`
    );
  }
  static register(e, r) {
    r || (r = e.locale);
  }
}
const Yee =
  "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
let Uh = null;
function Fk(t) {
  if (
    Uh == null &&
    ((Uh = Yee.replace(/([A-Z])/g, " $1")
      .toLowerCase()
      .substring(1)
      .split(" ")),
    Lm.check(t) !==
      "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60")
  )
    throw ((Uh = null), new Error("BIP39 Wordlist for en (English) FAILED"));
}
class Xee extends Lm {
  constructor() {
    super("en");
  }
  getWord(e) {
    return Fk(this), Uh[e];
  }
  getWordIndex(e) {
    return Fk(this), Uh.indexOf(e);
  }
}
const kD = new Xee();
Lm.register(kD);
const Lk = {
    en: kD,
  },
  ete = "hdnode/5.7.0",
  Hp = new ue(ete),
  tte = ae.from(
    "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"
  ),
  rte = Lt("Bitcoin seed"),
  f0 = 2147483648;
function SD(t) {
  return ((1 << t) - 1) << (8 - t);
}
function nte(t) {
  return (1 << t) - 1;
}
function Q1(t) {
  return Rt(Ke(t), 32);
}
function $k(t) {
  return Ef.encode(cr([t, sn(Zo(Zo(t)), 0, 4)]));
}
function aE(t) {
  if (t == null) return Lk.en;
  if (typeof t == "string") {
    const e = Lk[t];
    return (
      e == null && Hp.throwArgumentError("unknown locale", "wordlist", t), e
    );
  }
  return t;
}
const Zu = {},
  Cf = "m/44'/60'/0'/0/0";
class na {
  constructor(e, r, n, i, a, s, o, c) {
    if (e !== Zu)
      throw new Error("HDNode constructor cannot be called directly");
    if (r) {
      const u = new tu(r);
      _e(this, "privateKey", u.privateKey),
        _e(this, "publicKey", u.compressedPublicKey);
    } else _e(this, "privateKey", null), _e(this, "publicKey", Ke(n));
    _e(this, "parentFingerprint", i),
      _e(this, "fingerprint", sn(AD(Zo(this.publicKey)), 0, 4)),
      _e(this, "address", Fc(this.publicKey)),
      _e(this, "chainCode", a),
      _e(this, "index", s),
      _e(this, "depth", o),
      c == null
        ? (_e(this, "mnemonic", null), _e(this, "path", null))
        : typeof c == "string"
        ? (_e(this, "mnemonic", null), _e(this, "path", c))
        : (_e(this, "mnemonic", c), _e(this, "path", c.path));
  }
  get extendedKey() {
    if (this.depth >= 256) throw new Error("Depth too large!");
    return $k(
      cr([
        this.privateKey != null ? "0x0488ADE4" : "0x0488B21E",
        Ke(this.depth),
        this.parentFingerprint,
        Rt(Ke(this.index), 4),
        this.chainCode,
        this.privateKey != null
          ? cr(["0x00", this.privateKey])
          : this.publicKey,
      ])
    );
  }
  neuter() {
    return new na(
      Zu,
      null,
      this.publicKey,
      this.parentFingerprint,
      this.chainCode,
      this.index,
      this.depth,
      this.path
    );
  }
  _derive(e) {
    if (e > 4294967295) throw new Error("invalid index - " + String(e));
    let r = this.path;
    r && (r += "/" + (e & ~f0));
    const n = new Uint8Array(37);
    if (e & f0) {
      if (!this.privateKey)
        throw new Error("cannot derive child of neutered node");
      n.set(qe(this.privateKey), 1), r && (r += "'");
    } else n.set(qe(this.publicKey));
    for (let m = 24; m >= 0; m -= 8) n[33 + (m >> 3)] = (e >> (24 - m)) & 255;
    const i = qe(jp(Tf.sha512, this.chainCode, n)),
      a = i.slice(0, 32),
      s = i.slice(32);
    let o = null,
      c = null;
    this.privateKey
      ? (o = Q1(ae.from(a).add(this.privateKey).mod(tte)))
      : (c = new tu(Ke(a))._addPoint(this.publicKey));
    let u = r;
    const d = this.mnemonic;
    return (
      d &&
        (u = Object.freeze({
          phrase: d.phrase,
          path: r,
          locale: d.locale || "en",
        })),
      new na(Zu, o, c, this.fingerprint, Q1(s), e, this.depth + 1, u)
    );
  }
  derivePath(e) {
    const r = e.split("/");
    if (r.length === 0 || (r[0] === "m" && this.depth !== 0))
      throw new Error("invalid path - " + e);
    r[0] === "m" && r.shift();
    let n = this;
    for (let i = 0; i < r.length; i++) {
      const a = r[i];
      if (a.match(/^[0-9]+'$/)) {
        const s = parseInt(a.substring(0, a.length - 1));
        if (s >= f0) throw new Error("invalid path index - " + a);
        n = n._derive(f0 + s);
      } else if (a.match(/^[0-9]+$/)) {
        const s = parseInt(a);
        if (s >= f0) throw new Error("invalid path index - " + a);
        n = n._derive(s);
      } else throw new Error("invalid path component - " + a);
    }
    return n;
  }
  static _fromSeed(e, r) {
    const n = qe(e);
    if (n.length < 16 || n.length > 64) throw new Error("invalid seed");
    const i = qe(jp(Tf.sha512, rte, n));
    return new na(
      Zu,
      Q1(i.slice(0, 32)),
      null,
      "0x00000000",
      Q1(i.slice(32)),
      0,
      0,
      r
    );
  }
  static fromMnemonic(e, r, n) {
    return (
      (n = aE(n)),
      (e = nv(rv(e, n), n)),
      na._fromSeed(MD(e, r), {
        phrase: e,
        path: "m",
        locale: n.locale,
      })
    );
  }
  static fromSeed(e) {
    return na._fromSeed(e, null);
  }
  static fromExtendedKey(e) {
    const r = Ef.decode(e);
    (r.length !== 82 || $k(r.slice(0, 78)) !== e) &&
      Hp.throwArgumentError(
        "invalid extended key",
        "extendedKey",
        "[REDACTED]"
      );
    const n = r[4],
      i = Ke(r.slice(5, 9)),
      a = parseInt(Ke(r.slice(9, 13)).substring(2), 16),
      s = Ke(r.slice(13, 45)),
      o = r.slice(45, 78);
    switch (Ke(r.slice(0, 4))) {
      case "0x0488b21e":
      case "0x043587cf":
        return new na(Zu, null, Ke(o), i, s, a, n, null);
      case "0x0488ade4":
      case "0x04358394 ":
        if (o[0] !== 0) break;
        return new na(Zu, Ke(o.slice(1)), null, i, s, a, n, null);
    }
    return Hp.throwArgumentError(
      "invalid extended key",
      "extendedKey",
      "[REDACTED]"
    );
  }
}
function MD(t, e) {
  e || (e = "");
  const r = Lt("mnemonic" + e, co.NFKD);
  return iE(Lt(t, co.NFKD), r, 2048, 64, "sha512");
}
function rv(t, e) {
  (e = aE(e)), Hp.checkNormalize();
  const r = e.split(t);
  if (r.length % 3 !== 0) throw new Error("invalid mnemonic");
  const n = qe(new Uint8Array(Math.ceil((11 * r.length) / 8)));
  let i = 0;
  for (let u = 0; u < r.length; u++) {
    let d = e.getWordIndex(r[u].normalize("NFKD"));
    if (d === -1) throw new Error("invalid mnemonic");
    for (let m = 0; m < 11; m++)
      d & (1 << (10 - m)) && (n[i >> 3] |= 1 << (7 - (i % 8))), i++;
  }
  const a = (32 * r.length) / 3,
    s = r.length / 3,
    o = SD(s);
  if ((qe(Zo(n.slice(0, a / 8)))[0] & o) !== (n[n.length - 1] & o))
    throw new Error("invalid checksum");
  return Ke(n.slice(0, a / 8));
}
function nv(t, e) {
  if (
    ((e = aE(e)),
    (t = qe(t)),
    t.length % 4 !== 0 || t.length < 16 || t.length > 32)
  )
    throw new Error("invalid entropy");
  const r = [0];
  let n = 11;
  for (let s = 0; s < t.length; s++)
    n > 8
      ? ((r[r.length - 1] <<= 8), (r[r.length - 1] |= t[s]), (n -= 8))
      : ((r[r.length - 1] <<= n),
        (r[r.length - 1] |= t[s] >> (8 - n)),
        r.push(t[s] & nte(8 - n)),
        (n += 3));
  const i = t.length / 4,
    a = qe(Zo(t))[0] & SD(i);
  return (
    (r[r.length - 1] <<= i),
    (r[r.length - 1] |= a >> (8 - i)),
    e.join(r.map((s) => e.getWord(s)))
  );
}
function ite(t, e) {
  try {
    return rv(t, e), !0;
  } catch {}
  return !1;
}
function ate(t) {
  return (
    (typeof t != "number" || t < 0 || t >= f0 || t % 1) &&
      Hp.throwArgumentError("invalid account index", "index", t),
    `m/44'/60'/${t}'/0/0`
  );
}
const ste = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        HDNode: na,
        defaultPath: Cf,
        entropyToMnemonic: nv,
        getAccountPath: ate,
        isValidMnemonic: ite,
        mnemonicToEntropy: rv,
        mnemonicToSeed: MD,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  ote = "random/5.7.0",
  l_ = new ue(ote);
function cte() {
  if (typeof self < "u") return self;
  if (typeof window < "u") return window;
  if (typeof global < "u") return global;
  throw new Error("unable to locate global object");
}
const Uk = cte();
let Zy = Uk.crypto || Uk.msCrypto;
(!Zy || !Zy.getRandomValues) &&
  (l_.warn("WARNING: Missing strong random number source"),
  (Zy = {
    getRandomValues: function (t) {
      return l_.throwError(
        "no secure random source avaialble",
        ue.errors.UNSUPPORTED_OPERATION,
        {
          operation: "crypto.getRandomValues",
        }
      );
    },
  }));
function P0(t) {
  (t <= 0 || t > 1024 || t % 1 || t != t) &&
    l_.throwArgumentError("invalid length", "length", t);
  const e = new Uint8Array(t);
  return Zy.getRandomValues(e), qe(e);
}
function ID(t) {
  t = t.slice();
  for (let e = t.length - 1; e > 0; e--) {
    const r = Math.floor(Math.random() * (e + 1)),
      n = t[e];
    (t[e] = t[r]), (t[r] = n);
  }
  return t;
}
const lte = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      randomBytes: P0,
      shuffled: ID,
    },
    Symbol.toStringTag,
    {
      value: "Module",
    }
  )
);
var RD = {
  exports: {},
};
(function (t, e) {
  (function (r) {
    function n(P) {
      return parseInt(P) === P;
    }
    function i(P) {
      if (!n(P.length)) return !1;
      for (var M = 0; M < P.length; M++)
        if (!n(P[M]) || P[M] < 0 || P[M] > 255) return !1;
      return !0;
    }
    function a(P, M) {
      if (P.buffer && ArrayBuffer.isView(P) && P.name === "Uint8Array")
        return (
          M &&
            (P.slice ? (P = P.slice()) : (P = Array.prototype.slice.call(P))),
          P
        );
      if (Array.isArray(P)) {
        if (!i(P)) throw new Error("Array contains invalid value: " + P);
        return new Uint8Array(P);
      }
      if (n(P.length) && i(P)) return new Uint8Array(P);
      throw new Error("unsupported array-like object");
    }
    function s(P) {
      return new Uint8Array(P);
    }
    function o(P, M, D, q, B) {
      (q != null || B != null) &&
        (P.slice
          ? (P = P.slice(q, B))
          : (P = Array.prototype.slice.call(P, q, B))),
        M.set(P, D);
    }
    var c = (function () {
        function P(D) {
          var q = [],
            B = 0;
          for (D = encodeURI(D); B < D.length; ) {
            var H = D.charCodeAt(B++);
            H === 37
              ? (q.push(parseInt(D.substr(B, 2), 16)), (B += 2))
              : q.push(H);
          }
          return a(q);
        }
        function M(D) {
          for (var q = [], B = 0; B < D.length; ) {
            var H = D[B];
            H < 128
              ? (q.push(String.fromCharCode(H)), B++)
              : H > 191 && H < 224
              ? (q.push(String.fromCharCode(((H & 31) << 6) | (D[B + 1] & 63))),
                (B += 2))
              : (q.push(
                  String.fromCharCode(
                    ((H & 15) << 12) | ((D[B + 1] & 63) << 6) | (D[B + 2] & 63)
                  )
                ),
                (B += 3));
          }
          return q.join("");
        }
        return {
          toBytes: P,
          fromBytes: M,
        };
      })(),
      u = (function () {
        function P(q) {
          for (var B = [], H = 0; H < q.length; H += 2)
            B.push(parseInt(q.substr(H, 2), 16));
          return B;
        }
        var M = "0123456789abcdef";
        function D(q) {
          for (var B = [], H = 0; H < q.length; H++) {
            var Q = q[H];
            B.push(M[(Q & 240) >> 4] + M[Q & 15]);
          }
          return B.join("");
        }
        return {
          toBytes: P,
          fromBytes: D,
        };
      })(),
      d = {
        16: 10,
        24: 12,
        32: 14,
      },
      m = [
        1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94,
        188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145,
      ],
      v = [
        99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171,
        118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164,
        114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113,
        216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39,
        178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227,
        47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76,
        88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60,
        159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16,
        255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61,
        100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20,
        222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98,
        145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244,
        234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221,
        116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53,
        87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155,
        30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104,
        65, 153, 45, 15, 176, 84, 187, 22,
      ],
      E = [
        82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251,
        124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233,
        203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195,
        78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209,
        37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101,
        182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167,
        141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5,
        184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1,
        19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206,
        240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55,
        232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183,
        98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219,
        192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18,
        16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229,
        122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200,
        235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225,
        105, 20, 99, 85, 33, 12, 125,
      ],
      A = [
        3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157,
        3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757,
        3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813,
        2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307,
        1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063,
        3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618,
        1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420,
        3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767,
        134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841,
        168101135, 798661301, 235341577, 605164086, 461406363, 3756188221,
        3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174,
        1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627,
        2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582,
        1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436,
        1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302,
        1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746,
        3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463,
        1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577,
        2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438,
        2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100,
        1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450,
        4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079,
        3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866,
        4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909,
        3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534,
        999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540,
        2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286,
        1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836,
        2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756,
        3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599,
        26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514,
        4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816,
        1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505,
        1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977,
        2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954,
        1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154,
        3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992,
        974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859,
        3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754,
        361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378,
        59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649,
        2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377,
        2075177163, 2824099068, 1841019862, 739644986,
      ],
      I = [
        2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027,
        2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147,
        434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938,
        1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592,
        3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988,
        2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398,
        1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525,
        886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517,
        201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806,
        252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786,
        651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339,
        1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112,
        4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187,
        1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861,
        1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867,
        3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471,
        1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773,
        1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647,
        4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603,
        3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005,
        3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895,
        251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324,
        3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751,
        2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019,
        2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034,
        2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540,
        2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026,
        1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516,
        1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981,
        936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389,
        2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294,
        133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816,
        3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350,
        3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327,
        3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654,
        3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494,
        2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617,
        658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609,
        3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214,
        2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103,
        2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934,
        3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607,
        3413881008, 4238890068, 3597515707, 975967766,
      ],
      b = [
        1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307,
        1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347,
        4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298,
        3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232,
        2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228,
        1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518,
        911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325,
        3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077,
        67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926,
        84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826,
        3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539,
        745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552,
        1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067,
        795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784,
        4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910,
        961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360,
        4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739,
        2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960,
        1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568,
        2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668,
        3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003,
        3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855,
        2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534,
        1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744,
        2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008,
        2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782,
        1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090,
        169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650,
        3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972,
        2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893,
        3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908,
        3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946,
        2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164,
        3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131,
        3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261,
        1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081,
        895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045,
        2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777,
        3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927,
        3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796,
        2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242,
        1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488,
        1425844308, 3151392187, 372911126,
      ],
      w = [
        1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062,
        1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422,
        4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983,
        3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547,
        2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643,
        1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788,
        909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625,
        3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962,
        67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071,
        84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791,
        3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989,
        741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667,
        1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797,
        791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704,
        4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535,
        960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995,
        4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214,
        2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760,
        1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408,
        2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563,
        3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573,
        3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230,
        2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284,
        1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344,
        2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123,
        2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087,
        1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700,
        168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855,
        3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747,
        2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873,
        3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523,
        3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511,
        2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419,
        3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126,
        3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401,
        1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866,
        892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850,
        2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042,
        3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917,
        3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891,
        2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452,
        1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443,
        1414855848, 3149649517, 370555436,
      ],
      S = [
        1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753,
        2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485,
        1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703,
        1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150,
        59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843,
        1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733,
        3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074,
        2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228,
        1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562,
        3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269,
        807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154,
        4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474,
        875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634,
        1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366,
        2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327,
        2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483,
        2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436,
        1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852,
        1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058,
        463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234,
        3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465,
        337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775,
        1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960,
        3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733,
        3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860,
        2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396,
        2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238,
        2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012,
        1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814,
        2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619,
        270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369,
        2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889,
        1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144,
        899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186,
        1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980,
        3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204,
        25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971,
        1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302,
        3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761,
        1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769,
        3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627,
        4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265,
        3576870512, 1215061108, 3501741890,
      ],
      k = [
        1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933,
        2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900,
        4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723,
        2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385,
        3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473,
        692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113,
        3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529,
        1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523,
        1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122,
        1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824,
        4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204,
        4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614,
        2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839,
        106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461,
        3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937,
        3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598,
        1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597,
        2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945,
        1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535,
        3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394,
        182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863,
        3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624,
        2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486,
        1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369,
        2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024,
        3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148,
        3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545,
        4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671,
        3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776,
        1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106,
        1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472,
        32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392,
        3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259,
        818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840,
        1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904,
        1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889,
        77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242,
        870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476,
        4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235,
        2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891,
        2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253,
        2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913,
        1635502980, 1893020342, 1950903388, 1120974935,
      ],
      N = [
        2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173,
        1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970,
        3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698,
        244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515,
        1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868,
        1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033,
        1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914,
        861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368,
        1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827,
        2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239,
        2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009,
        4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174,
        1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224,
        2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286,
        2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237,
        1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968,
        172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081,
        1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047,
        2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278,
        2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539,
        719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150,
        2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665,
        4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005,
        4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898,
        1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670,
        3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556,
        1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178,
        188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442,
        2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569,
        2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044,
        2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634,
        2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639,
        919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549,
        1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196,
        3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050,
        81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974,
        895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576,
        1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897,
        3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516,
        935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519,
        3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572,
        2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195,
        3060847922, 1551124588, 1463996600,
      ],
      O = [
        4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623,
        4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885,
        3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053,
        3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835,
        2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848,
        3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143,
        3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389,
        1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913,
        1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242,
        529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619,
        679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159,
        133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524,
        777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424,
        1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981,
        1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582,
        1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953,
        2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766,
        1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162,
        1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748,
        2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234,
        2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765,
        514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535,
        1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070,
        3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413,
        3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325,
        3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816,
        4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628,
        3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092,
        2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814,
        3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464,
        410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844,
        1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714,
        1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454,
        2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521,
        3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700,
        2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909,
        2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841,
        3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542,
        1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736,
        3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274,
        1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712,
        227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555,
        850817237, 1817998408, 3092726480,
      ],
      F = [
        0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554,
        708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108,
        1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990,
        4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216,
        2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058,
        3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343,
        3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029,
        3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995,
        899835584, 666464733, 699432150, 59727847, 226906860, 530400753,
        294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775,
        2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520,
        3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422,
        3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228,
        4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434,
        2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896,
        800440835, 92987698, 193195065, 429456164, 395441711, 1984812685,
        2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311,
        1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657,
        807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971,
        2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805,
        3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751,
        3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483,
        2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465,
        599762354, 159417987, 126454664, 361929877, 463180190, 2709260871,
        2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733,
        2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971,
        3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178,
        2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284,
        3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302,
        3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384,
        1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330,
        404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369,
        3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619,
        3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557,
        2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487,
        504459436, 875451293, 975658646, 675039627, 641025152, 2084704233,
        1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843,
        1451044056, 933301370, 967311729, 733156972, 632953703, 260388950,
        25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500,
        1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226,
        3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432,
        4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150,
        2438237621, 2203032232, 2370213795,
      ],
      V = [
        0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694,
        824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388,
        2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410,
        2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776,
        3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918,
        3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543,
        1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569,
        1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355,
        3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933,
        4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895,
        3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975,
        3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917,
        2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523,
        2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409,
        1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751,
        53458370, 839224033, 957055980, 605657339, 790073846, 2373340630,
        2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216,
        3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602,
        4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276,
        545572369, 296679730, 446754879, 129166120, 213705253, 1709610350,
        1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296,
        1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598,
        3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840,
        2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386,
        1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268,
        1988838185, 533804130, 350174575, 164439672, 46346101, 870912086,
        954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643,
        2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929,
        3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127,
        3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309,
        457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035,
        2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319,
        182621114, 401639597, 486441376, 768917123, 651868046, 1003007129,
        818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387,
        2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917,
        2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703,
        3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473,
        3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720,
        1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390,
        1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636,
        3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122,
        4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200,
        3046200461, 2827177882, 2743944855,
      ],
      j = [
        0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294,
        590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588,
        1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250,
        3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176,
        3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278,
        2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663,
        2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769,
        3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195,
        1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173,
        1224348052, 59984867, 244860394, 428169201, 344873464, 935293895,
        984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180,
        2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982,
        145085239, 532201772, 313773861, 830661914, 1015671571, 731183368,
        648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554,
        2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636,
        3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085,
        3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771,
        4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177,
        2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631,
        287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925,
        1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571,
        1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968,
        3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150,
        2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556,
        122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898,
        695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576,
        1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613,
        1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639,
        81781910, 331544205, 516552836, 1039717051, 821288114, 669961897,
        719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299,
        2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885,
        3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634,
        3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044,
        2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702,
        3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632,
        1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938,
        48394827, 369057872, 418672217, 1002783846, 919489135, 567498868,
        752375421, 209336225, 24197544, 376187827, 459744698, 945164165,
        895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635,
        1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881,
        3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127,
        4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285,
        2377486676, 2594734927, 2544078150,
      ],
      X = [
        0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204,
        1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408,
        1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100,
        2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816,
        3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748,
        3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843,
        377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439,
        1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315,
        2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623,
        2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475,
        3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905,
        1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837,
        923313619, 740276417, 621982671, 439452389, 322734571, 137073913,
        19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589,
        3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641,
        3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550,
        1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426,
        1928707164, 96392454, 213114376, 396673818, 514443284, 562755902,
        679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866,
        3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230,
        2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026,
        2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953,
        3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765,
        3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481,
        1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413,
        1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841,
        425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038,
        3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674,
        2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542,
        2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834,
        1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990,
        349075736, 736970802, 585122620, 972512814, 821712160, 2595684844,
        2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464,
        2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212,
        4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952,
        292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068,
        1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848,
        2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775,
        2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155,
        4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431,
        953270745, 600235211, 718002117, 367585007, 484830689, 133361907,
        251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495,
        1418573201, 1335535747, 1184342925,
      ];
    function C(P) {
      for (var M = [], D = 0; D < P.length; D += 4)
        M.push((P[D] << 24) | (P[D + 1] << 16) | (P[D + 2] << 8) | P[D + 3]);
      return M;
    }
    var l = function (P) {
      if (!(this instanceof l))
        throw Error("AES must be instanitated with `new`");
      Object.defineProperty(this, "key", {
        value: a(P, !0),
      }),
        this._prepare();
    };
    (l.prototype._prepare = function () {
      var P = d[this.key.length];
      if (P == null)
        throw new Error("invalid key size (must be 16, 24 or 32 bytes)");
      (this._Ke = []), (this._Kd = []);
      for (var M = 0; M <= P; M++)
        this._Ke.push([0, 0, 0, 0]), this._Kd.push([0, 0, 0, 0]);
      for (
        var D = (P + 1) * 4, q = this.key.length / 4, B = C(this.key), H, M = 0;
        M < q;
        M++
      )
        (H = M >> 2),
          (this._Ke[H][M % 4] = B[M]),
          (this._Kd[P - H][M % 4] = B[M]);
      for (var Q = 0, Z = q, te; Z < D; ) {
        if (
          ((te = B[q - 1]),
          (B[0] ^=
            (v[(te >> 16) & 255] << 24) ^
            (v[(te >> 8) & 255] << 16) ^
            (v[te & 255] << 8) ^
            v[(te >> 24) & 255] ^
            (m[Q] << 24)),
          (Q += 1),
          q != 8)
        )
          for (var M = 1; M < q; M++) B[M] ^= B[M - 1];
        else {
          for (var M = 1; M < q / 2; M++) B[M] ^= B[M - 1];
          (te = B[q / 2 - 1]),
            (B[q / 2] ^=
              v[te & 255] ^
              (v[(te >> 8) & 255] << 8) ^
              (v[(te >> 16) & 255] << 16) ^
              (v[(te >> 24) & 255] << 24));
          for (var M = q / 2 + 1; M < q; M++) B[M] ^= B[M - 1];
        }
        for (var M = 0, Te, K; M < q && Z < D; )
          (Te = Z >> 2),
            (K = Z % 4),
            (this._Ke[Te][K] = B[M]),
            (this._Kd[P - Te][K] = B[M++]),
            Z++;
      }
      for (var Te = 1; Te < P; Te++)
        for (var K = 0; K < 4; K++)
          (te = this._Kd[Te][K]),
            (this._Kd[Te][K] =
              F[(te >> 24) & 255] ^
              V[(te >> 16) & 255] ^
              j[(te >> 8) & 255] ^
              X[te & 255]);
    }),
      (l.prototype.encrypt = function (P) {
        if (P.length != 16)
          throw new Error("invalid plaintext size (must be 16 bytes)");
        for (
          var M = this._Ke.length - 1, D = [0, 0, 0, 0], q = C(P), B = 0;
          B < 4;
          B++
        )
          q[B] ^= this._Ke[0][B];
        for (var H = 1; H < M; H++) {
          for (var B = 0; B < 4; B++)
            D[B] =
              A[(q[B] >> 24) & 255] ^
              I[(q[(B + 1) % 4] >> 16) & 255] ^
              b[(q[(B + 2) % 4] >> 8) & 255] ^
              w[q[(B + 3) % 4] & 255] ^
              this._Ke[H][B];
          q = D.slice();
        }
        for (var Q = s(16), Z, B = 0; B < 4; B++)
          (Z = this._Ke[M][B]),
            (Q[4 * B] = (v[(q[B] >> 24) & 255] ^ (Z >> 24)) & 255),
            (Q[4 * B + 1] =
              (v[(q[(B + 1) % 4] >> 16) & 255] ^ (Z >> 16)) & 255),
            (Q[4 * B + 2] = (v[(q[(B + 2) % 4] >> 8) & 255] ^ (Z >> 8)) & 255),
            (Q[4 * B + 3] = (v[q[(B + 3) % 4] & 255] ^ Z) & 255);
        return Q;
      }),
      (l.prototype.decrypt = function (P) {
        if (P.length != 16)
          throw new Error("invalid ciphertext size (must be 16 bytes)");
        for (
          var M = this._Kd.length - 1, D = [0, 0, 0, 0], q = C(P), B = 0;
          B < 4;
          B++
        )
          q[B] ^= this._Kd[0][B];
        for (var H = 1; H < M; H++) {
          for (var B = 0; B < 4; B++)
            D[B] =
              S[(q[B] >> 24) & 255] ^
              k[(q[(B + 3) % 4] >> 16) & 255] ^
              N[(q[(B + 2) % 4] >> 8) & 255] ^
              O[q[(B + 1) % 4] & 255] ^
              this._Kd[H][B];
          q = D.slice();
        }
        for (var Q = s(16), Z, B = 0; B < 4; B++)
          (Z = this._Kd[M][B]),
            (Q[4 * B] = (E[(q[B] >> 24) & 255] ^ (Z >> 24)) & 255),
            (Q[4 * B + 1] =
              (E[(q[(B + 3) % 4] >> 16) & 255] ^ (Z >> 16)) & 255),
            (Q[4 * B + 2] = (E[(q[(B + 2) % 4] >> 8) & 255] ^ (Z >> 8)) & 255),
            (Q[4 * B + 3] = (E[q[(B + 1) % 4] & 255] ^ Z) & 255);
        return Q;
      });
    var p = function (P) {
      if (!(this instanceof p))
        throw Error("AES must be instanitated with `new`");
      (this.description = "Electronic Code Block"),
        (this.name = "ecb"),
        (this._aes = new l(P));
    };
    (p.prototype.encrypt = function (P) {
      if (((P = a(P)), P.length % 16 !== 0))
        throw new Error(
          "invalid plaintext size (must be multiple of 16 bytes)"
        );
      for (var M = s(P.length), D = s(16), q = 0; q < P.length; q += 16)
        o(P, D, 0, q, q + 16), (D = this._aes.encrypt(D)), o(D, M, q);
      return M;
    }),
      (p.prototype.decrypt = function (P) {
        if (((P = a(P)), P.length % 16 !== 0))
          throw new Error(
            "invalid ciphertext size (must be multiple of 16 bytes)"
          );
        for (var M = s(P.length), D = s(16), q = 0; q < P.length; q += 16)
          o(P, D, 0, q, q + 16), (D = this._aes.decrypt(D)), o(D, M, q);
        return M;
      });
    var y = function (P, M) {
      if (!(this instanceof y))
        throw Error("AES must be instanitated with `new`");
      if (
        ((this.description = "Cipher Block Chaining"), (this.name = "cbc"), !M)
      )
        M = s(16);
      else if (M.length != 16)
        throw new Error("invalid initialation vector size (must be 16 bytes)");
      (this._lastCipherblock = a(M, !0)), (this._aes = new l(P));
    };
    (y.prototype.encrypt = function (P) {
      if (((P = a(P)), P.length % 16 !== 0))
        throw new Error(
          "invalid plaintext size (must be multiple of 16 bytes)"
        );
      for (var M = s(P.length), D = s(16), q = 0; q < P.length; q += 16) {
        o(P, D, 0, q, q + 16);
        for (var B = 0; B < 16; B++) D[B] ^= this._lastCipherblock[B];
        (this._lastCipherblock = this._aes.encrypt(D)),
          o(this._lastCipherblock, M, q);
      }
      return M;
    }),
      (y.prototype.decrypt = function (P) {
        if (((P = a(P)), P.length % 16 !== 0))
          throw new Error(
            "invalid ciphertext size (must be multiple of 16 bytes)"
          );
        for (var M = s(P.length), D = s(16), q = 0; q < P.length; q += 16) {
          o(P, D, 0, q, q + 16), (D = this._aes.decrypt(D));
          for (var B = 0; B < 16; B++)
            M[q + B] = D[B] ^ this._lastCipherblock[B];
          o(P, this._lastCipherblock, 0, q, q + 16);
        }
        return M;
      });
    var h = function (P, M, D) {
      if (!(this instanceof h))
        throw Error("AES must be instanitated with `new`");
      if (((this.description = "Cipher Feedback"), (this.name = "cfb"), !M))
        M = s(16);
      else if (M.length != 16)
        throw new Error("invalid initialation vector size (must be 16 size)");
      D || (D = 1),
        (this.segmentSize = D),
        (this._shiftRegister = a(M, !0)),
        (this._aes = new l(P));
    };
    (h.prototype.encrypt = function (P) {
      if (P.length % this.segmentSize != 0)
        throw new Error("invalid plaintext size (must be segmentSize bytes)");
      for (var M = a(P, !0), D, q = 0; q < M.length; q += this.segmentSize) {
        D = this._aes.encrypt(this._shiftRegister);
        for (var B = 0; B < this.segmentSize; B++) M[q + B] ^= D[B];
        o(this._shiftRegister, this._shiftRegister, 0, this.segmentSize),
          o(
            M,
            this._shiftRegister,
            16 - this.segmentSize,
            q,
            q + this.segmentSize
          );
      }
      return M;
    }),
      (h.prototype.decrypt = function (P) {
        if (P.length % this.segmentSize != 0)
          throw new Error(
            "invalid ciphertext size (must be segmentSize bytes)"
          );
        for (var M = a(P, !0), D, q = 0; q < M.length; q += this.segmentSize) {
          D = this._aes.encrypt(this._shiftRegister);
          for (var B = 0; B < this.segmentSize; B++) M[q + B] ^= D[B];
          o(this._shiftRegister, this._shiftRegister, 0, this.segmentSize),
            o(
              P,
              this._shiftRegister,
              16 - this.segmentSize,
              q,
              q + this.segmentSize
            );
        }
        return M;
      });
    var g = function (P, M) {
      if (!(this instanceof g))
        throw Error("AES must be instanitated with `new`");
      if (((this.description = "Output Feedback"), (this.name = "ofb"), !M))
        M = s(16);
      else if (M.length != 16)
        throw new Error("invalid initialation vector size (must be 16 bytes)");
      (this._lastPrecipher = a(M, !0)),
        (this._lastPrecipherIndex = 16),
        (this._aes = new l(P));
    };
    (g.prototype.encrypt = function (P) {
      for (var M = a(P, !0), D = 0; D < M.length; D++)
        this._lastPrecipherIndex === 16 &&
          ((this._lastPrecipher = this._aes.encrypt(this._lastPrecipher)),
          (this._lastPrecipherIndex = 0)),
          (M[D] ^= this._lastPrecipher[this._lastPrecipherIndex++]);
      return M;
    }),
      (g.prototype.decrypt = g.prototype.encrypt);
    var T = function (P) {
      if (!(this instanceof T))
        throw Error("Counter must be instanitated with `new`");
      P !== 0 && !P && (P = 1),
        typeof P == "number"
          ? ((this._counter = s(16)), this.setValue(P))
          : this.setBytes(P);
    };
    (T.prototype.setValue = function (P) {
      if (typeof P != "number" || parseInt(P) != P)
        throw new Error("invalid counter value (must be an integer)");
      for (var M = 15; M >= 0; --M) (this._counter[M] = P % 256), (P = P >> 8);
    }),
      (T.prototype.setBytes = function (P) {
        if (((P = a(P, !0)), P.length != 16))
          throw new Error("invalid counter bytes size (must be 16 bytes)");
        this._counter = P;
      }),
      (T.prototype.increment = function () {
        for (var P = 15; P >= 0; P--)
          if (this._counter[P] === 255) this._counter[P] = 0;
          else {
            this._counter[P]++;
            break;
          }
      });
    var R = function (P, M) {
      if (!(this instanceof R))
        throw Error("AES must be instanitated with `new`");
      (this.description = "Counter"),
        (this.name = "ctr"),
        M instanceof T || (M = new T(M)),
        (this._counter = M),
        (this._remainingCounter = null),
        (this._remainingCounterIndex = 16),
        (this._aes = new l(P));
    };
    (R.prototype.encrypt = function (P) {
      for (var M = a(P, !0), D = 0; D < M.length; D++)
        this._remainingCounterIndex === 16 &&
          ((this._remainingCounter = this._aes.encrypt(this._counter._counter)),
          (this._remainingCounterIndex = 0),
          this._counter.increment()),
          (M[D] ^= this._remainingCounter[this._remainingCounterIndex++]);
      return M;
    }),
      (R.prototype.decrypt = R.prototype.encrypt);
    function x(P) {
      P = a(P, !0);
      var M = 16 - (P.length % 16),
        D = s(P.length + M);
      o(P, D);
      for (var q = P.length; q < D.length; q++) D[q] = M;
      return D;
    }
    function f(P) {
      if (((P = a(P, !0)), P.length < 16))
        throw new Error("PKCS#7 invalid length");
      var M = P[P.length - 1];
      if (M > 16) throw new Error("PKCS#7 padding byte out of range");
      for (var D = P.length - M, q = 0; q < M; q++)
        if (P[D + q] !== M) throw new Error("PKCS#7 invalid padding byte");
      var B = s(D);
      return o(P, B, 0, 0, D), B;
    }
    var _ = {
      AES: l,
      Counter: T,
      ModeOfOperation: {
        ecb: p,
        cbc: y,
        cfb: h,
        ofb: g,
        ctr: R,
      },
      utils: {
        hex: u,
        utf8: c,
      },
      padding: {
        pkcs7: {
          pad: x,
          strip: f,
        },
      },
      _arrayTest: {
        coerceArray: a,
        createArray: s,
        copyArray: o,
      },
    };
    t.exports = _;
  })();
})(RD);
var ute = RD.exports;
const Vs = mn(ute),
  PD = "json-wallets/5.7.0";
function ru(t) {
  return (
    typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), qe(t)
  );
}
function Jd(t, e) {
  for (t = String(t); t.length < e; ) t = "0" + t;
  return t;
}
function sE(t) {
  return typeof t == "string" ? Lt(t, co.NFKC) : qe(t);
}
function an(t, e) {
  let r = t;
  const n = e.toLowerCase().split("/");
  for (let i = 0; i < n.length; i++) {
    let a = null;
    for (const s in r)
      if (s.toLowerCase() === n[i]) {
        a = r[s];
        break;
      }
    if (a === null) return null;
    r = a;
  }
  return r;
}
function fte(t) {
  const e = qe(t);
  (e[6] = (e[6] & 15) | 64), (e[8] = (e[8] & 63) | 128);
  const r = Ke(e);
  return [
    r.substring(2, 10),
    r.substring(10, 14),
    r.substring(14, 18),
    r.substring(18, 22),
    r.substring(22, 34),
  ].join("-");
}
const dte = new ue(PD);
class hte extends pl {
  isCrowdsaleAccount(e) {
    return !!(e && e._isCrowdsaleAccount);
  }
}
function oE(t, e) {
  const r = JSON.parse(t);
  e = sE(e);
  const n = Xt(an(r, "ethaddr")),
    i = ru(an(r, "encseed"));
  (!i || i.length % 16 !== 0) &&
    dte.throwArgumentError("invalid encseed", "json", t);
  const a = qe(iE(e, e, 2e3, 32, "sha256")).slice(0, 16),
    s = i.slice(0, 16),
    o = i.slice(16),
    c = new Vs.ModeOfOperation.cbc(a, s),
    u = Vs.padding.pkcs7.strip(qe(c.decrypt(o)));
  let d = "";
  for (let E = 0; E < u.length; E++) d += String.fromCharCode(u[E]);
  const m = Lt(d),
    v = Ut(m);
  return new hte({
    _isCrowdsaleAccount: !0,
    address: n,
    privateKey: v,
  });
}
function iv(t) {
  let e = null;
  try {
    e = JSON.parse(t);
  } catch {
    return !1;
  }
  return e.encseed && e.ethaddr;
}
function av(t) {
  let e = null;
  try {
    e = JSON.parse(t);
  } catch {
    return !1;
  }
  return !(
    !e.version ||
    parseInt(e.version) !== e.version ||
    parseInt(e.version) !== 3
  );
}
function pte(t) {
  if (iv(t))
    try {
      return Xt(JSON.parse(t).ethaddr);
    } catch {
      return null;
    }
  if (av(t))
    try {
      return Xt(JSON.parse(t).address);
    } catch {
      return null;
    }
  return null;
}
var ND = {
  exports: {},
};
(function (t, e) {
  (function (r) {
    function i(I) {
      const b = new Uint32Array([
        1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
        2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
        1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
        264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
        2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711,
        113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
        1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
        3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
        430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
        1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424,
        2428436474, 2756734187, 3204031479, 3329325298,
      ]);
      let w = 1779033703,
        S = 3144134277,
        k = 1013904242,
        N = 2773480762,
        O = 1359893119,
        F = 2600822924,
        V = 528734635,
        j = 1541459225;
      const X = new Uint32Array(64);
      function C(R) {
        let x = 0,
          f = R.length;
        for (; f >= 64; ) {
          let _ = w,
            P = S,
            M = k,
            D = N,
            q = O,
            B = F,
            H = V,
            Q = j,
            Z,
            te,
            Te,
            K,
            G;
          for (te = 0; te < 16; te++)
            (Te = x + te * 4),
              (X[te] =
                ((R[Te] & 255) << 24) |
                ((R[Te + 1] & 255) << 16) |
                ((R[Te + 2] & 255) << 8) |
                (R[Te + 3] & 255));
          for (te = 16; te < 64; te++)
            (Z = X[te - 2]),
              (K =
                ((Z >>> 17) | (Z << 15)) ^
                ((Z >>> 19) | (Z << 13)) ^
                (Z >>> 10)),
              (Z = X[te - 15]),
              (G =
                ((Z >>> 7) | (Z << 25)) ^ ((Z >>> 18) | (Z << 14)) ^ (Z >>> 3)),
              (X[te] = (((K + X[te - 7]) | 0) + ((G + X[te - 16]) | 0)) | 0);
          for (te = 0; te < 64; te++)
            (K =
              ((((((q >>> 6) | (q << 26)) ^
                ((q >>> 11) | (q << 21)) ^
                ((q >>> 25) | (q << 7))) +
                ((q & B) ^ (~q & H))) |
                0) +
                ((Q + ((b[te] + X[te]) | 0)) | 0)) |
              0),
              (G =
                ((((_ >>> 2) | (_ << 30)) ^
                  ((_ >>> 13) | (_ << 19)) ^
                  ((_ >>> 22) | (_ << 10))) +
                  ((_ & P) ^ (_ & M) ^ (P & M))) |
                0),
              (Q = H),
              (H = B),
              (B = q),
              (q = (D + K) | 0),
              (D = M),
              (M = P),
              (P = _),
              (_ = (K + G) | 0);
          (w = (w + _) | 0),
            (S = (S + P) | 0),
            (k = (k + M) | 0),
            (N = (N + D) | 0),
            (O = (O + q) | 0),
            (F = (F + B) | 0),
            (V = (V + H) | 0),
            (j = (j + Q) | 0),
            (x += 64),
            (f -= 64);
        }
      }
      C(I);
      let l,
        p = I.length % 64,
        y = (I.length / 536870912) | 0,
        h = I.length << 3,
        g = p < 56 ? 56 : 120,
        T = I.slice(I.length - p, I.length);
      for (T.push(128), l = p + 1; l < g; l++) T.push(0);
      return (
        T.push((y >>> 24) & 255),
        T.push((y >>> 16) & 255),
        T.push((y >>> 8) & 255),
        T.push((y >>> 0) & 255),
        T.push((h >>> 24) & 255),
        T.push((h >>> 16) & 255),
        T.push((h >>> 8) & 255),
        T.push((h >>> 0) & 255),
        C(T),
        [
          (w >>> 24) & 255,
          (w >>> 16) & 255,
          (w >>> 8) & 255,
          (w >>> 0) & 255,
          (S >>> 24) & 255,
          (S >>> 16) & 255,
          (S >>> 8) & 255,
          (S >>> 0) & 255,
          (k >>> 24) & 255,
          (k >>> 16) & 255,
          (k >>> 8) & 255,
          (k >>> 0) & 255,
          (N >>> 24) & 255,
          (N >>> 16) & 255,
          (N >>> 8) & 255,
          (N >>> 0) & 255,
          (O >>> 24) & 255,
          (O >>> 16) & 255,
          (O >>> 8) & 255,
          (O >>> 0) & 255,
          (F >>> 24) & 255,
          (F >>> 16) & 255,
          (F >>> 8) & 255,
          (F >>> 0) & 255,
          (V >>> 24) & 255,
          (V >>> 16) & 255,
          (V >>> 8) & 255,
          (V >>> 0) & 255,
          (j >>> 24) & 255,
          (j >>> 16) & 255,
          (j >>> 8) & 255,
          (j >>> 0) & 255,
        ]
      );
    }
    function a(I, b, w) {
      I = I.length <= 64 ? I : i(I);
      const S = 64 + b.length + 4,
        k = new Array(S),
        N = new Array(64);
      let O,
        F = [];
      for (O = 0; O < 64; O++) k[O] = 54;
      for (O = 0; O < I.length; O++) k[O] ^= I[O];
      for (O = 0; O < b.length; O++) k[64 + O] = b[O];
      for (O = S - 4; O < S; O++) k[O] = 0;
      for (O = 0; O < 64; O++) N[O] = 92;
      for (O = 0; O < I.length; O++) N[O] ^= I[O];
      function V() {
        for (let j = S - 1; j >= S - 4; j--) {
          if ((k[j]++, k[j] <= 255)) return;
          k[j] = 0;
        }
      }
      for (; w >= 32; ) V(), (F = F.concat(i(N.concat(i(k))))), (w -= 32);
      return w > 0 && (V(), (F = F.concat(i(N.concat(i(k))).slice(0, w)))), F;
    }
    function s(I, b, w, S, k) {
      let N;
      for (d(I, (2 * w - 1) * 16, k, 0, 16), N = 0; N < 2 * w; N++)
        u(I, N * 16, k, 16), c(k, S), d(k, 0, I, b + N * 16, 16);
      for (N = 0; N < w; N++) d(I, b + N * 2 * 16, I, N * 16, 16);
      for (N = 0; N < w; N++) d(I, b + (N * 2 + 1) * 16, I, (N + w) * 16, 16);
    }
    function o(I, b) {
      return (I << b) | (I >>> (32 - b));
    }
    function c(I, b) {
      d(I, 0, b, 0, 16);
      for (let w = 8; w > 0; w -= 2)
        (b[4] ^= o(b[0] + b[12], 7)),
          (b[8] ^= o(b[4] + b[0], 9)),
          (b[12] ^= o(b[8] + b[4], 13)),
          (b[0] ^= o(b[12] + b[8], 18)),
          (b[9] ^= o(b[5] + b[1], 7)),
          (b[13] ^= o(b[9] + b[5], 9)),
          (b[1] ^= o(b[13] + b[9], 13)),
          (b[5] ^= o(b[1] + b[13], 18)),
          (b[14] ^= o(b[10] + b[6], 7)),
          (b[2] ^= o(b[14] + b[10], 9)),
          (b[6] ^= o(b[2] + b[14], 13)),
          (b[10] ^= o(b[6] + b[2], 18)),
          (b[3] ^= o(b[15] + b[11], 7)),
          (b[7] ^= o(b[3] + b[15], 9)),
          (b[11] ^= o(b[7] + b[3], 13)),
          (b[15] ^= o(b[11] + b[7], 18)),
          (b[1] ^= o(b[0] + b[3], 7)),
          (b[2] ^= o(b[1] + b[0], 9)),
          (b[3] ^= o(b[2] + b[1], 13)),
          (b[0] ^= o(b[3] + b[2], 18)),
          (b[6] ^= o(b[5] + b[4], 7)),
          (b[7] ^= o(b[6] + b[5], 9)),
          (b[4] ^= o(b[7] + b[6], 13)),
          (b[5] ^= o(b[4] + b[7], 18)),
          (b[11] ^= o(b[10] + b[9], 7)),
          (b[8] ^= o(b[11] + b[10], 9)),
          (b[9] ^= o(b[8] + b[11], 13)),
          (b[10] ^= o(b[9] + b[8], 18)),
          (b[12] ^= o(b[15] + b[14], 7)),
          (b[13] ^= o(b[12] + b[15], 9)),
          (b[14] ^= o(b[13] + b[12], 13)),
          (b[15] ^= o(b[14] + b[13], 18));
      for (let w = 0; w < 16; ++w) I[w] += b[w];
    }
    function u(I, b, w, S) {
      for (let k = 0; k < S; k++) w[k] ^= I[b + k];
    }
    function d(I, b, w, S, k) {
      for (; k--; ) w[S++] = I[b++];
    }
    function m(I) {
      if (!I || typeof I.length != "number") return !1;
      for (let b = 0; b < I.length; b++) {
        const w = I[b];
        if (typeof w != "number" || w % 1 || w < 0 || w >= 256) return !1;
      }
      return !0;
    }
    function v(I, b) {
      if (typeof I != "number" || I % 1) throw new Error("invalid " + b);
      return I;
    }
    function E(I, b, w, S, k, N, O) {
      if (
        ((w = v(w, "N")),
        (S = v(S, "r")),
        (k = v(k, "p")),
        (N = v(N, "dkLen")),
        w === 0 || w & (w - 1))
      )
        throw new Error("N must be power of 2");
      if (w > 2147483647 / 128 / S) throw new Error("N too large");
      if (S > 2147483647 / 128 / k) throw new Error("r too large");
      if (!m(I)) throw new Error("password must be an array or buffer");
      if (((I = Array.prototype.slice.call(I)), !m(b)))
        throw new Error("salt must be an array or buffer");
      b = Array.prototype.slice.call(b);
      let F = a(I, b, k * 128 * S);
      const V = new Uint32Array(k * 32 * S);
      for (let q = 0; q < V.length; q++) {
        const B = q * 4;
        V[q] =
          ((F[B + 3] & 255) << 24) |
          ((F[B + 2] & 255) << 16) |
          ((F[B + 1] & 255) << 8) |
          ((F[B + 0] & 255) << 0);
      }
      const j = new Uint32Array(64 * S),
        X = new Uint32Array(32 * S * w),
        C = 32 * S,
        l = new Uint32Array(16),
        p = new Uint32Array(16),
        y = k * w * 2;
      let h = 0,
        g = null,
        T = !1,
        R = 0,
        x = 0,
        f,
        _;
      const P = O ? parseInt(1e3 / S) : 4294967295,
        M = typeof setImmediate < "u" ? setImmediate : setTimeout,
        D = function () {
          if (T) return O(new Error("cancelled"), h / y);
          let q;
          switch (R) {
            case 0:
              (_ = x * 32 * S), d(V, _, j, 0, C), (R = 1), (f = 0);
            case 1:
              (q = w - f), q > P && (q = P);
              for (let H = 0; H < q; H++)
                d(j, 0, X, (f + H) * C, C), s(j, C, S, l, p);
              if (((f += q), (h += q), O)) {
                const H = parseInt((1e3 * h) / y);
                if (H !== g) {
                  if (((T = O(null, h / y)), T)) break;
                  g = H;
                }
              }
              if (f < w) break;
              (f = 0), (R = 2);
            case 2:
              (q = w - f), q > P && (q = P);
              for (let H = 0; H < q; H++) {
                const Q = (2 * S - 1) * 16,
                  Z = j[Q] & (w - 1);
                u(X, Z * C, j, C), s(j, C, S, l, p);
              }
              if (((f += q), (h += q), O)) {
                const H = parseInt((1e3 * h) / y);
                if (H !== g) {
                  if (((T = O(null, h / y)), T)) break;
                  g = H;
                }
              }
              if (f < w) break;
              if ((d(j, 0, V, _, C), x++, x < k)) {
                R = 0;
                break;
              }
              F = [];
              for (let H = 0; H < V.length; H++)
                F.push((V[H] >> 0) & 255),
                  F.push((V[H] >> 8) & 255),
                  F.push((V[H] >> 16) & 255),
                  F.push((V[H] >> 24) & 255);
              const B = a(I, F, N);
              return O && O(null, 1, B), B;
          }
          O && M(D);
        };
      if (!O)
        for (;;) {
          const q = D();
          if (q != null) return q;
        }
      D();
    }
    const A = {
      scrypt: function (I, b, w, S, k, N, O) {
        return new Promise(function (F, V) {
          let j = 0;
          O && O(0),
            E(I, b, w, S, k, N, function (X, C, l) {
              if (X) V(X);
              else if (l) O && j !== 1 && O(1), F(new Uint8Array(l));
              else if (O && C !== j) return (j = C), O(C);
            });
        });
      },
      syncScrypt: function (I, b, w, S, k, N) {
        return new Uint8Array(E(I, b, w, S, k, N));
      },
    };
    t.exports = A;
  })();
})(ND);
var mte = ND.exports;
const cE = mn(mte);
var yte = function (t, e, r, n) {
  function i(a) {
    return a instanceof r
      ? a
      : new r(function (s) {
          s(a);
        });
  }
  return new (r || (r = Promise))(function (a, s) {
    function o(d) {
      try {
        u(n.next(d));
      } catch (m) {
        s(m);
      }
    }
    function c(d) {
      try {
        u(n.throw(d));
      } catch (m) {
        s(m);
      }
    }
    function u(d) {
      d.done ? a(d.value) : i(d.value).then(o, c);
    }
    u((n = n.apply(t, e || [])).next());
  });
};
const u_ = new ue(PD);
function Wk(t) {
  return t != null && t.mnemonic && t.mnemonic.phrase;
}
class gte extends pl {
  isKeystoreAccount(e) {
    return !!(e && e._isKeystoreAccount);
  }
}
function bte(t, e, r) {
  if (an(t, "crypto/cipher") === "aes-128-ctr") {
    const i = ru(an(t, "crypto/cipherparams/iv")),
      a = new Vs.Counter(i),
      s = new Vs.ModeOfOperation.ctr(e, a);
    return qe(s.decrypt(r));
  }
  return null;
}
function BD(t, e) {
  const r = ru(an(t, "crypto/ciphertext"));
  if (
    Ke(Ut(cr([e.slice(16, 32), r]))).substring(2) !==
    an(t, "crypto/mac").toLowerCase()
  )
    throw new Error("invalid password");
  const i = bte(t, e.slice(0, 16), r);
  i ||
    u_.throwError("unsupported cipher", ue.errors.UNSUPPORTED_OPERATION, {
      operation: "decrypt",
    });
  const a = e.slice(32, 64),
    s = Fc(i);
  if (t.address) {
    let c = t.address.toLowerCase();
    if ((c.substring(0, 2) !== "0x" && (c = "0x" + c), Xt(c) !== s))
      throw new Error("address mismatch");
  }
  const o = {
    _isKeystoreAccount: !0,
    address: s,
    privateKey: Ke(i),
  };
  if (an(t, "x-ethers/version") === "0.1") {
    const c = ru(an(t, "x-ethers/mnemonicCiphertext")),
      u = ru(an(t, "x-ethers/mnemonicCounter")),
      d = new Vs.Counter(u),
      m = new Vs.ModeOfOperation.ctr(a, d),
      v = an(t, "x-ethers/path") || Cf,
      E = an(t, "x-ethers/locale") || "en",
      A = qe(m.decrypt(c));
    try {
      const I = nv(A, E),
        b = na.fromMnemonic(I, null, E).derivePath(v);
      if (b.privateKey != o.privateKey) throw new Error("mnemonic mismatch");
      o.mnemonic = b.mnemonic;
    } catch (I) {
      if (I.code !== ue.errors.INVALID_ARGUMENT || I.argument !== "wordlist")
        throw I;
    }
  }
  return new gte(o);
}
function DD(t, e, r, n, i) {
  return qe(iE(t, e, r, n, i));
}
function vte(t, e, r, n, i) {
  return Promise.resolve(DD(t, e, r, n, i));
}
function OD(t, e, r, n, i) {
  const a = sE(e),
    s = an(t, "crypto/kdf");
  if (s && typeof s == "string") {
    const o = function (c, u) {
      return u_.throwArgumentError(
        "invalid key-derivation function parameters",
        c,
        u
      );
    };
    if (s.toLowerCase() === "scrypt") {
      const c = ru(an(t, "crypto/kdfparams/salt")),
        u = parseInt(an(t, "crypto/kdfparams/n")),
        d = parseInt(an(t, "crypto/kdfparams/r")),
        m = parseInt(an(t, "crypto/kdfparams/p"));
      (!u || !d || !m) && o("kdf", s), u & (u - 1) && o("N", u);
      const v = parseInt(an(t, "crypto/kdfparams/dklen"));
      return v !== 32 && o("dklen", v), n(a, c, u, d, m, 64, i);
    } else if (s.toLowerCase() === "pbkdf2") {
      const c = ru(an(t, "crypto/kdfparams/salt"));
      let u = null;
      const d = an(t, "crypto/kdfparams/prf");
      d === "hmac-sha256"
        ? (u = "sha256")
        : d === "hmac-sha512"
        ? (u = "sha512")
        : o("prf", d);
      const m = parseInt(an(t, "crypto/kdfparams/c")),
        v = parseInt(an(t, "crypto/kdfparams/dklen"));
      return v !== 32 && o("dklen", v), r(a, c, m, v, u);
    }
  }
  return u_.throwArgumentError("unsupported key-derivation function", "kdf", s);
}
function FD(t, e) {
  const r = JSON.parse(t),
    n = OD(r, e, DD, cE.syncScrypt);
  return BD(r, n);
}
function LD(t, e, r) {
  return yte(this, void 0, void 0, function* () {
    const n = JSON.parse(t),
      i = yield OD(n, e, vte, cE.scrypt, r);
    return BD(n, i);
  });
}
function $D(t, e, r, n) {
  try {
    if (Xt(t.address) !== Fc(t.privateKey))
      throw new Error("address/privateKey mismatch");
    if (Wk(t)) {
      const b = t.mnemonic;
      if (
        na.fromMnemonic(b.phrase, null, b.locale).derivePath(b.path || Cf)
          .privateKey != t.privateKey
      )
        throw new Error("mnemonic mismatch");
    }
  } catch (b) {
    return Promise.reject(b);
  }
  typeof r == "function" && !n && ((n = r), (r = {})), r || (r = {});
  const i = qe(t.privateKey),
    a = sE(e);
  let s = null,
    o = null,
    c = null;
  if (Wk(t)) {
    const b = t.mnemonic;
    (s = qe(rv(b.phrase, b.locale || "en"))),
      (o = b.path || Cf),
      (c = b.locale || "en");
  }
  let u = r.client;
  u || (u = "ethers.js");
  let d = null;
  r.salt ? (d = qe(r.salt)) : (d = P0(32));
  let m = null;
  if (r.iv) {
    if (((m = qe(r.iv)), m.length !== 16)) throw new Error("invalid iv");
  } else m = P0(16);
  let v = null;
  if (r.uuid) {
    if (((v = qe(r.uuid)), v.length !== 16)) throw new Error("invalid uuid");
  } else v = P0(16);
  let E = 1 << 17,
    A = 8,
    I = 1;
  return (
    r.scrypt &&
      (r.scrypt.N && (E = r.scrypt.N),
      r.scrypt.r && (A = r.scrypt.r),
      r.scrypt.p && (I = r.scrypt.p)),
    cE.scrypt(a, d, E, A, I, 64, n).then((b) => {
      b = qe(b);
      const w = b.slice(0, 16),
        S = b.slice(16, 32),
        k = b.slice(32, 64),
        N = new Vs.Counter(m),
        O = new Vs.ModeOfOperation.ctr(w, N),
        F = qe(O.encrypt(i)),
        V = Ut(cr([S, F])),
        j = {
          address: t.address.substring(2).toLowerCase(),
          id: fte(v),
          version: 3,
          crypto: {
            cipher: "aes-128-ctr",
            cipherparams: {
              iv: Ke(m).substring(2),
            },
            ciphertext: Ke(F).substring(2),
            kdf: "scrypt",
            kdfparams: {
              salt: Ke(d).substring(2),
              n: E,
              dklen: 32,
              p: I,
              r: A,
            },
            mac: V.substring(2),
          },
        };
      if (s) {
        const X = P0(16),
          C = new Vs.Counter(X),
          l = new Vs.ModeOfOperation.ctr(k, C),
          p = qe(l.encrypt(s)),
          y = new Date(),
          h =
            y.getUTCFullYear() +
            "-" +
            Jd(y.getUTCMonth() + 1, 2) +
            "-" +
            Jd(y.getUTCDate(), 2) +
            "T" +
            Jd(y.getUTCHours(), 2) +
            "-" +
            Jd(y.getUTCMinutes(), 2) +
            "-" +
            Jd(y.getUTCSeconds(), 2) +
            ".0Z";
        j["x-ethers"] = {
          client: u,
          gethFilename: "UTC--" + h + "--" + j.address,
          mnemonicCounter: Ke(X).substring(2),
          mnemonicCiphertext: Ke(p).substring(2),
          path: o,
          locale: c,
          version: "0.1",
        };
      }
      return JSON.stringify(j);
    })
  );
}
function UD(t, e, r) {
  if (iv(t)) {
    r && r(0);
    const n = oE(t, e);
    return r && r(1), Promise.resolve(n);
  }
  return av(t) ? LD(t, e, r) : Promise.reject(new Error("invalid JSON wallet"));
}
function WD(t, e) {
  if (iv(t)) return oE(t, e);
  if (av(t)) return FD(t, e);
  throw new Error("invalid JSON wallet");
}
const xte = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        decryptCrowdsale: oE,
        decryptJsonWallet: UD,
        decryptJsonWalletSync: WD,
        decryptKeystore: LD,
        decryptKeystoreSync: FD,
        encryptKeystore: $D,
        getJsonWalletAddress: pte,
        isCrowdsaleWallet: iv,
        isKeystoreWallet: av,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  wte = "wallet/5.7.0";
var jk = function (t, e, r, n) {
  function i(a) {
    return a instanceof r
      ? a
      : new r(function (s) {
          s(a);
        });
  }
  return new (r || (r = Promise))(function (a, s) {
    function o(d) {
      try {
        u(n.next(d));
      } catch (m) {
        s(m);
      }
    }
    function c(d) {
      try {
        u(n.throw(d));
      } catch (m) {
        s(m);
      }
    }
    function u(d) {
      d.done ? a(d.value) : i(d.value).then(o, c);
    }
    u((n = n.apply(t, e || [])).next());
  });
};
const Ju = new ue(wte);
function _te(t) {
  return t != null && gt(t.privateKey, 32) && t.address != null;
}
function Ete(t) {
  const e = t.mnemonic;
  return e && e.phrase;
}
class Do extends Nu {
  constructor(e, r) {
    if ((super(), _te(e))) {
      const n = new tu(e.privateKey);
      if (
        (_e(this, "_signingKey", () => n),
        _e(this, "address", Fc(this.publicKey)),
        this.address !== Xt(e.address) &&
          Ju.throwArgumentError(
            "privateKey/address mismatch",
            "privateKey",
            "[REDACTED]"
          ),
        Ete(e))
      ) {
        const i = e.mnemonic;
        _e(this, "_mnemonic", () => ({
          phrase: i.phrase,
          path: i.path || Cf,
          locale: i.locale || "en",
        }));
        const a = this.mnemonic,
          s = na.fromMnemonic(a.phrase, null, a.locale).derivePath(a.path);
        Fc(s.privateKey) !== this.address &&
          Ju.throwArgumentError(
            "mnemonic/address mismatch",
            "privateKey",
            "[REDACTED]"
          );
      } else _e(this, "_mnemonic", () => null);
    } else {
      if (tu.isSigningKey(e))
        e.curve !== "secp256k1" &&
          Ju.throwArgumentError(
            "unsupported curve; must be secp256k1",
            "privateKey",
            "[REDACTED]"
          ),
          _e(this, "_signingKey", () => e);
      else {
        typeof e == "string" &&
          e.match(/^[0-9a-f]*$/i) &&
          e.length === 64 &&
          (e = "0x" + e);
        const n = new tu(e);
        _e(this, "_signingKey", () => n);
      }
      _e(this, "_mnemonic", () => null),
        _e(this, "address", Fc(this.publicKey));
    }
    r &&
      !Qb.isProvider(r) &&
      Ju.throwArgumentError("invalid provider", "provider", r),
      _e(this, "provider", r || null);
  }
  get mnemonic() {
    return this._mnemonic();
  }
  get privateKey() {
    return this._signingKey().privateKey;
  }
  get publicKey() {
    return this._signingKey().publicKey;
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  connect(e) {
    return new Do(this, e);
  }
  signTransaction(e) {
    return en(e).then((r) => {
      r.from != null &&
        (Xt(r.from) !== this.address &&
          Ju.throwArgumentError(
            "transaction from address mismatch",
            "transaction.from",
            e.from
          ),
        delete r.from);
      const n = this._signingKey().signDigest(Ut(Up(r)));
      return Up(r, n);
    });
  }
  signMessage(e) {
    return jk(this, void 0, void 0, function* () {
      return Bp(this._signingKey().signDigest(Jb(e)));
    });
  }
  _signTypedData(e, r, n) {
    return jk(this, void 0, void 0, function* () {
      const i = yield wn.resolveNames(
        e,
        r,
        n,
        (a) => (
          this.provider == null &&
            Ju.throwError(
              "cannot resolve ENS names without a provider",
              ue.errors.UNSUPPORTED_OPERATION,
              {
                operation: "resolveName",
                value: a,
              }
            ),
          this.provider.resolveName(a)
        )
      );
      return Bp(this._signingKey().signDigest(wn.hash(i.domain, r, i.value)));
    });
  }
  encrypt(e, r, n) {
    if (
      (typeof r == "function" && !n && ((n = r), (r = {})),
      n && typeof n != "function")
    )
      throw new Error("invalid callback");
    return r || (r = {}), $D(this, e, r, n);
  }
  static createRandom(e) {
    let r = P0(16);
    e || (e = {}),
      e.extraEntropy && (r = qe(sn(Ut(cr([r, e.extraEntropy])), 0, 16)));
    const n = nv(r, e.locale);
    return Do.fromMnemonic(n, e.path, e.locale);
  }
  static fromEncryptedJson(e, r, n) {
    return UD(e, r, n).then((i) => new Do(i));
  }
  static fromEncryptedJsonSync(e, r) {
    return new Do(WD(e, r));
  }
  static fromMnemonic(e, r, n) {
    return r || (r = Cf), new Do(na.fromMnemonic(e, null, n).derivePath(r));
  }
}
function Tte(t, e) {
  return Du(Jb(t), e);
}
function Cte(t, e, r, n) {
  return Du(wn.hash(t, e, r), n);
}
const Ate = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        Wallet: Do,
        verifyMessage: Tte,
        verifyTypedData: Cte,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  kte = "networks/5.7.1",
  Hk = new ue(kte);
function Ste(t) {
  return t && typeof t.renetwork == "function";
}
function Ro(t) {
  const e = function (r, n) {
    n == null && (n = {});
    const i = [];
    if (r.InfuraProvider && n.infura !== "-")
      try {
        i.push(new r.InfuraProvider(t, n.infura));
      } catch {}
    if (r.EtherscanProvider && n.etherscan !== "-")
      try {
        i.push(new r.EtherscanProvider(t, n.etherscan));
      } catch {}
    if (r.AlchemyProvider && n.alchemy !== "-")
      try {
        i.push(new r.AlchemyProvider(t, n.alchemy));
      } catch {}
    if (r.PocketProvider && n.pocket !== "-") {
      const a = ["goerli", "ropsten", "rinkeby", "sepolia"];
      try {
        const s = new r.PocketProvider(t, n.pocket);
        s.network && a.indexOf(s.network.name) === -1 && i.push(s);
      } catch {}
    }
    if (r.CloudflareProvider && n.cloudflare !== "-")
      try {
        i.push(new r.CloudflareProvider(t));
      } catch {}
    if (r.AnkrProvider && n.ankr !== "-")
      try {
        const a = ["ropsten"],
          s = new r.AnkrProvider(t, n.ankr);
        s.network && a.indexOf(s.network.name) === -1 && i.push(s);
      } catch {}
    if (i.length === 0) return null;
    if (r.FallbackProvider) {
      let a = 1;
      return (
        n.quorum != null ? (a = n.quorum) : t === "homestead" && (a = 2),
        new r.FallbackProvider(i, a)
      );
    }
    return i[0];
  };
  return (
    (e.renetwork = function (r) {
      return Ro(r);
    }),
    e
  );
}
function Xg(t, e) {
  const r = function (n, i) {
    return n.JsonRpcProvider ? new n.JsonRpcProvider(t, e) : null;
  };
  return (
    (r.renetwork = function (n) {
      return Xg(t, n);
    }),
    r
  );
}
const zk = {
    chainId: 1,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "homestead",
    _defaultProvider: Ro("homestead"),
  },
  qk = {
    chainId: 3,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "ropsten",
    _defaultProvider: Ro("ropsten"),
  },
  Vk = {
    chainId: 63,
    name: "classicMordor",
    _defaultProvider: Xg(
      "https://www.ethercluster.com/mordor",
      "classicMordor"
    ),
  },
  Y1 = {
    unspecified: {
      chainId: 0,
      name: "unspecified",
    },
    homestead: zk,
    mainnet: zk,
    morden: {
      chainId: 2,
      name: "morden",
    },
    ropsten: qk,
    testnet: qk,
    rinkeby: {
      chainId: 4,
      ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
      name: "rinkeby",
      _defaultProvider: Ro("rinkeby"),
    },
    kovan: {
      chainId: 42,
      name: "kovan",
      _defaultProvider: Ro("kovan"),
    },
    goerli: {
      chainId: 5,
      ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
      name: "goerli",
      _defaultProvider: Ro("goerli"),
    },
    kintsugi: {
      chainId: 1337702,
      name: "kintsugi",
    },
    sepolia: {
      chainId: 11155111,
      name: "sepolia",
      _defaultProvider: Ro("sepolia"),
    },
    classic: {
      chainId: 61,
      name: "classic",
      _defaultProvider: Xg("https://www.ethercluster.com/etc", "classic"),
    },
    classicMorden: {
      chainId: 62,
      name: "classicMorden",
    },
    classicMordor: Vk,
    classicTestnet: Vk,
    classicKotti: {
      chainId: 6,
      name: "classicKotti",
      _defaultProvider: Xg(
        "https://www.ethercluster.com/kotti",
        "classicKotti"
      ),
    },
    xdai: {
      chainId: 100,
      name: "xdai",
    },
    matic: {
      chainId: 137,
      name: "matic",
      _defaultProvider: Ro("matic"),
    },
    maticmum: {
      chainId: 80001,
      name: "maticmum",
    },
    optimism: {
      chainId: 10,
      name: "optimism",
      _defaultProvider: Ro("optimism"),
    },
    "optimism-kovan": {
      chainId: 69,
      name: "optimism-kovan",
    },
    "optimism-goerli": {
      chainId: 420,
      name: "optimism-goerli",
    },
    arbitrum: {
      chainId: 42161,
      name: "arbitrum",
    },
    "arbitrum-rinkeby": {
      chainId: 421611,
      name: "arbitrum-rinkeby",
    },
    "arbitrum-goerli": {
      chainId: 421613,
      name: "arbitrum-goerli",
    },
    bnb: {
      chainId: 56,
      name: "bnb",
    },
    bnbt: {
      chainId: 97,
      name: "bnbt",
    },
  };
function jD(t) {
  if (t == null) return null;
  if (typeof t == "number") {
    for (const n in Y1) {
      const i = Y1[n];
      if (i.chainId === t)
        return {
          name: i.name,
          chainId: i.chainId,
          ensAddress: i.ensAddress || null,
          _defaultProvider: i._defaultProvider || null,
        };
    }
    return {
      chainId: t,
      name: "unknown",
    };
  }
  if (typeof t == "string") {
    const n = Y1[t];
    return n == null
      ? null
      : {
          name: n.name,
          chainId: n.chainId,
          ensAddress: n.ensAddress,
          _defaultProvider: n._defaultProvider || null,
        };
  }
  const e = Y1[t.name];
  if (!e)
    return (
      typeof t.chainId != "number" &&
        Hk.throwArgumentError("invalid network chainId", "network", t),
      t
    );
  t.chainId !== 0 &&
    t.chainId !== e.chainId &&
    Hk.throwArgumentError("network chainId mismatch", "network", t);
  let r = t._defaultProvider || null;
  return (
    r == null &&
      e._defaultProvider &&
      (Ste(e._defaultProvider)
        ? (r = e._defaultProvider.renetwork(t))
        : (r = e._defaultProvider)),
    {
      name: t.name,
      chainId: e.chainId,
      ensAddress: t.ensAddress || e.ensAddress || null,
      _defaultProvider: r,
    }
  );
}
const Mte = "web/5.7.1";
var Ite = function (t, e, r, n) {
  function i(a) {
    return a instanceof r
      ? a
      : new r(function (s) {
          s(a);
        });
  }
  return new (r || (r = Promise))(function (a, s) {
    function o(d) {
      try {
        u(n.next(d));
      } catch (m) {
        s(m);
      }
    }
    function c(d) {
      try {
        u(n.throw(d));
      } catch (m) {
        s(m);
      }
    }
    function u(d) {
      d.done ? a(d.value) : i(d.value).then(o, c);
    }
    u((n = n.apply(t, e || [])).next());
  });
};
function Rte(t, e) {
  return Ite(this, void 0, void 0, function* () {
    e == null && (e = {});
    const r = {
      method: e.method || "GET",
      headers: e.headers || {},
      body: e.body || void 0,
    };
    if (
      (e.skipFetchSetup !== !0 &&
        ((r.mode = "cors"),
        (r.cache = "no-cache"),
        (r.credentials = "same-origin"),
        (r.redirect = "follow"),
        (r.referrer = "client")),
      e.fetchOptions != null)
    ) {
      const s = e.fetchOptions;
      s.mode && (r.mode = s.mode),
        s.cache && (r.cache = s.cache),
        s.credentials && (r.credentials = s.credentials),
        s.redirect && (r.redirect = s.redirect),
        s.referrer && (r.referrer = s.referrer);
    }
    const n = yield fetch(t, r),
      i = yield n.arrayBuffer(),
      a = {};
    return (
      n.headers.forEach
        ? n.headers.forEach((s, o) => {
            a[o.toLowerCase()] = s;
          })
        : n.headers.keys().forEach((s) => {
            a[s.toLowerCase()] = n.headers.get(s);
          }),
      {
        headers: a,
        statusCode: n.status,
        statusMessage: n.statusText,
        body: qe(new Uint8Array(i)),
      }
    );
  });
}
var Pte = function (t, e, r, n) {
  function i(a) {
    return a instanceof r
      ? a
      : new r(function (s) {
          s(a);
        });
  }
  return new (r || (r = Promise))(function (a, s) {
    function o(d) {
      try {
        u(n.next(d));
      } catch (m) {
        s(m);
      }
    }
    function c(d) {
      try {
        u(n.throw(d));
      } catch (m) {
        s(m);
      }
    }
    function u(d) {
      d.done ? a(d.value) : i(d.value).then(o, c);
    }
    u((n = n.apply(t, e || [])).next());
  });
};
const rs = new ue(Mte);
function Kk(t) {
  return new Promise((e) => {
    setTimeout(e, t);
  });
}
function ic(t, e) {
  if (t == null) return null;
  if (typeof t == "string") return t;
  if (Bm(t)) {
    if (
      e &&
      (e.split("/")[0] === "text" ||
        e.split(";")[0].trim() === "application/json")
    )
      try {
        return go(t);
      } catch {}
    return Ke(t);
  }
  return t;
}
function Nte(t) {
  return Lt(
    t.replace(/%([0-9a-f][0-9a-f])/gi, (e, r) =>
      String.fromCharCode(parseInt(r, 16))
    )
  );
}
function HD(t, e, r) {
  const n =
    typeof t == "object" && t.throttleLimit != null ? t.throttleLimit : 12;
  rs.assertArgument(
    n > 0 && n % 1 === 0,
    "invalid connection throttle limit",
    "connection.throttleLimit",
    n
  );
  const i = typeof t == "object" ? t.throttleCallback : null,
    a =
      typeof t == "object" && typeof t.throttleSlotInterval == "number"
        ? t.throttleSlotInterval
        : 100;
  rs.assertArgument(
    a > 0 && a % 1 === 0,
    "invalid connection throttle slot interval",
    "connection.throttleSlotInterval",
    a
  );
  const s = typeof t == "object" ? !!t.errorPassThrough : !1,
    o = {};
  let c = null;
  const u = {
    method: "GET",
  };
  let d = !1,
    m = 2 * 60 * 1e3;
  if (typeof t == "string") c = t;
  else if (typeof t == "object") {
    if (
      ((t == null || t.url == null) &&
        rs.throwArgumentError("missing URL", "connection.url", t),
      (c = t.url),
      typeof t.timeout == "number" && t.timeout > 0 && (m = t.timeout),
      t.headers)
    )
      for (const w in t.headers)
        (o[w.toLowerCase()] = {
          key: w,
          value: String(t.headers[w]),
        }),
          ["if-none-match", "if-modified-since"].indexOf(w.toLowerCase()) >=
            0 && (d = !0);
    if (((u.allowGzip = !!t.allowGzip), t.user != null && t.password != null)) {
      c.substring(0, 6) !== "https:" &&
        t.allowInsecureAuthentication !== !0 &&
        rs.throwError(
          "basic authentication requires a secure https url",
          ue.errors.INVALID_ARGUMENT,
          {
            argument: "url",
            url: c,
            user: t.user,
            password: "[REDACTED]",
          }
        );
      const w = t.user + ":" + t.password;
      o.authorization = {
        key: "Authorization",
        value: "Basic " + J8(Lt(w)),
      };
    }
    t.skipFetchSetup != null && (u.skipFetchSetup = !!t.skipFetchSetup),
      t.fetchOptions != null && (u.fetchOptions = vr(t.fetchOptions));
  }
  const v = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i"),
    E = c ? c.match(v) : null;
  if (E)
    try {
      const w = {
        statusCode: 200,
        statusMessage: "OK",
        headers: {
          "content-type": E[1] || "text/plain",
        },
        body: E[2] ? Z8(E[3]) : Nte(E[3]),
      };
      let S = w.body;
      return r && (S = r(w.body, w)), Promise.resolve(S);
    } catch (w) {
      rs.throwError("processing response error", ue.errors.SERVER_ERROR, {
        body: ic(E[1], E[2]),
        error: w,
        requestBody: null,
        requestMethod: "GET",
        url: c,
      });
    }
  e &&
    ((u.method = "POST"),
    (u.body = e),
    o["content-type"] == null &&
      (o["content-type"] = {
        key: "Content-Type",
        value: "application/octet-stream",
      }),
    o["content-length"] == null &&
      (o["content-length"] = {
        key: "Content-Length",
        value: String(e.length),
      }));
  const A = {};
  Object.keys(o).forEach((w) => {
    const S = o[w];
    A[S.key] = S.value;
  }),
    (u.headers = A);
  const I = (function () {
      let w = null;
      return {
        promise: new Promise(function (N, O) {
          m &&
            (w = setTimeout(() => {
              w != null &&
                ((w = null),
                O(
                  rs.makeError("timeout", ue.errors.TIMEOUT, {
                    requestBody: ic(u.body, A["content-type"]),
                    requestMethod: u.method,
                    timeout: m,
                    url: c,
                  })
                ));
            }, m));
        }),
        cancel: function () {
          w != null && (clearTimeout(w), (w = null));
        },
      };
    })(),
    b = (function () {
      return Pte(this, void 0, void 0, function* () {
        for (let w = 0; w < n; w++) {
          let S = null;
          try {
            if (((S = yield Rte(c, u)), w < n)) {
              if (S.statusCode === 301 || S.statusCode === 302) {
                const N = S.headers.location || "";
                if (u.method === "GET" && N.match(/^https:/)) {
                  c = S.headers.location;
                  continue;
                }
              } else if (S.statusCode === 429) {
                let N = !0;
                if ((i && (N = yield i(w, c)), N)) {
                  let O = 0;
                  const F = S.headers["retry-after"];
                  typeof F == "string" && F.match(/^[1-9][0-9]*$/)
                    ? (O = parseInt(F) * 1e3)
                    : (O =
                        a * parseInt(String(Math.random() * Math.pow(2, w)))),
                    yield Kk(O);
                  continue;
                }
              }
            }
          } catch (N) {
            (S = N.response),
              S == null &&
                (I.cancel(),
                rs.throwError("missing response", ue.errors.SERVER_ERROR, {
                  requestBody: ic(u.body, A["content-type"]),
                  requestMethod: u.method,
                  serverError: N,
                  url: c,
                }));
          }
          let k = S.body;
          if (
            (d && S.statusCode === 304
              ? (k = null)
              : !s &&
                (S.statusCode < 200 || S.statusCode >= 300) &&
                (I.cancel(),
                rs.throwError("bad response", ue.errors.SERVER_ERROR, {
                  status: S.statusCode,
                  headers: S.headers,
                  body: ic(k, S.headers ? S.headers["content-type"] : null),
                  requestBody: ic(u.body, A["content-type"]),
                  requestMethod: u.method,
                  url: c,
                })),
            r)
          )
            try {
              const N = yield r(k, S);
              return I.cancel(), N;
            } catch (N) {
              if (N.throttleRetry && w < n) {
                let O = !0;
                if ((i && (O = yield i(w, c)), O)) {
                  const F =
                    a * parseInt(String(Math.random() * Math.pow(2, w)));
                  yield Kk(F);
                  continue;
                }
              }
              I.cancel(),
                rs.throwError(
                  "processing response error",
                  ue.errors.SERVER_ERROR,
                  {
                    body: ic(k, S.headers ? S.headers["content-type"] : null),
                    error: N,
                    requestBody: ic(u.body, A["content-type"]),
                    requestMethod: u.method,
                    url: c,
                  }
                );
            }
          return I.cancel(), k;
        }
        return rs.throwError("failed response", ue.errors.SERVER_ERROR, {
          requestBody: ic(u.body, A["content-type"]),
          requestMethod: u.method,
          url: c,
        });
      });
    })();
  return Promise.race([I.promise, b]);
}
function Ou(t, e, r) {
  let n = (a, s) => {
      let o = null;
      if (a != null)
        try {
          o = JSON.parse(go(a));
        } catch (c) {
          rs.throwError("invalid JSON", ue.errors.SERVER_ERROR, {
            body: a,
            error: c,
          });
        }
      return r && (o = r(o, s)), o;
    },
    i = null;
  if (e != null) {
    i = Lt(e);
    const a =
      typeof t == "string"
        ? {
            url: t,
          }
        : vr(t);
    a.headers
      ? Object.keys(a.headers).filter((o) => o.toLowerCase() === "content-type")
          .length !== 0 ||
        ((a.headers = vr(a.headers)),
        (a.headers["content-type"] = "application/json"))
      : (a.headers = {
          "content-type": "application/json",
        }),
      (t = a);
  }
  return HD(t, i, n);
}
function ql(t, e) {
  return (
    e || (e = {}),
    (e = vr(e)),
    e.floor == null && (e.floor = 0),
    e.ceiling == null && (e.ceiling = 1e4),
    e.interval == null && (e.interval = 250),
    new Promise(function (r, n) {
      let i = null,
        a = !1;
      const s = () => (a ? !1 : ((a = !0), i && clearTimeout(i), !0));
      e.timeout &&
        (i = setTimeout(() => {
          s() && n(new Error("timeout"));
        }, e.timeout));
      const o = e.retryLimit;
      let c = 0;
      function u() {
        return t().then(
          function (d) {
            if (d !== void 0) s() && r(d);
            else if (e.oncePoll) e.oncePoll.once("poll", u);
            else if (e.onceBlock) e.onceBlock.once("block", u);
            else if (!a) {
              if ((c++, c > o)) {
                s() && n(new Error("retry limit reached"));
                return;
              }
              let m =
                e.interval * parseInt(String(Math.random() * Math.pow(2, c)));
              m < e.floor && (m = e.floor),
                m > e.ceiling && (m = e.ceiling),
                setTimeout(u, m);
            }
            return null;
          },
          function (d) {
            s() && n(d);
          }
        );
      }
      u();
    })
  );
}
const Bte = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      _fetchData: HD,
      fetchJson: Ou,
      poll: ql,
    },
    Symbol.toStringTag,
    {
      value: "Module",
    }
  )
);
var e2 = "qpzry9x8gf2tvdw0s3jn54khce6mua7l",
  f_ = {};
for (var X1 = 0; X1 < e2.length; X1++) {
  var Xw = e2.charAt(X1);
  if (f_[Xw] !== void 0) throw new TypeError(Xw + " is ambiguous");
  f_[Xw] = X1;
}
function G0(t) {
  var e = t >> 25;
  return (
    ((t & 33554431) << 5) ^
    (-((e >> 0) & 1) & 996825010) ^
    (-((e >> 1) & 1) & 642813549) ^
    (-((e >> 2) & 1) & 513874426) ^
    (-((e >> 3) & 1) & 1027748829) ^
    (-((e >> 4) & 1) & 705979059)
  );
}
function zD(t) {
  for (var e = 1, r = 0; r < t.length; ++r) {
    var n = t.charCodeAt(r);
    if (n < 33 || n > 126) return "Invalid prefix (" + t + ")";
    e = G0(e) ^ (n >> 5);
  }
  for (e = G0(e), r = 0; r < t.length; ++r) {
    var i = t.charCodeAt(r);
    e = G0(e) ^ (i & 31);
  }
  return e;
}
function Dte(t, e, r) {
  if (((r = r || 90), t.length + 7 + e.length > r))
    throw new TypeError("Exceeds length limit");
  t = t.toLowerCase();
  var n = zD(t);
  if (typeof n == "string") throw new Error(n);
  for (var i = t + "1", a = 0; a < e.length; ++a) {
    var s = e[a];
    if (s >> 5) throw new Error("Non 5-bit word");
    (n = G0(n) ^ s), (i += e2.charAt(s));
  }
  for (a = 0; a < 6; ++a) n = G0(n);
  for (n ^= 1, a = 0; a < 6; ++a) {
    var o = (n >> ((5 - a) * 5)) & 31;
    i += e2.charAt(o);
  }
  return i;
}
function qD(t, e) {
  if (((e = e || 90), t.length < 8)) return t + " too short";
  if (t.length > e) return "Exceeds length limit";
  var r = t.toLowerCase(),
    n = t.toUpperCase();
  if (t !== r && t !== n) return "Mixed-case string " + t;
  t = r;
  var i = t.lastIndexOf("1");
  if (i === -1) return "No separator character for " + t;
  if (i === 0) return "Missing prefix for " + t;
  var a = t.slice(0, i),
    s = t.slice(i + 1);
  if (s.length < 6) return "Data too short";
  var o = zD(a);
  if (typeof o == "string") return o;
  for (var c = [], u = 0; u < s.length; ++u) {
    var d = s.charAt(u),
      m = f_[d];
    if (m === void 0) return "Unknown character " + d;
    (o = G0(o) ^ m), !(u + 6 >= s.length) && c.push(m);
  }
  return o !== 1
    ? "Invalid checksum for " + t
    : {
        prefix: a,
        words: c,
      };
}
function Ote() {
  var t = qD.apply(null, arguments);
  if (typeof t == "object") return t;
}
function Fte(t) {
  var e = qD.apply(null, arguments);
  if (typeof e == "object") return e;
  throw new Error(e);
}
function sv(t, e, r, n) {
  for (var i = 0, a = 0, s = (1 << r) - 1, o = [], c = 0; c < t.length; ++c)
    for (i = (i << e) | t[c], a += e; a >= r; ) (a -= r), o.push((i >> a) & s);
  if (n) a > 0 && o.push((i << (r - a)) & s);
  else {
    if (a >= e) return "Excess padding";
    if ((i << (r - a)) & s) return "Non-zero padding";
  }
  return o;
}
function Lte(t) {
  var e = sv(t, 8, 5, !0);
  if (Array.isArray(e)) return e;
}
function $te(t) {
  var e = sv(t, 8, 5, !0);
  if (Array.isArray(e)) return e;
  throw new Error(e);
}
function Ute(t) {
  var e = sv(t, 5, 8, !1);
  if (Array.isArray(e)) return e;
}
function Wte(t) {
  var e = sv(t, 5, 8, !1);
  if (Array.isArray(e)) return e;
  throw new Error(e);
}
var jte = {
  decodeUnsafe: Ote,
  decode: Fte,
  encode: Dte,
  toWordsUnsafe: Lte,
  toWords: $te,
  fromWordsUnsafe: Ute,
  fromWords: Wte,
};
const Gk = mn(jte),
  gi = "providers/5.7.2",
  Qd = new ue(gi);
class at {
  constructor() {
    this.formats = this.getDefaultFormats();
  }
  getDefaultFormats() {
    const e = {},
      r = this.address.bind(this),
      n = this.bigNumber.bind(this),
      i = this.blockTag.bind(this),
      a = this.data.bind(this),
      s = this.hash.bind(this),
      o = this.hex.bind(this),
      c = this.number.bind(this),
      u = this.type.bind(this),
      d = (m) => this.data(m, !0);
    return (
      (e.transaction = {
        hash: s,
        type: u,
        accessList: at.allowNull(this.accessList.bind(this), null),
        blockHash: at.allowNull(s, null),
        blockNumber: at.allowNull(c, null),
        transactionIndex: at.allowNull(c, null),
        confirmations: at.allowNull(c, null),
        from: r,
        gasPrice: at.allowNull(n),
        maxPriorityFeePerGas: at.allowNull(n),
        maxFeePerGas: at.allowNull(n),
        gasLimit: n,
        to: at.allowNull(r, null),
        value: n,
        nonce: c,
        data: a,
        r: at.allowNull(this.uint256),
        s: at.allowNull(this.uint256),
        v: at.allowNull(c),
        creates: at.allowNull(r, null),
        raw: at.allowNull(a),
      }),
      (e.transactionRequest = {
        from: at.allowNull(r),
        nonce: at.allowNull(c),
        gasLimit: at.allowNull(n),
        gasPrice: at.allowNull(n),
        maxPriorityFeePerGas: at.allowNull(n),
        maxFeePerGas: at.allowNull(n),
        to: at.allowNull(r),
        value: at.allowNull(n),
        data: at.allowNull(d),
        type: at.allowNull(c),
        accessList: at.allowNull(this.accessList.bind(this), null),
      }),
      (e.receiptLog = {
        transactionIndex: c,
        blockNumber: c,
        transactionHash: s,
        address: r,
        topics: at.arrayOf(s),
        data: a,
        logIndex: c,
        blockHash: s,
      }),
      (e.receipt = {
        to: at.allowNull(this.address, null),
        from: at.allowNull(this.address, null),
        contractAddress: at.allowNull(r, null),
        transactionIndex: c,
        root: at.allowNull(o),
        gasUsed: n,
        logsBloom: at.allowNull(a),
        blockHash: s,
        transactionHash: s,
        logs: at.arrayOf(this.receiptLog.bind(this)),
        blockNumber: c,
        confirmations: at.allowNull(c, null),
        cumulativeGasUsed: n,
        effectiveGasPrice: at.allowNull(n),
        status: at.allowNull(c),
        type: u,
      }),
      (e.block = {
        hash: at.allowNull(s),
        parentHash: s,
        number: c,
        timestamp: c,
        nonce: at.allowNull(o),
        difficulty: this.difficulty.bind(this),
        gasLimit: n,
        gasUsed: n,
        miner: at.allowNull(r),
        extraData: a,
        transactions: at.allowNull(at.arrayOf(s)),
        baseFeePerGas: at.allowNull(n),
      }),
      (e.blockWithTransactions = vr(e.block)),
      (e.blockWithTransactions.transactions = at.allowNull(
        at.arrayOf(this.transactionResponse.bind(this))
      )),
      (e.filter = {
        fromBlock: at.allowNull(i, void 0),
        toBlock: at.allowNull(i, void 0),
        blockHash: at.allowNull(s, void 0),
        address: at.allowNull(r, void 0),
        topics: at.allowNull(this.topics.bind(this), void 0),
      }),
      (e.filterLog = {
        blockNumber: at.allowNull(c),
        blockHash: at.allowNull(s),
        transactionIndex: c,
        removed: at.allowNull(this.boolean.bind(this)),
        address: r,
        data: at.allowFalsish(a, "0x"),
        topics: at.arrayOf(s),
        transactionHash: s,
        logIndex: c,
      }),
      e
    );
  }
  accessList(e) {
    return yl(e || []);
  }
  number(e) {
    return e === "0x" ? 0 : ae.from(e).toNumber();
  }
  type(e) {
    return e === "0x" || e == null ? 0 : ae.from(e).toNumber();
  }
  bigNumber(e) {
    return ae.from(e);
  }
  boolean(e) {
    if (typeof e == "boolean") return e;
    if (typeof e == "string") {
      if (((e = e.toLowerCase()), e === "true")) return !0;
      if (e === "false") return !1;
    }
    throw new Error("invalid boolean - " + e);
  }
  hex(e, r) {
    return typeof e == "string" &&
      (!r && e.substring(0, 2) !== "0x" && (e = "0x" + e), gt(e))
      ? e.toLowerCase()
      : Qd.throwArgumentError("invalid hash", "value", e);
  }
  data(e, r) {
    const n = this.hex(e, r);
    if (n.length % 2 !== 0) throw new Error("invalid data; odd-length - " + e);
    return n;
  }
  address(e) {
    return Xt(e);
  }
  callAddress(e) {
    if (!gt(e, 32)) return null;
    const r = Xt(sn(e, 12));
    return r === Ft ? null : r;
  }
  contractAddress(e) {
    return fd(e);
  }
  blockTag(e) {
    if (e == null) return "latest";
    if (e === "earliest") return "0x0";
    switch (e) {
      case "earliest":
        return "0x0";
      case "latest":
      case "pending":
      case "safe":
      case "finalized":
        return e;
    }
    if (typeof e == "number" || gt(e)) return Dm(e);
    throw new Error("invalid blockTag");
  }
  hash(e, r) {
    const n = this.hex(e, r);
    return za(n) !== 32 ? Qd.throwArgumentError("invalid hash", "value", e) : n;
  }
  difficulty(e) {
    if (e == null) return null;
    const r = ae.from(e);
    try {
      return r.toNumber();
    } catch {}
    return null;
  }
  uint256(e) {
    if (!gt(e)) throw new Error("invalid uint256");
    return Rt(e, 32);
  }
  _block(e, r) {
    e.author != null && e.miner == null && (e.miner = e.author);
    const n = e._difficulty != null ? e._difficulty : e.difficulty,
      i = at.check(r, e);
    return (i._difficulty = n == null ? null : ae.from(n)), i;
  }
  block(e) {
    return this._block(e, this.formats.block);
  }
  blockWithTransactions(e) {
    return this._block(e, this.formats.blockWithTransactions);
  }
  transactionRequest(e) {
    return at.check(this.formats.transactionRequest, e);
  }
  transactionResponse(e) {
    e.gas != null && e.gasLimit == null && (e.gasLimit = e.gas),
      e.to &&
        ae.from(e.to).isZero() &&
        (e.to = "0x0000000000000000000000000000000000000000"),
      e.input != null && e.data == null && (e.data = e.input),
      e.to == null &&
        e.creates == null &&
        (e.creates = this.contractAddress(e)),
      (e.type === 1 || e.type === 2) &&
        e.accessList == null &&
        (e.accessList = []);
    const r = at.check(this.formats.transaction, e);
    if (e.chainId != null) {
      let n = e.chainId;
      gt(n) && (n = ae.from(n).toNumber()), (r.chainId = n);
    } else {
      let n = e.networkId;
      n == null && r.v == null && (n = e.chainId),
        gt(n) && (n = ae.from(n).toNumber()),
        typeof n != "number" &&
          r.v != null &&
          ((n = (r.v - 35) / 2), n < 0 && (n = 0), (n = parseInt(n))),
        typeof n != "number" && (n = 0),
        (r.chainId = n);
    }
    return (
      r.blockHash &&
        r.blockHash.replace(/0/g, "") === "x" &&
        (r.blockHash = null),
      r
    );
  }
  transaction(e) {
    return wD(e);
  }
  receiptLog(e) {
    return at.check(this.formats.receiptLog, e);
  }
  receipt(e) {
    const r = at.check(this.formats.receipt, e);
    if (r.root != null)
      if (r.root.length <= 4) {
        const n = ae.from(r.root).toNumber();
        n === 0 || n === 1
          ? (r.status != null &&
              r.status !== n &&
              Qd.throwArgumentError(
                "alt-root-status/status mismatch",
                "value",
                {
                  root: r.root,
                  status: r.status,
                }
              ),
            (r.status = n),
            delete r.root)
          : Qd.throwArgumentError(
              "invalid alt-root-status",
              "value.root",
              r.root
            );
      } else
        r.root.length !== 66 &&
          Qd.throwArgumentError("invalid root hash", "value.root", r.root);
    return r.status != null && (r.byzantium = !0), r;
  }
  topics(e) {
    return Array.isArray(e)
      ? e.map((r) => this.topics(r))
      : e != null
      ? this.hash(e, !0)
      : null;
  }
  filter(e) {
    return at.check(this.formats.filter, e);
  }
  filterLog(e) {
    return at.check(this.formats.filterLog, e);
  }
  static check(e, r) {
    const n = {};
    for (const i in e)
      try {
        const a = e[i](r[i]);
        a !== void 0 && (n[i] = a);
      } catch (a) {
        throw ((a.checkKey = i), (a.checkValue = r[i]), a);
      }
    return n;
  }
  static allowNull(e, r) {
    return function (n) {
      return n == null ? r : e(n);
    };
  }
  static allowFalsish(e, r) {
    return function (n) {
      return n ? e(n) : r;
    };
  }
  static arrayOf(e) {
    return function (r) {
      if (!Array.isArray(r)) throw new Error("not an array");
      const n = [];
      return (
        r.forEach(function (i) {
          n.push(e(i));
        }),
        n
      );
    };
  }
}
function Hte(t) {
  return t && typeof t.isCommunityResource == "function";
}
function Zk(t) {
  return Hte(t) && t.isCommunityResource();
}
let Jk = !1;
function ov() {
  Jk ||
    ((Jk = !0),
    console.log("========= NOTICE ========="),
    console.log("Request-Rate Exceeded  (this message will not be repeated)"),
    console.log(""),
    console.log(
      "The default API keys for each service are provided as a highly-throttled,"
    ),
    console.log(
      "community resource for low-traffic projects and early prototyping."
    ),
    console.log(""),
    console.log(
      "While your application will continue to function, we highly recommended"
    ),
    console.log(
      "signing up for your own API keys to improve performance, increase your"
    ),
    console.log(
      "request rate/limit and enable other perks, such as metrics and advanced APIs."
    ),
    console.log(""),
    console.log("For more details: https://docs.ethers.io/api-keys/"),
    console.log("=========================="));
}
var vt = function (t, e, r, n) {
  function i(a) {
    return a instanceof r
      ? a
      : new r(function (s) {
          s(a);
        });
  }
  return new (r || (r = Promise))(function (a, s) {
    function o(d) {
      try {
        u(n.next(d));
      } catch (m) {
        s(m);
      }
    }
    function c(d) {
      try {
        u(n.throw(d));
      } catch (m) {
        s(m);
      }
    }
    function u(d) {
      d.done ? a(d.value) : i(d.value).then(o, c);
    }
    u((n = n.apply(t, e || [])).next());
  });
};
const Tt = new ue(gi),
  zte = 10;
function Qk(t) {
  return t == null
    ? "null"
    : (za(t) !== 32 && Tt.throwArgumentError("invalid topic", "topic", t),
      t.toLowerCase());
}
function Yk(t) {
  for (t = t.slice(); t.length > 0 && t[t.length - 1] == null; ) t.pop();
  return t
    .map((e) => {
      if (Array.isArray(e)) {
        const r = {};
        e.forEach((i) => {
          r[Qk(i)] = !0;
        });
        const n = Object.keys(r);
        return n.sort(), n.join("|");
      } else return Qk(e);
    })
    .join("&");
}
function qte(t) {
  return t === ""
    ? []
    : t.split(/&/g).map((e) => {
        if (e === "") return [];
        const r = e.split("|").map((n) => (n === "null" ? null : n));
        return r.length === 1 ? r[0] : r;
      });
}
function Qu(t) {
  if (typeof t == "string") {
    if (((t = t.toLowerCase()), za(t) === 32)) return "tx:" + t;
    if (t.indexOf(":") === -1) return t;
  } else {
    if (Array.isArray(t)) return "filter:*:" + Yk(t);
    if (WY.isForkEvent(t))
      throw (Tt.warn("not implemented"), new Error("not implemented"));
    if (t && typeof t == "object")
      return "filter:" + (t.address || "*") + ":" + Yk(t.topics || []);
  }
  throw new Error("invalid event - " + t);
}
function Yd() {
  return new Date().getTime();
}
function Xk(t) {
  return new Promise((e) => {
    setTimeout(e, t);
  });
}
const Vte = ["block", "network", "pending", "poll"];
let Kte = class {
  constructor(e, r, n) {
    _e(this, "tag", e),
      _e(this, "listener", r),
      _e(this, "once", n),
      (this._lastBlockNumber = -2),
      (this._inflight = !1);
  }
  get event() {
    switch (this.type) {
      case "tx":
        return this.hash;
      case "filter":
        return this.filter;
    }
    return this.tag;
  }
  get type() {
    return this.tag.split(":")[0];
  }
  get hash() {
    const e = this.tag.split(":");
    return e[0] !== "tx" ? null : e[1];
  }
  get filter() {
    const e = this.tag.split(":");
    if (e[0] !== "filter") return null;
    const r = e[1],
      n = qte(e[2]),
      i = {};
    return n.length > 0 && (i.topics = n), r && r !== "*" && (i.address = r), i;
  }
  pollable() {
    return this.tag.indexOf(":") >= 0 || Vte.indexOf(this.tag) >= 0;
  }
};
const Gte = {
  0: {
    symbol: "btc",
    p2pkh: 0,
    p2sh: 5,
    prefix: "bc",
  },
  2: {
    symbol: "ltc",
    p2pkh: 48,
    p2sh: 50,
    prefix: "ltc",
  },
  3: {
    symbol: "doge",
    p2pkh: 30,
    p2sh: 22,
  },
  60: {
    symbol: "eth",
    ilk: "eth",
  },
  61: {
    symbol: "etc",
    ilk: "eth",
  },
  700: {
    symbol: "xdai",
    ilk: "eth",
  },
};
function e3(t) {
  return Rt(ae.from(t).toHexString(), 32);
}
function eS(t) {
  return Ef.encode(cr([t, sn(Zo(Zo(t)), 0, 4)]));
}
const VD = new RegExp("^(ipfs)://(.*)$", "i"),
  tS = [
    new RegExp("^(https)://(.*)$", "i"),
    new RegExp("^(data):(.*)$", "i"),
    VD,
    new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i"),
  ];
function Jy(t, e) {
  try {
    return go(zp(t, e));
  } catch {}
  return null;
}
function zp(t, e) {
  if (t === "0x") return null;
  const r = ae.from(sn(t, e, e + 32)).toNumber(),
    n = ae.from(sn(t, r, r + 32)).toNumber();
  return sn(t, r + 32, r + 32 + n);
}
function t3(t) {
  return (
    t.match(/^ipfs:\/\/ipfs\//i)
      ? (t = t.substring(12))
      : t.match(/^ipfs:\/\//i)
      ? (t = t.substring(7))
      : Tt.throwArgumentError("unsupported IPFS format", "link", t),
    `https://gateway.ipfs.io/ipfs/${t}`
  );
}
function rS(t) {
  const e = qe(t);
  if (e.length > 32) throw new Error("internal; should not happen");
  const r = new Uint8Array(32);
  return r.set(e, 32 - e.length), r;
}
function Zte(t) {
  if (t.length % 32 === 0) return t;
  const e = new Uint8Array(Math.ceil(t.length / 32) * 32);
  return e.set(t), e;
}
function KD(t) {
  const e = [];
  let r = 0;
  for (let n = 0; n < t.length; n++) e.push(null), (r += 32);
  for (let n = 0; n < t.length; n++) {
    const i = qe(t[n]);
    (e[n] = rS(r)),
      e.push(rS(i.length)),
      e.push(Zte(i)),
      (r += 32 + Math.ceil(i.length / 32) * 32);
  }
  return Ti(e);
}
class nS {
  constructor(e, r, n, i) {
    _e(this, "provider", e),
      _e(this, "name", n),
      _e(this, "address", e.formatter.address(r)),
      _e(this, "_resolvedAddress", i);
  }
  supportsWildcard() {
    return (
      this._supportsEip2544 ||
        (this._supportsEip2544 = this.provider
          .call({
            to: this.address,
            data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000",
          })
          .then((e) => ae.from(e).eq(1))
          .catch((e) => {
            if (e.code === ue.errors.CALL_EXCEPTION) return !1;
            throw ((this._supportsEip2544 = null), e);
          })),
      this._supportsEip2544
    );
  }
  _fetch(e, r) {
    return vt(this, void 0, void 0, function* () {
      const n = {
        to: this.address,
        ccipReadEnabled: !0,
        data: Ti([e, Lh(this.name), r || "0x"]),
      };
      let i = !1;
      (yield this.supportsWildcard()) &&
        ((i = !0), (n.data = Ti(["0x9061b923", KD([UB(this.name), n.data])])));
      try {
        let a = yield this.provider.call(n);
        return (
          qe(a).length % 32 === 4 &&
            Tt.throwError("resolver threw error", ue.errors.CALL_EXCEPTION, {
              transaction: n,
              data: a,
            }),
          i && (a = zp(a, 0)),
          a
        );
      } catch (a) {
        if (a.code === ue.errors.CALL_EXCEPTION) return null;
        throw a;
      }
    });
  }
  _fetchBytes(e, r) {
    return vt(this, void 0, void 0, function* () {
      const n = yield this._fetch(e, r);
      return n != null ? zp(n, 0) : null;
    });
  }
  _getAddress(e, r) {
    const n = Gte[String(e)];
    if (
      (n == null &&
        Tt.throwError(
          `unsupported coin type: ${e}`,
          ue.errors.UNSUPPORTED_OPERATION,
          {
            operation: `getAddress(${e})`,
          }
        ),
      n.ilk === "eth")
    )
      return this.provider.formatter.address(r);
    const i = qe(r);
    if (n.p2pkh != null) {
      const a = r.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
      if (a) {
        const s = parseInt(a[1], 16);
        if (a[2].length === s * 2 && s >= 1 && s <= 75)
          return eS(cr([[n.p2pkh], "0x" + a[2]]));
      }
    }
    if (n.p2sh != null) {
      const a = r.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
      if (a) {
        const s = parseInt(a[1], 16);
        if (a[2].length === s * 2 && s >= 1 && s <= 75)
          return eS(cr([[n.p2sh], "0x" + a[2]]));
      }
    }
    if (n.prefix != null) {
      const a = i[1];
      let s = i[0];
      if (
        (s === 0 ? a !== 20 && a !== 32 && (s = -1) : (s = -1),
        s >= 0 && i.length === 2 + a && a >= 1 && a <= 75)
      ) {
        const o = Gk.toWords(i.slice(2));
        return o.unshift(s), Gk.encode(n.prefix, o);
      }
    }
    return null;
  }
  getAddress(e) {
    return vt(this, void 0, void 0, function* () {
      if ((e == null && (e = 60), e === 60))
        try {
          const i = yield this._fetch("0x3b3b57de");
          return i === "0x" || i === SB
            ? null
            : this.provider.formatter.callAddress(i);
        } catch (i) {
          if (i.code === ue.errors.CALL_EXCEPTION) return null;
          throw i;
        }
      const r = yield this._fetchBytes("0xf1cb7e06", e3(e));
      if (r == null || r === "0x") return null;
      const n = this._getAddress(e, r);
      return (
        n == null &&
          Tt.throwError(
            "invalid or unsupported coin data",
            ue.errors.UNSUPPORTED_OPERATION,
            {
              operation: `getAddress(${e})`,
              coinType: e,
              data: r,
            }
          ),
        n
      );
    });
  }
  getAvatar() {
    return vt(this, void 0, void 0, function* () {
      const e = [
        {
          type: "name",
          content: this.name,
        },
      ];
      try {
        const r = yield this.getText("avatar");
        if (r == null) return null;
        for (let n = 0; n < tS.length; n++) {
          const i = r.match(tS[n]);
          if (i == null) continue;
          const a = i[1].toLowerCase();
          switch (a) {
            case "https":
              return (
                e.push({
                  type: "url",
                  content: r,
                }),
                {
                  linkage: e,
                  url: r,
                }
              );
            case "data":
              return (
                e.push({
                  type: "data",
                  content: r,
                }),
                {
                  linkage: e,
                  url: r,
                }
              );
            case "ipfs":
              return (
                e.push({
                  type: "ipfs",
                  content: r,
                }),
                {
                  linkage: e,
                  url: t3(r),
                }
              );
            case "erc721":
            case "erc1155": {
              const s = a === "erc721" ? "0xc87b56dd" : "0x0e89341c";
              e.push({
                type: a,
                content: r,
              });
              const o = this._resolvedAddress || (yield this.getAddress()),
                c = (i[2] || "").split("/");
              if (c.length !== 2) return null;
              const u = yield this.provider.formatter.address(c[0]),
                d = Rt(ae.from(c[1]).toHexString(), 32);
              if (a === "erc721") {
                const I = this.provider.formatter.callAddress(
                  yield this.provider.call({
                    to: u,
                    data: Ti(["0x6352211e", d]),
                  })
                );
                if (o !== I) return null;
                e.push({
                  type: "owner",
                  content: I,
                });
              } else if (a === "erc1155") {
                const I = ae.from(
                  yield this.provider.call({
                    to: u,
                    data: Ti(["0x00fdd58e", Rt(o, 32), d]),
                  })
                );
                if (I.isZero()) return null;
                e.push({
                  type: "balance",
                  content: I.toString(),
                });
              }
              const m = {
                to: this.provider.formatter.address(c[0]),
                data: Ti([s, d]),
              };
              let v = Jy(yield this.provider.call(m), 0);
              if (v == null) return null;
              e.push({
                type: "metadata-url-base",
                content: v,
              }),
                a === "erc1155" &&
                  ((v = v.replace("{id}", d.substring(2))),
                  e.push({
                    type: "metadata-url-expanded",
                    content: v,
                  })),
                v.match(/^ipfs:/i) && (v = t3(v)),
                e.push({
                  type: "metadata-url",
                  content: v,
                });
              const E = yield Ou(v);
              if (!E) return null;
              e.push({
                type: "metadata",
                content: JSON.stringify(E),
              });
              let A = E.image;
              if (typeof A != "string") return null;
              if (!A.match(/^(https:\/\/|data:)/i)) {
                if (A.match(VD) == null) return null;
                e.push({
                  type: "url-ipfs",
                  content: A,
                }),
                  (A = t3(A));
              }
              return (
                e.push({
                  type: "url",
                  content: A,
                }),
                {
                  linkage: e,
                  url: A,
                }
              );
            }
          }
        }
      } catch {}
      return null;
    });
  }
  getContentHash() {
    return vt(this, void 0, void 0, function* () {
      const e = yield this._fetchBytes("0xbc1c58d1");
      if (e == null || e === "0x") return null;
      const r = e.match(
        /^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/
      );
      if (r) {
        const s = parseInt(r[3], 16);
        if (r[4].length === s * 2) return "ipfs://" + Ef.encode("0x" + r[1]);
      }
      const n = e.match(
        /^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/
      );
      if (n) {
        const s = parseInt(n[3], 16);
        if (n[4].length === s * 2) return "ipns://" + Ef.encode("0x" + n[1]);
      }
      const i = e.match(/^0xe40101fa011b20([0-9a-f]*)$/);
      if (i && i[1].length === 32 * 2) return "bzz://" + i[1];
      const a = e.match(/^0x90b2c605([0-9a-f]*)$/);
      if (a && a[1].length === 34 * 2) {
        const s = {
          "=": "",
          "+": "-",
          "/": "_",
        };
        return "sia://" + J8("0x" + a[1]).replace(/[=+\/]/g, (c) => s[c]);
      }
      return Tt.throwError(
        "invalid or unsupported content hash data",
        ue.errors.UNSUPPORTED_OPERATION,
        {
          operation: "getContentHash()",
          data: e,
        }
      );
    });
  }
  getText(e) {
    return vt(this, void 0, void 0, function* () {
      let r = Lt(e);
      (r = cr([e3(64), e3(r.length), r])),
        r.length % 32 !== 0 && (r = cr([r, Rt("0x", 32 - (e.length % 32))]));
      const n = yield this._fetchBytes("0x59d1d43c", Ke(r));
      return n == null || n === "0x" ? null : go(n);
    });
  }
}
let r3 = null,
  Jte = 1;
class lE extends Qb {
  constructor(e) {
    if (
      (super(),
      (this._events = []),
      (this._emitted = {
        block: -2,
      }),
      (this.disableCcipRead = !1),
      (this.formatter = new.target.getFormatter()),
      _e(this, "anyNetwork", e === "any"),
      this.anyNetwork && (e = this.detectNetwork()),
      e instanceof Promise)
    )
      (this._networkPromise = e),
        e.catch((r) => {}),
        this._ready().catch((r) => {});
    else {
      const r = qn(new.target, "getNetwork")(e);
      r
        ? (_e(this, "_network", r), this.emit("network", r, null))
        : Tt.throwArgumentError("invalid network", "network", e);
    }
    (this._maxInternalBlockNumber = -1024),
      (this._lastBlockNumber = -2),
      (this._maxFilterBlockRange = 10),
      (this._pollingInterval = 4e3),
      (this._fastQueryDate = 0);
  }
  _ready() {
    return vt(this, void 0, void 0, function* () {
      if (this._network == null) {
        let e = null;
        if (this._networkPromise)
          try {
            e = yield this._networkPromise;
          } catch {}
        e == null && (e = yield this.detectNetwork()),
          e ||
            Tt.throwError("no network detected", ue.errors.UNKNOWN_ERROR, {}),
          this._network == null &&
            (this.anyNetwork ? (this._network = e) : _e(this, "_network", e),
            this.emit("network", e, null));
      }
      return this._network;
    });
  }
  get ready() {
    return ql(() =>
      this._ready().then(
        (e) => e,
        (e) => {
          if (!(e.code === ue.errors.NETWORK_ERROR && e.event === "noNetwork"))
            throw e;
        }
      )
    );
  }
  static getFormatter() {
    return r3 == null && (r3 = new at()), r3;
  }
  static getNetwork(e) {
    return jD(e ?? "homestead");
  }
  ccipReadFetch(e, r, n) {
    return vt(this, void 0, void 0, function* () {
      if (this.disableCcipRead || n.length === 0) return null;
      const i = e.to.toLowerCase(),
        a = r.toLowerCase(),
        s = [];
      for (let o = 0; o < n.length; o++) {
        const c = n[o],
          u = c.replace("{sender}", i).replace("{data}", a),
          d =
            c.indexOf("{data}") >= 0
              ? null
              : JSON.stringify({
                  data: a,
                  sender: i,
                }),
          m = yield Ou(
            {
              url: u,
              errorPassThrough: !0,
            },
            d,
            (E, A) => ((E.status = A.statusCode), E)
          );
        if (m.data) return m.data;
        const v = m.message || "unknown error";
        if (m.status >= 400 && m.status < 500)
          return Tt.throwError(
            `response not found during CCIP fetch: ${v}`,
            ue.errors.SERVER_ERROR,
            {
              url: c,
              errorMessage: v,
            }
          );
        s.push(v);
      }
      return Tt.throwError(
        `error encountered during CCIP fetch: ${s
          .map((o) => JSON.stringify(o))
          .join(", ")}`,
        ue.errors.SERVER_ERROR,
        {
          urls: n,
          errorMessages: s,
        }
      );
    });
  }
  _getInternalBlockNumber(e) {
    return vt(this, void 0, void 0, function* () {
      if ((yield this._ready(), e > 0))
        for (; this._internalBlockNumber; ) {
          const i = this._internalBlockNumber;
          try {
            const a = yield i;
            if (Yd() - a.respTime <= e) return a.blockNumber;
            break;
          } catch {
            if (this._internalBlockNumber === i) break;
          }
        }
      const r = Yd(),
        n = en({
          blockNumber: this.perform("getBlockNumber", {}),
          networkError: this.getNetwork().then(
            (i) => null,
            (i) => i
          ),
        }).then(({ blockNumber: i, networkError: a }) => {
          if (a)
            throw (
              (this._internalBlockNumber === n &&
                (this._internalBlockNumber = null),
              a)
            );
          const s = Yd();
          return (
            (i = ae.from(i).toNumber()),
            i < this._maxInternalBlockNumber &&
              (i = this._maxInternalBlockNumber),
            (this._maxInternalBlockNumber = i),
            this._setFastBlockNumber(i),
            {
              blockNumber: i,
              reqTime: r,
              respTime: s,
            }
          );
        });
      return (
        (this._internalBlockNumber = n),
        n.catch((i) => {
          this._internalBlockNumber === n && (this._internalBlockNumber = null);
        }),
        (yield n).blockNumber
      );
    });
  }
  poll() {
    return vt(this, void 0, void 0, function* () {
      const e = Jte++,
        r = [];
      let n = null;
      try {
        n = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
      } catch (i) {
        this.emit("error", i);
        return;
      }
      if (
        (this._setFastBlockNumber(n),
        this.emit("poll", e, n),
        n === this._lastBlockNumber)
      ) {
        this.emit("didPoll", e);
        return;
      }
      if (
        (this._emitted.block === -2 && (this._emitted.block = n - 1),
        Math.abs(this._emitted.block - n) > 1e3)
      )
        Tt.warn(
          `network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${n})`
        ),
          this.emit(
            "error",
            Tt.makeError(
              "network block skew detected",
              ue.errors.NETWORK_ERROR,
              {
                blockNumber: n,
                event: "blockSkew",
                previousBlockNumber: this._emitted.block,
              }
            )
          ),
          this.emit("block", n);
      else
        for (let i = this._emitted.block + 1; i <= n; i++)
          this.emit("block", i);
      this._emitted.block !== n &&
        ((this._emitted.block = n),
        Object.keys(this._emitted).forEach((i) => {
          if (i === "block") return;
          const a = this._emitted[i];
          a !== "pending" && n - a > 12 && delete this._emitted[i];
        })),
        this._lastBlockNumber === -2 && (this._lastBlockNumber = n - 1),
        this._events.forEach((i) => {
          switch (i.type) {
            case "tx": {
              const a = i.hash;
              let s = this.getTransactionReceipt(a)
                .then(
                  (o) => (
                    !o ||
                      o.blockNumber == null ||
                      ((this._emitted["t:" + a] = o.blockNumber),
                      this.emit(a, o)),
                    null
                  )
                )
                .catch((o) => {
                  this.emit("error", o);
                });
              r.push(s);
              break;
            }
            case "filter": {
              if (!i._inflight) {
                (i._inflight = !0),
                  i._lastBlockNumber === -2 && (i._lastBlockNumber = n - 1);
                const a = i.filter;
                (a.fromBlock = i._lastBlockNumber + 1), (a.toBlock = n);
                const s = a.toBlock - this._maxFilterBlockRange;
                s > a.fromBlock && (a.fromBlock = s),
                  a.fromBlock < 0 && (a.fromBlock = 0);
                const o = this.getLogs(a)
                  .then((c) => {
                    (i._inflight = !1),
                      c.length !== 0 &&
                        c.forEach((u) => {
                          u.blockNumber > i._lastBlockNumber &&
                            (i._lastBlockNumber = u.blockNumber),
                            (this._emitted["b:" + u.blockHash] = u.blockNumber),
                            (this._emitted["t:" + u.transactionHash] =
                              u.blockNumber),
                            this.emit(a, u);
                        });
                  })
                  .catch((c) => {
                    this.emit("error", c), (i._inflight = !1);
                  });
                r.push(o);
              }
              break;
            }
          }
        }),
        (this._lastBlockNumber = n),
        Promise.all(r)
          .then(() => {
            this.emit("didPoll", e);
          })
          .catch((i) => {
            this.emit("error", i);
          });
    });
  }
  resetEventsBlock(e) {
    (this._lastBlockNumber = e - 1), this.polling && this.poll();
  }
  get network() {
    return this._network;
  }
  detectNetwork() {
    return vt(this, void 0, void 0, function* () {
      return Tt.throwError(
        "provider does not support network detection",
        ue.errors.UNSUPPORTED_OPERATION,
        {
          operation: "provider.detectNetwork",
        }
      );
    });
  }
  getNetwork() {
    return vt(this, void 0, void 0, function* () {
      const e = yield this._ready(),
        r = yield this.detectNetwork();
      if (e.chainId !== r.chainId) {
        if (this.anyNetwork)
          return (
            (this._network = r),
            (this._lastBlockNumber = -2),
            (this._fastBlockNumber = null),
            (this._fastBlockNumberPromise = null),
            (this._fastQueryDate = 0),
            (this._emitted.block = -2),
            (this._maxInternalBlockNumber = -1024),
            (this._internalBlockNumber = null),
            this.emit("network", r, e),
            yield Xk(0),
            this._network
          );
        const n = Tt.makeError(
          "underlying network changed",
          ue.errors.NETWORK_ERROR,
          {
            event: "changed",
            network: e,
            detectedNetwork: r,
          }
        );
        throw (this.emit("error", n), n);
      }
      return e;
    });
  }
  get blockNumber() {
    return (
      this._getInternalBlockNumber(100 + this.pollingInterval / 2).then(
        (e) => {
          this._setFastBlockNumber(e);
        },
        (e) => {}
      ),
      this._fastBlockNumber != null ? this._fastBlockNumber : -1
    );
  }
  get polling() {
    return this._poller != null;
  }
  set polling(e) {
    e && !this._poller
      ? ((this._poller = setInterval(() => {
          this.poll();
        }, this.pollingInterval)),
        this._bootstrapPoll ||
          (this._bootstrapPoll = setTimeout(() => {
            this.poll(),
              (this._bootstrapPoll = setTimeout(() => {
                this._poller || this.poll(), (this._bootstrapPoll = null);
              }, this.pollingInterval));
          }, 0)))
      : !e &&
        this._poller &&
        (clearInterval(this._poller), (this._poller = null));
  }
  get pollingInterval() {
    return this._pollingInterval;
  }
  set pollingInterval(e) {
    if (typeof e != "number" || e <= 0 || parseInt(String(e)) != e)
      throw new Error("invalid polling interval");
    (this._pollingInterval = e),
      this._poller &&
        (clearInterval(this._poller),
        (this._poller = setInterval(() => {
          this.poll();
        }, this._pollingInterval)));
  }
  _getFastBlockNumber() {
    const e = Yd();
    return (
      e - this._fastQueryDate > 2 * this._pollingInterval &&
        ((this._fastQueryDate = e),
        (this._fastBlockNumberPromise = this.getBlockNumber().then(
          (r) => (
            (this._fastBlockNumber == null || r > this._fastBlockNumber) &&
              (this._fastBlockNumber = r),
            this._fastBlockNumber
          )
        ))),
      this._fastBlockNumberPromise
    );
  }
  _setFastBlockNumber(e) {
    (this._fastBlockNumber != null && e < this._fastBlockNumber) ||
      ((this._fastQueryDate = Yd()),
      (this._fastBlockNumber == null || e > this._fastBlockNumber) &&
        ((this._fastBlockNumber = e),
        (this._fastBlockNumberPromise = Promise.resolve(e))));
  }
  waitForTransaction(e, r, n) {
    return vt(this, void 0, void 0, function* () {
      return this._waitForTransaction(e, r ?? 1, n || 0, null);
    });
  }
  _waitForTransaction(e, r, n, i) {
    return vt(this, void 0, void 0, function* () {
      const a = yield this.getTransactionReceipt(e);
      return (a ? a.confirmations : 0) >= r
        ? a
        : new Promise((s, o) => {
            const c = [];
            let u = !1;
            const d = function () {
                return u
                  ? !0
                  : ((u = !0),
                    c.forEach((v) => {
                      v();
                    }),
                    !1);
              },
              m = (v) => {
                v.confirmations < r || d() || s(v);
              };
            if (
              (this.on(e, m),
              c.push(() => {
                this.removeListener(e, m);
              }),
              i)
            ) {
              let v = i.startBlock,
                E = null;
              const A = (I) =>
                vt(this, void 0, void 0, function* () {
                  u ||
                    (yield Xk(1e3),
                    this.getTransactionCount(i.from).then(
                      (b) =>
                        vt(this, void 0, void 0, function* () {
                          if (!u) {
                            if (b <= i.nonce) v = I;
                            else {
                              {
                                const w = yield this.getTransaction(e);
                                if (w && w.blockNumber != null) return;
                              }
                              for (
                                E == null &&
                                ((E = v - 3),
                                E < i.startBlock && (E = i.startBlock));
                                E <= I;

                              ) {
                                if (u) return;
                                const w = yield this.getBlockWithTransactions(
                                  E
                                );
                                for (
                                  let S = 0;
                                  S < w.transactions.length;
                                  S++
                                ) {
                                  const k = w.transactions[S];
                                  if (k.hash === e) return;
                                  if (
                                    k.from === i.from &&
                                    k.nonce === i.nonce
                                  ) {
                                    if (u) return;
                                    const N = yield this.waitForTransaction(
                                      k.hash,
                                      r
                                    );
                                    if (d()) return;
                                    let O = "replaced";
                                    k.data === i.data &&
                                    k.to === i.to &&
                                    k.value.eq(i.value)
                                      ? (O = "repriced")
                                      : k.data === "0x" &&
                                        k.from === k.to &&
                                        k.value.isZero() &&
                                        (O = "cancelled"),
                                      o(
                                        Tt.makeError(
                                          "transaction was replaced",
                                          ue.errors.TRANSACTION_REPLACED,
                                          {
                                            cancelled:
                                              O === "replaced" ||
                                              O === "cancelled",
                                            reason: O,
                                            replacement:
                                              this._wrapTransaction(k),
                                            hash: e,
                                            receipt: N,
                                          }
                                        )
                                      );
                                    return;
                                  }
                                }
                                E++;
                              }
                            }
                            u || this.once("block", A);
                          }
                        }),
                      (b) => {
                        u || this.once("block", A);
                      }
                    ));
                });
              if (u) return;
              this.once("block", A),
                c.push(() => {
                  this.removeListener("block", A);
                });
            }
            if (typeof n == "number" && n > 0) {
              const v = setTimeout(() => {
                d() ||
                  o(
                    Tt.makeError("timeout exceeded", ue.errors.TIMEOUT, {
                      timeout: n,
                    })
                  );
              }, n);
              v.unref && v.unref(),
                c.push(() => {
                  clearTimeout(v);
                });
            }
          });
    });
  }
  getBlockNumber() {
    return vt(this, void 0, void 0, function* () {
      return this._getInternalBlockNumber(0);
    });
  }
  getGasPrice() {
    return vt(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const e = yield this.perform("getGasPrice", {});
      try {
        return ae.from(e);
      } catch (r) {
        return Tt.throwError(
          "bad result from backend",
          ue.errors.SERVER_ERROR,
          {
            method: "getGasPrice",
            result: e,
            error: r,
          }
        );
      }
    });
  }
  getBalance(e, r) {
    return vt(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const n = yield en({
          address: this._getAddress(e),
          blockTag: this._getBlockTag(r),
        }),
        i = yield this.perform("getBalance", n);
      try {
        return ae.from(i);
      } catch (a) {
        return Tt.throwError(
          "bad result from backend",
          ue.errors.SERVER_ERROR,
          {
            method: "getBalance",
            params: n,
            result: i,
            error: a,
          }
        );
      }
    });
  }
  getTransactionCount(e, r) {
    return vt(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const n = yield en({
          address: this._getAddress(e),
          blockTag: this._getBlockTag(r),
        }),
        i = yield this.perform("getTransactionCount", n);
      try {
        return ae.from(i).toNumber();
      } catch (a) {
        return Tt.throwError(
          "bad result from backend",
          ue.errors.SERVER_ERROR,
          {
            method: "getTransactionCount",
            params: n,
            result: i,
            error: a,
          }
        );
      }
    });
  }
  getCode(e, r) {
    return vt(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const n = yield en({
          address: this._getAddress(e),
          blockTag: this._getBlockTag(r),
        }),
        i = yield this.perform("getCode", n);
      try {
        return Ke(i);
      } catch (a) {
        return Tt.throwError(
          "bad result from backend",
          ue.errors.SERVER_ERROR,
          {
            method: "getCode",
            params: n,
            result: i,
            error: a,
          }
        );
      }
    });
  }
  getStorageAt(e, r, n) {
    return vt(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const i = yield en({
          address: this._getAddress(e),
          blockTag: this._getBlockTag(n),
          position: Promise.resolve(r).then((s) => Dm(s)),
        }),
        a = yield this.perform("getStorageAt", i);
      try {
        return Ke(a);
      } catch (s) {
        return Tt.throwError(
          "bad result from backend",
          ue.errors.SERVER_ERROR,
          {
            method: "getStorageAt",
            params: i,
            result: a,
            error: s,
          }
        );
      }
    });
  }
  _wrapTransaction(e, r, n) {
    if (r != null && za(r) !== 32)
      throw new Error("invalid response - sendTransaction");
    const i = e;
    return (
      r != null &&
        e.hash !== r &&
        Tt.throwError(
          "Transaction hash mismatch from Provider.sendTransaction.",
          ue.errors.UNKNOWN_ERROR,
          {
            expectedHash: e.hash,
            returnedHash: r,
          }
        ),
      (i.wait = (a, s) =>
        vt(this, void 0, void 0, function* () {
          a == null && (a = 1), s == null && (s = 0);
          let o;
          a !== 0 &&
            n != null &&
            (o = {
              data: e.data,
              from: e.from,
              nonce: e.nonce,
              to: e.to,
              value: e.value,
              startBlock: n,
            });
          const c = yield this._waitForTransaction(e.hash, a, s, o);
          return c == null && a === 0
            ? null
            : ((this._emitted["t:" + e.hash] = c.blockNumber),
              c.status === 0 &&
                Tt.throwError("transaction failed", ue.errors.CALL_EXCEPTION, {
                  transactionHash: e.hash,
                  transaction: e,
                  receipt: c,
                }),
              c);
        })),
      i
    );
  }
  sendTransaction(e) {
    return vt(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const r = yield Promise.resolve(e).then((a) => Ke(a)),
        n = this.formatter.transaction(e);
      n.confirmations == null && (n.confirmations = 0);
      const i = yield this._getInternalBlockNumber(
        100 + 2 * this.pollingInterval
      );
      try {
        const a = yield this.perform("sendTransaction", {
          signedTransaction: r,
        });
        return this._wrapTransaction(n, a, i);
      } catch (a) {
        throw ((a.transaction = n), (a.transactionHash = n.hash), a);
      }
    });
  }
  _getTransactionRequest(e) {
    return vt(this, void 0, void 0, function* () {
      const r = yield e,
        n = {};
      return (
        ["from", "to"].forEach((i) => {
          r[i] != null &&
            (n[i] = Promise.resolve(r[i]).then((a) =>
              a ? this._getAddress(a) : null
            ));
        }),
        [
          "gasLimit",
          "gasPrice",
          "maxFeePerGas",
          "maxPriorityFeePerGas",
          "value",
        ].forEach((i) => {
          r[i] != null &&
            (n[i] = Promise.resolve(r[i]).then((a) => (a ? ae.from(a) : null)));
        }),
        ["type"].forEach((i) => {
          r[i] != null && (n[i] = Promise.resolve(r[i]).then((a) => a ?? null));
        }),
        r.accessList &&
          (n.accessList = this.formatter.accessList(r.accessList)),
        ["data"].forEach((i) => {
          r[i] != null &&
            (n[i] = Promise.resolve(r[i]).then((a) => (a ? Ke(a) : null)));
        }),
        this.formatter.transactionRequest(yield en(n))
      );
    });
  }
  _getFilter(e) {
    return vt(this, void 0, void 0, function* () {
      e = yield e;
      const r = {};
      return (
        e.address != null && (r.address = this._getAddress(e.address)),
        ["blockHash", "topics"].forEach((n) => {
          e[n] != null && (r[n] = e[n]);
        }),
        ["fromBlock", "toBlock"].forEach((n) => {
          e[n] != null && (r[n] = this._getBlockTag(e[n]));
        }),
        this.formatter.filter(yield en(r))
      );
    });
  }
  _call(e, r, n) {
    return vt(this, void 0, void 0, function* () {
      n >= zte &&
        Tt.throwError(
          "CCIP read exceeded maximum redirections",
          ue.errors.SERVER_ERROR,
          {
            redirects: n,
            transaction: e,
          }
        );
      const i = e.to,
        a = yield this.perform("call", {
          transaction: e,
          blockTag: r,
        });
      if (
        n >= 0 &&
        r === "latest" &&
        i != null &&
        a.substring(0, 10) === "0x556f1830" &&
        za(a) % 32 === 4
      )
        try {
          const s = sn(a, 4),
            o = sn(s, 0, 32);
          ae.from(o).eq(i) ||
            Tt.throwError(
              "CCIP Read sender did not match",
              ue.errors.CALL_EXCEPTION,
              {
                name: "OffchainLookup",
                signature:
                  "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                transaction: e,
                data: a,
              }
            );
          const c = [],
            u = ae.from(sn(s, 32, 64)).toNumber(),
            d = ae.from(sn(s, u, u + 32)).toNumber(),
            m = sn(s, u + 32);
          for (let w = 0; w < d; w++) {
            const S = Jy(m, w * 32);
            S == null &&
              Tt.throwError(
                "CCIP Read contained corrupt URL string",
                ue.errors.CALL_EXCEPTION,
                {
                  name: "OffchainLookup",
                  signature:
                    "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                  transaction: e,
                  data: a,
                }
              ),
              c.push(S);
          }
          const v = zp(s, 64);
          ae.from(sn(s, 100, 128)).isZero() ||
            Tt.throwError(
              "CCIP Read callback selector included junk",
              ue.errors.CALL_EXCEPTION,
              {
                name: "OffchainLookup",
                signature:
                  "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                transaction: e,
                data: a,
              }
            );
          const E = sn(s, 96, 100),
            A = zp(s, 128),
            I = yield this.ccipReadFetch(e, v, c);
          I == null &&
            Tt.throwError(
              "CCIP Read disabled or provided no URLs",
              ue.errors.CALL_EXCEPTION,
              {
                name: "OffchainLookup",
                signature:
                  "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                transaction: e,
                data: a,
              }
            );
          const b = {
            to: i,
            data: Ti([E, KD([I, A])]),
          };
          return this._call(b, r, n + 1);
        } catch (s) {
          if (s.code === ue.errors.SERVER_ERROR) throw s;
        }
      try {
        return Ke(a);
      } catch (s) {
        return Tt.throwError(
          "bad result from backend",
          ue.errors.SERVER_ERROR,
          {
            method: "call",
            params: {
              transaction: e,
              blockTag: r,
            },
            result: a,
            error: s,
          }
        );
      }
    });
  }
  call(e, r) {
    return vt(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const n = yield en({
        transaction: this._getTransactionRequest(e),
        blockTag: this._getBlockTag(r),
        ccipReadEnabled: Promise.resolve(e.ccipReadEnabled),
      });
      return this._call(n.transaction, n.blockTag, n.ccipReadEnabled ? 0 : -1);
    });
  }
  estimateGas(e) {
    return vt(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const r = yield en({
          transaction: this._getTransactionRequest(e),
        }),
        n = yield this.perform("estimateGas", r);
      try {
        return ae.from(n);
      } catch (i) {
        return Tt.throwError(
          "bad result from backend",
          ue.errors.SERVER_ERROR,
          {
            method: "estimateGas",
            params: r,
            result: n,
            error: i,
          }
        );
      }
    });
  }
  _getAddress(e) {
    return vt(this, void 0, void 0, function* () {
      (e = yield e),
        typeof e != "string" &&
          Tt.throwArgumentError("invalid address or ENS name", "name", e);
      const r = yield this.resolveName(e);
      return (
        r == null &&
          Tt.throwError(
            "ENS name not configured",
            ue.errors.UNSUPPORTED_OPERATION,
            {
              operation: `resolveName(${JSON.stringify(e)})`,
            }
          ),
        r
      );
    });
  }
  _getBlock(e, r) {
    return vt(this, void 0, void 0, function* () {
      yield this.getNetwork(), (e = yield e);
      let n = -128;
      const i = {
        includeTransactions: !!r,
      };
      if (gt(e, 32)) i.blockHash = e;
      else
        try {
          (i.blockTag = yield this._getBlockTag(e)),
            gt(i.blockTag) && (n = parseInt(i.blockTag.substring(2), 16));
        } catch {
          Tt.throwArgumentError(
            "invalid block hash or block tag",
            "blockHashOrBlockTag",
            e
          );
        }
      return ql(
        () =>
          vt(this, void 0, void 0, function* () {
            const a = yield this.perform("getBlock", i);
            if (a == null)
              return (i.blockHash != null &&
                this._emitted["b:" + i.blockHash] == null) ||
                (i.blockTag != null && n > this._emitted.block)
                ? null
                : void 0;
            if (r) {
              let s = null;
              for (let c = 0; c < a.transactions.length; c++) {
                const u = a.transactions[c];
                if (u.blockNumber == null) u.confirmations = 0;
                else if (u.confirmations == null) {
                  s == null &&
                    (s = yield this._getInternalBlockNumber(
                      100 + 2 * this.pollingInterval
                    ));
                  let d = s - u.blockNumber + 1;
                  d <= 0 && (d = 1), (u.confirmations = d);
                }
              }
              const o = this.formatter.blockWithTransactions(a);
              return (
                (o.transactions = o.transactions.map((c) =>
                  this._wrapTransaction(c)
                )),
                o
              );
            }
            return this.formatter.block(a);
          }),
        {
          oncePoll: this,
        }
      );
    });
  }
  getBlock(e) {
    return this._getBlock(e, !1);
  }
  getBlockWithTransactions(e) {
    return this._getBlock(e, !0);
  }
  getTransaction(e) {
    return vt(this, void 0, void 0, function* () {
      yield this.getNetwork(), (e = yield e);
      const r = {
        transactionHash: this.formatter.hash(e, !0),
      };
      return ql(
        () =>
          vt(this, void 0, void 0, function* () {
            const n = yield this.perform("getTransaction", r);
            if (n == null)
              return this._emitted["t:" + e] == null ? null : void 0;
            const i = this.formatter.transactionResponse(n);
            if (i.blockNumber == null) i.confirmations = 0;
            else if (i.confirmations == null) {
              let s =
                (yield this._getInternalBlockNumber(
                  100 + 2 * this.pollingInterval
                )) -
                i.blockNumber +
                1;
              s <= 0 && (s = 1), (i.confirmations = s);
            }
            return this._wrapTransaction(i);
          }),
        {
          oncePoll: this,
        }
      );
    });
  }
  getTransactionReceipt(e) {
    return vt(this, void 0, void 0, function* () {
      yield this.getNetwork(), (e = yield e);
      const r = {
        transactionHash: this.formatter.hash(e, !0),
      };
      return ql(
        () =>
          vt(this, void 0, void 0, function* () {
            const n = yield this.perform("getTransactionReceipt", r);
            if (n == null)
              return this._emitted["t:" + e] == null ? null : void 0;
            if (n.blockHash == null) return;
            const i = this.formatter.receipt(n);
            if (i.blockNumber == null) i.confirmations = 0;
            else if (i.confirmations == null) {
              let s =
                (yield this._getInternalBlockNumber(
                  100 + 2 * this.pollingInterval
                )) -
                i.blockNumber +
                1;
              s <= 0 && (s = 1), (i.confirmations = s);
            }
            return i;
          }),
        {
          oncePoll: this,
        }
      );
    });
  }
  getLogs(e) {
    return vt(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const r = yield en({
          filter: this._getFilter(e),
        }),
        n = yield this.perform("getLogs", r);
      return (
        n.forEach((i) => {
          i.removed == null && (i.removed = !1);
        }),
        at.arrayOf(this.formatter.filterLog.bind(this.formatter))(n)
      );
    });
  }
  getEtherPrice() {
    return vt(this, void 0, void 0, function* () {
      return yield this.getNetwork(), this.perform("getEtherPrice", {});
    });
  }
  _getBlockTag(e) {
    return vt(this, void 0, void 0, function* () {
      if (((e = yield e), typeof e == "number" && e < 0)) {
        e % 1 && Tt.throwArgumentError("invalid BlockTag", "blockTag", e);
        let r = yield this._getInternalBlockNumber(
          100 + 2 * this.pollingInterval
        );
        return (r += e), r < 0 && (r = 0), this.formatter.blockTag(r);
      }
      return this.formatter.blockTag(e);
    });
  }
  getResolver(e) {
    return vt(this, void 0, void 0, function* () {
      let r = e;
      for (;;) {
        if (r === "" || r === "." || (e !== "eth" && r === "eth")) return null;
        const n = yield this._getResolver(r, "getResolver");
        if (n != null) {
          const i = new nS(this, n, e);
          return r !== e && !(yield i.supportsWildcard()) ? null : i;
        }
        r = r.split(".").slice(1).join(".");
      }
    });
  }
  _getResolver(e, r) {
    return vt(this, void 0, void 0, function* () {
      r == null && (r = "ENS");
      const n = yield this.getNetwork();
      n.ensAddress ||
        Tt.throwError(
          "network does not support ENS",
          ue.errors.UNSUPPORTED_OPERATION,
          {
            operation: r,
            network: n.name,
          }
        );
      try {
        const i = yield this.call({
          to: n.ensAddress,
          data: "0x0178b8bf" + Lh(e).substring(2),
        });
        return this.formatter.callAddress(i);
      } catch {}
      return null;
    });
  }
  resolveName(e) {
    return vt(this, void 0, void 0, function* () {
      e = yield e;
      try {
        return Promise.resolve(this.formatter.address(e));
      } catch (n) {
        if (gt(e)) throw n;
      }
      typeof e != "string" &&
        Tt.throwArgumentError("invalid ENS name", "name", e);
      const r = yield this.getResolver(e);
      return r ? yield r.getAddress() : null;
    });
  }
  lookupAddress(e) {
    return vt(this, void 0, void 0, function* () {
      (e = yield e), (e = this.formatter.address(e));
      const r = e.substring(2).toLowerCase() + ".addr.reverse",
        n = yield this._getResolver(r, "lookupAddress");
      if (n == null) return null;
      const i = Jy(
        yield this.call({
          to: n,
          data: "0x691f3431" + Lh(r).substring(2),
        }),
        0
      );
      return (yield this.resolveName(i)) != e ? null : i;
    });
  }
  getAvatar(e) {
    return vt(this, void 0, void 0, function* () {
      let r = null;
      if (gt(e)) {
        const a =
            this.formatter.address(e).substring(2).toLowerCase() +
            ".addr.reverse",
          s = yield this._getResolver(a, "getAvatar");
        if (!s) return null;
        r = new nS(this, s, a);
        try {
          const o = yield r.getAvatar();
          if (o) return o.url;
        } catch (o) {
          if (o.code !== ue.errors.CALL_EXCEPTION) throw o;
        }
        try {
          const o = Jy(
            yield this.call({
              to: s,
              data: "0x691f3431" + Lh(a).substring(2),
            }),
            0
          );
          r = yield this.getResolver(o);
        } catch (o) {
          if (o.code !== ue.errors.CALL_EXCEPTION) throw o;
          return null;
        }
      } else if (((r = yield this.getResolver(e)), !r)) return null;
      const n = yield r.getAvatar();
      return n == null ? null : n.url;
    });
  }
  perform(e, r) {
    return Tt.throwError(e + " not implemented", ue.errors.NOT_IMPLEMENTED, {
      operation: e,
    });
  }
  _startEvent(e) {
    this.polling = this._events.filter((r) => r.pollable()).length > 0;
  }
  _stopEvent(e) {
    this.polling = this._events.filter((r) => r.pollable()).length > 0;
  }
  _addEventListener(e, r, n) {
    const i = new Kte(Qu(e), r, n);
    return this._events.push(i), this._startEvent(i), this;
  }
  on(e, r) {
    return this._addEventListener(e, r, !1);
  }
  once(e, r) {
    return this._addEventListener(e, r, !0);
  }
  emit(e, ...r) {
    let n = !1,
      i = [],
      a = Qu(e);
    return (
      (this._events = this._events.filter((s) =>
        s.tag !== a
          ? !0
          : (setTimeout(() => {
              s.listener.apply(this, r);
            }, 0),
            (n = !0),
            s.once ? (i.push(s), !1) : !0)
      )),
      i.forEach((s) => {
        this._stopEvent(s);
      }),
      n
    );
  }
  listenerCount(e) {
    if (!e) return this._events.length;
    let r = Qu(e);
    return this._events.filter((n) => n.tag === r).length;
  }
  listeners(e) {
    if (e == null) return this._events.map((n) => n.listener);
    let r = Qu(e);
    return this._events.filter((n) => n.tag === r).map((n) => n.listener);
  }
  off(e, r) {
    if (r == null) return this.removeAllListeners(e);
    const n = [];
    let i = !1,
      a = Qu(e);
    return (
      (this._events = this._events.filter((s) =>
        s.tag !== a || s.listener != r || i ? !0 : ((i = !0), n.push(s), !1)
      )),
      n.forEach((s) => {
        this._stopEvent(s);
      }),
      this
    );
  }
  removeAllListeners(e) {
    let r = [];
    if (e == null) (r = this._events), (this._events = []);
    else {
      const n = Qu(e);
      this._events = this._events.filter((i) =>
        i.tag !== n ? !0 : (r.push(i), !1)
      );
    }
    return (
      r.forEach((n) => {
        this._stopEvent(n);
      }),
      this
    );
  }
}
var So = function (t, e, r, n) {
  function i(a) {
    return a instanceof r
      ? a
      : new r(function (s) {
          s(a);
        });
  }
  return new (r || (r = Promise))(function (a, s) {
    function o(d) {
      try {
        u(n.next(d));
      } catch (m) {
        s(m);
      }
    }
    function c(d) {
      try {
        u(n.throw(d));
      } catch (m) {
        s(m);
      }
    }
    function u(d) {
      d.done ? a(d.value) : i(d.value).then(o, c);
    }
    u((n = n.apply(t, e || [])).next());
  });
};
const un = new ue(gi),
  Qte = ["call", "estimateGas"];
function Wh(t, e) {
  if (t == null) return null;
  if (typeof t.message == "string" && t.message.match("reverted")) {
    const r = gt(t.data) ? t.data : null;
    if (!e || r)
      return {
        message: t.message,
        data: r,
      };
  }
  if (typeof t == "object") {
    for (const r in t) {
      const n = Wh(t[r], e);
      if (n) return n;
    }
    return null;
  }
  if (typeof t == "string")
    try {
      return Wh(JSON.parse(t), e);
    } catch {}
  return null;
}
function GD(t, e, r) {
  const n = r.transaction || r.signedTransaction;
  if (t === "call") {
    const a = Wh(e, !0);
    if (a) return a.data;
    un.throwError(
      "missing revert data in call exception; Transaction reverted without a reason string",
      ue.errors.CALL_EXCEPTION,
      {
        data: "0x",
        transaction: n,
        error: e,
      }
    );
  }
  if (t === "estimateGas") {
    let a = Wh(e.body, !1);
    a == null && (a = Wh(e, !1)),
      a &&
        un.throwError(
          "cannot estimate gas; transaction may fail or may require manual gas limit",
          ue.errors.UNPREDICTABLE_GAS_LIMIT,
          {
            reason: a.message,
            method: t,
            transaction: n,
            error: e,
          }
        );
  }
  let i = e.message;
  throw (
    (e.code === ue.errors.SERVER_ERROR &&
    e.error &&
    typeof e.error.message == "string"
      ? (i = e.error.message)
      : typeof e.body == "string"
      ? (i = e.body)
      : typeof e.responseText == "string" && (i = e.responseText),
    (i = (i || "").toLowerCase()),
    i.match(
      /insufficient funds|base fee exceeds gas limit|InsufficientFunds/i
    ) &&
      un.throwError(
        "insufficient funds for intrinsic transaction cost",
        ue.errors.INSUFFICIENT_FUNDS,
        {
          error: e,
          method: t,
          transaction: n,
        }
      ),
    i.match(/nonce (is )?too low/i) &&
      un.throwError("nonce has already been used", ue.errors.NONCE_EXPIRED, {
        error: e,
        method: t,
        transaction: n,
      }),
    i.match(
      /replacement transaction underpriced|transaction gas price.*too low/i
    ) &&
      un.throwError(
        "replacement fee too low",
        ue.errors.REPLACEMENT_UNDERPRICED,
        {
          error: e,
          method: t,
          transaction: n,
        }
      ),
    i.match(/only replay-protected/i) &&
      un.throwError(
        "legacy pre-eip-155 transactions not supported",
        ue.errors.UNSUPPORTED_OPERATION,
        {
          error: e,
          method: t,
          transaction: n,
        }
      ),
    Qte.indexOf(t) >= 0 &&
      i.match(
        /gas required exceeds allowance|always failing transaction|execution reverted|revert/
      ) &&
      un.throwError(
        "cannot estimate gas; transaction may fail or may require manual gas limit",
        ue.errors.UNPREDICTABLE_GAS_LIMIT,
        {
          error: e,
          method: t,
          transaction: n,
        }
      ),
    e)
  );
}
function iS(t) {
  return new Promise(function (e) {
    setTimeout(e, t);
  });
}
function Yte(t) {
  if (t.error) {
    const e = new Error(t.error.message);
    throw ((e.code = t.error.code), (e.data = t.error.data), e);
  }
  return t.result;
}
function Xd(t) {
  return t && t.toLowerCase();
}
const d_ = {};
class ZD extends Nu {
  constructor(e, r, n) {
    if ((super(), e !== d_))
      throw new Error(
        "do not call the JsonRpcSigner constructor directly; use provider.getSigner"
      );
    _e(this, "provider", r),
      n == null && (n = 0),
      typeof n == "string"
        ? (_e(this, "_address", this.provider.formatter.address(n)),
          _e(this, "_index", null))
        : typeof n == "number"
        ? (_e(this, "_index", n), _e(this, "_address", null))
        : un.throwArgumentError(
            "invalid address or index",
            "addressOrIndex",
            n
          );
  }
  connect(e) {
    return un.throwError(
      "cannot alter JSON-RPC Signer connection",
      ue.errors.UNSUPPORTED_OPERATION,
      {
        operation: "connect",
      }
    );
  }
  connectUnchecked() {
    return new Xte(d_, this.provider, this._address || this._index);
  }
  getAddress() {
    return this._address
      ? Promise.resolve(this._address)
      : this.provider.send("eth_accounts", []).then(
          (e) => (
            e.length <= this._index &&
              un.throwError(
                "unknown account #" + this._index,
                ue.errors.UNSUPPORTED_OPERATION,
                {
                  operation: "getAddress",
                }
              ),
            this.provider.formatter.address(e[this._index])
          )
        );
  }
  sendUncheckedTransaction(e) {
    e = vr(e);
    const r = this.getAddress().then((n) => (n && (n = n.toLowerCase()), n));
    if (e.gasLimit == null) {
      const n = vr(e);
      (n.from = r), (e.gasLimit = this.provider.estimateGas(n));
    }
    return (
      e.to != null &&
        (e.to = Promise.resolve(e.to).then((n) =>
          So(this, void 0, void 0, function* () {
            if (n == null) return null;
            const i = yield this.provider.resolveName(n);
            return (
              i == null &&
                un.throwArgumentError(
                  "provided ENS name resolves to null",
                  "tx.to",
                  n
                ),
              i
            );
          })
        )),
      en({
        tx: en(e),
        sender: r,
      }).then(({ tx: n, sender: i }) => {
        n.from != null
          ? n.from.toLowerCase() !== i &&
            un.throwArgumentError("from address mismatch", "transaction", e)
          : (n.from = i);
        const a = this.provider.constructor.hexlifyTransaction(n, {
          from: !0,
        });
        return this.provider.send("eth_sendTransaction", [a]).then(
          (s) => s,
          (s) => (
            typeof s.message == "string" &&
              s.message.match(/user denied/i) &&
              un.throwError(
                "user rejected transaction",
                ue.errors.ACTION_REJECTED,
                {
                  action: "sendTransaction",
                  transaction: n,
                }
              ),
            GD("sendTransaction", s, a)
          )
        );
      })
    );
  }
  signTransaction(e) {
    return un.throwError(
      "signing transactions is unsupported",
      ue.errors.UNSUPPORTED_OPERATION,
      {
        operation: "signTransaction",
      }
    );
  }
  sendTransaction(e) {
    return So(this, void 0, void 0, function* () {
      const r = yield this.provider._getInternalBlockNumber(
          100 + 2 * this.provider.pollingInterval
        ),
        n = yield this.sendUncheckedTransaction(e);
      try {
        return yield ql(
          () =>
            So(this, void 0, void 0, function* () {
              const i = yield this.provider.getTransaction(n);
              if (i !== null) return this.provider._wrapTransaction(i, n, r);
            }),
          {
            oncePoll: this.provider,
          }
        );
      } catch (i) {
        throw ((i.transactionHash = n), i);
      }
    });
  }
  signMessage(e) {
    return So(this, void 0, void 0, function* () {
      const r = typeof e == "string" ? Lt(e) : e,
        n = yield this.getAddress();
      try {
        return yield this.provider.send("personal_sign", [
          Ke(r),
          n.toLowerCase(),
        ]);
      } catch (i) {
        throw (
          (typeof i.message == "string" &&
            i.message.match(/user denied/i) &&
            un.throwError("user rejected signing", ue.errors.ACTION_REJECTED, {
              action: "signMessage",
              from: n,
              messageData: e,
            }),
          i)
        );
      }
    });
  }
  _legacySignMessage(e) {
    return So(this, void 0, void 0, function* () {
      const r = typeof e == "string" ? Lt(e) : e,
        n = yield this.getAddress();
      try {
        return yield this.provider.send("eth_sign", [n.toLowerCase(), Ke(r)]);
      } catch (i) {
        throw (
          (typeof i.message == "string" &&
            i.message.match(/user denied/i) &&
            un.throwError("user rejected signing", ue.errors.ACTION_REJECTED, {
              action: "_legacySignMessage",
              from: n,
              messageData: e,
            }),
          i)
        );
      }
    });
  }
  _signTypedData(e, r, n) {
    return So(this, void 0, void 0, function* () {
      const i = yield wn.resolveNames(e, r, n, (s) =>
          this.provider.resolveName(s)
        ),
        a = yield this.getAddress();
      try {
        return yield this.provider.send("eth_signTypedData_v4", [
          a.toLowerCase(),
          JSON.stringify(wn.getPayload(i.domain, r, i.value)),
        ]);
      } catch (s) {
        throw (
          (typeof s.message == "string" &&
            s.message.match(/user denied/i) &&
            un.throwError("user rejected signing", ue.errors.ACTION_REJECTED, {
              action: "_signTypedData",
              from: a,
              messageData: {
                domain: i.domain,
                types: r,
                value: i.value,
              },
            }),
          s)
        );
      }
    });
  }
  unlock(e) {
    return So(this, void 0, void 0, function* () {
      const r = this.provider,
        n = yield this.getAddress();
      return r.send("personal_unlockAccount", [n.toLowerCase(), e, null]);
    });
  }
}
class Xte extends ZD {
  sendTransaction(e) {
    return this.sendUncheckedTransaction(e).then((r) => ({
      hash: r,
      nonce: null,
      gasLimit: null,
      gasPrice: null,
      data: null,
      value: null,
      chainId: null,
      confirmations: 0,
      from: null,
      wait: (n) => this.provider.waitForTransaction(r, n),
    }));
  }
}
const ere = {
  chainId: !0,
  data: !0,
  gasLimit: !0,
  gasPrice: !0,
  nonce: !0,
  to: !0,
  value: !0,
  type: !0,
  accessList: !0,
  maxFeePerGas: !0,
  maxPriorityFeePerGas: !0,
};
class Af extends lE {
  constructor(e, r) {
    let n = r;
    n == null &&
      (n = new Promise((i, a) => {
        setTimeout(() => {
          this.detectNetwork().then(
            (s) => {
              i(s);
            },
            (s) => {
              a(s);
            }
          );
        }, 0);
      })),
      super(n),
      e || (e = qn(this.constructor, "defaultUrl")()),
      typeof e == "string"
        ? _e(
            this,
            "connection",
            Object.freeze({
              url: e,
            })
          )
        : _e(this, "connection", Object.freeze(vr(e))),
      (this._nextId = 42);
  }
  get _cache() {
    return (
      this._eventLoopCache == null && (this._eventLoopCache = {}),
      this._eventLoopCache
    );
  }
  static defaultUrl() {
    return "http://localhost:8545";
  }
  detectNetwork() {
    return (
      this._cache.detectNetwork ||
        ((this._cache.detectNetwork = this._uncachedDetectNetwork()),
        setTimeout(() => {
          this._cache.detectNetwork = null;
        }, 0)),
      this._cache.detectNetwork
    );
  }
  _uncachedDetectNetwork() {
    return So(this, void 0, void 0, function* () {
      yield iS(0);
      let e = null;
      try {
        e = yield this.send("eth_chainId", []);
      } catch {
        try {
          e = yield this.send("net_version", []);
        } catch {}
      }
      if (e != null) {
        const r = qn(this.constructor, "getNetwork");
        try {
          return r(ae.from(e).toNumber());
        } catch (n) {
          return un.throwError(
            "could not detect network",
            ue.errors.NETWORK_ERROR,
            {
              chainId: e,
              event: "invalidNetwork",
              serverError: n,
            }
          );
        }
      }
      return un.throwError(
        "could not detect network",
        ue.errors.NETWORK_ERROR,
        {
          event: "noNetwork",
        }
      );
    });
  }
  getSigner(e) {
    return new ZD(d_, this, e);
  }
  getUncheckedSigner(e) {
    return this.getSigner(e).connectUnchecked();
  }
  listAccounts() {
    return this.send("eth_accounts", []).then((e) =>
      e.map((r) => this.formatter.address(r))
    );
  }
  send(e, r) {
    const n = {
      method: e,
      params: r,
      id: this._nextId++,
      jsonrpc: "2.0",
    };
    this.emit("debug", {
      action: "request",
      request: fi(n),
      provider: this,
    });
    const i = ["eth_chainId", "eth_blockNumber"].indexOf(e) >= 0;
    if (i && this._cache[e]) return this._cache[e];
    const a = Ou(this.connection, JSON.stringify(n), Yte).then(
      (s) => (
        this.emit("debug", {
          action: "response",
          request: n,
          response: s,
          provider: this,
        }),
        s
      ),
      (s) => {
        throw (
          (this.emit("debug", {
            action: "response",
            error: s,
            request: n,
            provider: this,
          }),
          s)
        );
      }
    );
    return (
      i &&
        ((this._cache[e] = a),
        setTimeout(() => {
          this._cache[e] = null;
        }, 0)),
      a
    );
  }
  prepareRequest(e, r) {
    switch (e) {
      case "getBlockNumber":
        return ["eth_blockNumber", []];
      case "getGasPrice":
        return ["eth_gasPrice", []];
      case "getBalance":
        return ["eth_getBalance", [Xd(r.address), r.blockTag]];
      case "getTransactionCount":
        return ["eth_getTransactionCount", [Xd(r.address), r.blockTag]];
      case "getCode":
        return ["eth_getCode", [Xd(r.address), r.blockTag]];
      case "getStorageAt":
        return [
          "eth_getStorageAt",
          [Xd(r.address), Rt(r.position, 32), r.blockTag],
        ];
      case "sendTransaction":
        return ["eth_sendRawTransaction", [r.signedTransaction]];
      case "getBlock":
        return r.blockTag
          ? ["eth_getBlockByNumber", [r.blockTag, !!r.includeTransactions]]
          : r.blockHash
          ? ["eth_getBlockByHash", [r.blockHash, !!r.includeTransactions]]
          : null;
      case "getTransaction":
        return ["eth_getTransactionByHash", [r.transactionHash]];
      case "getTransactionReceipt":
        return ["eth_getTransactionReceipt", [r.transactionHash]];
      case "call":
        return [
          "eth_call",
          [
            qn(this.constructor, "hexlifyTransaction")(r.transaction, {
              from: !0,
            }),
            r.blockTag,
          ],
        ];
      case "estimateGas":
        return [
          "eth_estimateGas",
          [
            qn(this.constructor, "hexlifyTransaction")(r.transaction, {
              from: !0,
            }),
          ],
        ];
      case "getLogs":
        return (
          r.filter &&
            r.filter.address != null &&
            (r.filter.address = Xd(r.filter.address)),
          ["eth_getLogs", [r.filter]]
        );
    }
    return null;
  }
  perform(e, r) {
    return So(this, void 0, void 0, function* () {
      if (e === "call" || e === "estimateGas") {
        const i = r.transaction;
        if (
          i &&
          i.type != null &&
          ae.from(i.type).isZero() &&
          i.maxFeePerGas == null &&
          i.maxPriorityFeePerGas == null
        ) {
          const a = yield this.getFeeData();
          a.maxFeePerGas == null &&
            a.maxPriorityFeePerGas == null &&
            ((r = vr(r)), (r.transaction = vr(i)), delete r.transaction.type);
        }
      }
      const n = this.prepareRequest(e, r);
      n == null &&
        un.throwError(e + " not implemented", ue.errors.NOT_IMPLEMENTED, {
          operation: e,
        });
      try {
        return yield this.send(n[0], n[1]);
      } catch (i) {
        return GD(e, i, r);
      }
    });
  }
  _startEvent(e) {
    e.tag === "pending" && this._startPending(), super._startEvent(e);
  }
  _startPending() {
    if (this._pendingFilter != null) return;
    const e = this,
      r = this.send("eth_newPendingTransactionFilter", []);
    (this._pendingFilter = r),
      r
        .then(function (n) {
          function i() {
            e.send("eth_getFilterChanges", [n])
              .then(function (a) {
                if (e._pendingFilter != r) return null;
                let s = Promise.resolve();
                return (
                  a.forEach(function (o) {
                    (e._emitted["t:" + o.toLowerCase()] = "pending"),
                      (s = s.then(function () {
                        return e.getTransaction(o).then(function (c) {
                          return e.emit("pending", c), null;
                        });
                      }));
                  }),
                  s.then(function () {
                    return iS(1e3);
                  })
                );
              })
              .then(function () {
                if (e._pendingFilter != r) {
                  e.send("eth_uninstallFilter", [n]);
                  return;
                }
                return (
                  setTimeout(function () {
                    i();
                  }, 0),
                  null
                );
              })
              .catch((a) => {});
          }
          return i(), n;
        })
        .catch((n) => {});
  }
  _stopEvent(e) {
    e.tag === "pending" &&
      this.listenerCount("pending") === 0 &&
      (this._pendingFilter = null),
      super._stopEvent(e);
  }
  static hexlifyTransaction(e, r) {
    const n = vr(ere);
    if (r) for (const a in r) r[a] && (n[a] = !0);
    H8(e, n);
    const i = {};
    return (
      [
        "chainId",
        "gasLimit",
        "gasPrice",
        "type",
        "maxFeePerGas",
        "maxPriorityFeePerGas",
        "nonce",
        "value",
      ].forEach(function (a) {
        if (e[a] == null) return;
        const s = Dm(ae.from(e[a]));
        a === "gasLimit" && (a = "gas"), (i[a] = s);
      }),
      ["from", "to", "data"].forEach(function (a) {
        e[a] != null && (i[a] = Ke(e[a]));
      }),
      e.accessList && (i.accessList = yl(e.accessList)),
      i
    );
  }
}
let jh = null;
try {
  if (((jh = WebSocket), jh == null)) throw new Error("inject please");
} catch {
  const e = new ue(gi);
  jh = function () {
    e.throwError(
      "WebSockets not supported in this environment",
      ue.errors.UNSUPPORTED_OPERATION,
      {
        operation: "new WebSocket()",
      }
    );
  };
}
var n3 = function (t, e, r, n) {
  function i(a) {
    return a instanceof r
      ? a
      : new r(function (s) {
          s(a);
        });
  }
  return new (r || (r = Promise))(function (a, s) {
    function o(d) {
      try {
        u(n.next(d));
      } catch (m) {
        s(m);
      }
    }
    function c(d) {
      try {
        u(n.throw(d));
      } catch (m) {
        s(m);
      }
    }
    function u(d) {
      d.done ? a(d.value) : i(d.value).then(o, c);
    }
    u((n = n.apply(t, e || [])).next());
  });
};
const ey = new ue(gi);
let tre = 1;
class cv extends Af {
  constructor(e, r) {
    r === "any" &&
      ey.throwError(
        "WebSocketProvider does not support 'any' network yet",
        ue.errors.UNSUPPORTED_OPERATION,
        {
          operation: "network:any",
        }
      ),
      typeof e == "string" ? super(e, r) : super("_websocket", r),
      (this._pollingInterval = -1),
      (this._wsReady = !1),
      typeof e == "string"
        ? _e(this, "_websocket", new jh(this.connection.url))
        : _e(this, "_websocket", e),
      _e(this, "_requests", {}),
      _e(this, "_subs", {}),
      _e(this, "_subIds", {}),
      _e(this, "_detectNetwork", super.detectNetwork()),
      (this.websocket.onopen = () => {
        (this._wsReady = !0),
          Object.keys(this._requests).forEach((i) => {
            this.websocket.send(this._requests[i].payload);
          });
      }),
      (this.websocket.onmessage = (i) => {
        const a = i.data,
          s = JSON.parse(a);
        if (s.id != null) {
          const o = String(s.id),
            c = this._requests[o];
          if ((delete this._requests[o], s.result !== void 0))
            c.callback(null, s.result),
              this.emit("debug", {
                action: "response",
                request: JSON.parse(c.payload),
                response: s.result,
                provider: this,
              });
          else {
            let u = null;
            s.error
              ? ((u = new Error(s.error.message || "unknown error")),
                _e(u, "code", s.error.code || null),
                _e(u, "response", a))
              : (u = new Error("unknown error")),
              c.callback(u, void 0),
              this.emit("debug", {
                action: "response",
                error: u,
                request: JSON.parse(c.payload),
                provider: this,
              });
          }
        } else if (s.method === "eth_subscription") {
          const o = this._subs[s.params.subscription];
          o && o.processFunc(s.params.result);
        } else console.warn("this should not happen");
      });
    const n = setInterval(() => {
      this.emit("poll");
    }, 1e3);
    n.unref && n.unref();
  }
  get websocket() {
    return this._websocket;
  }
  detectNetwork() {
    return this._detectNetwork;
  }
  get pollingInterval() {
    return 0;
  }
  resetEventsBlock(e) {
    ey.throwError(
      "cannot reset events block on WebSocketProvider",
      ue.errors.UNSUPPORTED_OPERATION,
      {
        operation: "resetEventBlock",
      }
    );
  }
  set pollingInterval(e) {
    ey.throwError(
      "cannot set polling interval on WebSocketProvider",
      ue.errors.UNSUPPORTED_OPERATION,
      {
        operation: "setPollingInterval",
      }
    );
  }
  poll() {
    return n3(this, void 0, void 0, function* () {
      return null;
    });
  }
  set polling(e) {
    e &&
      ey.throwError(
        "cannot set polling on WebSocketProvider",
        ue.errors.UNSUPPORTED_OPERATION,
        {
          operation: "setPolling",
        }
      );
  }
  send(e, r) {
    const n = tre++;
    return new Promise((i, a) => {
      function s(c, u) {
        return c ? a(c) : i(u);
      }
      const o = JSON.stringify({
        method: e,
        params: r,
        id: n,
        jsonrpc: "2.0",
      });
      this.emit("debug", {
        action: "request",
        request: JSON.parse(o),
        provider: this,
      }),
        (this._requests[String(n)] = {
          callback: s,
          payload: o,
        }),
        this._wsReady && this.websocket.send(o);
    });
  }
  static defaultUrl() {
    return "ws://localhost:8546";
  }
  _subscribe(e, r, n) {
    return n3(this, void 0, void 0, function* () {
      let i = this._subIds[e];
      i == null &&
        ((i = Promise.all(r).then((s) => this.send("eth_subscribe", s))),
        (this._subIds[e] = i));
      const a = yield i;
      this._subs[a] = {
        tag: e,
        processFunc: n,
      };
    });
  }
  _startEvent(e) {
    switch (e.type) {
      case "block":
        this._subscribe("block", ["newHeads"], (r) => {
          const n = ae.from(r.number).toNumber();
          (this._emitted.block = n), this.emit("block", n);
        });
        break;
      case "pending":
        this._subscribe("pending", ["newPendingTransactions"], (r) => {
          this.emit("pending", r);
        });
        break;
      case "filter":
        this._subscribe(e.tag, ["logs", this._getFilter(e.filter)], (r) => {
          r.removed == null && (r.removed = !1),
            this.emit(e.filter, this.formatter.filterLog(r));
        });
        break;
      case "tx": {
        const r = (n) => {
          const i = n.hash;
          this.getTransactionReceipt(i).then((a) => {
            a && this.emit(i, a);
          });
        };
        r(e),
          this._subscribe("tx", ["newHeads"], (n) => {
            this._events.filter((i) => i.type === "tx").forEach(r);
          });
        break;
      }
      case "debug":
      case "poll":
      case "willPoll":
      case "didPoll":
      case "error":
        break;
      default:
        console.log("unhandled:", e);
        break;
    }
  }
  _stopEvent(e) {
    let r = e.tag;
    if (e.type === "tx") {
      if (this._events.filter((i) => i.type === "tx").length) return;
      r = "tx";
    } else if (this.listenerCount(e.event)) return;
    const n = this._subIds[r];
    n &&
      (delete this._subIds[r],
      n.then((i) => {
        this._subs[i] &&
          (delete this._subs[i], this.send("eth_unsubscribe", [i]));
      }));
  }
  destroy() {
    return n3(this, void 0, void 0, function* () {
      this.websocket.readyState === jh.CONNECTING &&
        (yield new Promise((e) => {
          (this.websocket.onopen = function () {
            e(!0);
          }),
            (this.websocket.onerror = function () {
              e(!1);
            });
        })),
        this.websocket.close(1e3);
    });
  }
}
var rre = function (t, e, r, n) {
  function i(a) {
    return a instanceof r
      ? a
      : new r(function (s) {
          s(a);
        });
  }
  return new (r || (r = Promise))(function (a, s) {
    function o(d) {
      try {
        u(n.next(d));
      } catch (m) {
        s(m);
      }
    }
    function c(d) {
      try {
        u(n.throw(d));
      } catch (m) {
        s(m);
      }
    }
    function u(d) {
      d.done ? a(d.value) : i(d.value).then(o, c);
    }
    u((n = n.apply(t, e || [])).next());
  });
};
const wh = new ue(gi);
class JD extends Af {
  detectNetwork() {
    const e = Object.create(null, {
      detectNetwork: {
        get: () => super.detectNetwork,
      },
    });
    return rre(this, void 0, void 0, function* () {
      let r = this.network;
      return (
        r == null &&
          ((r = yield e.detectNetwork.call(this)),
          r ||
            wh.throwError("no network detected", ue.errors.UNKNOWN_ERROR, {}),
          this._network == null &&
            (_e(this, "_network", r), this.emit("network", r, null))),
        r
      );
    });
  }
}
class gl extends JD {
  constructor(e, r) {
    wh.checkAbstract(new.target, gl),
      (e = qn(new.target, "getNetwork")(e)),
      (r = qn(new.target, "getApiKey")(r));
    const n = qn(new.target, "getUrl")(e, r);
    super(n, e),
      typeof r == "string"
        ? _e(this, "apiKey", r)
        : r != null &&
          Object.keys(r).forEach((i) => {
            _e(this, i, r[i]);
          });
  }
  _startPending() {
    wh.warn("WARNING: API provider does not support pending filters");
  }
  isCommunityResource() {
    return !1;
  }
  getSigner(e) {
    return wh.throwError(
      "API provider does not support signing",
      ue.errors.UNSUPPORTED_OPERATION,
      {
        operation: "getSigner",
      }
    );
  }
  listAccounts() {
    return Promise.resolve([]);
  }
  static getApiKey(e) {
    return e;
  }
  static getUrl(e, r) {
    return wh.throwError(
      "not implemented; sub-classes must override getUrl",
      ue.errors.NOT_IMPLEMENTED,
      {
        operation: "getUrl",
      }
    );
  }
}
const aS = new ue(gi),
  Qy = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
class nre extends cv {
  constructor(e, r) {
    const n = new QD(e, r),
      i = n.connection.url
        .replace(/^http/i, "ws")
        .replace(".alchemyapi.", ".ws.alchemyapi.");
    super(i, n.network), _e(this, "apiKey", n.apiKey);
  }
  isCommunityResource() {
    return this.apiKey === Qy;
  }
}
class QD extends gl {
  static getWebSocketProvider(e, r) {
    return new nre(e, r);
  }
  static getApiKey(e) {
    return e == null
      ? Qy
      : (e &&
          typeof e != "string" &&
          aS.throwArgumentError("invalid apiKey", "apiKey", e),
        e);
  }
  static getUrl(e, r) {
    let n = null;
    switch (e.name) {
      case "homestead":
        n = "eth-mainnet.alchemyapi.io/v2/";
        break;
      case "goerli":
        n = "eth-goerli.g.alchemy.com/v2/";
        break;
      case "matic":
        n = "polygon-mainnet.g.alchemy.com/v2/";
        break;
      case "maticmum":
        n = "polygon-mumbai.g.alchemy.com/v2/";
        break;
      case "arbitrum":
        n = "arb-mainnet.g.alchemy.com/v2/";
        break;
      case "arbitrum-goerli":
        n = "arb-goerli.g.alchemy.com/v2/";
        break;
      case "optimism":
        n = "opt-mainnet.g.alchemy.com/v2/";
        break;
      case "optimism-goerli":
        n = "opt-goerli.g.alchemy.com/v2/";
        break;
      default:
        aS.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return {
      allowGzip: !0,
      url: "https://" + n + r,
      throttleCallback: (i, a) => (r === Qy && ov(), Promise.resolve(!0)),
    };
  }
  isCommunityResource() {
    return this.apiKey === Qy;
  }
}
const ire = new ue(gi),
  ty = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
function are(t) {
  switch (t) {
    case "homestead":
      return "rpc.ankr.com/eth/";
    case "ropsten":
      return "rpc.ankr.com/eth_ropsten/";
    case "rinkeby":
      return "rpc.ankr.com/eth_rinkeby/";
    case "goerli":
      return "rpc.ankr.com/eth_goerli/";
    case "matic":
      return "rpc.ankr.com/polygon/";
    case "arbitrum":
      return "rpc.ankr.com/arbitrum/";
  }
  return ire.throwArgumentError("unsupported network", "name", t);
}
class sre extends gl {
  isCommunityResource() {
    return this.apiKey === ty;
  }
  static getApiKey(e) {
    return e ?? ty;
  }
  static getUrl(e, r) {
    r == null && (r = ty);
    const n = {
      allowGzip: !0,
      url: "https://" + are(e.name) + r,
      throttleCallback: (i, a) => (
        r.apiKey === ty && ov(), Promise.resolve(!0)
      ),
    };
    return (
      r.projectSecret != null &&
        ((n.user = ""), (n.password = r.projectSecret)),
      n
    );
  }
}
var ore = function (t, e, r, n) {
  function i(a) {
    return a instanceof r
      ? a
      : new r(function (s) {
          s(a);
        });
  }
  return new (r || (r = Promise))(function (a, s) {
    function o(d) {
      try {
        u(n.next(d));
      } catch (m) {
        s(m);
      }
    }
    function c(d) {
      try {
        u(n.throw(d));
      } catch (m) {
        s(m);
      }
    }
    function u(d) {
      d.done ? a(d.value) : i(d.value).then(o, c);
    }
    u((n = n.apply(t, e || [])).next());
  });
};
const sS = new ue(gi);
class cre extends gl {
  static getApiKey(e) {
    return (
      e != null &&
        sS.throwArgumentError(
          "apiKey not supported for cloudflare",
          "apiKey",
          e
        ),
      null
    );
  }
  static getUrl(e, r) {
    let n = null;
    switch (e.name) {
      case "homestead":
        n = "https://cloudflare-eth.com/";
        break;
      default:
        sS.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return n;
  }
  perform(e, r) {
    const n = Object.create(null, {
      perform: {
        get: () => super.perform,
      },
    });
    return ore(this, void 0, void 0, function* () {
      return e === "getBlockNumber"
        ? (yield n.perform.call(this, "getBlock", {
            blockTag: "latest",
          })).number
        : n.perform.call(this, e, r);
    });
  }
}
var ry = function (t, e, r, n) {
  function i(a) {
    return a instanceof r
      ? a
      : new r(function (s) {
          s(a);
        });
  }
  return new (r || (r = Promise))(function (a, s) {
    function o(d) {
      try {
        u(n.next(d));
      } catch (m) {
        s(m);
      }
    }
    function c(d) {
      try {
        u(n.throw(d));
      } catch (m) {
        s(m);
      }
    }
    function u(d) {
      d.done ? a(d.value) : i(d.value).then(o, c);
    }
    u((n = n.apply(t, e || [])).next());
  });
};
const bc = new ue(gi);
function oS(t) {
  const e = {};
  for (let r in t) {
    if (t[r] == null) continue;
    let n = t[r];
    (r === "type" && n === 0) ||
      ({
        type: !0,
        gasLimit: !0,
        gasPrice: !0,
        maxFeePerGs: !0,
        maxPriorityFeePerGas: !0,
        nonce: !0,
        value: !0,
      }[r]
        ? (n = Dm(Ke(n)))
        : r === "accessList"
        ? (n =
            "[" +
            yl(n)
              .map(
                (i) =>
                  `{address:"${i.address}",storageKeys:["${i.storageKeys.join(
                    '","'
                  )}"]}`
              )
              .join(",") +
            "]")
        : (n = Ke(n)),
      (e[r] = n));
  }
  return e;
}
function lre(t) {
  if (
    t.status == 0 &&
    (t.message === "No records found" || t.message === "No transactions found")
  )
    return t.result;
  if (
    t.status != 1 ||
    typeof t.message != "string" ||
    !t.message.match(/^OK/)
  ) {
    const e = new Error("invalid response");
    throw (
      ((e.result = JSON.stringify(t)),
      (t.result || "").toLowerCase().indexOf("rate limit") >= 0 &&
        (e.throttleRetry = !0),
      e)
    );
  }
  return t.result;
}
function cS(t) {
  if (
    t &&
    t.status == 0 &&
    t.message == "NOTOK" &&
    (t.result || "").toLowerCase().indexOf("rate limit") >= 0
  ) {
    const e = new Error("throttled response");
    throw ((e.result = JSON.stringify(t)), (e.throttleRetry = !0), e);
  }
  if (t.jsonrpc != "2.0") {
    const e = new Error("invalid response");
    throw ((e.result = JSON.stringify(t)), e);
  }
  if (t.error) {
    const e = new Error(t.error.message || "unknown error");
    throw (
      (t.error.code && (e.code = t.error.code),
      t.error.data && (e.data = t.error.data),
      e)
    );
  }
  return t.result;
}
function lS(t) {
  if (t === "pending") throw new Error("pending not supported");
  return t === "latest" ? t : parseInt(t.substring(2), 16);
}
function i3(t, e, r) {
  if (t === "call" && e.code === ue.errors.SERVER_ERROR) {
    const i = e.error;
    if (
      i &&
      (i.message.match(/reverted/i) || i.message.match(/VM execution error/i))
    ) {
      let a = i.data;
      if ((a && (a = "0x" + a.replace(/^.*0x/i, "")), gt(a))) return a;
      bc.throwError(
        "missing revert data in call exception",
        ue.errors.CALL_EXCEPTION,
        {
          error: e,
          data: "0x",
        }
      );
    }
  }
  let n = e.message;
  throw (
    (e.code === ue.errors.SERVER_ERROR &&
      (e.error && typeof e.error.message == "string"
        ? (n = e.error.message)
        : typeof e.body == "string"
        ? (n = e.body)
        : typeof e.responseText == "string" && (n = e.responseText)),
    (n = (n || "").toLowerCase()),
    n.match(/insufficient funds/) &&
      bc.throwError(
        "insufficient funds for intrinsic transaction cost",
        ue.errors.INSUFFICIENT_FUNDS,
        {
          error: e,
          method: t,
          transaction: r,
        }
      ),
    n.match(
      /same hash was already imported|transaction nonce is too low|nonce too low/
    ) &&
      bc.throwError("nonce has already been used", ue.errors.NONCE_EXPIRED, {
        error: e,
        method: t,
        transaction: r,
      }),
    n.match(/another transaction with same nonce/) &&
      bc.throwError(
        "replacement fee too low",
        ue.errors.REPLACEMENT_UNDERPRICED,
        {
          error: e,
          method: t,
          transaction: r,
        }
      ),
    n.match(/execution failed due to an exception|execution reverted/) &&
      bc.throwError(
        "cannot estimate gas; transaction may fail or may require manual gas limit",
        ue.errors.UNPREDICTABLE_GAS_LIMIT,
        {
          error: e,
          method: t,
          transaction: r,
        }
      ),
    e)
  );
}
class ure extends lE {
  constructor(e, r) {
    super(e),
      _e(this, "baseUrl", this.getBaseUrl()),
      _e(this, "apiKey", r || null);
  }
  getBaseUrl() {
    switch (this.network ? this.network.name : "invalid") {
      case "homestead":
        return "https://api.etherscan.io";
      case "goerli":
        return "https://api-goerli.etherscan.io";
      case "sepolia":
        return "https://api-sepolia.etherscan.io";
      case "matic":
        return "https://api.polygonscan.com";
      case "maticmum":
        return "https://api-testnet.polygonscan.com";
      case "arbitrum":
        return "https://api.arbiscan.io";
      case "arbitrum-goerli":
        return "https://api-goerli.arbiscan.io";
      case "optimism":
        return "https://api-optimistic.etherscan.io";
      case "optimism-goerli":
        return "https://api-goerli-optimistic.etherscan.io";
    }
    return bc.throwArgumentError(
      "unsupported network",
      "network",
      this.network.name
    );
  }
  getUrl(e, r) {
    const n = Object.keys(r).reduce((a, s) => {
        const o = r[s];
        return o != null && (a += `&${s}=${o}`), a;
      }, ""),
      i = this.apiKey ? `&apikey=${this.apiKey}` : "";
    return `${this.baseUrl}/api?module=${e}${n}${i}`;
  }
  getPostUrl() {
    return `${this.baseUrl}/api`;
  }
  getPostData(e, r) {
    return (r.module = e), (r.apikey = this.apiKey), r;
  }
  fetch(e, r, n) {
    return ry(this, void 0, void 0, function* () {
      const i = n ? this.getPostUrl() : this.getUrl(e, r),
        a = n ? this.getPostData(e, r) : null,
        s = e === "proxy" ? cS : lre;
      this.emit("debug", {
        action: "request",
        request: i,
        provider: this,
      });
      const o = {
        url: i,
        throttleSlotInterval: 1e3,
        throttleCallback: (d, m) => (
          this.isCommunityResource() && ov(), Promise.resolve(!0)
        ),
      };
      let c = null;
      a &&
        ((o.headers = {
          "content-type": "application/x-www-form-urlencoded; charset=UTF-8",
        }),
        (c = Object.keys(a)
          .map((d) => `${d}=${a[d]}`)
          .join("&")));
      const u = yield Ou(o, c, s || cS);
      return (
        this.emit("debug", {
          action: "response",
          request: i,
          response: fi(u),
          provider: this,
        }),
        u
      );
    });
  }
  detectNetwork() {
    return ry(this, void 0, void 0, function* () {
      return this.network;
    });
  }
  perform(e, r) {
    const n = Object.create(null, {
      perform: {
        get: () => super.perform,
      },
    });
    return ry(this, void 0, void 0, function* () {
      switch (e) {
        case "getBlockNumber":
          return this.fetch("proxy", {
            action: "eth_blockNumber",
          });
        case "getGasPrice":
          return this.fetch("proxy", {
            action: "eth_gasPrice",
          });
        case "getBalance":
          return this.fetch("account", {
            action: "balance",
            address: r.address,
            tag: r.blockTag,
          });
        case "getTransactionCount":
          return this.fetch("proxy", {
            action: "eth_getTransactionCount",
            address: r.address,
            tag: r.blockTag,
          });
        case "getCode":
          return this.fetch("proxy", {
            action: "eth_getCode",
            address: r.address,
            tag: r.blockTag,
          });
        case "getStorageAt":
          return this.fetch("proxy", {
            action: "eth_getStorageAt",
            address: r.address,
            position: r.position,
            tag: r.blockTag,
          });
        case "sendTransaction":
          return this.fetch(
            "proxy",
            {
              action: "eth_sendRawTransaction",
              hex: r.signedTransaction,
            },
            !0
          ).catch((i) => i3("sendTransaction", i, r.signedTransaction));
        case "getBlock":
          if (r.blockTag)
            return this.fetch("proxy", {
              action: "eth_getBlockByNumber",
              tag: r.blockTag,
              boolean: r.includeTransactions ? "true" : "false",
            });
          throw new Error("getBlock by blockHash not implemented");
        case "getTransaction":
          return this.fetch("proxy", {
            action: "eth_getTransactionByHash",
            txhash: r.transactionHash,
          });
        case "getTransactionReceipt":
          return this.fetch("proxy", {
            action: "eth_getTransactionReceipt",
            txhash: r.transactionHash,
          });
        case "call": {
          if (r.blockTag !== "latest")
            throw new Error(
              "EtherscanProvider does not support blockTag for call"
            );
          const i = oS(r.transaction);
          (i.module = "proxy"), (i.action = "eth_call");
          try {
            return yield this.fetch("proxy", i, !0);
          } catch (a) {
            return i3("call", a, r.transaction);
          }
        }
        case "estimateGas": {
          const i = oS(r.transaction);
          (i.module = "proxy"), (i.action = "eth_estimateGas");
          try {
            return yield this.fetch("proxy", i, !0);
          } catch (a) {
            return i3("estimateGas", a, r.transaction);
          }
        }
        case "getLogs": {
          const i = {
            action: "getLogs",
          };
          if (
            (r.filter.fromBlock && (i.fromBlock = lS(r.filter.fromBlock)),
            r.filter.toBlock && (i.toBlock = lS(r.filter.toBlock)),
            r.filter.address && (i.address = r.filter.address),
            r.filter.topics &&
              r.filter.topics.length > 0 &&
              (r.filter.topics.length > 1 &&
                bc.throwError(
                  "unsupported topic count",
                  ue.errors.UNSUPPORTED_OPERATION,
                  {
                    topics: r.filter.topics,
                  }
                ),
              r.filter.topics.length === 1))
          ) {
            const o = r.filter.topics[0];
            (typeof o != "string" || o.length !== 66) &&
              bc.throwError(
                "unsupported topic format",
                ue.errors.UNSUPPORTED_OPERATION,
                {
                  topic0: o,
                }
              ),
              (i.topic0 = o);
          }
          const a = yield this.fetch("logs", i);
          let s = {};
          for (let o = 0; o < a.length; o++) {
            const c = a[o];
            if (c.blockHash == null) {
              if (s[c.blockNumber] == null) {
                const u = yield this.getBlock(c.blockNumber);
                u && (s[c.blockNumber] = u.hash);
              }
              c.blockHash = s[c.blockNumber];
            }
          }
          return a;
        }
        case "getEtherPrice":
          return this.network.name !== "homestead"
            ? 0
            : parseFloat(
                (yield this.fetch("stats", {
                  action: "ethprice",
                })).ethusd
              );
      }
      return n.perform.call(this, e, r);
    });
  }
  getHistory(e, r, n) {
    return ry(this, void 0, void 0, function* () {
      const i = {
        action: "txlist",
        address: yield this.resolveName(e),
        startblock: r ?? 0,
        endblock: n ?? 99999999,
        sort: "asc",
      };
      return (yield this.fetch("account", i)).map((s) => {
        ["contractAddress", "to"].forEach(function (c) {
          s[c] == "" && delete s[c];
        }),
          s.creates == null &&
            s.contractAddress != null &&
            (s.creates = s.contractAddress);
        const o = this.formatter.transactionResponse(s);
        return s.timeStamp && (o.timestamp = parseInt(s.timeStamp)), o;
      });
    });
  }
  isCommunityResource() {
    return this.apiKey == null;
  }
}
var t2 = function (t, e, r, n) {
  function i(a) {
    return a instanceof r
      ? a
      : new r(function (s) {
          s(a);
        });
  }
  return new (r || (r = Promise))(function (a, s) {
    function o(d) {
      try {
        u(n.next(d));
      } catch (m) {
        s(m);
      }
    }
    function c(d) {
      try {
        u(n.throw(d));
      } catch (m) {
        s(m);
      }
    }
    function u(d) {
      d.done ? a(d.value) : i(d.value).then(o, c);
    }
    u((n = n.apply(t, e || [])).next());
  });
};
const Ol = new ue(gi);
function ny() {
  return new Date().getTime();
}
function uS(t) {
  let e = null;
  for (let r = 0; r < t.length; r++) {
    const n = t[r];
    if (n == null) return null;
    e
      ? (e.name === n.name &&
          e.chainId === n.chainId &&
          (e.ensAddress === n.ensAddress ||
            (e.ensAddress == null && n.ensAddress == null))) ||
        Ol.throwArgumentError("provider mismatch", "networks", t)
      : (e = n);
  }
  return e;
}
function fS(t, e) {
  t = t.slice().sort();
  const r = Math.floor(t.length / 2);
  if (t.length % 2) return t[r];
  const n = t[r - 1],
    i = t[r];
  return e != null && Math.abs(n - i) > e ? null : (n + i) / 2;
}
function N0(t) {
  if (t === null) return "null";
  if (typeof t == "number" || typeof t == "boolean") return JSON.stringify(t);
  if (typeof t == "string") return t;
  if (ae.isBigNumber(t)) return t.toString();
  if (Array.isArray(t)) return JSON.stringify(t.map((e) => N0(e)));
  if (typeof t == "object") {
    const e = Object.keys(t);
    return (
      e.sort(),
      "{" +
        e
          .map((r) => {
            let n = t[r];
            return (
              typeof n == "function" ? (n = "[function]") : (n = N0(n)),
              JSON.stringify(r) + ":" + n
            );
          })
          .join(",") +
        "}"
    );
  }
  throw new Error("unknown value type: " + typeof t);
}
let fre = 1;
function dS(t) {
  let e = null,
    r = null,
    n = new Promise((s) => {
      (e = function () {
        r && (clearTimeout(r), (r = null)), s();
      }),
        (r = setTimeout(e, t));
    });
  const i = (s) => ((n = n.then(s)), n);
  function a() {
    return n;
  }
  return {
    cancel: e,
    getPromise: a,
    wait: i,
  };
}
const dre = [
    ue.errors.CALL_EXCEPTION,
    ue.errors.INSUFFICIENT_FUNDS,
    ue.errors.NONCE_EXPIRED,
    ue.errors.REPLACEMENT_UNDERPRICED,
    ue.errors.UNPREDICTABLE_GAS_LIMIT,
  ],
  hre = [
    "address",
    "args",
    "errorArgs",
    "errorSignature",
    "method",
    "transaction",
  ];
function iy(t, e) {
  const r = {
    weight: t.weight,
  };
  return (
    Object.defineProperty(r, "provider", {
      get: () => t.provider,
    }),
    t.start && (r.start = t.start),
    e && (r.duration = e - t.start),
    t.done && (t.error ? (r.error = t.error) : (r.result = t.result || null)),
    r
  );
}
function pre(t, e) {
  return function (r) {
    const n = {};
    r.forEach((a) => {
      const s = t(a.result);
      n[s] ||
        (n[s] = {
          count: 0,
          result: a.result,
        }),
        n[s].count++;
    });
    const i = Object.keys(n);
    for (let a = 0; a < i.length; a++) {
      const s = n[i[a]];
      if (s.count >= e) return s.result;
    }
  };
}
function mre(t, e, r) {
  let n = N0;
  switch (e) {
    case "getBlockNumber":
      return function (i) {
        const a = i.map((o) => o.result);
        let s = fS(
          i.map((o) => o.result),
          2
        );
        if (s != null)
          return (
            (s = Math.ceil(s)),
            a.indexOf(s + 1) >= 0 && s++,
            s >= t._highestBlockNumber && (t._highestBlockNumber = s),
            t._highestBlockNumber
          );
      };
    case "getGasPrice":
      return function (i) {
        const a = i.map((s) => s.result);
        return a.sort(), a[Math.floor(a.length / 2)];
      };
    case "getEtherPrice":
      return function (i) {
        return fS(i.map((a) => a.result));
      };
    case "getBalance":
    case "getTransactionCount":
    case "getCode":
    case "getStorageAt":
    case "call":
    case "estimateGas":
    case "getLogs":
      break;
    case "getTransaction":
    case "getTransactionReceipt":
      n = function (i) {
        return i == null ? null : ((i = vr(i)), (i.confirmations = -1), N0(i));
      };
      break;
    case "getBlock":
      r.includeTransactions
        ? (n = function (i) {
            return i == null
              ? null
              : ((i = vr(i)),
                (i.transactions = i.transactions.map(
                  (a) => ((a = vr(a)), (a.confirmations = -1), a)
                )),
                N0(i));
          })
        : (n = function (i) {
            return i == null ? null : N0(i);
          });
      break;
    default:
      throw new Error("unknown method: " + e);
  }
  return pre(n, t.quorum);
}
function eh(t, e) {
  return t2(this, void 0, void 0, function* () {
    const r = t.provider;
    return (r.blockNumber != null && r.blockNumber >= e) || e === -1
      ? r
      : ql(
          () =>
            new Promise((n, i) => {
              setTimeout(function () {
                return r.blockNumber >= e
                  ? n(r)
                  : t.cancelled
                  ? n(null)
                  : n(void 0);
              }, 0);
            }),
          {
            oncePoll: r,
          }
        );
  });
}
function yre(t, e, r, n) {
  return t2(this, void 0, void 0, function* () {
    let i = t.provider;
    switch (r) {
      case "getBlockNumber":
      case "getGasPrice":
        return i[r]();
      case "getEtherPrice":
        if (i.getEtherPrice) return i.getEtherPrice();
        break;
      case "getBalance":
      case "getTransactionCount":
      case "getCode":
        return (
          n.blockTag && gt(n.blockTag) && (i = yield eh(t, e)),
          i[r](n.address, n.blockTag || "latest")
        );
      case "getStorageAt":
        return (
          n.blockTag && gt(n.blockTag) && (i = yield eh(t, e)),
          i.getStorageAt(n.address, n.position, n.blockTag || "latest")
        );
      case "getBlock":
        return (
          n.blockTag && gt(n.blockTag) && (i = yield eh(t, e)),
          i[n.includeTransactions ? "getBlockWithTransactions" : "getBlock"](
            n.blockTag || n.blockHash
          )
        );
      case "call":
      case "estimateGas":
        return (
          n.blockTag && gt(n.blockTag) && (i = yield eh(t, e)),
          r === "call" && n.blockTag
            ? i[r](n.transaction, n.blockTag)
            : i[r](n.transaction)
        );
      case "getTransaction":
      case "getTransactionReceipt":
        return i[r](n.transactionHash);
      case "getLogs": {
        let a = n.filter;
        return (
          ((a.fromBlock && gt(a.fromBlock)) || (a.toBlock && gt(a.toBlock))) &&
            (i = yield eh(t, e)),
          i.getLogs(a)
        );
      }
    }
    return Ol.throwError("unknown method error", ue.errors.UNKNOWN_ERROR, {
      method: r,
      params: n,
    });
  });
}
class gre extends lE {
  constructor(e, r) {
    e.length === 0 &&
      Ol.throwArgumentError("missing providers", "providers", e);
    const n = e.map((s, o) => {
        if (Qb.isProvider(s)) {
          const d = Zk(s) ? 2e3 : 750;
          return Object.freeze({
            provider: s,
            weight: 1,
            stallTimeout: d,
            priority: 1,
          });
        }
        const c = vr(s);
        c.priority == null && (c.priority = 1),
          c.stallTimeout == null && (c.stallTimeout = Zk(s) ? 2e3 : 750),
          c.weight == null && (c.weight = 1);
        const u = c.weight;
        return (
          (u % 1 || u > 512 || u < 1) &&
            Ol.throwArgumentError(
              "invalid weight; must be integer in [1, 512]",
              `providers[${o}].weight`,
              u
            ),
          Object.freeze(c)
        );
      }),
      i = n.reduce((s, o) => s + o.weight, 0);
    r == null
      ? (r = i / 2)
      : r > i &&
        Ol.throwArgumentError(
          "quorum will always fail; larger than total weight",
          "quorum",
          r
        );
    let a = uS(n.map((s) => s.provider.network));
    a == null &&
      (a = new Promise((s, o) => {
        setTimeout(() => {
          this.detectNetwork().then(s, o);
        }, 0);
      })),
      super(a),
      _e(this, "providerConfigs", Object.freeze(n)),
      _e(this, "quorum", r),
      (this._highestBlockNumber = -1);
  }
  detectNetwork() {
    return t2(this, void 0, void 0, function* () {
      const e = yield Promise.all(
        this.providerConfigs.map((r) => r.provider.getNetwork())
      );
      return uS(e);
    });
  }
  perform(e, r) {
    return t2(this, void 0, void 0, function* () {
      if (e === "sendTransaction") {
        const c = yield Promise.all(
          this.providerConfigs.map((u) =>
            u.provider.sendTransaction(r.signedTransaction).then(
              (d) => d.hash,
              (d) => d
            )
          )
        );
        for (let u = 0; u < c.length; u++) {
          const d = c[u];
          if (typeof d == "string") return d;
        }
        throw c[0];
      }
      this._highestBlockNumber === -1 &&
        e !== "getBlockNumber" &&
        (yield this.getBlockNumber());
      const n = mre(this, e, r),
        i = ID(this.providerConfigs.map(vr));
      i.sort((c, u) => c.priority - u.priority);
      const a = this._highestBlockNumber;
      let s = 0,
        o = !0;
      for (;;) {
        const c = ny();
        let u = i
          .filter((E) => E.runner && c - E.start < E.stallTimeout)
          .reduce((E, A) => E + A.weight, 0);
        for (; u < this.quorum && s < i.length; ) {
          const E = i[s++],
            A = fre++;
          (E.start = ny()),
            (E.staller = dS(E.stallTimeout)),
            E.staller.wait(() => {
              E.staller = null;
            }),
            (E.runner = yre(E, a, e, r).then(
              (I) => {
                (E.done = !0),
                  (E.result = I),
                  this.listenerCount("debug") &&
                    this.emit("debug", {
                      action: "request",
                      rid: A,
                      backend: iy(E, ny()),
                      request: {
                        method: e,
                        params: fi(r),
                      },
                      provider: this,
                    });
              },
              (I) => {
                (E.done = !0),
                  (E.error = I),
                  this.listenerCount("debug") &&
                    this.emit("debug", {
                      action: "request",
                      rid: A,
                      backend: iy(E, ny()),
                      request: {
                        method: e,
                        params: fi(r),
                      },
                      provider: this,
                    });
              }
            )),
            this.listenerCount("debug") &&
              this.emit("debug", {
                action: "request",
                rid: A,
                backend: iy(E, null),
                request: {
                  method: e,
                  params: fi(r),
                },
                provider: this,
              }),
            (u += E.weight);
        }
        const d = [];
        i.forEach((E) => {
          E.done ||
            !E.runner ||
            (d.push(E.runner), E.staller && d.push(E.staller.getPromise()));
        }),
          d.length && (yield Promise.race(d));
        const m = i.filter((E) => E.done && E.error == null);
        if (m.length >= this.quorum) {
          const E = n(m);
          if (E !== void 0)
            return (
              i.forEach((A) => {
                A.staller && A.staller.cancel(), (A.cancelled = !0);
              }),
              E
            );
          o || (yield dS(100).getPromise()), (o = !1);
        }
        const v = i.reduce((E, A) => {
          if (!A.done || A.error == null) return E;
          const I = A.error.code;
          return (
            dre.indexOf(I) >= 0 &&
              (E[I] ||
                (E[I] = {
                  error: A.error,
                  weight: 0,
                }),
              (E[I].weight += A.weight)),
            E
          );
        }, {});
        if (
          (Object.keys(v).forEach((E) => {
            const A = v[E];
            if (A.weight < this.quorum) return;
            i.forEach((w) => {
              w.staller && w.staller.cancel(), (w.cancelled = !0);
            });
            const I = A.error,
              b = {};
            hre.forEach((w) => {
              I[w] != null && (b[w] = I[w]);
            }),
              Ol.throwError(I.reason || I.message, E, b);
          }),
          i.filter((E) => !E.done).length === 0)
        )
          break;
      }
      return (
        i.forEach((c) => {
          c.staller && c.staller.cancel(), (c.cancelled = !0);
        }),
        Ol.throwError("failed to meet quorum", ue.errors.SERVER_ERROR, {
          method: e,
          params: r,
          results: i.map((c) => iy(c)),
          provider: this,
        })
      );
    });
  }
}
const bre = null,
  Yy = new ue(gi),
  _h = "84842078b09946638c03157f83405213";
class vre extends cv {
  constructor(e, r) {
    const n = new YD(e, r),
      i = n.connection;
    i.password &&
      Yy.throwError(
        "INFURA WebSocket project secrets unsupported",
        ue.errors.UNSUPPORTED_OPERATION,
        {
          operation: "InfuraProvider.getWebSocketProvider()",
        }
      );
    const a = i.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
    super(a, e),
      _e(this, "apiKey", n.projectId),
      _e(this, "projectId", n.projectId),
      _e(this, "projectSecret", n.projectSecret);
  }
  isCommunityResource() {
    return this.projectId === _h;
  }
}
class YD extends gl {
  static getWebSocketProvider(e, r) {
    return new vre(e, r);
  }
  static getApiKey(e) {
    const r = {
      apiKey: _h,
      projectId: _h,
      projectSecret: null,
    };
    return (
      e == null ||
        (typeof e == "string"
          ? (r.projectId = e)
          : e.projectSecret != null
          ? (Yy.assertArgument(
              typeof e.projectId == "string",
              "projectSecret requires a projectId",
              "projectId",
              e.projectId
            ),
            Yy.assertArgument(
              typeof e.projectSecret == "string",
              "invalid projectSecret",
              "projectSecret",
              "[REDACTED]"
            ),
            (r.projectId = e.projectId),
            (r.projectSecret = e.projectSecret))
          : e.projectId && (r.projectId = e.projectId),
        (r.apiKey = r.projectId)),
      r
    );
  }
  static getUrl(e, r) {
    let n = null;
    switch (e ? e.name : "unknown") {
      case "homestead":
        n = "mainnet.infura.io";
        break;
      case "goerli":
        n = "goerli.infura.io";
        break;
      case "sepolia":
        n = "sepolia.infura.io";
        break;
      case "matic":
        n = "polygon-mainnet.infura.io";
        break;
      case "maticmum":
        n = "polygon-mumbai.infura.io";
        break;
      case "optimism":
        n = "optimism-mainnet.infura.io";
        break;
      case "optimism-goerli":
        n = "optimism-goerli.infura.io";
        break;
      case "arbitrum":
        n = "arbitrum-mainnet.infura.io";
        break;
      case "arbitrum-goerli":
        n = "arbitrum-goerli.infura.io";
        break;
      default:
        Yy.throwError("unsupported network", ue.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: e,
        });
    }
    const i = {
      allowGzip: !0,
      url: "https://" + n + "/v3/" + r.projectId,
      throttleCallback: (a, s) => (
        r.projectId === _h && ov(), Promise.resolve(!0)
      ),
    };
    return (
      r.projectSecret != null &&
        ((i.user = ""), (i.password = r.projectSecret)),
      i
    );
  }
  isCommunityResource() {
    return this.projectId === _h;
  }
}
class xre extends Af {
  send(e, r) {
    const n = {
      method: e,
      params: r,
      id: this._nextId++,
      jsonrpc: "2.0",
    };
    this._pendingBatch == null && (this._pendingBatch = []);
    const i = {
        request: n,
        resolve: null,
        reject: null,
      },
      a = new Promise((s, o) => {
        (i.resolve = s), (i.reject = o);
      });
    return (
      this._pendingBatch.push(i),
      this._pendingBatchAggregator ||
        (this._pendingBatchAggregator = setTimeout(() => {
          const s = this._pendingBatch;
          (this._pendingBatch = null), (this._pendingBatchAggregator = null);
          const o = s.map((c) => c.request);
          return (
            this.emit("debug", {
              action: "requestBatch",
              request: fi(o),
              provider: this,
            }),
            Ou(this.connection, JSON.stringify(o)).then(
              (c) => {
                this.emit("debug", {
                  action: "response",
                  request: o,
                  response: c,
                  provider: this,
                }),
                  s.forEach((u, d) => {
                    const m = c[d];
                    if (m.error) {
                      const v = new Error(m.error.message);
                      (v.code = m.error.code),
                        (v.data = m.error.data),
                        u.reject(v);
                    } else u.resolve(m.result);
                  });
              },
              (c) => {
                this.emit("debug", {
                  action: "response",
                  error: c,
                  request: o,
                  provider: this,
                }),
                  s.forEach((u) => {
                    u.reject(c);
                  });
              }
            )
          );
        }, 10)),
      a
    );
  }
}
const a3 = new ue(gi),
  wre = "ETHERS_JS_SHARED";
class _re extends gl {
  static getApiKey(e) {
    return (
      e &&
        typeof e != "string" &&
        a3.throwArgumentError("invalid apiKey", "apiKey", e),
      e || wre
    );
  }
  static getUrl(e, r) {
    a3.warn(
      "NodeSmith will be discontinued on 2019-12-20; please migrate to another platform."
    );
    let n = null;
    switch (e.name) {
      case "homestead":
        n = "https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc";
        break;
      case "ropsten":
        n = "https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc";
        break;
      case "rinkeby":
        n = "https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc";
        break;
      case "goerli":
        n = "https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc";
        break;
      case "kovan":
        n = "https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc";
        break;
      default:
        a3.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return n + "?apiKey=" + r;
  }
}
const hS = new ue(gi),
  pS = "62e1ad51b37b8e00394bda3b";
class Ere extends gl {
  static getApiKey(e) {
    const r = {
      applicationId: null,
      loadBalancer: !0,
      applicationSecretKey: null,
    };
    return (
      e == null
        ? (r.applicationId = pS)
        : typeof e == "string"
        ? (r.applicationId = e)
        : e.applicationSecretKey != null
        ? ((r.applicationId = e.applicationId),
          (r.applicationSecretKey = e.applicationSecretKey))
        : e.applicationId
        ? (r.applicationId = e.applicationId)
        : hS.throwArgumentError(
            "unsupported PocketProvider apiKey",
            "apiKey",
            e
          ),
      r
    );
  }
  static getUrl(e, r) {
    let n = null;
    switch (e ? e.name : "unknown") {
      case "goerli":
        n = "eth-goerli.gateway.pokt.network";
        break;
      case "homestead":
        n = "eth-mainnet.gateway.pokt.network";
        break;
      case "kovan":
        n = "poa-kovan.gateway.pokt.network";
        break;
      case "matic":
        n = "poly-mainnet.gateway.pokt.network";
        break;
      case "maticmum":
        n = "polygon-mumbai-rpc.gateway.pokt.network";
        break;
      case "rinkeby":
        n = "eth-rinkeby.gateway.pokt.network";
        break;
      case "ropsten":
        n = "eth-ropsten.gateway.pokt.network";
        break;
      default:
        hS.throwError("unsupported network", ue.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: e,
        });
    }
    const i = `https://${n}/v1/lb/${r.applicationId}`,
      a = {
        headers: {},
        url: i,
      };
    return (
      r.applicationSecretKey != null &&
        ((a.user = ""), (a.password = r.applicationSecretKey)),
      a
    );
  }
  isCommunityResource() {
    return this.applicationId === pS;
  }
}
const mS = new ue(gi);
let Tre = 1;
function yS(t, e) {
  const r = "Web3LegacyFetcher";
  return function (n, i) {
    const a = {
      method: n,
      params: i,
      id: Tre++,
      jsonrpc: "2.0",
    };
    return new Promise((s, o) => {
      this.emit("debug", {
        action: "request",
        fetcher: r,
        request: fi(a),
        provider: this,
      }),
        e(a, (c, u) => {
          if (c)
            return (
              this.emit("debug", {
                action: "response",
                fetcher: r,
                error: c,
                request: a,
                provider: this,
              }),
              o(c)
            );
          if (
            (this.emit("debug", {
              action: "response",
              fetcher: r,
              request: a,
              response: u,
              provider: this,
            }),
            u.error)
          ) {
            const d = new Error(u.error.message);
            return (d.code = u.error.code), (d.data = u.error.data), o(d);
          }
          s(u.result);
        });
    });
  };
}
function Cre(t) {
  return function (e, r) {
    r == null && (r = []);
    const n = {
      method: e,
      params: r,
    };
    return (
      this.emit("debug", {
        action: "request",
        fetcher: "Eip1193Fetcher",
        request: fi(n),
        provider: this,
      }),
      t.request(n).then(
        (i) => (
          this.emit("debug", {
            action: "response",
            fetcher: "Eip1193Fetcher",
            request: n,
            response: i,
            provider: this,
          }),
          i
        ),
        (i) => {
          throw (
            (this.emit("debug", {
              action: "response",
              fetcher: "Eip1193Fetcher",
              request: n,
              error: i,
              provider: this,
            }),
            i)
          );
        }
      )
    );
  };
}
class kf extends Af {
  constructor(e, r) {
    e == null && mS.throwArgumentError("missing provider", "provider", e);
    let n = null,
      i = null,
      a = null;
    typeof e == "function"
      ? ((n = "unknown:"), (i = e))
      : ((n = e.host || e.path || ""),
        !n && e.isMetaMask && (n = "metamask"),
        (a = e),
        e.request
          ? (n === "" && (n = "eip-1193:"), (i = Cre(e)))
          : e.sendAsync
          ? (i = yS(e, e.sendAsync.bind(e)))
          : e.send
          ? (i = yS(e, e.send.bind(e)))
          : mS.throwArgumentError("unsupported provider", "provider", e),
        n || (n = "unknown:")),
      super(n, r),
      _e(this, "jsonRpcFetchFunc", i),
      _e(this, "provider", a);
  }
  send(e, r) {
    return this.jsonRpcFetchFunc(e, r);
  }
}
const gS = new ue(gi);
function XD(t, e) {
  if ((t == null && (t = "homestead"), typeof t == "string")) {
    const n = t.match(/^(ws|http)s?:/i);
    if (n)
      switch (n[1].toLowerCase()) {
        case "http":
        case "https":
          return new Af(t);
        case "ws":
        case "wss":
          return new cv(t);
        default:
          gS.throwArgumentError("unsupported URL scheme", "network", t);
      }
  }
  const r = jD(t);
  return (
    (!r || !r._defaultProvider) &&
      gS.throwError(
        "unsupported getDefaultProvider network",
        ue.errors.NETWORK_ERROR,
        {
          operation: "getDefaultProvider",
          network: t,
        }
      ),
    r._defaultProvider(
      {
        FallbackProvider: gre,
        AlchemyProvider: QD,
        AnkrProvider: sre,
        CloudflareProvider: cre,
        EtherscanProvider: ure,
        InfuraProvider: YD,
        JsonRpcProvider: Af,
        NodesmithProvider: _re,
        PocketProvider: Ere,
        Web3Provider: kf,
        IpcProvider: bre,
      },
      e
    )
  );
}
const Are = "solidity/5.7.0",
  kre = new RegExp("^bytes([0-9]+)$"),
  Sre = new RegExp("^(u?int)([0-9]*)$"),
  Mre = new RegExp("^(.*)\\[([0-9]*)\\]$"),
  Ire = "0000000000000000000000000000000000000000000000000000000000000000",
  d0 = new ue(Are);
function eO(t, e, r) {
  switch (t) {
    case "address":
      return r ? Dh(e, 32) : qe(e);
    case "string":
      return Lt(e);
    case "bytes":
      return qe(e);
    case "bool":
      return (e = e ? "0x01" : "0x00"), r ? Dh(e, 32) : qe(e);
  }
  let n = t.match(Sre);
  if (n) {
    let i = parseInt(n[2] || "256");
    return (
      ((n[2] && String(i) !== n[2]) || i % 8 !== 0 || i === 0 || i > 256) &&
        d0.throwArgumentError("invalid number type", "type", t),
      r && (i = 256),
      (e = ae.from(e).toTwos(i)),
      Dh(e, i / 8)
    );
  }
  if (((n = t.match(kre)), n)) {
    const i = parseInt(n[1]);
    return (
      (String(i) !== n[1] || i === 0 || i > 32) &&
        d0.throwArgumentError("invalid bytes type", "type", t),
      qe(e).byteLength !== i &&
        d0.throwArgumentError(`invalid value for ${t}`, "value", e),
      r ? qe((e + Ire).substring(0, 66)) : e
    );
  }
  if (((n = t.match(Mre)), n && Array.isArray(e))) {
    const i = n[1];
    parseInt(n[2] || String(e.length)) != e.length &&
      d0.throwArgumentError(`invalid array length for ${t}`, "value", e);
    const s = [];
    return (
      e.forEach(function (o) {
        s.push(eO(i, o, !0));
      }),
      cr(s)
    );
  }
  return d0.throwArgumentError("invalid type", "type", t);
}
function rl(t, e) {
  t.length != e.length &&
    d0.throwArgumentError(
      "wrong number of values; expected ${ types.length }",
      "values",
      e
    );
  const r = [];
  return (
    t.forEach(function (n, i) {
      r.push(eO(n, e[i]));
    }),
    Ke(cr(r))
  );
}
function ha(t, e) {
  return Ut(rl(t, e));
}
function Rre(t, e) {
  return Zo(rl(t, e));
}
const Pre = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        keccak256: ha,
        pack: rl,
        sha256: Rre,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  Nre = "units/5.7.0",
  tO = new ue(Nre),
  rO = ["wei", "kwei", "mwei", "gwei", "szabo", "finney", "ether"];
function Bre(t) {
  const e = String(t).split(".");
  (e.length > 2 ||
    !e[0].match(/^-?[0-9]*$/) ||
    (e[1] && !e[1].match(/^[0-9]*$/)) ||
    t === "." ||
    t === "-.") &&
    tO.throwArgumentError("invalid value", "value", t);
  let r = e[0],
    n = "";
  for (
    r.substring(0, 1) === "-" && ((n = "-"), (r = r.substring(1)));
    r.substring(0, 1) === "0";

  )
    r = r.substring(1);
  r === "" && (r = "0");
  let i = "";
  for (
    e.length === 2 && (i = "." + (e[1] || "0"));
    i.length > 2 && i[i.length - 1] === "0";

  )
    i = i.substring(0, i.length - 1);
  const a = [];
  for (; r.length; )
    if (r.length <= 3) {
      a.unshift(r);
      break;
    } else {
      const s = r.length - 3;
      a.unshift(r.substring(s)), (r = r.substring(0, s));
    }
  return n + a.join(",") + i;
}
function nl(t, e) {
  if (typeof e == "string") {
    const r = rO.indexOf(e);
    r !== -1 && (e = 3 * r);
  }
  return qy(t, e ?? 18);
}
function ya(t, e) {
  if (
    (typeof t != "string" &&
      tO.throwArgumentError("value must be a string", "value", t),
    typeof e == "string")
  ) {
    const r = rO.indexOf(e);
    r !== -1 && (e = 3 * r);
  }
  return Rs(t, e ?? 18);
}
function Wr(t) {
  return nl(t, 18);
}
function lv(t) {
  return ya(t, 18);
}
const Dre = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      commify: Bre,
      formatEther: Wr,
      formatUnits: nl,
      parseEther: lv,
      parseUnits: ya,
    },
    Symbol.toStringTag,
    {
      value: "Module",
    }
  )
);
var Ore = "Invariant failed";
function Je(t, e) {
  if (!t) throw new Error(Ore);
}
var Fre = {
    chain: "ETH",
    chainId: 1,
    explorers: [
      {
        name: "etherscan",
        url: "https://etherscan.io",
        standard: "EIP3091",
      },
      {
        name: "blockscout",
        url: "https://eth.blockscout.com",
        standard: "EIP3091",
      },
    ],
    faucets: [],
    features: [
      {
        name: "EIP1559",
      },
      {
        name: "EIP155",
      },
    ],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/ethereum/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://ethereum.org",
    name: "Ethereum Mainnet",
    nativeCurrency: {
      name: "Ether",
      symbol: "ETH",
      decimals: 18,
    },
    redFlags: [],
    rpc: [
      "https://ethereum.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://mainnet.infura.io/v3/${INFURA_API_KEY}",
      "wss://mainnet.infura.io/ws/v3/${INFURA_API_KEY}",
      "https://eth-mainnet.g.alchemy.com/v2/${ALCHEMY_API_KEY}",
      "https://api.mycryptoapi.com/eth",
      "https://cloudflare-eth.com",
      "https://ethereum.publicnode.com",
      "wss://ethereum.publicnode.com",
      "https://mainnet.gateway.tenderly.co",
      "wss://mainnet.gateway.tenderly.co",
    ],
    shortName: "eth",
    slug: "ethereum",
    testnet: !1,
  },
  Lre = {
    chain: "ETH",
    chainId: 5,
    explorers: [
      {
        name: "etherscan-goerli",
        url: "https://goerli.etherscan.io",
        standard: "EIP3091",
      },
      {
        name: "blockscout-goerli",
        url: "https://eth-goerli.blockscout.com",
        standard: "EIP3091",
      },
    ],
    faucets: [
      "https://faucet.paradigm.xyz/",
      "http://fauceth.komputing.org?chain=5&address=${ADDRESS}",
      "https://goerli-faucet.slock.it?address=${ADDRESS}",
      "https://faucet.goerli.mudit.blog",
    ],
    features: [],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/ethereum/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://goerli.net/#about",
    name: "Goerli",
    nativeCurrency: {
      name: "Goerli Ether",
      symbol: "ETH",
      decimals: 18,
    },
    redFlags: [],
    rpc: [
      "https://goerli.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://goerli.infura.io/v3/${INFURA_API_KEY}",
      "wss://goerli.infura.io/v3/${INFURA_API_KEY}",
      "https://eth-goerli.g.alchemy.com/v2/${ALCHEMY_API_KEY}",
      "https://rpc.goerli.mudit.blog/",
      "https://ethereum-goerli.publicnode.com",
      "wss://ethereum-goerli.publicnode.com",
      "https://goerli.gateway.tenderly.co",
      "wss://goerli.gateway.tenderly.co",
    ],
    shortName: "gor",
    slug: "goerli",
    testnet: !0,
  },
  $re = {
    chain: "ETH",
    chainId: 10,
    explorers: [
      {
        name: "etherscan",
        url: "https://optimistic.etherscan.io",
        standard: "EIP3091",
      },
      {
        name: "blockscout",
        url: "https://optimism.blockscout.com",
        standard: "EIP3091",
      },
    ],
    faucets: [],
    features: [],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/optimism/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://optimism.io",
    name: "OP Mainnet",
    nativeCurrency: {
      name: "Ether",
      symbol: "ETH",
      decimals: 18,
    },
    redFlags: [],
    rpc: [
      "https://optimism.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://optimism-mainnet.infura.io/v3/${INFURA_API_KEY}",
      "https://opt-mainnet.g.alchemy.com/v2/${ALCHEMY_API_KEY}",
      "https://mainnet.optimism.io",
      "https://optimism.publicnode.com",
      "wss://optimism.publicnode.com",
      "https://optimism.gateway.tenderly.co",
      "wss://optimism.gateway.tenderly.co",
    ],
    shortName: "oeth",
    slug: "optimism",
    testnet: !1,
  },
  Ure = {
    chain: "BSC",
    chainId: 56,
    explorers: [
      {
        name: "bscscan",
        url: "https://bscscan.com",
        standard: "EIP3091",
      },
    ],
    faucets: [],
    features: [],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/binance-coin/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://www.bnbchain.org/en",
    name: "BNB Smart Chain Mainnet",
    nativeCurrency: {
      name: "BNB Chain Native Token",
      symbol: "BNB",
      decimals: 18,
    },
    redFlags: [],
    rpc: [
      "https://binance.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "wss://bsc-ws-node.nariox.org",
      "wss://bsc.publicnode.com",
      "https://bsc.publicnode.com",
      "https://bsc-dataseed4.ninicoin.io",
      "https://bsc-dataseed3.ninicoin.io",
      "https://bsc-dataseed2.ninicoin.io",
      "https://bsc-dataseed1.ninicoin.io",
      "https://bsc-dataseed4.defibit.io",
      "https://bsc-dataseed3.defibit.io",
      "https://bsc-dataseed2.defibit.io",
      "https://bsc-dataseed1.defibit.io",
      "https://bsc-dataseed4.bnbchain.org",
      "https://bsc-dataseed3.bnbchain.org",
      "https://bsc-dataseed2.bnbchain.org",
      "https://bsc-dataseed1.bnbchain.org",
    ],
    shortName: "bnb",
    slug: "binance",
    testnet: !1,
  },
  Wre = {
    chain: "BSC",
    chainId: 97,
    explorers: [
      {
        name: "bscscan-testnet",
        url: "https://testnet.bscscan.com",
        standard: "EIP3091",
      },
    ],
    faucets: ["https://testnet.bnbchain.org/faucet-smart"],
    features: [],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/binance-coin/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://www.bnbchain.org/en",
    name: "BNB Smart Chain Testnet",
    nativeCurrency: {
      name: "BNB Chain Native Token",
      symbol: "BNB",
      decimals: 18,
    },
    redFlags: [],
    rpc: [
      "https://binance-testnet.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "wss://bsc-testnet.publicnode.com",
      "https://bsc-testnet.publicnode.com",
      "https://data-seed-prebsc-2-s3.bnbchain.org:8545",
      "https://data-seed-prebsc-1-s3.bnbchain.org:8545",
      "https://data-seed-prebsc-2-s2.bnbchain.org:8545",
      "https://data-seed-prebsc-1-s2.bnbchain.org:8545",
      "https://data-seed-prebsc-2-s1.bnbchain.org:8545",
      "https://data-seed-prebsc-1-s1.bnbchain.org:8545",
    ],
    shortName: "bnbt",
    slug: "binance-testnet",
    testnet: !0,
  },
  jre = {
    chain: "Polygon",
    chainId: 137,
    explorers: [
      {
        name: "polygonscan",
        url: "https://polygonscan.com",
        standard: "EIP3091",
      },
    ],
    faucets: [],
    features: [],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/polygon/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://polygon.technology/",
    name: "Polygon Mainnet",
    nativeCurrency: {
      name: "MATIC",
      symbol: "MATIC",
      decimals: 18,
    },
    redFlags: [],
    rpc: [
      "https://polygon.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://polygon-mainnet.infura.io/v3/${INFURA_API_KEY}",
      "https://polygon-mainnet.g.alchemy.com/v2/${ALCHEMY_API_KEY}",
      "https://polygon-rpc.com/",
      "https://rpc-mainnet.matic.network",
      "https://matic-mainnet.chainstacklabs.com",
      "https://rpc-mainnet.maticvigil.com",
      "https://rpc-mainnet.matic.quiknode.pro",
      "https://matic-mainnet-full-rpc.bwarelabs.com",
      "https://polygon-bor.publicnode.com",
      "wss://polygon-bor.publicnode.com",
      "https://polygon.gateway.tenderly.co",
      "wss://polygon.gateway.tenderly.co",
    ],
    shortName: "matic",
    slug: "polygon",
    testnet: !1,
  },
  Hre = {
    chain: "FTM",
    chainId: 250,
    explorers: [
      {
        name: "ftmscan",
        url: "https://ftmscan.com",
        standard: "EIP3091",
      },
    ],
    faucets: [],
    features: [],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/fantom/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://fantom.foundation",
    name: "Fantom Opera",
    nativeCurrency: {
      name: "Fantom",
      symbol: "FTM",
      decimals: 18,
    },
    redFlags: [],
    rpc: [
      "https://fantom.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "wss://fantom.publicnode.com",
      "https://fantom.publicnode.com",
      "https://rpc.ftm.tools",
    ],
    shortName: "ftm",
    slug: "fantom",
    testnet: !1,
  },
  zre = {
    chain: "ETH",
    chainId: 420,
    explorers: [
      {
        name: "blockscout",
        url: "https://optimism-goerli.blockscout.com",
        standard: "EIP3091",
      },
    ],
    faucets: ["https://coinbase.com/faucets/optimism-goerli-faucet"],
    features: [],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/optimism/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://optimism.io",
    name: "Optimism Goerli Testnet",
    nativeCurrency: {
      name: "Goerli Ether",
      symbol: "ETH",
      decimals: 18,
    },
    redFlags: [],
    rpc: [
      "https://optimism-goerli.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://optimism-goerli.infura.io/v3/${INFURA_API_KEY}",
      "https://opt-goerli.g.alchemy.com/v2/${ALCHEMY_API_KEY}",
      "https://goerli.optimism.io",
      "https://optimism-goerli.publicnode.com",
      "wss://optimism-goerli.publicnode.com",
      "https://optimism-goerli.gateway.tenderly.co",
      "wss://optimism-goerli.gateway.tenderly.co",
    ],
    shortName: "ogor",
    slug: "optimism-goerli",
    testnet: !0,
  },
  qre = {
    chain: "ETH",
    chainId: 1337,
    explorers: [],
    faucets: [],
    features: [],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/ethereum/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    name: "Localhost",
    nativeCurrency: {
      name: "Ether",
      symbol: "ETH",
      decimals: 18,
    },
    redFlags: [],
    rpc: [
      "https://localhost.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "http://localhost:8545",
    ],
    shortName: "local",
    slug: "localhost",
    testnet: !0,
  },
  Vre = {
    chain: "FTM",
    chainId: 4002,
    explorers: [
      {
        name: "ftmscan",
        url: "https://testnet.ftmscan.com",
        standard: "EIP3091",
      },
    ],
    faucets: ["https://faucet.fantom.network"],
    features: [],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/fantom/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL:
      "https://docs.fantom.foundation/quick-start/short-guide#fantom-testnet",
    name: "Fantom Testnet",
    nativeCurrency: {
      name: "Fantom",
      symbol: "FTM",
      decimals: 18,
    },
    redFlags: [],
    rpc: [
      "https://fantom-testnet.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "wss://fantom-testnet.publicnode.com",
      "https://fantom-testnet.publicnode.com",
      "https://rpc.testnet.fantom.network",
    ],
    shortName: "tftm",
    slug: "fantom-testnet",
    testnet: !0,
  },
  Kre = {
    chain: "ETH",
    chainId: 8453,
    explorers: [
      {
        name: "basescan",
        url: "https://basescan.org",
        standard: "none",
      },
      {
        name: "basescout",
        url: "https://base.blockscout.com",
        standard: "EIP3091",
      },
    ],
    faucets: [],
    features: [],
    icon: {
      url: "ipfs://QmW5Vn15HeRkScMfPcW12ZdZcC2yUASpu6eCsECRdEmjjj/base-512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://base.org",
    name: "Base",
    nativeCurrency: {
      name: "Ether",
      symbol: "ETH",
      decimals: 18,
    },
    redFlags: [],
    rpc: [
      "https://base.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://mainnet.base.org/",
      "https://developer-access-mainnet.base.org/",
      "https://base.gateway.tenderly.co",
      "wss://base.gateway.tenderly.co",
      "https://base.publicnode.com",
      "wss://base.publicnode.com",
    ],
    shortName: "base",
    slug: "base",
    status: "active",
    testnet: !1,
  },
  Gre = {
    chain: "ETH",
    chainId: 42161,
    explorers: [
      {
        name: "Arbitrum Explorer",
        url: "https://explorer.arbitrum.io",
        standard: "EIP3091",
      },
      {
        name: "Arbiscan",
        url: "https://arbiscan.io",
        standard: "EIP3091",
      },
    ],
    faucets: [],
    features: [],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/arbitrum/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://arbitrum.io",
    name: "Arbitrum One",
    nativeCurrency: {
      name: "Ether",
      symbol: "ETH",
      decimals: 18,
    },
    redFlags: [],
    rpc: [
      "https://arbitrum.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://arbitrum-mainnet.infura.io/v3/${INFURA_API_KEY}",
      "https://arb-mainnet.g.alchemy.com/v2/${ALCHEMY_API_KEY}",
      "https://arb1.arbitrum.io/rpc",
      "https://arbitrum-one.publicnode.com",
      "wss://arbitrum-one.publicnode.com",
    ],
    shortName: "arb1",
    slug: "arbitrum",
    testnet: !1,
  },
  Zre = {
    chain: "AVAX",
    chainId: 43113,
    explorers: [
      {
        name: "snowtrace",
        url: "https://testnet.snowtrace.io",
        standard: "EIP3091",
      },
    ],
    faucets: [
      "https://faucet.avax.network/",
      "https://faucet.avax-test.network/",
    ],
    features: [],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/avalanche/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://cchain.explorer.avax-test.network",
    name: "Avalanche Fuji Testnet",
    nativeCurrency: {
      name: "Avalanche",
      symbol: "AVAX",
      decimals: 18,
    },
    redFlags: [],
    rpc: [
      "https://avalanche-fuji.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://avalanche-fuji.infura.io/v3/${INFURA_API_KEY}",
      "https://api.avax-test.network/ext/bc/C/rpc",
      "https://avalanche-fuji-c-chain.publicnode.com",
      "wss://avalanche-fuji-c-chain.publicnode.com",
    ],
    shortName: "Fuji",
    slug: "avalanche-fuji",
    testnet: !0,
  },
  Jre = {
    chain: "AVAX",
    chainId: 43114,
    explorers: [
      {
        name: "snowtrace",
        url: "https://snowtrace.io",
        standard: "EIP3091",
      },
    ],
    faucets: [],
    features: [
      {
        name: "EIP1559",
      },
    ],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/avalanche/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://www.avax.network/",
    name: "Avalanche C-Chain",
    nativeCurrency: {
      name: "Avalanche",
      symbol: "AVAX",
      decimals: 18,
    },
    redFlags: [],
    rpc: [
      "https://avalanche.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://avalanche-mainnet.infura.io/v3/${INFURA_API_KEY}",
      "https://api.avax.network/ext/bc/C/rpc",
      "https://avalanche-c-chain.publicnode.com",
      "wss://avalanche-c-chain.publicnode.com",
    ],
    shortName: "avax",
    slug: "avalanche",
    testnet: !1,
  },
  Qre = {
    chain: "Polygon",
    chainId: 80001,
    explorers: [
      {
        name: "polygonscan",
        url: "https://mumbai.polygonscan.com",
        standard: "EIP3091",
      },
    ],
    faucets: ["https://faucet.polygon.technology/"],
    features: [],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/polygon/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://polygon.technology/",
    name: "Mumbai",
    nativeCurrency: {
      name: "MATIC",
      symbol: "MATIC",
      decimals: 18,
    },
    redFlags: [],
    rpc: [
      "https://mumbai.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://polygon-mumbai.infura.io/v3/${INFURA_API_KEY}",
      "https://polygon-mumbai.g.alchemy.com/v2/${ALCHEMY_API_KEY}",
      "https://rpc-mumbai.maticvigil.com",
      "https://polygon-mumbai-bor.publicnode.com",
      "wss://polygon-mumbai-bor.publicnode.com",
      "https://polygon-mumbai.gateway.tenderly.co",
      "wss://polygon-mumbai.gateway.tenderly.co",
    ],
    shortName: "maticmum",
    slug: "mumbai",
    testnet: !0,
  },
  Yre = {
    chain: "ETH",
    chainId: 84531,
    explorers: [
      {
        name: "basescan",
        url: "https://goerli.basescan.org",
        standard: "none",
      },
      {
        name: "basescout",
        url: "https://base-goerli.blockscout.com",
        standard: "EIP3091",
      },
    ],
    faucets: ["https://www.coinbase.com/faucets/base-ethereum-goerli-faucet"],
    features: [],
    icon: {
      url: "ipfs://QmW5Vn15HeRkScMfPcW12ZdZcC2yUASpu6eCsECRdEmjjj/base-512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://base.org",
    name: "Base Goerli Testnet",
    nativeCurrency: {
      name: "Goerli Ether",
      symbol: "ETH",
      decimals: 18,
    },
    redFlags: [],
    rpc: [
      "https://base-goerli.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "wss://base-goerli.publicnode.com",
      "https://base-goerli.publicnode.com",
      "wss://base-goerli.gateway.tenderly.co",
      "https://base-goerli.gateway.tenderly.co",
      "https://goerli.base.org",
    ],
    shortName: "basegor",
    slug: "base-goerli",
    testnet: !0,
  },
  Xre = {
    chain: "ETH",
    chainId: 421613,
    explorers: [
      {
        name: "Arbitrum Goerli Rollup Explorer",
        url: "https://goerli-rollup-explorer.arbitrum.io",
        standard: "EIP3091",
      },
    ],
    faucets: [],
    features: [],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/arbitrum/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://arbitrum.io/",
    name: "Arbitrum Goerli",
    nativeCurrency: {
      name: "Arbitrum Goerli Ether",
      symbol: "AGOR",
      decimals: 18,
    },
    redFlags: [],
    rpc: [
      "https://arbitrum-goerli.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://arbitrum-goerli.infura.io/v3/${INFURA_API_KEY}",
      "https://arb-goerli.g.alchemy.com/v2/${ALCHEMY_API_KEY}",
      "https://goerli-rollup.arbitrum.io/rpc",
      "https://arbitrum-goerli.publicnode.com",
      "wss://arbitrum-goerli.publicnode.com",
    ],
    shortName: "arb-goerli",
    slug: "arbitrum-goerli",
    testnet: !0,
  };
function uE(t, e) {
  let r =
    arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "http";
  const n = [];
  if (
    (t.rpc.forEach((i) => {
      if (
        !(r === "http" && !i.startsWith("http")) &&
        !(r === "ws" && !i.startsWith("ws"))
      )
        if (i.includes("${THIRDWEB_API_KEY}"))
          e
            ? n.push(
                i.replace("${THIRDWEB_API_KEY}", e) +
                  (typeof globalThis < "u" && "APP_BUNDLE_ID" in globalThis
                    ? `/?bundleId=${globalThis.APP_BUNDLE_ID}`
                    : "")
              )
            : n.push(i.replace("${THIRDWEB_API_KEY}", ""));
        else {
          if (i.includes("${")) return;
          n.push(i);
        }
    }),
    n.length === 0)
  )
    throw new Error(
      `No RPC available for chainId "${t.chainId}" with mode ${r}`
    );
  return n;
}
function bS(t, e) {
  try {
    return {
      ...t,
      rpc: uE(t, e),
    };
  } catch {
    return t;
  }
}
const ene = [
    Fre,
    Lre,
    Kre,
    Yre,
    jre,
    Qre,
    Gre,
    Xre,
    $re,
    zre,
    Ure,
    Wre,
    Hre,
    Vre,
    Jre,
    Zre,
    qre,
  ],
  tne = (t) => {
    let { queryClient: e, children: r } = t;
    const n = ye.useMemo(() => e || new lZ(), [e]);
    return de.jsx(CZ, {
      client: n,
      children: r,
    });
  },
  vS = ne.instanceof(File),
  rne = ne.union([
    vS,
    ne.object({
      data: ne.union([vS, ne.string()]),
      name: ne.string(),
    }),
  ]),
  gu = ne.union([rne, ne.string()]),
  nO = 1e4,
  nne = ne.union([ne.array(ne.number()), ne.string()]),
  iO = ne
    .union([
      ne.bigint(),
      ne.custom((t) => ae.isBigNumber(t)),
      ne.custom((t) => pt.isBN(t)),
    ])
    .transform((t) =>
      pt.isBN(t) ? new pt(t).toString() : ae.from(t).toString()
    ),
  yd = ne.number().max(nO, "Cannot exceed 100%").min(0, "Cannot be below 0%"),
  ine = ne.number().max(100, "Cannot exceed 100%").min(0, "Cannot be below 0%"),
  ane = ne.union([
    ne.string().regex(/^([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, "Invalid hex color"),
    ne
      .string()
      .regex(/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, "Invalid hex color")
      .transform((t) => t.replace("#", "")),
    ne.string().length(0),
  ]),
  Gi = ne
    .union([
      ne.string().regex(/^([0-9]+\.?[0-9]*|\.[0-9]+)$/, "Invalid amount"),
      ne.number().min(0, "Amount cannot be negative"),
    ])
    .transform((t) => (typeof t == "number" ? t.toString() : t)),
  Sf = ne.union([Gi, ne.literal("unlimited")]).default("unlimited"),
  xS = ne.object({}).catchall(ne.union([iO, ne.unknown()])),
  wS = ne
    .union([ne.array(xS), xS])
    .optional()
    .nullable(),
  aO = ne.object({
    name: ne.union([ne.string(), ne.number()]).optional().nullable(),
    description: ne.string().nullable().optional().nullable(),
    image: gu.nullable().optional(),
    animation_url: gu.optional().nullable(),
  }),
  il = aO
    .extend({
      external_url: gu.nullable().optional(),
      background_color: ane.optional().nullable(),
      properties: wS,
      attributes: wS,
    })
    .catchall(ne.union([iO, ne.unknown()])),
  uv = ne.union([il, ne.string()]),
  h_ = il.extend({
    id: ne.string(),
    uri: ne.string(),
    image: ne.string().nullable().optional(),
    external_url: ne.string().nullable().optional(),
    animation_url: ne.string().nullable().optional(),
  }),
  Hh = 100;
var gd = {},
  p_ = {
    exports: {},
  };
function sne(t) {
  if (t.length >= 255) throw new TypeError("Alphabet too long");
  for (var e = new Uint8Array(256), r = 0; r < e.length; r++) e[r] = 255;
  for (var n = 0; n < t.length; n++) {
    var i = t.charAt(n),
      a = i.charCodeAt(0);
    if (e[a] !== 255) throw new TypeError(i + " is ambiguous");
    e[a] = n;
  }
  var s = t.length,
    o = t.charAt(0),
    c = Math.log(s) / Math.log(256),
    u = Math.log(256) / Math.log(s);
  function d(E) {
    if (
      (E instanceof Uint8Array ||
        (ArrayBuffer.isView(E)
          ? (E = new Uint8Array(E.buffer, E.byteOffset, E.byteLength))
          : Array.isArray(E) && (E = Uint8Array.from(E))),
      !(E instanceof Uint8Array))
    )
      throw new TypeError("Expected Uint8Array");
    if (E.length === 0) return "";
    for (var A = 0, I = 0, b = 0, w = E.length; b !== w && E[b] === 0; )
      b++, A++;
    for (var S = ((w - b) * u + 1) >>> 0, k = new Uint8Array(S); b !== w; ) {
      for (
        var N = E[b], O = 0, F = S - 1;
        (N !== 0 || O < I) && F !== -1;
        F--, O++
      )
        (N += (256 * k[F]) >>> 0), (k[F] = N % s >>> 0), (N = (N / s) >>> 0);
      if (N !== 0) throw new Error("Non-zero carry");
      (I = O), b++;
    }
    for (var V = S - I; V !== S && k[V] === 0; ) V++;
    for (var j = o.repeat(A); V < S; ++V) j += t.charAt(k[V]);
    return j;
  }
  function m(E) {
    if (typeof E != "string") throw new TypeError("Expected String");
    if (E.length === 0) return new Uint8Array();
    var A = 0;
    if (E[A] !== " ") {
      for (var I = 0, b = 0; E[A] === o; ) I++, A++;
      for (
        var w = ((E.length - A) * c + 1) >>> 0, S = new Uint8Array(w);
        E[A];

      ) {
        var k = e[E.charCodeAt(A)];
        if (k === 255) return;
        for (var N = 0, O = w - 1; (k !== 0 || N < b) && O !== -1; O--, N++)
          (k += (s * S[O]) >>> 0),
            (S[O] = k % 256 >>> 0),
            (k = (k / 256) >>> 0);
        if (k !== 0) throw new Error("Non-zero carry");
        (b = N), A++;
      }
      if (E[A] !== " ") {
        for (var F = w - b; F !== w && S[F] === 0; ) F++;
        for (var V = new Uint8Array(I + (w - F)), j = I; F !== w; )
          V[j++] = S[F++];
        return V;
      }
    }
  }
  function v(E) {
    var A = m(E);
    if (A) return A;
    throw new Error("Non-base" + s + " character");
  }
  return {
    encode: d,
    decodeUnsafe: m,
    decode: v,
  };
}
var one = sne;
const cne = new TextDecoder(),
  lne = (t) => cne.decode(t),
  une = new TextEncoder(),
  fne = (t) => une.encode(t);
function dne(t, e) {
  const r = new Uint8Array(e);
  let n = 0;
  for (const i of t) r.set(i, n), (n += i.length);
  return r;
}
var fE = {
  decodeText: lne,
  encodeText: fne,
  concat: dne,
};
const { encodeText: hne } = fE;
let pne = class {
  constructor(e, r, n, i) {
    (this.name = e),
      (this.code = r),
      (this.codeBuf = hne(this.code)),
      (this.alphabet = i),
      (this.codec = n(i));
  }
  encode(e) {
    return this.codec.encode(e);
  }
  decode(e) {
    for (const r of e)
      if (this.alphabet && this.alphabet.indexOf(r) < 0)
        throw new Error(`invalid character '${r}' in '${e}'`);
    return this.codec.decode(e);
  }
};
var mne = pne;
const yne = (t, e, r) => {
    const n = {};
    for (let u = 0; u < e.length; ++u) n[e[u]] = u;
    let i = t.length;
    for (; t[i - 1] === "="; ) --i;
    const a = new Uint8Array(((i * r) / 8) | 0);
    let s = 0,
      o = 0,
      c = 0;
    for (let u = 0; u < i; ++u) {
      const d = n[t[u]];
      if (d === void 0) throw new SyntaxError("Invalid character " + t[u]);
      (o = (o << r) | d),
        (s += r),
        s >= 8 && ((s -= 8), (a[c++] = 255 & (o >> s)));
    }
    if (s >= r || 255 & (o << (8 - s)))
      throw new SyntaxError("Unexpected end of data");
    return a;
  },
  gne = (t, e, r) => {
    const n = e[e.length - 1] === "=",
      i = (1 << r) - 1;
    let a = "",
      s = 0,
      o = 0;
    for (let c = 0; c < t.length; ++c)
      for (o = (o << 8) | t[c], s += 8; s > r; )
        (s -= r), (a += e[i & (o >> s)]);
    if ((s && (a += e[i & (o << (r - s))]), n))
      for (; (a.length * r) & 7; ) a += "=";
    return a;
  },
  bne = (t) => (e) => ({
    encode(r) {
      return gne(r, e, t);
    },
    decode(r) {
      return yne(r, e, t);
    },
  });
var vne = {
  rfc4648: bne,
};
const th = one,
  xne = mne,
  { rfc4648: Fn } = vne,
  { decodeText: wne, encodeText: _ne } = fE,
  Ene = () => ({
    encode: wne,
    decode: _ne,
  }),
  sO = [
    ["identity", "\0", Ene, ""],
    ["base2", "0", Fn(1), "01"],
    ["base8", "7", Fn(3), "01234567"],
    ["base10", "9", th, "0123456789"],
    ["base16", "f", Fn(4), "0123456789abcdef"],
    ["base16upper", "F", Fn(4), "0123456789ABCDEF"],
    ["base32hex", "v", Fn(5), "0123456789abcdefghijklmnopqrstuv"],
    ["base32hexupper", "V", Fn(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV"],
    ["base32hexpad", "t", Fn(5), "0123456789abcdefghijklmnopqrstuv="],
    ["base32hexpadupper", "T", Fn(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV="],
    ["base32", "b", Fn(5), "abcdefghijklmnopqrstuvwxyz234567"],
    ["base32upper", "B", Fn(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"],
    ["base32pad", "c", Fn(5), "abcdefghijklmnopqrstuvwxyz234567="],
    ["base32padupper", "C", Fn(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567="],
    ["base32z", "h", Fn(5), "ybndrfg8ejkmcpqxot1uwisza345h769"],
    ["base36", "k", th, "0123456789abcdefghijklmnopqrstuvwxyz"],
    ["base36upper", "K", th, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"],
    [
      "base58btc",
      "z",
      th,
      "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
    ],
    [
      "base58flickr",
      "Z",
      th,
      "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
    ],
    [
      "base64",
      "m",
      Fn(6),
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    ],
    [
      "base64pad",
      "M",
      Fn(6),
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    ],
    [
      "base64url",
      "u",
      Fn(6),
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    ],
    [
      "base64urlpad",
      "U",
      Fn(6),
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    ],
  ],
  oO = sO.reduce(
    (t, e) => ((t[e[0]] = new xne(e[0], e[1], e[2], e[3])), t),
    {}
  ),
  Tne = sO.reduce((t, e) => ((t[e[1]] = oO[e[0]]), t), {});
var Cne = {
  names: oO,
  codes: Tne,
};
(function (t, e) {
  const r = Cne,
    { encodeText: n, decodeText: i, concat: a } = fE;
  function s(I, b) {
    if (!b) throw new Error("requires an encoded Uint8Array");
    const { name: w, codeBuf: S } = m(I);
    return d(w, b), a([S, b], S.length + b.length);
  }
  function o(I, b) {
    const w = m(I),
      S = n(w.encode(b));
    return a([w.codeBuf, S], w.codeBuf.length + S.length);
  }
  function c(I) {
    I instanceof Uint8Array && (I = i(I));
    const b = I[0];
    return (
      [
        "f",
        "F",
        "v",
        "V",
        "t",
        "T",
        "b",
        "B",
        "c",
        "C",
        "h",
        "k",
        "K",
      ].includes(b) && (I = I.toLowerCase()),
      m(I[0]).decode(I.substring(1))
    );
  }
  function u(I) {
    if (
      (I instanceof Uint8Array && (I = i(I)),
      Object.prototype.toString.call(I) !== "[object String]")
    )
      return !1;
    try {
      return m(I[0]).name;
    } catch {
      return !1;
    }
  }
  function d(I, b) {
    m(I).decode(i(b));
  }
  function m(I) {
    if (Object.prototype.hasOwnProperty.call(r.names, I)) return r.names[I];
    if (Object.prototype.hasOwnProperty.call(r.codes, I)) return r.codes[I];
    throw new Error(`Unsupported encoding: ${I}`);
  }
  function v(I) {
    return I instanceof Uint8Array && (I = i(I)), m(I[0]);
  }
  (e = t.exports = s),
    (e.encode = o),
    (e.decode = c),
    (e.isEncoded = u),
    (e.encoding = m),
    (e.encodingFromData = v);
  const E = Object.freeze(r.names),
    A = Object.freeze(r.codes);
  (e.names = E), (e.codes = A);
})(p_, p_.exports);
var fv = p_.exports,
  Ane = cO,
  _S = 128,
  kne = 127,
  Sne = ~kne,
  Mne = Math.pow(2, 31);
function cO(t, e, r) {
  (e = e || []), (r = r || 0);
  for (var n = r; t >= Mne; ) (e[r++] = (t & 255) | _S), (t /= 128);
  for (; t & Sne; ) (e[r++] = (t & 255) | _S), (t >>>= 7);
  return (e[r] = t | 0), (cO.bytes = r - n + 1), e;
}
var Ine = m_,
  Rne = 128,
  ES = 127;
function m_(t, n) {
  var r = 0,
    n = n || 0,
    i = 0,
    a = n,
    s,
    o = t.length;
  do {
    if (a >= o)
      throw ((m_.bytes = 0), new RangeError("Could not decode varint"));
    (s = t[a++]),
      (r += i < 28 ? (s & ES) << i : (s & ES) * Math.pow(2, i)),
      (i += 7);
  } while (s >= Rne);
  return (m_.bytes = a - n), r;
}
var Pne = Math.pow(2, 7),
  Nne = Math.pow(2, 14),
  Bne = Math.pow(2, 21),
  Dne = Math.pow(2, 28),
  One = Math.pow(2, 35),
  Fne = Math.pow(2, 42),
  Lne = Math.pow(2, 49),
  $ne = Math.pow(2, 56),
  Une = Math.pow(2, 63),
  Wne = function (t) {
    return t < Pne
      ? 1
      : t < Nne
      ? 2
      : t < Bne
      ? 3
      : t < Dne
      ? 4
      : t < One
      ? 5
      : t < Fne
      ? 6
      : t < Lne
      ? 7
      : t < $ne
      ? 8
      : t < Une
      ? 9
      : 10;
  },
  jne = {
    encode: Ane,
    decode: Ine,
    encodingLength: Wne,
  };
const Hne = Object.freeze({
  identity: 0,
  sha1: 17,
  "sha2-256": 18,
  "sha2-512": 19,
  "sha3-512": 20,
  "sha3-384": 21,
  "sha3-256": 22,
  "sha3-224": 23,
  "shake-128": 24,
  "shake-256": 25,
  "keccak-224": 26,
  "keccak-256": 27,
  "keccak-384": 28,
  "keccak-512": 29,
  blake3: 30,
  "murmur3-128": 34,
  "murmur3-32": 35,
  "dbl-sha2-256": 86,
  md4: 212,
  md5: 213,
  bmt: 214,
  "sha2-256-trunc254-padded": 4114,
  "ripemd-128": 4178,
  "ripemd-160": 4179,
  "ripemd-256": 4180,
  "ripemd-320": 4181,
  x11: 4352,
  kangarootwelve: 7425,
  "sm3-256": 21325,
  "blake2b-8": 45569,
  "blake2b-16": 45570,
  "blake2b-24": 45571,
  "blake2b-32": 45572,
  "blake2b-40": 45573,
  "blake2b-48": 45574,
  "blake2b-56": 45575,
  "blake2b-64": 45576,
  "blake2b-72": 45577,
  "blake2b-80": 45578,
  "blake2b-88": 45579,
  "blake2b-96": 45580,
  "blake2b-104": 45581,
  "blake2b-112": 45582,
  "blake2b-120": 45583,
  "blake2b-128": 45584,
  "blake2b-136": 45585,
  "blake2b-144": 45586,
  "blake2b-152": 45587,
  "blake2b-160": 45588,
  "blake2b-168": 45589,
  "blake2b-176": 45590,
  "blake2b-184": 45591,
  "blake2b-192": 45592,
  "blake2b-200": 45593,
  "blake2b-208": 45594,
  "blake2b-216": 45595,
  "blake2b-224": 45596,
  "blake2b-232": 45597,
  "blake2b-240": 45598,
  "blake2b-248": 45599,
  "blake2b-256": 45600,
  "blake2b-264": 45601,
  "blake2b-272": 45602,
  "blake2b-280": 45603,
  "blake2b-288": 45604,
  "blake2b-296": 45605,
  "blake2b-304": 45606,
  "blake2b-312": 45607,
  "blake2b-320": 45608,
  "blake2b-328": 45609,
  "blake2b-336": 45610,
  "blake2b-344": 45611,
  "blake2b-352": 45612,
  "blake2b-360": 45613,
  "blake2b-368": 45614,
  "blake2b-376": 45615,
  "blake2b-384": 45616,
  "blake2b-392": 45617,
  "blake2b-400": 45618,
  "blake2b-408": 45619,
  "blake2b-416": 45620,
  "blake2b-424": 45621,
  "blake2b-432": 45622,
  "blake2b-440": 45623,
  "blake2b-448": 45624,
  "blake2b-456": 45625,
  "blake2b-464": 45626,
  "blake2b-472": 45627,
  "blake2b-480": 45628,
  "blake2b-488": 45629,
  "blake2b-496": 45630,
  "blake2b-504": 45631,
  "blake2b-512": 45632,
  "blake2s-8": 45633,
  "blake2s-16": 45634,
  "blake2s-24": 45635,
  "blake2s-32": 45636,
  "blake2s-40": 45637,
  "blake2s-48": 45638,
  "blake2s-56": 45639,
  "blake2s-64": 45640,
  "blake2s-72": 45641,
  "blake2s-80": 45642,
  "blake2s-88": 45643,
  "blake2s-96": 45644,
  "blake2s-104": 45645,
  "blake2s-112": 45646,
  "blake2s-120": 45647,
  "blake2s-128": 45648,
  "blake2s-136": 45649,
  "blake2s-144": 45650,
  "blake2s-152": 45651,
  "blake2s-160": 45652,
  "blake2s-168": 45653,
  "blake2s-176": 45654,
  "blake2s-184": 45655,
  "blake2s-192": 45656,
  "blake2s-200": 45657,
  "blake2s-208": 45658,
  "blake2s-216": 45659,
  "blake2s-224": 45660,
  "blake2s-232": 45661,
  "blake2s-240": 45662,
  "blake2s-248": 45663,
  "blake2s-256": 45664,
  "skein256-8": 45825,
  "skein256-16": 45826,
  "skein256-24": 45827,
  "skein256-32": 45828,
  "skein256-40": 45829,
  "skein256-48": 45830,
  "skein256-56": 45831,
  "skein256-64": 45832,
  "skein256-72": 45833,
  "skein256-80": 45834,
  "skein256-88": 45835,
  "skein256-96": 45836,
  "skein256-104": 45837,
  "skein256-112": 45838,
  "skein256-120": 45839,
  "skein256-128": 45840,
  "skein256-136": 45841,
  "skein256-144": 45842,
  "skein256-152": 45843,
  "skein256-160": 45844,
  "skein256-168": 45845,
  "skein256-176": 45846,
  "skein256-184": 45847,
  "skein256-192": 45848,
  "skein256-200": 45849,
  "skein256-208": 45850,
  "skein256-216": 45851,
  "skein256-224": 45852,
  "skein256-232": 45853,
  "skein256-240": 45854,
  "skein256-248": 45855,
  "skein256-256": 45856,
  "skein512-8": 45857,
  "skein512-16": 45858,
  "skein512-24": 45859,
  "skein512-32": 45860,
  "skein512-40": 45861,
  "skein512-48": 45862,
  "skein512-56": 45863,
  "skein512-64": 45864,
  "skein512-72": 45865,
  "skein512-80": 45866,
  "skein512-88": 45867,
  "skein512-96": 45868,
  "skein512-104": 45869,
  "skein512-112": 45870,
  "skein512-120": 45871,
  "skein512-128": 45872,
  "skein512-136": 45873,
  "skein512-144": 45874,
  "skein512-152": 45875,
  "skein512-160": 45876,
  "skein512-168": 45877,
  "skein512-176": 45878,
  "skein512-184": 45879,
  "skein512-192": 45880,
  "skein512-200": 45881,
  "skein512-208": 45882,
  "skein512-216": 45883,
  "skein512-224": 45884,
  "skein512-232": 45885,
  "skein512-240": 45886,
  "skein512-248": 45887,
  "skein512-256": 45888,
  "skein512-264": 45889,
  "skein512-272": 45890,
  "skein512-280": 45891,
  "skein512-288": 45892,
  "skein512-296": 45893,
  "skein512-304": 45894,
  "skein512-312": 45895,
  "skein512-320": 45896,
  "skein512-328": 45897,
  "skein512-336": 45898,
  "skein512-344": 45899,
  "skein512-352": 45900,
  "skein512-360": 45901,
  "skein512-368": 45902,
  "skein512-376": 45903,
  "skein512-384": 45904,
  "skein512-392": 45905,
  "skein512-400": 45906,
  "skein512-408": 45907,
  "skein512-416": 45908,
  "skein512-424": 45909,
  "skein512-432": 45910,
  "skein512-440": 45911,
  "skein512-448": 45912,
  "skein512-456": 45913,
  "skein512-464": 45914,
  "skein512-472": 45915,
  "skein512-480": 45916,
  "skein512-488": 45917,
  "skein512-496": 45918,
  "skein512-504": 45919,
  "skein512-512": 45920,
  "skein1024-8": 45921,
  "skein1024-16": 45922,
  "skein1024-24": 45923,
  "skein1024-32": 45924,
  "skein1024-40": 45925,
  "skein1024-48": 45926,
  "skein1024-56": 45927,
  "skein1024-64": 45928,
  "skein1024-72": 45929,
  "skein1024-80": 45930,
  "skein1024-88": 45931,
  "skein1024-96": 45932,
  "skein1024-104": 45933,
  "skein1024-112": 45934,
  "skein1024-120": 45935,
  "skein1024-128": 45936,
  "skein1024-136": 45937,
  "skein1024-144": 45938,
  "skein1024-152": 45939,
  "skein1024-160": 45940,
  "skein1024-168": 45941,
  "skein1024-176": 45942,
  "skein1024-184": 45943,
  "skein1024-192": 45944,
  "skein1024-200": 45945,
  "skein1024-208": 45946,
  "skein1024-216": 45947,
  "skein1024-224": 45948,
  "skein1024-232": 45949,
  "skein1024-240": 45950,
  "skein1024-248": 45951,
  "skein1024-256": 45952,
  "skein1024-264": 45953,
  "skein1024-272": 45954,
  "skein1024-280": 45955,
  "skein1024-288": 45956,
  "skein1024-296": 45957,
  "skein1024-304": 45958,
  "skein1024-312": 45959,
  "skein1024-320": 45960,
  "skein1024-328": 45961,
  "skein1024-336": 45962,
  "skein1024-344": 45963,
  "skein1024-352": 45964,
  "skein1024-360": 45965,
  "skein1024-368": 45966,
  "skein1024-376": 45967,
  "skein1024-384": 45968,
  "skein1024-392": 45969,
  "skein1024-400": 45970,
  "skein1024-408": 45971,
  "skein1024-416": 45972,
  "skein1024-424": 45973,
  "skein1024-432": 45974,
  "skein1024-440": 45975,
  "skein1024-448": 45976,
  "skein1024-456": 45977,
  "skein1024-464": 45978,
  "skein1024-472": 45979,
  "skein1024-480": 45980,
  "skein1024-488": 45981,
  "skein1024-496": 45982,
  "skein1024-504": 45983,
  "skein1024-512": 45984,
  "skein1024-520": 45985,
  "skein1024-528": 45986,
  "skein1024-536": 45987,
  "skein1024-544": 45988,
  "skein1024-552": 45989,
  "skein1024-560": 45990,
  "skein1024-568": 45991,
  "skein1024-576": 45992,
  "skein1024-584": 45993,
  "skein1024-592": 45994,
  "skein1024-600": 45995,
  "skein1024-608": 45996,
  "skein1024-616": 45997,
  "skein1024-624": 45998,
  "skein1024-632": 45999,
  "skein1024-640": 46e3,
  "skein1024-648": 46001,
  "skein1024-656": 46002,
  "skein1024-664": 46003,
  "skein1024-672": 46004,
  "skein1024-680": 46005,
  "skein1024-688": 46006,
  "skein1024-696": 46007,
  "skein1024-704": 46008,
  "skein1024-712": 46009,
  "skein1024-720": 46010,
  "skein1024-728": 46011,
  "skein1024-736": 46012,
  "skein1024-744": 46013,
  "skein1024-752": 46014,
  "skein1024-760": 46015,
  "skein1024-768": 46016,
  "skein1024-776": 46017,
  "skein1024-784": 46018,
  "skein1024-792": 46019,
  "skein1024-800": 46020,
  "skein1024-808": 46021,
  "skein1024-816": 46022,
  "skein1024-824": 46023,
  "skein1024-832": 46024,
  "skein1024-840": 46025,
  "skein1024-848": 46026,
  "skein1024-856": 46027,
  "skein1024-864": 46028,
  "skein1024-872": 46029,
  "skein1024-880": 46030,
  "skein1024-888": 46031,
  "skein1024-896": 46032,
  "skein1024-904": 46033,
  "skein1024-912": 46034,
  "skein1024-920": 46035,
  "skein1024-928": 46036,
  "skein1024-936": 46037,
  "skein1024-944": 46038,
  "skein1024-952": 46039,
  "skein1024-960": 46040,
  "skein1024-968": 46041,
  "skein1024-976": 46042,
  "skein1024-984": 46043,
  "skein1024-992": 46044,
  "skein1024-1000": 46045,
  "skein1024-1008": 46046,
  "skein1024-1016": 46047,
  "skein1024-1024": 46048,
  "poseidon-bls12_381-a2-fc1": 46081,
  "poseidon-bls12_381-a2-fc1-sc": 46082,
});
var zne = {
  names: Hne,
};
function qne(t, e) {
  if (t.length >= 255) throw new TypeError("Alphabet too long");
  for (var r = new Uint8Array(256), n = 0; n < r.length; n++) r[n] = 255;
  for (var i = 0; i < t.length; i++) {
    var a = t.charAt(i),
      s = a.charCodeAt(0);
    if (r[s] !== 255) throw new TypeError(a + " is ambiguous");
    r[s] = i;
  }
  var o = t.length,
    c = t.charAt(0),
    u = Math.log(o) / Math.log(256),
    d = Math.log(256) / Math.log(o);
  function m(A) {
    if (
      (A instanceof Uint8Array ||
        (ArrayBuffer.isView(A)
          ? (A = new Uint8Array(A.buffer, A.byteOffset, A.byteLength))
          : Array.isArray(A) && (A = Uint8Array.from(A))),
      !(A instanceof Uint8Array))
    )
      throw new TypeError("Expected Uint8Array");
    if (A.length === 0) return "";
    for (var I = 0, b = 0, w = 0, S = A.length; w !== S && A[w] === 0; )
      w++, I++;
    for (var k = ((S - w) * d + 1) >>> 0, N = new Uint8Array(k); w !== S; ) {
      for (
        var O = A[w], F = 0, V = k - 1;
        (O !== 0 || F < b) && V !== -1;
        V--, F++
      )
        (O += (256 * N[V]) >>> 0), (N[V] = O % o >>> 0), (O = (O / o) >>> 0);
      if (O !== 0) throw new Error("Non-zero carry");
      (b = F), w++;
    }
    for (var j = k - b; j !== k && N[j] === 0; ) j++;
    for (var X = c.repeat(I); j < k; ++j) X += t.charAt(N[j]);
    return X;
  }
  function v(A) {
    if (typeof A != "string") throw new TypeError("Expected String");
    if (A.length === 0) return new Uint8Array();
    var I = 0;
    if (A[I] !== " ") {
      for (var b = 0, w = 0; A[I] === c; ) b++, I++;
      for (
        var S = ((A.length - I) * u + 1) >>> 0, k = new Uint8Array(S);
        A[I];

      ) {
        var N = r[A.charCodeAt(I)];
        if (N === 255) return;
        for (var O = 0, F = S - 1; (N !== 0 || O < w) && F !== -1; F--, O++)
          (N += (o * k[F]) >>> 0),
            (k[F] = N % 256 >>> 0),
            (N = (N / 256) >>> 0);
        if (N !== 0) throw new Error("Non-zero carry");
        (w = O), I++;
      }
      if (A[I] !== " ") {
        for (var V = S - w; V !== S && k[V] === 0; ) V++;
        for (var j = new Uint8Array(b + (S - V)), X = b; V !== S; )
          j[X++] = k[V++];
        return j;
      }
    }
  }
  function E(A) {
    var I = v(A);
    if (I) return I;
    throw new Error(`Non-${e} character`);
  }
  return {
    encode: m,
    decodeUnsafe: v,
    decode: E,
  };
}
var Vne = qne,
  Kne = Vne;
const lO = new Uint8Array(0),
  Gne = (t) => t.reduce((e, r) => e + r.toString(16).padStart(2, "0"), ""),
  Zne = (t) => {
    const e = t.match(/../g);
    return e ? new Uint8Array(e.map((r) => parseInt(r, 16))) : lO;
  },
  uO = (t, e) => {
    if (t === e) return !0;
    if (t.byteLength !== e.byteLength) return !1;
    for (let r = 0; r < t.byteLength; r++) if (t[r] !== e[r]) return !1;
    return !0;
  },
  Fu = (t) => {
    if (t instanceof Uint8Array && t.constructor.name === "Uint8Array")
      return t;
    if (t instanceof ArrayBuffer) return new Uint8Array(t);
    if (ArrayBuffer.isView(t))
      return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
    throw new Error("Unknown type, must be binary type");
  },
  Jne = (t) => t instanceof ArrayBuffer || ArrayBuffer.isView(t),
  fO = (t) => new TextEncoder().encode(t),
  dO = (t) => new TextDecoder().decode(t),
  Qne = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        coerce: Fu,
        empty: lO,
        equals: uO,
        fromHex: Zne,
        fromString: fO,
        isBinary: Jne,
        toHex: Gne,
        toString: dO,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  );
class Yne {
  constructor(e, r, n) {
    (this.name = e), (this.prefix = r), (this.baseEncode = n);
  }
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
let Xne = class {
  constructor(e, r, n) {
    if (((this.name = e), (this.prefix = r), r.codePointAt(0) === void 0))
      throw new Error("Invalid prefix character");
    (this.prefixCodePoint = r.codePointAt(0)), (this.baseDecode = n);
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(
          `Unable to decode multibase string ${JSON.stringify(e)}, ${
            this.name
          } decoder only supports inputs prefixed with ${this.prefix}`
        );
      return this.baseDecode(e.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e) {
    return hO(this, e);
  }
};
class eie {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return hO(this, e);
  }
  decode(e) {
    const r = e[0],
      n = this.decoders[r];
    if (n) return n.decode(e);
    throw RangeError(
      `Unable to decode multibase string ${JSON.stringify(
        e
      )}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`
    );
  }
}
const hO = (t, e) =>
  new eie({
    ...(t.decoders || {
      [t.prefix]: t,
    }),
    ...(e.decoders || {
      [e.prefix]: e,
    }),
  });
class tie {
  constructor(e, r, n, i) {
    (this.name = e),
      (this.prefix = r),
      (this.baseEncode = n),
      (this.baseDecode = i),
      (this.encoder = new Yne(e, r, n)),
      (this.decoder = new Xne(e, r, i));
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
}
const dv = ({ name: t, prefix: e, encode: r, decode: n }) =>
    new tie(t, e, r, n),
  $m = ({ prefix: t, name: e, alphabet: r }) => {
    const { encode: n, decode: i } = Kne(r, e);
    return dv({
      prefix: t,
      name: e,
      encode: n,
      decode: (a) => Fu(i(a)),
    });
  },
  rie = (t, e, r, n) => {
    const i = {};
    for (let d = 0; d < e.length; ++d) i[e[d]] = d;
    let a = t.length;
    for (; t[a - 1] === "="; ) --a;
    const s = new Uint8Array(((a * r) / 8) | 0);
    let o = 0,
      c = 0,
      u = 0;
    for (let d = 0; d < a; ++d) {
      const m = i[t[d]];
      if (m === void 0) throw new SyntaxError(`Non-${n} character`);
      (c = (c << r) | m),
        (o += r),
        o >= 8 && ((o -= 8), (s[u++] = 255 & (c >> o)));
    }
    if (o >= r || 255 & (c << (8 - o)))
      throw new SyntaxError("Unexpected end of data");
    return s;
  },
  nie = (t, e, r) => {
    const n = e[e.length - 1] === "=",
      i = (1 << r) - 1;
    let a = "",
      s = 0,
      o = 0;
    for (let c = 0; c < t.length; ++c)
      for (o = (o << 8) | t[c], s += 8; s > r; )
        (s -= r), (a += e[i & (o >> s)]);
    if ((s && (a += e[i & (o << (r - s))]), n))
      for (; (a.length * r) & 7; ) a += "=";
    return a;
  },
  Xn = ({ name: t, prefix: e, bitsPerChar: r, alphabet: n }) =>
    dv({
      prefix: e,
      name: t,
      encode(i) {
        return nie(i, n, r);
      },
      decode(i) {
        return rie(i, n, r, t);
      },
    }),
  iie = dv({
    prefix: "\0",
    name: "identity",
    encode: (t) => dO(t),
    decode: (t) => fO(t),
  }),
  aie = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        identity: iie,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  sie = Xn({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1,
  }),
  oie = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        base2: sie,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  cie = Xn({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3,
  }),
  lie = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        base8: cie,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  uie = $m({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789",
  }),
  fie = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        base10: uie,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  die = Xn({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4,
  }),
  hie = Xn({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4,
  }),
  pie = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        base16: die,
        base16upper: hie,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  zh = Xn({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5,
  }),
  mie = Xn({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5,
  }),
  yie = Xn({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5,
  }),
  gie = Xn({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5,
  }),
  bie = Xn({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5,
  }),
  vie = Xn({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5,
  }),
  xie = Xn({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5,
  }),
  wie = Xn({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5,
  }),
  _ie = Xn({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5,
  }),
  Eie = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        base32: zh,
        base32hex: bie,
        base32hexpad: xie,
        base32hexpadupper: wie,
        base32hexupper: vie,
        base32pad: yie,
        base32padupper: gie,
        base32upper: mie,
        base32z: _ie,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  Tie = $m({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz",
  }),
  Cie = $m({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",
  }),
  Aie = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        base36: Tie,
        base36upper: Cie,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  Po = $m({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
  }),
  kie = $m({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
  }),
  Sie = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        base58btc: Po,
        base58flickr: kie,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  Mie = Xn({
    prefix: "m",
    name: "base64",
    alphabet:
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6,
  }),
  Iie = Xn({
    prefix: "M",
    name: "base64pad",
    alphabet:
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6,
  }),
  Rie = Xn({
    prefix: "u",
    name: "base64url",
    alphabet:
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6,
  }),
  Pie = Xn({
    prefix: "U",
    name: "base64urlpad",
    alphabet:
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6,
  }),
  Nie = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        base64: Mie,
        base64pad: Iie,
        base64url: Rie,
        base64urlpad: Pie,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  pO = Array.from(
    "🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"
  ),
  Bie = pO.reduce((t, e, r) => ((t[r] = e), t), []),
  Die = pO.reduce((t, e, r) => ((t[e.codePointAt(0)] = r), t), []);
function Oie(t) {
  return t.reduce((e, r) => ((e += Bie[r]), e), "");
}
function Fie(t) {
  const e = [];
  for (const r of t) {
    const n = Die[r.codePointAt(0)];
    if (n === void 0) throw new Error(`Non-base256emoji character: ${r}`);
    e.push(n);
  }
  return new Uint8Array(e);
}
const Lie = dv({
    prefix: "🚀",
    name: "base256emoji",
    encode: Oie,
    decode: Fie,
  }),
  $ie = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        base256emoji: Lie,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  );
var Uie = mO,
  TS = 128,
  Wie = 127,
  jie = ~Wie,
  Hie = Math.pow(2, 31);
function mO(t, e, r) {
  (e = e || []), (r = r || 0);
  for (var n = r; t >= Hie; ) (e[r++] = (t & 255) | TS), (t /= 128);
  for (; t & jie; ) (e[r++] = (t & 255) | TS), (t >>>= 7);
  return (e[r] = t | 0), (mO.bytes = r - n + 1), e;
}
var zie = y_,
  qie = 128,
  CS = 127;
function y_(t, n) {
  var r = 0,
    n = n || 0,
    i = 0,
    a = n,
    s,
    o = t.length;
  do {
    if (a >= o)
      throw ((y_.bytes = 0), new RangeError("Could not decode varint"));
    (s = t[a++]),
      (r += i < 28 ? (s & CS) << i : (s & CS) * Math.pow(2, i)),
      (i += 7);
  } while (s >= qie);
  return (y_.bytes = a - n), r;
}
var Vie = Math.pow(2, 7),
  Kie = Math.pow(2, 14),
  Gie = Math.pow(2, 21),
  Zie = Math.pow(2, 28),
  Jie = Math.pow(2, 35),
  Qie = Math.pow(2, 42),
  Yie = Math.pow(2, 49),
  Xie = Math.pow(2, 56),
  eae = Math.pow(2, 63),
  tae = function (t) {
    return t < Vie
      ? 1
      : t < Kie
      ? 2
      : t < Gie
      ? 3
      : t < Zie
      ? 4
      : t < Jie
      ? 5
      : t < Qie
      ? 6
      : t < Yie
      ? 7
      : t < Xie
      ? 8
      : t < eae
      ? 9
      : 10;
  },
  rae = {
    encode: Uie,
    decode: zie,
    encodingLength: tae,
  },
  r2 = rae;
const n2 = (t, e = 0) => [r2.decode(t, e), r2.decode.bytes],
  qp = (t, e, r = 0) => (r2.encode(t, e, r), e),
  Vp = (t) => r2.encodingLength(t),
  nae = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        decode: n2,
        encodeTo: qp,
        encodingLength: Vp,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  Kp = (t, e) => {
    const r = e.byteLength,
      n = Vp(t),
      i = n + Vp(r),
      a = new Uint8Array(i + r);
    return qp(t, a, 0), qp(r, a, n), a.set(e, i), new hv(t, r, e, a);
  },
  yO = (t) => {
    const e = Fu(t),
      [r, n] = n2(e),
      [i, a] = n2(e.subarray(n)),
      s = e.subarray(n + a);
    if (s.byteLength !== i) throw new Error("Incorrect length");
    return new hv(r, i, s, e);
  },
  gO = (t, e) =>
    t === e
      ? !0
      : t.code === e.code && t.size === e.size && uO(t.bytes, e.bytes);
class hv {
  constructor(e, r, n, i) {
    (this.code = e), (this.size = r), (this.digest = n), (this.bytes = i);
  }
}
const iae = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        Digest: hv,
        create: Kp,
        decode: yO,
        equals: gO,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  dE = ({ name: t, code: e, encode: r }) => new bO(t, e, r);
class bO {
  constructor(e, r, n) {
    (this.name = e), (this.code = r), (this.encode = n);
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const r = this.encode(e);
      return r instanceof Uint8Array
        ? Kp(this.code, r)
        : r.then((n) => Kp(this.code, n));
    } else throw Error("Unknown type, must be binary type");
  }
}
const aae = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        Hasher: bO,
        from: dE,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  vO = (t) => async (e) => new Uint8Array(await crypto.subtle.digest(t, e)),
  sae = dE({
    name: "sha2-256",
    code: 18,
    encode: vO("SHA-256"),
  }),
  oae = dE({
    name: "sha2-512",
    code: 19,
    encode: vO("SHA-512"),
  }),
  cae = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        sha256: sae,
        sha512: oae,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  xO = 0,
  lae = "identity",
  wO = Fu,
  uae = (t) => Kp(xO, wO(t)),
  fae = {
    code: xO,
    name: lae,
    encode: wO,
    digest: uae,
  },
  dae = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        identity: fae,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  hae = "raw",
  pae = 85,
  mae = (t) => Fu(t),
  yae = (t) => Fu(t),
  gae = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        code: pae,
        decode: yae,
        encode: mae,
        name: hae,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  bae = new TextEncoder(),
  vae = new TextDecoder(),
  xae = "json",
  wae = 512,
  _ae = (t) => bae.encode(JSON.stringify(t)),
  Eae = (t) => JSON.parse(vae.decode(t)),
  Tae = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        code: wae,
        decode: Eae,
        encode: _ae,
        name: xae,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  );
let Cae = class bi {
  constructor(e, r, n, i) {
    (this.code = r),
      (this.version = e),
      (this.multihash = n),
      (this.bytes = i),
      (this.byteOffset = i.byteOffset),
      (this.byteLength = i.byteLength),
      (this.asCID = this),
      (this._baseCache = new Map()),
      Object.defineProperties(this, {
        byteOffset: sy,
        byteLength: sy,
        code: ay,
        version: ay,
        multihash: ay,
        bytes: ay,
        _baseCache: sy,
        asCID: sy,
      });
  }
  toV0() {
    switch (this.version) {
      case 0:
        return this;
      default: {
        const { code: e, multihash: r } = this;
        if (e !== rh)
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        if (r.code !== Mae)
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        return bi.createV0(r);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: e, digest: r } = this.multihash,
          n = Kp(e, r);
        return bi.createV1(this.code, n);
      }
      case 1:
        return this;
      default:
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
    }
  }
  equals(e) {
    return (
      e &&
      this.code === e.code &&
      this.version === e.version &&
      gO(this.multihash, e.multihash)
    );
  }
  toString(e) {
    const { bytes: r, version: n, _baseCache: i } = this;
    switch (n) {
      case 0:
        return kae(r, i, e || Po.encoder);
      default:
        return Sae(r, i, e || zh.encoder);
    }
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes,
    };
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return "CID(" + this.toString() + ")";
  }
  static isCID(e) {
    return Rae(/^0\.0/, Pae), !!(e && (e[kS] || e.asCID === e));
  }
  get toBaseEncodedString() {
    throw new Error("Deprecated, use .toString()");
  }
  get codec() {
    throw new Error(
      '"codec" property is deprecated, use integer "code" property instead'
    );
  }
  get buffer() {
    throw new Error(
      "Deprecated .buffer property, use .bytes to get Uint8Array instead"
    );
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(e) {
    if (e instanceof bi) return e;
    if (e != null && e.asCID === e) {
      const { version: r, code: n, multihash: i, bytes: a } = e;
      return new bi(r, n, i, a || AS(r, n, i.bytes));
    } else if (e != null && e[kS] === !0) {
      const { version: r, multihash: n, code: i } = e,
        a = yO(n);
      return bi.create(r, i, a);
    } else return null;
  }
  static create(e, r, n) {
    if (typeof r != "number")
      throw new Error("String codecs are no longer supported");
    switch (e) {
      case 0: {
        if (r !== rh)
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${rh}) block encoding`
          );
        return new bi(e, r, n, n.bytes);
      }
      case 1: {
        const i = AS(e, r, n.bytes);
        return new bi(e, r, n, i);
      }
      default:
        throw new Error("Invalid version");
    }
  }
  static createV0(e) {
    return bi.create(0, rh, e);
  }
  static createV1(e, r) {
    return bi.create(1, e, r);
  }
  static decode(e) {
    const [r, n] = bi.decodeFirst(e);
    if (n.length) throw new Error("Incorrect length");
    return r;
  }
  static decodeFirst(e) {
    const r = bi.inspectBytes(e),
      n = r.size - r.multihashSize,
      i = Fu(e.subarray(n, n + r.multihashSize));
    if (i.byteLength !== r.multihashSize) throw new Error("Incorrect length");
    const a = i.subarray(r.multihashSize - r.digestSize),
      s = new hv(r.multihashCode, r.digestSize, a, i);
    return [
      r.version === 0 ? bi.createV0(s) : bi.createV1(r.codec, s),
      e.subarray(r.size),
    ];
  }
  static inspectBytes(e) {
    let r = 0;
    const n = () => {
      const [m, v] = n2(e.subarray(r));
      return (r += v), m;
    };
    let i = n(),
      a = rh;
    if (
      (i === 18 ? ((i = 0), (r = 0)) : i === 1 && (a = n()), i !== 0 && i !== 1)
    )
      throw new RangeError(`Invalid CID version ${i}`);
    const s = r,
      o = n(),
      c = n(),
      u = r + c,
      d = u - s;
    return {
      version: i,
      codec: a,
      multihashCode: o,
      digestSize: c,
      multihashSize: d,
      size: u,
    };
  }
  static parse(e, r) {
    const [n, i] = Aae(e, r),
      a = bi.decode(i);
    return a._baseCache.set(n, e), a;
  }
};
const Aae = (t, e) => {
    switch (t[0]) {
      case "Q": {
        const r = e || Po;
        return [Po.prefix, r.decode(`${Po.prefix}${t}`)];
      }
      case Po.prefix: {
        const r = e || Po;
        return [Po.prefix, r.decode(t)];
      }
      case zh.prefix: {
        const r = e || zh;
        return [zh.prefix, r.decode(t)];
      }
      default: {
        if (e == null)
          throw Error(
            "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
          );
        return [t[0], e.decode(t)];
      }
    }
  },
  kae = (t, e, r) => {
    const { prefix: n } = r;
    if (n !== Po.prefix)
      throw Error(`Cannot string encode V0 in ${r.name} encoding`);
    const i = e.get(n);
    if (i == null) {
      const a = r.encode(t).slice(1);
      return e.set(n, a), a;
    } else return i;
  },
  Sae = (t, e, r) => {
    const { prefix: n } = r,
      i = e.get(n);
    if (i == null) {
      const a = r.encode(t);
      return e.set(n, a), a;
    } else return i;
  },
  rh = 112,
  Mae = 18,
  AS = (t, e, r) => {
    const n = Vp(t),
      i = n + Vp(e),
      a = new Uint8Array(i + r.byteLength);
    return qp(t, a, 0), qp(e, a, n), a.set(r, i), a;
  },
  kS = Symbol.for("@ipld/js-cid/CID"),
  ay = {
    writable: !1,
    configurable: !1,
    enumerable: !0,
  },
  sy = {
    writable: !1,
    enumerable: !1,
    configurable: !1,
  },
  Iae = "0.0.0-dev",
  Rae = (t, e) => {
    if (t.test(Iae)) console.warn(e);
    else throw new Error(e);
  },
  Pae = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`,
  g_ = {
    ...aie,
    ...oie,
    ...lie,
    ...fie,
    ...pie,
    ...Eie,
    ...Aie,
    ...Sie,
    ...Nie,
    ...$ie,
  },
  Nae = {
    ...cae,
    ...dae,
  },
  Bae = {
    raw: gae,
    json: Tae,
  },
  Dae = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        CID: Cae,
        bases: g_,
        bytes: Qne,
        codecs: Bae,
        digest: iae,
        hasher: aae,
        hashes: Nae,
        varint: nae,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  );
function _O(t = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null
    ? globalThis.Buffer.allocUnsafe(t)
    : new Uint8Array(t);
}
function EO(t, e, r, n) {
  return {
    name: t,
    prefix: e,
    encoder: {
      name: t,
      prefix: e,
      encode: r,
    },
    decoder: {
      decode: n,
    },
  };
}
const SS = EO(
    "utf8",
    "u",
    (t) => "u" + new TextDecoder("utf8").decode(t),
    (t) => new TextEncoder().encode(t.substring(1))
  ),
  s3 = EO(
    "ascii",
    "a",
    (t) => {
      let e = "a";
      for (let r = 0; r < t.length; r++) e += String.fromCharCode(t[r]);
      return e;
    },
    (t) => {
      t = t.substring(1);
      const e = _O(t.length);
      for (let r = 0; r < t.length; r++) e[r] = t.charCodeAt(r);
      return e;
    }
  ),
  TO = {
    utf8: SS,
    "utf-8": SS,
    hex: g_.base16,
    latin1: s3,
    ascii: s3,
    binary: s3,
    ...g_,
  };
function Oae(t, e = "utf8") {
  const r = TO[e];
  if (!r) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") &&
    globalThis.Buffer != null &&
    globalThis.Buffer.from != null
    ? globalThis.Buffer.from(t.buffer, t.byteOffset, t.byteLength).toString(
        "utf8"
      )
    : r.encoder.encode(t).substring(1);
}
const Fae = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        toString: Oae,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  hE = Pt(Fae);
function Lae(t, e = "utf8") {
  const r = TO[e];
  if (!r) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") &&
    globalThis.Buffer != null &&
    globalThis.Buffer.from != null
    ? globalThis.Buffer.from(t, "utf8")
    : r.decoder.decode(`${r.prefix}${t}`);
}
const $ae = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        fromString: Lae,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  CO = Pt($ae);
function Uae(t, e) {
  e || (e = t.reduce((i, a) => i + a.length, 0));
  const r = _O(e);
  let n = 0;
  for (const i of t) r.set(i, n), (n += i.length);
  return r;
}
const Wae = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        concat: Uae,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  pE = Pt(Wae),
  AO = fv,
  B0 = jne,
  { names: Gp } = zne,
  { toString: pv } = hE,
  { fromString: jae } = CO,
  { concat: Hae } = pE,
  bd = {};
for (const t in Gp) {
  const e = t;
  bd[Gp[e]] = e;
}
Object.freeze(bd);
function zae(t) {
  if (!(t instanceof Uint8Array))
    throw new Error("must be passed a Uint8Array");
  return pv(t, "base16");
}
function qae(t) {
  return jae(t, "base16");
}
function Vae(t) {
  if (!(t instanceof Uint8Array))
    throw new Error("must be passed a Uint8Array");
  return pv(AO.encode("base58btc", t)).slice(1);
}
function Kae(t) {
  const e = t instanceof Uint8Array ? pv(t) : t;
  return AO.decode("z" + e);
}
function kO(t) {
  if (!(t instanceof Uint8Array))
    throw new Error("multihash must be a Uint8Array");
  if (t.length < 2) throw new Error("multihash too short. must be > 2 bytes.");
  const e = B0.decode(t);
  if (!MO(e))
    throw new Error(`multihash unknown function code: 0x${e.toString(16)}`);
  t = t.slice(B0.decode.bytes);
  const r = B0.decode(t);
  if (r < 0) throw new Error(`multihash invalid length: ${r}`);
  if (((t = t.slice(B0.decode.bytes)), t.length !== r))
    throw new Error(`multihash length inconsistent: 0x${pv(t, "base16")}`);
  return {
    code: e,
    name: bd[e],
    length: r,
    digest: t,
  };
}
function Gae(t, e, r) {
  if (!t || e === void 0)
    throw new Error(
      "multihash encode requires at least two args: digest, code"
    );
  const n = SO(e);
  if (!(t instanceof Uint8Array))
    throw new Error("digest should be a Uint8Array");
  if ((r == null && (r = t.length), r && t.length !== r))
    throw new Error("digest length should be equal to specified length.");
  const i = B0.encode(n),
    a = B0.encode(r);
  return Hae([i, a, t], i.length + a.length + t.length);
}
function SO(t) {
  let e = t;
  if (typeof t == "string") {
    if (Gp[t] === void 0)
      throw new Error(`Unrecognized hash function named: ${t}`);
    e = Gp[t];
  }
  if (typeof e != "number")
    throw new Error(`Hash function code should be a number. Got: ${e}`);
  if (bd[e] === void 0 && !mE(e))
    throw new Error(`Unrecognized function code: ${e}`);
  return e;
}
function mE(t) {
  return t > 0 && t < 16;
}
function MO(t) {
  return !!(mE(t) || bd[t]);
}
function IO(t) {
  kO(t);
}
function Zae(t) {
  return IO(t), t.subarray(0, 2);
}
var mv = {
    names: Gp,
    codes: bd,
    toHexString: zae,
    fromHexString: qae,
    toB58String: Vae,
    fromB58String: Kae,
    decode: kO,
    encode: Gae,
    coerceCode: SO,
    isAppCode: mE,
    validate: IO,
    prefix: Zae,
    isValidCode: MO,
  },
  Jae = b_,
  MS = 128,
  Qae = 127,
  Yae = ~Qae,
  Xae = Math.pow(2, 31);
function b_(t, e, r) {
  if (Number.MAX_SAFE_INTEGER && t > Number.MAX_SAFE_INTEGER)
    throw ((b_.bytes = 0), new RangeError("Could not encode varint"));
  (e = e || []), (r = r || 0);
  for (var n = r; t >= Xae; ) (e[r++] = (t & 255) | MS), (t /= 128);
  for (; t & Yae; ) (e[r++] = (t & 255) | MS), (t >>>= 7);
  return (e[r] = t | 0), (b_.bytes = r - n + 1), e;
}
var ese = v_,
  tse = 128,
  IS = 127;
function v_(t, n) {
  var r = 0,
    n = n || 0,
    i = 0,
    a = n,
    s,
    o = t.length;
  do {
    if (a >= o || i > 49)
      throw ((v_.bytes = 0), new RangeError("Could not decode varint"));
    (s = t[a++]),
      (r += i < 28 ? (s & IS) << i : (s & IS) * Math.pow(2, i)),
      (i += 7);
  } while (s >= tse);
  return (v_.bytes = a - n), r;
}
var rse = Math.pow(2, 7),
  nse = Math.pow(2, 14),
  ise = Math.pow(2, 21),
  ase = Math.pow(2, 28),
  sse = Math.pow(2, 35),
  ose = Math.pow(2, 42),
  cse = Math.pow(2, 49),
  lse = Math.pow(2, 56),
  use = Math.pow(2, 63),
  fse = function (t) {
    return t < rse
      ? 1
      : t < nse
      ? 2
      : t < ise
      ? 3
      : t < ase
      ? 4
      : t < sse
      ? 5
      : t < ose
      ? 6
      : t < cse
      ? 7
      : t < lse
      ? 8
      : t < use
      ? 9
      : 10;
  },
  RO = {
    encode: Jae,
    decode: ese,
    encodingLength: fse,
  };
const PO = RO,
  { toString: dse } = hE,
  { fromString: hse } = CO;
var NO = {
  numberToUint8Array: pse,
  uint8ArrayToNumber: BO,
  varintUint8ArrayEncode: mse,
  varintEncode: yse,
};
function BO(t) {
  return parseInt(dse(t, "base16"), 16);
}
function pse(t) {
  let e = t.toString(16);
  return e.length % 2 === 1 && (e = "0" + e), hse(e, "base16");
}
function mse(t) {
  return Uint8Array.from(PO.encode(BO(t)));
}
function yse(t) {
  return Uint8Array.from(PO.encode(t));
}
const gse = Object.freeze({
  identity: 0,
  cidv1: 1,
  cidv2: 2,
  cidv3: 3,
  ip4: 4,
  tcp: 6,
  sha1: 17,
  "sha2-256": 18,
  "sha2-512": 19,
  "sha3-512": 20,
  "sha3-384": 21,
  "sha3-256": 22,
  "sha3-224": 23,
  "shake-128": 24,
  "shake-256": 25,
  "keccak-224": 26,
  "keccak-256": 27,
  "keccak-384": 28,
  "keccak-512": 29,
  blake3: 30,
  dccp: 33,
  "murmur3-128": 34,
  "murmur3-32": 35,
  ip6: 41,
  ip6zone: 42,
  path: 47,
  multicodec: 48,
  multihash: 49,
  multiaddr: 50,
  multibase: 51,
  dns: 53,
  dns4: 54,
  dns6: 55,
  dnsaddr: 56,
  protobuf: 80,
  cbor: 81,
  raw: 85,
  "dbl-sha2-256": 86,
  rlp: 96,
  bencode: 99,
  "dag-pb": 112,
  "dag-cbor": 113,
  "libp2p-key": 114,
  "git-raw": 120,
  "torrent-info": 123,
  "torrent-file": 124,
  "leofcoin-block": 129,
  "leofcoin-tx": 130,
  "leofcoin-pr": 131,
  sctp: 132,
  "dag-jose": 133,
  "dag-cose": 134,
  "eth-block": 144,
  "eth-block-list": 145,
  "eth-tx-trie": 146,
  "eth-tx": 147,
  "eth-tx-receipt-trie": 148,
  "eth-tx-receipt": 149,
  "eth-state-trie": 150,
  "eth-account-snapshot": 151,
  "eth-storage-trie": 152,
  "eth-receipt-log-trie": 153,
  "eth-reciept-log": 154,
  "bitcoin-block": 176,
  "bitcoin-tx": 177,
  "bitcoin-witness-commitment": 178,
  "zcash-block": 192,
  "zcash-tx": 193,
  "caip-50": 202,
  streamid: 206,
  "stellar-block": 208,
  "stellar-tx": 209,
  md4: 212,
  md5: 213,
  bmt: 214,
  "decred-block": 224,
  "decred-tx": 225,
  "ipld-ns": 226,
  "ipfs-ns": 227,
  "swarm-ns": 228,
  "ipns-ns": 229,
  zeronet: 230,
  "secp256k1-pub": 231,
  "bls12_381-g1-pub": 234,
  "bls12_381-g2-pub": 235,
  "x25519-pub": 236,
  "ed25519-pub": 237,
  "bls12_381-g1g2-pub": 238,
  "dash-block": 240,
  "dash-tx": 241,
  "swarm-manifest": 250,
  "swarm-feed": 251,
  udp: 273,
  "p2p-webrtc-star": 275,
  "p2p-webrtc-direct": 276,
  "p2p-stardust": 277,
  "p2p-circuit": 290,
  "dag-json": 297,
  udt: 301,
  utp: 302,
  unix: 400,
  thread: 406,
  p2p: 421,
  ipfs: 421,
  https: 443,
  onion: 444,
  onion3: 445,
  garlic64: 446,
  garlic32: 447,
  tls: 448,
  noise: 454,
  quic: 460,
  ws: 477,
  wss: 478,
  "p2p-websocket-star": 479,
  http: 480,
  "swhid-1-snp": 496,
  json: 512,
  messagepack: 513,
  "libp2p-peer-record": 769,
  "libp2p-relay-rsvp": 770,
  "car-index-sorted": 1024,
  "sha2-256-trunc254-padded": 4114,
  "ripemd-128": 4178,
  "ripemd-160": 4179,
  "ripemd-256": 4180,
  "ripemd-320": 4181,
  x11: 4352,
  "p256-pub": 4608,
  "p384-pub": 4609,
  "p521-pub": 4610,
  "ed448-pub": 4611,
  "x448-pub": 4612,
  "ed25519-priv": 4864,
  "secp256k1-priv": 4865,
  "x25519-priv": 4866,
  kangarootwelve: 7425,
  "sm3-256": 21325,
  "blake2b-8": 45569,
  "blake2b-16": 45570,
  "blake2b-24": 45571,
  "blake2b-32": 45572,
  "blake2b-40": 45573,
  "blake2b-48": 45574,
  "blake2b-56": 45575,
  "blake2b-64": 45576,
  "blake2b-72": 45577,
  "blake2b-80": 45578,
  "blake2b-88": 45579,
  "blake2b-96": 45580,
  "blake2b-104": 45581,
  "blake2b-112": 45582,
  "blake2b-120": 45583,
  "blake2b-128": 45584,
  "blake2b-136": 45585,
  "blake2b-144": 45586,
  "blake2b-152": 45587,
  "blake2b-160": 45588,
  "blake2b-168": 45589,
  "blake2b-176": 45590,
  "blake2b-184": 45591,
  "blake2b-192": 45592,
  "blake2b-200": 45593,
  "blake2b-208": 45594,
  "blake2b-216": 45595,
  "blake2b-224": 45596,
  "blake2b-232": 45597,
  "blake2b-240": 45598,
  "blake2b-248": 45599,
  "blake2b-256": 45600,
  "blake2b-264": 45601,
  "blake2b-272": 45602,
  "blake2b-280": 45603,
  "blake2b-288": 45604,
  "blake2b-296": 45605,
  "blake2b-304": 45606,
  "blake2b-312": 45607,
  "blake2b-320": 45608,
  "blake2b-328": 45609,
  "blake2b-336": 45610,
  "blake2b-344": 45611,
  "blake2b-352": 45612,
  "blake2b-360": 45613,
  "blake2b-368": 45614,
  "blake2b-376": 45615,
  "blake2b-384": 45616,
  "blake2b-392": 45617,
  "blake2b-400": 45618,
  "blake2b-408": 45619,
  "blake2b-416": 45620,
  "blake2b-424": 45621,
  "blake2b-432": 45622,
  "blake2b-440": 45623,
  "blake2b-448": 45624,
  "blake2b-456": 45625,
  "blake2b-464": 45626,
  "blake2b-472": 45627,
  "blake2b-480": 45628,
  "blake2b-488": 45629,
  "blake2b-496": 45630,
  "blake2b-504": 45631,
  "blake2b-512": 45632,
  "blake2s-8": 45633,
  "blake2s-16": 45634,
  "blake2s-24": 45635,
  "blake2s-32": 45636,
  "blake2s-40": 45637,
  "blake2s-48": 45638,
  "blake2s-56": 45639,
  "blake2s-64": 45640,
  "blake2s-72": 45641,
  "blake2s-80": 45642,
  "blake2s-88": 45643,
  "blake2s-96": 45644,
  "blake2s-104": 45645,
  "blake2s-112": 45646,
  "blake2s-120": 45647,
  "blake2s-128": 45648,
  "blake2s-136": 45649,
  "blake2s-144": 45650,
  "blake2s-152": 45651,
  "blake2s-160": 45652,
  "blake2s-168": 45653,
  "blake2s-176": 45654,
  "blake2s-184": 45655,
  "blake2s-192": 45656,
  "blake2s-200": 45657,
  "blake2s-208": 45658,
  "blake2s-216": 45659,
  "blake2s-224": 45660,
  "blake2s-232": 45661,
  "blake2s-240": 45662,
  "blake2s-248": 45663,
  "blake2s-256": 45664,
  "skein256-8": 45825,
  "skein256-16": 45826,
  "skein256-24": 45827,
  "skein256-32": 45828,
  "skein256-40": 45829,
  "skein256-48": 45830,
  "skein256-56": 45831,
  "skein256-64": 45832,
  "skein256-72": 45833,
  "skein256-80": 45834,
  "skein256-88": 45835,
  "skein256-96": 45836,
  "skein256-104": 45837,
  "skein256-112": 45838,
  "skein256-120": 45839,
  "skein256-128": 45840,
  "skein256-136": 45841,
  "skein256-144": 45842,
  "skein256-152": 45843,
  "skein256-160": 45844,
  "skein256-168": 45845,
  "skein256-176": 45846,
  "skein256-184": 45847,
  "skein256-192": 45848,
  "skein256-200": 45849,
  "skein256-208": 45850,
  "skein256-216": 45851,
  "skein256-224": 45852,
  "skein256-232": 45853,
  "skein256-240": 45854,
  "skein256-248": 45855,
  "skein256-256": 45856,
  "skein512-8": 45857,
  "skein512-16": 45858,
  "skein512-24": 45859,
  "skein512-32": 45860,
  "skein512-40": 45861,
  "skein512-48": 45862,
  "skein512-56": 45863,
  "skein512-64": 45864,
  "skein512-72": 45865,
  "skein512-80": 45866,
  "skein512-88": 45867,
  "skein512-96": 45868,
  "skein512-104": 45869,
  "skein512-112": 45870,
  "skein512-120": 45871,
  "skein512-128": 45872,
  "skein512-136": 45873,
  "skein512-144": 45874,
  "skein512-152": 45875,
  "skein512-160": 45876,
  "skein512-168": 45877,
  "skein512-176": 45878,
  "skein512-184": 45879,
  "skein512-192": 45880,
  "skein512-200": 45881,
  "skein512-208": 45882,
  "skein512-216": 45883,
  "skein512-224": 45884,
  "skein512-232": 45885,
  "skein512-240": 45886,
  "skein512-248": 45887,
  "skein512-256": 45888,
  "skein512-264": 45889,
  "skein512-272": 45890,
  "skein512-280": 45891,
  "skein512-288": 45892,
  "skein512-296": 45893,
  "skein512-304": 45894,
  "skein512-312": 45895,
  "skein512-320": 45896,
  "skein512-328": 45897,
  "skein512-336": 45898,
  "skein512-344": 45899,
  "skein512-352": 45900,
  "skein512-360": 45901,
  "skein512-368": 45902,
  "skein512-376": 45903,
  "skein512-384": 45904,
  "skein512-392": 45905,
  "skein512-400": 45906,
  "skein512-408": 45907,
  "skein512-416": 45908,
  "skein512-424": 45909,
  "skein512-432": 45910,
  "skein512-440": 45911,
  "skein512-448": 45912,
  "skein512-456": 45913,
  "skein512-464": 45914,
  "skein512-472": 45915,
  "skein512-480": 45916,
  "skein512-488": 45917,
  "skein512-496": 45918,
  "skein512-504": 45919,
  "skein512-512": 45920,
  "skein1024-8": 45921,
  "skein1024-16": 45922,
  "skein1024-24": 45923,
  "skein1024-32": 45924,
  "skein1024-40": 45925,
  "skein1024-48": 45926,
  "skein1024-56": 45927,
  "skein1024-64": 45928,
  "skein1024-72": 45929,
  "skein1024-80": 45930,
  "skein1024-88": 45931,
  "skein1024-96": 45932,
  "skein1024-104": 45933,
  "skein1024-112": 45934,
  "skein1024-120": 45935,
  "skein1024-128": 45936,
  "skein1024-136": 45937,
  "skein1024-144": 45938,
  "skein1024-152": 45939,
  "skein1024-160": 45940,
  "skein1024-168": 45941,
  "skein1024-176": 45942,
  "skein1024-184": 45943,
  "skein1024-192": 45944,
  "skein1024-200": 45945,
  "skein1024-208": 45946,
  "skein1024-216": 45947,
  "skein1024-224": 45948,
  "skein1024-232": 45949,
  "skein1024-240": 45950,
  "skein1024-248": 45951,
  "skein1024-256": 45952,
  "skein1024-264": 45953,
  "skein1024-272": 45954,
  "skein1024-280": 45955,
  "skein1024-288": 45956,
  "skein1024-296": 45957,
  "skein1024-304": 45958,
  "skein1024-312": 45959,
  "skein1024-320": 45960,
  "skein1024-328": 45961,
  "skein1024-336": 45962,
  "skein1024-344": 45963,
  "skein1024-352": 45964,
  "skein1024-360": 45965,
  "skein1024-368": 45966,
  "skein1024-376": 45967,
  "skein1024-384": 45968,
  "skein1024-392": 45969,
  "skein1024-400": 45970,
  "skein1024-408": 45971,
  "skein1024-416": 45972,
  "skein1024-424": 45973,
  "skein1024-432": 45974,
  "skein1024-440": 45975,
  "skein1024-448": 45976,
  "skein1024-456": 45977,
  "skein1024-464": 45978,
  "skein1024-472": 45979,
  "skein1024-480": 45980,
  "skein1024-488": 45981,
  "skein1024-496": 45982,
  "skein1024-504": 45983,
  "skein1024-512": 45984,
  "skein1024-520": 45985,
  "skein1024-528": 45986,
  "skein1024-536": 45987,
  "skein1024-544": 45988,
  "skein1024-552": 45989,
  "skein1024-560": 45990,
  "skein1024-568": 45991,
  "skein1024-576": 45992,
  "skein1024-584": 45993,
  "skein1024-592": 45994,
  "skein1024-600": 45995,
  "skein1024-608": 45996,
  "skein1024-616": 45997,
  "skein1024-624": 45998,
  "skein1024-632": 45999,
  "skein1024-640": 46e3,
  "skein1024-648": 46001,
  "skein1024-656": 46002,
  "skein1024-664": 46003,
  "skein1024-672": 46004,
  "skein1024-680": 46005,
  "skein1024-688": 46006,
  "skein1024-696": 46007,
  "skein1024-704": 46008,
  "skein1024-712": 46009,
  "skein1024-720": 46010,
  "skein1024-728": 46011,
  "skein1024-736": 46012,
  "skein1024-744": 46013,
  "skein1024-752": 46014,
  "skein1024-760": 46015,
  "skein1024-768": 46016,
  "skein1024-776": 46017,
  "skein1024-784": 46018,
  "skein1024-792": 46019,
  "skein1024-800": 46020,
  "skein1024-808": 46021,
  "skein1024-816": 46022,
  "skein1024-824": 46023,
  "skein1024-832": 46024,
  "skein1024-840": 46025,
  "skein1024-848": 46026,
  "skein1024-856": 46027,
  "skein1024-864": 46028,
  "skein1024-872": 46029,
  "skein1024-880": 46030,
  "skein1024-888": 46031,
  "skein1024-896": 46032,
  "skein1024-904": 46033,
  "skein1024-912": 46034,
  "skein1024-920": 46035,
  "skein1024-928": 46036,
  "skein1024-936": 46037,
  "skein1024-944": 46038,
  "skein1024-952": 46039,
  "skein1024-960": 46040,
  "skein1024-968": 46041,
  "skein1024-976": 46042,
  "skein1024-984": 46043,
  "skein1024-992": 46044,
  "skein1024-1000": 46045,
  "skein1024-1008": 46046,
  "skein1024-1016": 46047,
  "skein1024-1024": 46048,
  "poseidon-bls12_381-a2-fc1": 46081,
  "poseidon-bls12_381-a2-fc1-sc": 46082,
  "zeroxcert-imprint-256": 52753,
  "fil-commitment-unsealed": 61697,
  "fil-commitment-sealed": 61698,
  "holochain-adr-v0": 8417572,
  "holochain-adr-v1": 8483108,
  "holochain-key-v0": 9728292,
  "holochain-key-v1": 9793828,
  "holochain-sig-v0": 10645796,
  "holochain-sig-v1": 10711332,
  "skynet-ns": 11639056,
  "arweave-ns": 11704592,
});
var bse = {
  baseTable: gse,
};
const { baseTable: x_ } = bse,
  vse = NO.varintEncode,
  yE = {},
  gE = {},
  i2 = {};
for (const t in x_) {
  const e = t,
    r = x_[e];
  yE[e] = vse(r);
  const n = e.toUpperCase().replace(/-/g, "_");
  (gE[n] = r), i2[r] || (i2[r] = e);
}
Object.freeze(yE);
Object.freeze(gE);
Object.freeze(i2);
const xse = Object.freeze(x_);
var wse = {
  nameToVarint: yE,
  constantToCode: gE,
  nameToCode: xse,
  codeToName: i2,
};
const a2 = RO,
  { concat: _se } = pE,
  DO = NO,
  {
    nameToVarint: s2,
    constantToCode: Ese,
    nameToCode: OO,
    codeToName: bE,
  } = wse;
function Tse(t, e) {
  let r;
  if (t instanceof Uint8Array) r = DO.varintUint8ArrayEncode(t);
  else if (s2[t]) r = s2[t];
  else throw new Error("multicodec not recognized");
  return _se([r, e], r.length + e.length);
}
function Cse(t) {
  return a2.decode(t), t.slice(a2.decode.bytes);
}
function FO(t) {
  const e = a2.decode(t),
    r = bE[e];
  if (r === void 0) throw new Error(`Code "${e}" not found`);
  return r;
}
function LO(t) {
  return bE[t];
}
function $O(t) {
  const e = OO[t];
  if (e === void 0) throw new Error(`Codec "${t}" not found`);
  return e;
}
function UO(t) {
  return a2.decode(t);
}
function WO(t) {
  const e = s2[t];
  if (e === void 0) throw new Error(`Codec "${t}" not found`);
  return e;
}
function jO(t) {
  return DO.varintEncode(t);
}
function Ase(t) {
  return FO(t);
}
function kse(t) {
  return LO(t);
}
function Sse(t) {
  return $O(t);
}
function Mse(t) {
  return UO(t);
}
function Ise(t) {
  return WO(t);
}
function Rse(t) {
  return Array.from(jO(t));
}
var Pse = {
  addPrefix: Tse,
  rmPrefix: Cse,
  getNameFromData: FO,
  getNameFromCode: LO,
  getCodeFromName: $O,
  getCodeFromData: UO,
  getVarintFromName: WO,
  getVarintFromCode: jO,
  getCodec: Ase,
  getName: kse,
  getNumber: Sse,
  getCode: Mse,
  getCodeVarint: Ise,
  getVarint: Rse,
  ...Ese,
  nameToVarint: s2,
  nameToCode: OO,
  codeToName: bE,
};
const Nse = mv,
  Bse = {
    checkCIDComponents: function (t) {
      if (t == null) return "null values are not valid CIDs";
      if (!(t.version === 0 || t.version === 1))
        return "Invalid version, must be a number equal to 1 or 0";
      if (typeof t.codec != "string") return "codec must be string";
      if (t.version === 0) {
        if (t.codec !== "dag-pb") return "codec must be 'dag-pb' for CIDv0";
        if (t.multibaseName !== "base58btc")
          return "multibaseName must be 'base58btc' for CIDv0";
      }
      if (!(t.multihash instanceof Uint8Array))
        return "multihash must be a Uint8Array";
      try {
        Nse.validate(t.multihash);
      } catch (e) {
        let r = e.message;
        return r || (r = "Multihash validation failed"), r;
      }
    },
  };
var Dse = Bse;
function Ose(t, e) {
  if (t === e) return !0;
  if (t.byteLength !== e.byteLength) return !1;
  for (let r = 0; r < t.byteLength; r++) if (t[r] !== e[r]) return !1;
  return !0;
}
const Fse = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        equals: Ose,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  Lse = Pt(Fse),
  oy = mv,
  o3 = fv,
  Bl = Pse,
  $se = Dse,
  { concat: RS } = pE,
  { toString: Use } = hE,
  { equals: Wse } = Lse,
  o2 = Bl.nameToCode,
  jse = Object.keys(o2).reduce((t, e) => ((t[o2[e]] = e), t), {}),
  PS = Symbol.for("@ipld/js-cid/CID");
let HO = class fc {
  constructor(e, r, n, i) {
    if (
      (this.version,
      this.codec,
      this.multihash,
      Object.defineProperty(this, PS, {
        value: !0,
      }),
      fc.isCID(e))
    ) {
      const a = e;
      (this.version = a.version),
        (this.codec = a.codec),
        (this.multihash = a.multihash),
        (this.multibaseName =
          a.multibaseName || (a.version === 0 ? "base58btc" : "base32"));
      return;
    }
    if (typeof e == "string") {
      const a = o3.isEncoded(e);
      if (a) {
        const s = o3.decode(e);
        (this.version = parseInt(s[0].toString(), 16)),
          (this.codec = Bl.getCodec(s.slice(1))),
          (this.multihash = Bl.rmPrefix(s.slice(1))),
          (this.multibaseName = a);
      } else
        (this.version = 0),
          (this.codec = "dag-pb"),
          (this.multihash = oy.fromB58String(e)),
          (this.multibaseName = "base58btc");
      fc.validateCID(this),
        Object.defineProperty(this, "string", {
          value: e,
        });
      return;
    }
    if (e instanceof Uint8Array) {
      const a = parseInt(e[0].toString(), 16);
      if (a === 1) {
        const s = e;
        (this.version = a),
          (this.codec = Bl.getCodec(s.slice(1))),
          (this.multihash = Bl.rmPrefix(s.slice(1))),
          (this.multibaseName = "base32");
      } else
        (this.version = 0),
          (this.codec = "dag-pb"),
          (this.multihash = e),
          (this.multibaseName = "base58btc");
      fc.validateCID(this);
      return;
    }
    (this.version = e),
      typeof r == "number" && (r = jse[r]),
      (this.codec = r),
      (this.multihash = n),
      (this.multibaseName = i || (e === 0 ? "base58btc" : "base32")),
      fc.validateCID(this);
  }
  get bytes() {
    let e = this._bytes;
    if (!e) {
      if (this.version === 0) e = this.multihash;
      else if (this.version === 1) {
        const r = Bl.getCodeVarint(this.codec);
        e = RS(
          [[1], r, this.multihash],
          1 + r.byteLength + this.multihash.byteLength
        );
      } else throw new Error("unsupported version");
      Object.defineProperty(this, "_bytes", {
        value: e,
      });
    }
    return e;
  }
  get prefix() {
    const e = Bl.getCodeVarint(this.codec),
      r = oy.prefix(this.multihash);
    return RS([[this.version], e, r], 1 + e.byteLength + r.byteLength);
  }
  get code() {
    return o2[this.codec];
  }
  toV0() {
    if (this.codec !== "dag-pb")
      throw new Error("Cannot convert a non dag-pb CID to CIDv0");
    const { name: e, length: r } = oy.decode(this.multihash);
    if (e !== "sha2-256")
      throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
    if (r !== 32)
      throw new Error("Cannot convert non 32 byte multihash CID to CIDv0");
    return new fc(0, this.codec, this.multihash);
  }
  toV1() {
    return new fc(1, this.codec, this.multihash, this.multibaseName);
  }
  toBaseEncodedString(e = this.multibaseName) {
    if (this.string && this.string.length !== 0 && e === this.multibaseName)
      return this.string;
    let r;
    if (this.version === 0) {
      if (e !== "base58btc")
        throw new Error(
          "not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()"
        );
      r = oy.toB58String(this.multihash);
    } else if (this.version === 1) r = Use(o3.encode(e, this.bytes));
    else throw new Error("unsupported version");
    return (
      e === this.multibaseName &&
        Object.defineProperty(this, "string", {
          value: r,
        }),
      r
    );
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return "CID(" + this.toString() + ")";
  }
  toString(e) {
    return this.toBaseEncodedString(e);
  }
  toJSON() {
    return {
      codec: this.codec,
      version: this.version,
      hash: this.multihash,
    };
  }
  equals(e) {
    return (
      this.codec === e.codec &&
      this.version === e.version &&
      Wse(this.multihash, e.multihash)
    );
  }
  static validateCID(e) {
    const r = $se.checkCIDComponents(e);
    if (r) throw new Error(r);
  }
  static isCID(e) {
    return e instanceof fc || !!(e && e[PS]);
  }
};
HO.codecs = o2;
var vE = HO,
  zO = {
    exports: {},
  };
function NS(t) {
  if (t.stack && t.name && t.message)
    return t.stack.substring(t.name.length + 3 + t.message.length).split(`
`);
  if (t.stack)
    return t.stack.split(`
`);
}
function Hse(t, e) {
  return t.filter(function (r) {
    return !~e.indexOf(r);
  });
}
zO.exports = function (t, e) {
  if (!(t.stack && t.name && t.message))
    return console.error(new Error("stackless error")), t;
  var r = new Error(e),
    n = Hse(NS(r).slice(1), NS(t)).join(`
`);
  return (
    (r.__proto__ = t),
    (r.stack =
      r.name +
      ": " +
      r.message +
      `
` +
      n +
      `
  ` +
      t.stack),
    r
  );
};
var qO = zO.exports;
const zse = vE,
  qse = qO;
var Vse = function (e) {
  try {
    e = new zse(e);
  } catch (r) {
    throw qse(r, `invalid cid: ${e}`);
  }
  return e.version !== 1 && (e = e.toV1()), e.toBaseEncodedString("base32");
};
const Kse = fv;
var VO = function () {
  const e = [];
  for (const r of Object.values(Kse.names))
    e.push({
      name: r.name,
      code: r.code,
    });
  return e;
};
const Gse = vE;
var KO = function () {
  const e = [];
  for (const [r, n] of Object.entries(Gse.codecs))
    e.push({
      name: r,
      code: n,
    });
  return e;
};
const Zse = Pt(Dae),
  { bases: BS } = Zse;
function GO(t, e, r, n) {
  return {
    name: t,
    prefix: e,
    encoder: {
      name: t,
      prefix: e,
      encode: r,
    },
    decoder: {
      decode: n,
    },
  };
}
const DS = GO(
    "utf8",
    "u",
    (t) => "u" + new TextDecoder("utf8").decode(t),
    (t) => new TextEncoder().encode(t.substring(1))
  ),
  c3 = GO(
    "ascii",
    "a",
    (t) => {
      let e = "a";
      for (let r = 0; r < t.length; r++) e += String.fromCharCode(t[r]);
      return e;
    },
    (t) => {
      t = t.substring(1);
      const e = new Uint8Array(t.length);
      for (let r = 0; r < t.length; r++) e[r] = t.charCodeAt(r);
      return e;
    }
  ),
  Jse = {
    utf8: DS,
    "utf-8": DS,
    hex: BS.base16,
    latin1: c3,
    ascii: c3,
    binary: c3,
    ...BS,
  };
var Qse = Jse;
const Yse = Qse;
function Xse(t, e = "utf8") {
  const r = Yse[e];
  if (!r) throw new Error(`Unsupported encoding "${e}"`);
  return r.encoder.encode(t).substring(1);
}
var eoe = Xse;
const toe = vE,
  roe = VO,
  noe = KO,
  ioe = qO,
  w_ = fv,
  h0 = mv,
  nh = eoe;
var aoe = function (e, r) {
  r = r || {};
  let n = r.format || "%s";
  if ((n === "prefix" && (n = "%P"), !OS(n) || n.indexOf("%") === -1))
    throw new Error(`invalid format string: ${n}`);
  const i = e;
  try {
    e = new toe(e);
  } catch (s) {
    throw ioe(s, `invalid cid: ${e}`);
  }
  if (r.cidVersion != null && e.version !== r.cidVersion)
    if (r.cidVersion === 0) e = e.toV0();
    else if (r.cidVersion === 1) e = e.toV1();
    else throw new Error(`invalid cid version: ${r.cidVersion}`);
  let a = "base58btc";
  return (
    r.base ? (a = ZO(r.base).name) : OS(i) && (a = w_.isEncoded(i) || a),
    n.replace(/%([a-zA-Z%])/g, soe(e, a))
  );
};
function OS(t) {
  return Object.prototype.toString.call(t) === "[object String]";
}
function soe(t, e) {
  return (n, i) => {
    switch (i) {
      case "%":
        return "%";
      case "b":
        return e;
      case "B":
        return ZO(e).code;
      case "v":
        return `cidv${t.version}`;
      case "V":
        return t.version.toString();
      case "c":
        return t.codec;
      case "C":
        return ooe(t).toString();
      case "h":
        return h0.decode(t.multihash).name;
      case "H":
        return h0.decode(t.multihash).code.toString();
      case "L":
        return h0.decode(t.multihash).length.toString();
      case "m":
        return nh(w_.encode(e, t.multihash));
      case "M":
        return nh(t.multihash, e);
      case "d":
        return nh(w_.encode(e, h0.decode(t.multihash).digest));
      case "D":
        return nh(h0.decode(t.multihash).digest, e);
      case "s":
        return t.toString(e);
      case "S":
        return t.version === 1 ? t.toString(e).slice(1) : nh(t.bytes, e);
      case "P":
        return coe(t);
      default:
        throw new Error(`unrecognized specifier in format string: ${i}`);
    }
  };
}
function ZO(t) {
  const e = roe().find((r) => r.code === t || r.name === t);
  if (!e) throw new Error(`invalid multibase: ${t}`);
  return e;
}
function ooe(t) {
  const e = noe().find((r) => r.name === t.codec);
  if (!e) throw new Error(`invalid codec: ${t.codec}`);
  return e.code;
}
function coe(t) {
  const { name: e, length: r } = h0.decode(t.multihash);
  return `cidv${t.version}-${t.codec}-${e}-${r}`;
}
const loe = mv;
var uoe = function () {
  const e = [];
  for (const [r, n] of Object.entries(loe.names))
    e.push({
      name: r,
      code: n,
    });
  return e;
};
gd.base32 = Vse;
gd.bases = VO;
gd.codecs = KO;
gd.format = aoe;
gd.hashes = uoe;
var foe = gd;
const doe = mn(foe);
var __ = {
  exports: {},
};
(function (t, e) {
  var r = typeof self < "u" ? self : ke,
    n = (function () {
      function a() {
        (this.fetch = !1), (this.DOMException = r.DOMException);
      }
      return (a.prototype = r), new a();
    })();
  (function (a) {
    (function (s) {
      var o = {
        searchParams: "URLSearchParams" in a,
        iterable: "Symbol" in a && "iterator" in Symbol,
        blob:
          "FileReader" in a &&
          "Blob" in a &&
          (function () {
            try {
              return new Blob(), !0;
            } catch {
              return !1;
            }
          })(),
        formData: "FormData" in a,
        arrayBuffer: "ArrayBuffer" in a,
      };
      function c(h) {
        return h && DataView.prototype.isPrototypeOf(h);
      }
      if (o.arrayBuffer)
        var u = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]",
          ],
          d =
            ArrayBuffer.isView ||
            function (h) {
              return h && u.indexOf(Object.prototype.toString.call(h)) > -1;
            };
      function m(h) {
        if (
          (typeof h != "string" && (h = String(h)),
          /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(h))
        )
          throw new TypeError("Invalid character in header field name");
        return h.toLowerCase();
      }
      function v(h) {
        return typeof h != "string" && (h = String(h)), h;
      }
      function E(h) {
        var g = {
          next: function () {
            var T = h.shift();
            return {
              done: T === void 0,
              value: T,
            };
          },
        };
        return (
          o.iterable &&
            (g[Symbol.iterator] = function () {
              return g;
            }),
          g
        );
      }
      function A(h) {
        (this.map = {}),
          h instanceof A
            ? h.forEach(function (g, T) {
                this.append(T, g);
              }, this)
            : Array.isArray(h)
            ? h.forEach(function (g) {
                this.append(g[0], g[1]);
              }, this)
            : h &&
              Object.getOwnPropertyNames(h).forEach(function (g) {
                this.append(g, h[g]);
              }, this);
      }
      (A.prototype.append = function (h, g) {
        (h = m(h)), (g = v(g));
        var T = this.map[h];
        this.map[h] = T ? T + ", " + g : g;
      }),
        (A.prototype.delete = function (h) {
          delete this.map[m(h)];
        }),
        (A.prototype.get = function (h) {
          return (h = m(h)), this.has(h) ? this.map[h] : null;
        }),
        (A.prototype.has = function (h) {
          return this.map.hasOwnProperty(m(h));
        }),
        (A.prototype.set = function (h, g) {
          this.map[m(h)] = v(g);
        }),
        (A.prototype.forEach = function (h, g) {
          for (var T in this.map)
            this.map.hasOwnProperty(T) && h.call(g, this.map[T], T, this);
        }),
        (A.prototype.keys = function () {
          var h = [];
          return (
            this.forEach(function (g, T) {
              h.push(T);
            }),
            E(h)
          );
        }),
        (A.prototype.values = function () {
          var h = [];
          return (
            this.forEach(function (g) {
              h.push(g);
            }),
            E(h)
          );
        }),
        (A.prototype.entries = function () {
          var h = [];
          return (
            this.forEach(function (g, T) {
              h.push([T, g]);
            }),
            E(h)
          );
        }),
        o.iterable && (A.prototype[Symbol.iterator] = A.prototype.entries);
      function I(h) {
        if (h.bodyUsed) return Promise.reject(new TypeError("Already read"));
        h.bodyUsed = !0;
      }
      function b(h) {
        return new Promise(function (g, T) {
          (h.onload = function () {
            g(h.result);
          }),
            (h.onerror = function () {
              T(h.error);
            });
        });
      }
      function w(h) {
        var g = new FileReader(),
          T = b(g);
        return g.readAsArrayBuffer(h), T;
      }
      function S(h) {
        var g = new FileReader(),
          T = b(g);
        return g.readAsText(h), T;
      }
      function k(h) {
        for (
          var g = new Uint8Array(h), T = new Array(g.length), R = 0;
          R < g.length;
          R++
        )
          T[R] = String.fromCharCode(g[R]);
        return T.join("");
      }
      function N(h) {
        if (h.slice) return h.slice(0);
        var g = new Uint8Array(h.byteLength);
        return g.set(new Uint8Array(h)), g.buffer;
      }
      function O() {
        return (
          (this.bodyUsed = !1),
          (this._initBody = function (h) {
            (this._bodyInit = h),
              h
                ? typeof h == "string"
                  ? (this._bodyText = h)
                  : o.blob && Blob.prototype.isPrototypeOf(h)
                  ? (this._bodyBlob = h)
                  : o.formData && FormData.prototype.isPrototypeOf(h)
                  ? (this._bodyFormData = h)
                  : o.searchParams && URLSearchParams.prototype.isPrototypeOf(h)
                  ? (this._bodyText = h.toString())
                  : o.arrayBuffer && o.blob && c(h)
                  ? ((this._bodyArrayBuffer = N(h.buffer)),
                    (this._bodyInit = new Blob([this._bodyArrayBuffer])))
                  : o.arrayBuffer &&
                    (ArrayBuffer.prototype.isPrototypeOf(h) || d(h))
                  ? (this._bodyArrayBuffer = N(h))
                  : (this._bodyText = h = Object.prototype.toString.call(h))
                : (this._bodyText = ""),
              this.headers.get("content-type") ||
                (typeof h == "string"
                  ? this.headers.set("content-type", "text/plain;charset=UTF-8")
                  : this._bodyBlob && this._bodyBlob.type
                  ? this.headers.set("content-type", this._bodyBlob.type)
                  : o.searchParams &&
                    URLSearchParams.prototype.isPrototypeOf(h) &&
                    this.headers.set(
                      "content-type",
                      "application/x-www-form-urlencoded;charset=UTF-8"
                    ));
          }),
          o.blob &&
            ((this.blob = function () {
              var h = I(this);
              if (h) return h;
              if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
              if (this._bodyArrayBuffer)
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              if (this._bodyFormData)
                throw new Error("could not read FormData body as blob");
              return Promise.resolve(new Blob([this._bodyText]));
            }),
            (this.arrayBuffer = function () {
              return this._bodyArrayBuffer
                ? I(this) || Promise.resolve(this._bodyArrayBuffer)
                : this.blob().then(w);
            })),
          (this.text = function () {
            var h = I(this);
            if (h) return h;
            if (this._bodyBlob) return S(this._bodyBlob);
            if (this._bodyArrayBuffer)
              return Promise.resolve(k(this._bodyArrayBuffer));
            if (this._bodyFormData)
              throw new Error("could not read FormData body as text");
            return Promise.resolve(this._bodyText);
          }),
          o.formData &&
            (this.formData = function () {
              return this.text().then(X);
            }),
          (this.json = function () {
            return this.text().then(JSON.parse);
          }),
          this
        );
      }
      var F = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function V(h) {
        var g = h.toUpperCase();
        return F.indexOf(g) > -1 ? g : h;
      }
      function j(h, g) {
        g = g || {};
        var T = g.body;
        if (h instanceof j) {
          if (h.bodyUsed) throw new TypeError("Already read");
          (this.url = h.url),
            (this.credentials = h.credentials),
            g.headers || (this.headers = new A(h.headers)),
            (this.method = h.method),
            (this.mode = h.mode),
            (this.signal = h.signal),
            !T && h._bodyInit != null && ((T = h._bodyInit), (h.bodyUsed = !0));
        } else this.url = String(h);
        if (
          ((this.credentials =
            g.credentials || this.credentials || "same-origin"),
          (g.headers || !this.headers) && (this.headers = new A(g.headers)),
          (this.method = V(g.method || this.method || "GET")),
          (this.mode = g.mode || this.mode || null),
          (this.signal = g.signal || this.signal),
          (this.referrer = null),
          (this.method === "GET" || this.method === "HEAD") && T)
        )
          throw new TypeError("Body not allowed for GET or HEAD requests");
        this._initBody(T);
      }
      j.prototype.clone = function () {
        return new j(this, {
          body: this._bodyInit,
        });
      };
      function X(h) {
        var g = new FormData();
        return (
          h
            .trim()
            .split("&")
            .forEach(function (T) {
              if (T) {
                var R = T.split("="),
                  x = R.shift().replace(/\+/g, " "),
                  f = R.join("=").replace(/\+/g, " ");
                g.append(decodeURIComponent(x), decodeURIComponent(f));
              }
            }),
          g
        );
      }
      function C(h) {
        var g = new A(),
          T = h.replace(/\r?\n[\t ]+/g, " ");
        return (
          T.split(/\r?\n/).forEach(function (R) {
            var x = R.split(":"),
              f = x.shift().trim();
            if (f) {
              var _ = x.join(":").trim();
              g.append(f, _);
            }
          }),
          g
        );
      }
      O.call(j.prototype);
      function l(h, g) {
        g || (g = {}),
          (this.type = "default"),
          (this.status = g.status === void 0 ? 200 : g.status),
          (this.ok = this.status >= 200 && this.status < 300),
          (this.statusText = "statusText" in g ? g.statusText : "OK"),
          (this.headers = new A(g.headers)),
          (this.url = g.url || ""),
          this._initBody(h);
      }
      O.call(l.prototype),
        (l.prototype.clone = function () {
          return new l(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new A(this.headers),
            url: this.url,
          });
        }),
        (l.error = function () {
          var h = new l(null, {
            status: 0,
            statusText: "",
          });
          return (h.type = "error"), h;
        });
      var p = [301, 302, 303, 307, 308];
      (l.redirect = function (h, g) {
        if (p.indexOf(g) === -1) throw new RangeError("Invalid status code");
        return new l(null, {
          status: g,
          headers: {
            location: h,
          },
        });
      }),
        (s.DOMException = a.DOMException);
      try {
        new s.DOMException();
      } catch {
        (s.DOMException = function (g, T) {
          (this.message = g), (this.name = T);
          var R = Error(g);
          this.stack = R.stack;
        }),
          (s.DOMException.prototype = Object.create(Error.prototype)),
          (s.DOMException.prototype.constructor = s.DOMException);
      }
      function y(h, g) {
        return new Promise(function (T, R) {
          var x = new j(h, g);
          if (x.signal && x.signal.aborted)
            return R(new s.DOMException("Aborted", "AbortError"));
          var f = new XMLHttpRequest();
          function _() {
            f.abort();
          }
          (f.onload = function () {
            var P = {
              status: f.status,
              statusText: f.statusText,
              headers: C(f.getAllResponseHeaders() || ""),
            };
            P.url =
              "responseURL" in f
                ? f.responseURL
                : P.headers.get("X-Request-URL");
            var M = "response" in f ? f.response : f.responseText;
            T(new l(M, P));
          }),
            (f.onerror = function () {
              R(new TypeError("Network request failed"));
            }),
            (f.ontimeout = function () {
              R(new TypeError("Network request failed"));
            }),
            (f.onabort = function () {
              R(new s.DOMException("Aborted", "AbortError"));
            }),
            f.open(x.method, x.url, !0),
            x.credentials === "include"
              ? (f.withCredentials = !0)
              : x.credentials === "omit" && (f.withCredentials = !1),
            "responseType" in f && o.blob && (f.responseType = "blob"),
            x.headers.forEach(function (P, M) {
              f.setRequestHeader(M, P);
            }),
            x.signal &&
              (x.signal.addEventListener("abort", _),
              (f.onreadystatechange = function () {
                f.readyState === 4 && x.signal.removeEventListener("abort", _);
              })),
            f.send(typeof x._bodyInit > "u" ? null : x._bodyInit);
        });
      }
      return (
        (y.polyfill = !0),
        a.fetch ||
          ((a.fetch = y), (a.Headers = A), (a.Request = j), (a.Response = l)),
        (s.Headers = A),
        (s.Request = j),
        (s.Response = l),
        (s.fetch = y),
        Object.defineProperty(s, "__esModule", {
          value: !0,
        }),
        s
      );
    })({});
  })(n),
    (n.fetch.ponyfill = !0),
    delete n.fetch.polyfill;
  var i = n;
  (e = i.fetch),
    (e.default = i.fetch),
    (e.fetch = i.fetch),
    (e.Headers = i.Headers),
    (e.Request = i.Request),
    (e.Response = i.Response),
    (t.exports = e);
})(__, __.exports);
var E_ = __.exports;
const _s = mn(E_);
var hoe = typeof self == "object" ? self.FormData : window.FormData;
const poe = mn(hoe);
var FS = {};
function moe(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  return typeof process < "u" && FS[t] ? FS[t] : e;
}
const JO = ".ipfscdn.io",
  yoe = ".thirdwebstorage-staging.com",
  goe = [`https://{clientId}${JO}/ipfs/{cid}/{path}`];
function l3(t) {
  const e = new URL(t).hostname;
  return e.endsWith(JO) ? !0 : e.endsWith(yoe);
}
const boe = [
    "https://{cid}.ipfs.cf-ipfs.com/{path}",
    "https://{cid}.ipfs.dweb.link/{path}",
    "https://ipfs.io/ipfs/{cid}/{path}",
    "https://cloudflare-ipfs.com/ipfs/{cid}/{path}",
    "https://{cid}.ipfs.w3s.link/{path}",
    "https://w3s.link/ipfs/{cid}/{path}",
    "https://nftstorage.link/ipfs/{cid}/{path}",
    "https://gateway.pinata.cloud/ipfs/{cid}/{path}",
  ],
  voe = {
    "ipfs://": [...goe, ...boe],
  },
  xoe = moe("CUSTOM_UPLOAD_SERVER_URL", "https://storage.thirdweb.com");
function woe(t) {
  return Array.isArray(t)
    ? {
        "ipfs://": t,
      }
    : t || {};
}
function _oe(t, e, r) {
  const n = e.split("/"),
    i = Toe(n[0]),
    a = n.slice(1).join("/");
  let s = t;
  if (
    (t.includes("{cid}") && t.includes("{path}")
      ? (s = s.replace("{cid}", i).replace("{path}", a))
      : t.includes("{cid}")
      ? (s = s.replace("{cid}", i))
      : (s += `${i}/${a}`),
    t.includes("{clientId}"))
  ) {
    if (!r)
      throw new Error(
        "Cannot use {clientId} in gateway URL without providing a client ID"
      );
    s = s.replace("{clientId}", r);
  }
  return s;
}
function Eoe(t, e, r) {
  const n = {
    ...voe,
    ...t,
  };
  for (const i of Object.keys(n)) {
    const a = n[i]
      .map((s) => {
        if (e && s.includes("{clientId}")) return s.replace("{clientId}", e);
        if (r && s.includes("{clientId}"))
          throw new Error("Cannot use secretKey in browser context");
        return s.includes("{clientId}") ? void 0 : s;
      })
      .filter((s) => s !== void 0);
    n[i] = a;
  }
  return n;
}
function Toe(t) {
  let e;
  try {
    const r = t.split("/")[0];
    e = doe.base32(r);
  } catch {
    throw new Error(`The CID ${t} is not valid.`);
  }
  return e;
}
function Coe() {
  return !0;
}
function c2(t) {
  return global.File && t instanceof File;
}
function D0(t) {
  return global.Buffer && t instanceof Buffer;
}
function l2(t) {
  return !!(
    t &&
    t.name &&
    t.data &&
    typeof t.name == "string" &&
    (typeof t.data == "string" || D0(t.data))
  );
}
function bu(t) {
  return c2(t) || D0(t) || l2(t);
}
function Aoe(t, e) {
  if (c2(t) && c2(e)) {
    if (
      t.name === e.name &&
      t.lastModified === e.lastModified &&
      t.size === e.size
    )
      return !0;
  } else {
    if (D0(t) && D0(e)) return t.equals(e);
    if (l2(t) && l2(e) && t.name === e.name) {
      if (typeof t.data == "string" && typeof e.data == "string")
        return t.data === e.data;
      if (D0(t.data) && D0(e.data)) return t.data.equals(e.data);
    }
  }
  return !1;
}
function koe(t, e) {
  var a, s;
  const r = t
      .replace("{cid}", "(?<hash>[^/]+)")
      .replace("{path}", "(?<path>[^?#]+)"),
    n = new RegExp(r),
    i = e.match(n);
  if (i) {
    const o = (a = i.groups) == null ? void 0 : a.hash,
      c = (s = i.groups) == null ? void 0 : s.path,
      u = e.includes("?") ? e.substring(e.indexOf("?") + 1) : "";
    return {
      hash: o,
      path: c,
      query: u,
    };
  }
}
function QO(t, e) {
  for (const r of Object.keys(e))
    for (const n of e[r])
      if (n.includes("{cid}")) {
        const i = koe(n, t);
        if (i != null && i.hash && i != null && i.path) {
          const a =
            i != null && i.query ? `?${i == null ? void 0 : i.query}` : "";
          return `${r}${i == null ? void 0 : i.hash}/${
            i == null ? void 0 : i.path
          }${a}`;
        } else return t;
      } else if (t.startsWith(n)) return t.replace(n, r);
  return t;
}
function xE(t, e) {
  let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0,
    n = arguments.length > 3 ? arguments[3] : void 0;
  const i = Object.keys(e).find((o) => t.startsWith(o)),
    a = i ? e[i] : [];
  if ((!i && r > 0) || (i && r >= a.length)) return;
  if (!i) return t;
  const s = t.replace(i, "");
  return _oe(a[r], s, n);
}
function T_(t, e) {
  return typeof t == "string"
    ? QO(t, e)
    : typeof t == "object"
    ? !t || bu(t)
      ? t
      : Array.isArray(t)
      ? t.map((r) => T_(r, e))
      : Object.fromEntries(
          Object.entries(t).map((r) => {
            let [n, i] = r;
            return [n, T_(i, e)];
          })
        )
    : t;
}
function u2(t, e, r) {
  return typeof t == "string"
    ? xE(t, e, 0, r)
    : typeof t == "object"
    ? !t || bu(t)
      ? t
      : Array.isArray(t)
      ? t.map((n) => u2(n, e, r))
      : Object.fromEntries(
          Object.entries(t).map((n) => {
            let [i, a] = n;
            return [i, u2(a, e, r)];
          })
        )
    : t;
}
function C_(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  if (bu(t)) return e.push(t), e;
  if (typeof t == "object") {
    if (!t) return e;
    Array.isArray(t)
      ? t.forEach((r) => C_(r, e))
      : Object.keys(t).map((r) => C_(t[r], e));
  }
  return e;
}
function A_(t, e) {
  if (bu(t)) {
    if (e.length) return (t = e.shift()), t;
    console.warn("Not enough URIs to replace all files in object.");
  }
  return typeof t == "object"
    ? t &&
        (Array.isArray(t)
          ? t.map((r) => A_(r, e))
          : Object.fromEntries(
              Object.entries(t).map((r) => {
                let [n, i] = r;
                return [n, A_(i, e)];
              })
            ))
    : t;
}
var f2 = {
  name: "@thirdweb-dev/storage",
  version: "1.2.11",
  main: "dist/thirdweb-dev-storage.cjs.js",
  module: "dist/thirdweb-dev-storage.esm.js",
  browser: {
    "./dist/thirdweb-dev-storage.esm.js":
      "./dist/thirdweb-dev-storage.browser.esm.js",
  },
  exports: {
    ".": {
      module: {
        browser: "./dist/thirdweb-dev-storage.browser.esm.js",
        default: "./dist/thirdweb-dev-storage.esm.js",
      },
      default: "./dist/thirdweb-dev-storage.cjs.js",
    },
    "./package.json": "./package.json",
  },
  repository: "https://github.com/thirdweb-dev/js/tree/main/packages/storage",
  author: "thirdweb eng <eng@thirdweb.com>",
  license: "Apache-2.0",
  sideEffects: !1,
  scripts: {
    format: "prettier --write 'src/**/*'",
    lint: "eslint src/",
    fix: "eslint src/ --fix",
    "generate-docs":
      "api-extractor run --local && api-documenter markdown -i ./temp -o ./docs",
    clean: "rm -rf dist/",
    build: "tsc && preconstruct build",
    "test:all":
      "NODE_ENV=test SWC_NODE_PROJECT=./tsconfig.test.json mocha --timeout 30000 --parallel './test/**/*.test.ts'",
    test: "pnpm test:all",
    "test:single":
      "NODE_ENV=test SWC_NODE_PROJECT=./tsconfig.test.json mocha --timeout 30000",
    push: "yalc push",
  },
  files: ["dist/"],
  preconstruct: {
    exports: {
      envConditions: ["browser"],
    },
  },
  devDependencies: {
    "@babel/preset-env": "^7.22.9",
    "@babel/preset-typescript": "^7.22.5",
    "@microsoft/api-documenter": "^7.22.30",
    "@microsoft/api-extractor": "^7.36.3",
    "@microsoft/tsdoc": "^0.14.1",
    "@preconstruct/cli": "2.7.0",
    "@swc-node/register": "^1.6.6",
    "@thirdweb-dev/tsconfig": "workspace:*",
    "@types/chai": "^4.3.5",
    "@types/mocha": "^10.0.0",
    "@types/uuid": "^9.0.2",
    "@typescript-eslint/eslint-plugin": "^6.2.0",
    "@typescript-eslint/parser": "^6.2.0",
    chai: "^4.3.6",
    eslint: "^8.45.0",
    "eslint-config-thirdweb": "workspace:*",
    esm: "^3.2.25",
    mocha: "^10.2.0",
    typescript: "^5.1.6",
  },
  dependencies: {
    "cid-tool": "^3.0.0",
    "cross-fetch": "^3.1.8",
    "form-data": "^4.0.0",
    uuid: "^9.0.0",
  },
};
class Soe {
  constructor(e) {
    oe(this, "DEFAULT_TIMEOUT_IN_SECONDS", 60);
    oe(this, "DEFAULT_MAX_RETRIES", 3);
    (this.secretKey = e.secretKey),
      (this.clientId = e.clientId),
      (this.defaultTimeout =
        e.timeoutInSeconds || this.DEFAULT_TIMEOUT_IN_SECONDS);
  }
  async download(e, r, n) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    const a = (n == null ? void 0 : n.maxRetries) || this.DEFAULT_MAX_RETRIES;
    if (i > a)
      return (
        console.error(
          "[FAILED_TO_DOWNLOAD_ERROR] Failed to download from URI - too many attempts failed."
        ),
        new E_.Response(
          JSON.stringify({
            error: "Not Found",
          }),
          {
            status: 404,
            headers: {
              "Content-Type": "application/json",
            },
          }
        )
      );
    let s = xE(e, r, i, this.clientId);
    if (s)
      i > 0 && console.warn(`Retrying download with backup gateway URL: ${s}`);
    else
      return (
        console.error(
          "[FAILED_TO_DOWNLOAD_ERROR] Unable to download from URI - all gateway URLs failed to respond."
        ),
        new E_.Response(
          JSON.stringify({
            error: "Not Found",
          }),
          {
            status: 404,
            headers: {
              "Content-Type": "application/json",
            },
          }
        )
      );
    let o = {};
    if (l3(s)) {
      const v =
        typeof globalThis < "u" && "APP_BUNDLE_ID" in globalThis
          ? globalThis.APP_BUNDLE_ID
          : void 0;
      this.secretKey
        ? (o = {
            "x-secret-key": this.secretKey,
          })
        : this.clientId &&
          (s.includes("bundleId") || (s = s + (v ? `?bundleId=${v}` : "")),
          (o["x-client-Id"] = this.clientId)),
        typeof globalThis < "u" &&
          "TW_AUTH_TOKEN" in globalThis &&
          typeof globalThis.TW_AUTH_TOKEN == "string" &&
          (o = {
            ...o,
            authorization: `Bearer ${globalThis.TW_AUTH_TOKEN}`,
          }),
        typeof globalThis < "u" &&
          "TW_CLI_AUTH_TOKEN" in globalThis &&
          typeof globalThis.TW_CLI_AUTH_TOKEN == "string" &&
          ((o = {
            ...o,
            authorization: `Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`,
          }),
          (o["x-authorize-wallet"] = "true")),
        (o["x-sdk-version"] = f2.version),
        (o["x-sdk-name"] = f2.name),
        (o["x-sdk-platform"] = v
          ? "react-native"
          : window.bridge !== void 0
          ? "webGL"
          : "browser");
    }
    if (Moe(s)) return this.download(e, r, n, i + 1);
    const c = new AbortController(),
      u = (n == null ? void 0 : n.timeoutInSeconds) || this.defaultTimeout,
      d = setTimeout(() => c.abort(), u * 1e3),
      m = await _s(s, {
        headers: o,
        signal: c.signal,
      }).catch((v) => v);
    if ((d && clearTimeout(d), !("status" in m)))
      throw new Error(
        `Request timed out after ${u} seconds. ${
          l3(s)
            ? "You can update the timeoutInSeconds option to increase the timeout."
            : "You're using a public IPFS gateway, pass in a clientId or secretKey for a reliable IPFS gateway."
        }`
      );
    return m.ok
      ? m
      : m.status === 429
      ? (Ioe(s, m), this.download(e, r, n, i + 1))
      : m.status === 410
      ? (console.error(
          `Request to ${s} failed because this content seems to be blocklisted. Search VirusTotal for this URL to confirm: ${s} `
        ),
        m)
      : (console.warn(
          `Request to ${s} failed with status ${m.status} - ${m.statusText}`
        ),
        (m.status === 404 && l3(s)) ||
        (m.status !== 408 && m.status !== 429 && m.status < 500)
          ? m
          : this.download(e, r, n, i + 1));
  }
}
const k_ = new Map();
function Moe(t) {
  return k_.has(t);
}
const u3 = new Map();
function Ioe(t, e) {
  u3.has(t) && clearTimeout(u3.get(t));
  const r = e.headers.get("Retry-After");
  let n = 5e3;
  if (r) {
    const i = parseInt(r);
    isNaN(i) || (n = i * 1e3);
  }
  k_.set(t, !0),
    u3.set(
      t,
      setTimeout(() => k_.delete(t), n)
    );
}
class Roe {
  constructor(e) {
    (this.uploadWithGatewayUrl =
      (e == null ? void 0 : e.uploadWithGatewayUrl) || !1),
      (this.uploadServerUrl = (e == null ? void 0 : e.uploadServerUrl) || xoe),
      (this.clientId = e == null ? void 0 : e.clientId),
      (this.secretKey = e == null ? void 0 : e.secretKey);
  }
  async uploadBatch(e, r) {
    if (r != null && r.uploadWithoutDirectory && e.length > 1)
      throw new Error(
        "[UPLOAD_WITHOUT_DIRECTORY_ERROR] Cannot upload more than one file or object without directory!"
      );
    const n = new poe(),
      { form: i, fileNames: a } = this.buildFormData(n, e, r);
    return this.uploadBatchBrowser(i, a, r);
  }
  buildFormData(e, r, n) {
    const i = new Map(),
      a = [];
    for (let o = 0; o < r.length; o++) {
      const c = r[o];
      let u = "",
        d = c;
      if (c2(c))
        if (n != null && n.rewriteFileNames) {
          let v = "";
          if (c.name) {
            const E = c.name.lastIndexOf(".");
            E > -1 && (v = c.name.substring(E));
          }
          u = `${o + n.rewriteFileNames.fileStartNumber}${v}`;
        } else u = `${c.name}`;
      else
        l2(c)
          ? ((d = c.data),
            n != null && n.rewriteFileNames
              ? (u = `${o + n.rewriteFileNames.fileStartNumber}`)
              : (u = `${c.name}`))
          : n != null && n.rewriteFileNames
          ? (u = `${o + n.rewriteFileNames.fileStartNumber}`)
          : (u = `${o}`);
      const m = n != null && n.uploadWithoutDirectory ? "files" : `files/${u}`;
      if (i.has(u)) {
        if (Aoe(i.get(u), c)) {
          a.push(u);
          continue;
        }
        throw new Error(
          `[DUPLICATE_FILE_NAME_ERROR] File name ${u} was passed for more than one different file.`
        );
      }
      i.set(u, c), a.push(u), e.append("file", new Blob([d]), m);
    }
    const s = {
      name: "Storage SDK",
      keyvalues: {
        ...(n == null ? void 0 : n.metadata),
      },
    };
    return (
      e.append("pinataMetadata", JSON.stringify(s)),
      n != null &&
        n.uploadWithoutDirectory &&
        e.append(
          "pinataOptions",
          JSON.stringify({
            wrapWithDirectory: !1,
          })
        ),
      {
        form: e,
        fileNames: a.map((o) => encodeURIComponent(o)),
      }
    );
  }
  async uploadBatchBrowser(e, r, n) {
    return new Promise((i, a) => {
      const s = new XMLHttpRequest();
      let o = setTimeout(() => {
        s.abort(),
          a(
            new Error(
              "Request to upload timed out! No upload progress received in 30s"
            )
          );
      }, 3e4);
      s.upload.addEventListener("loadstart", () => {
        console.log(`[${Date.now()}] [IPFS] Started`);
      }),
        s.upload.addEventListener("progress", (u) => {
          console.log(`[IPFS] Progress Event ${u.loaded}/${u.total}`),
            clearTimeout(o),
            u.loaded < u.total
              ? (o = setTimeout(() => {
                  s.abort(),
                    a(
                      new Error(
                        "Request to upload timed out! No upload progress received in 30s"
                      )
                    );
                }, 3e4))
              : console.log(
                  `[${Date.now()}] [IPFS] Uploaded files. Waiting for response.`
                ),
            u.lengthComputable &&
              n != null &&
              n.onProgress &&
              (n == null ||
                n.onProgress({
                  progress: u.loaded,
                  total: u.total,
                }));
        }),
        s.addEventListener("load", () => {
          if (
            (console.log(`[${Date.now()}] [IPFS] Load`),
            clearTimeout(o),
            s.status >= 200 && s.status < 300)
          ) {
            let u;
            try {
              u = JSON.parse(s.responseText);
            } catch {
              return a(new Error("Failed to parse JSON from upload response"));
            }
            const d = u.IpfsHash;
            if (!d)
              throw new Error("Failed to get IPFS hash from upload response");
            return n != null && n.uploadWithoutDirectory
              ? i([`ipfs://${d}`])
              : i(r.map((m) => `ipfs://${d}/${m}`));
          }
          return a(
            new Error(
              `Upload failed with status ${s.status} - ${s.responseText}`
            )
          );
        }),
        s.addEventListener(
          "error",
          () => (
            console.log("[IPFS] Load"),
            clearTimeout(o),
            (s.readyState !== 0 && s.readyState !== 4) || s.status === 0
              ? a(new Error("Upload failed due to a network error."))
              : a(new Error("Unknown upload error occured"))
          )
        ),
        s.open("POST", `${this.uploadServerUrl}/ipfs/upload`),
        this.secretKey
          ? s.setRequestHeader("x-secret-key", this.secretKey)
          : this.clientId && s.setRequestHeader("x-client-id", this.clientId);
      const c =
        typeof globalThis < "u" && "APP_BUNDLE_ID" in globalThis
          ? globalThis.APP_BUNDLE_ID
          : void 0;
      c && s.setRequestHeader("x-bundle-id", c),
        s.setRequestHeader("x-sdk-version", f2.version),
        s.setRequestHeader("x-sdk-name", f2.name),
        s.setRequestHeader(
          "x-sdk-platform",
          c ? "react-native" : window.bridge !== void 0 ? "webGL" : "browser"
        ),
        typeof globalThis < "u" &&
          "TW_AUTH_TOKEN" in globalThis &&
          typeof globalThis.TW_AUTH_TOKEN == "string" &&
          s.setRequestHeader(
            "authorization",
            `Bearer ${globalThis.TW_AUTH_TOKEN}`
          ),
        typeof globalThis < "u" &&
          "TW_CLI_AUTH_TOKEN" in globalThis &&
          typeof globalThis.TW_CLI_AUTH_TOKEN == "string" &&
          (s.setRequestHeader(
            "authorization",
            `Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`
          ),
          s.setRequestHeader("x-authorize-wallet", "true")),
        s.send(e);
    });
  }
  async uploadBatchNode(e, r, n) {
    n != null &&
      n.onProgress &&
      console.warn("The onProgress option is only supported in the browser");
    const i = {};
    this.secretKey
      ? (i["x-secret-key"] = this.secretKey)
      : this.clientId && (i["x-client-id"] = this.clientId),
      typeof globalThis < "u" &&
        "APP_BUNDLE_ID" in globalThis &&
        (i["x-bundle-id"] = globalThis.APP_BUNDLE_ID),
      typeof globalThis < "u" &&
        "TW_AUTH_TOKEN" in globalThis &&
        typeof globalThis.TW_AUTH_TOKEN == "string" &&
        (i.authorization = `Bearer ${globalThis.TW_AUTH_TOKEN}`),
      typeof globalThis < "u" &&
        "TW_CLI_AUTH_TOKEN" in globalThis &&
        typeof globalThis.TW_CLI_AUTH_TOKEN == "string" &&
        ((i.authorization = `Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`),
        (i["x-authorize-wallet"] = "true"));
    const a = await _s(`${this.uploadServerUrl}/ipfs/upload`, {
      method: "POST",
      headers: {
        ...i,
        ...e.getHeaders(),
      },
      body: e.getBuffer(),
    });
    if (!a.ok)
      throw a.status === 401
        ? new Error(
            "Unauthorized - You don't have permission to use this service."
          )
        : new Error(
            `Failed to upload files to IPFS - ${a.status} - ${
              a.statusText
            } - ${await a.text()}`
          );
    const o = (await a.json()).IpfsHash;
    if (!o) throw new Error("Failed to upload files to IPFS - Bad CID");
    return n != null && n.uploadWithoutDirectory
      ? [`ipfs://${o}`]
      : r.map((c) => `ipfs://${o}/${c}`);
  }
}
class LS {
  constructor(e) {
    (this.uploader =
      (e == null ? void 0 : e.uploader) ||
      new Roe({
        clientId: e == null ? void 0 : e.clientId,
        secretKey: e == null ? void 0 : e.secretKey,
        uploadServerUrl: e == null ? void 0 : e.uploadServerUrl,
      })),
      (this.downloader =
        (e == null ? void 0 : e.downloader) ||
        new Soe({
          secretKey: e == null ? void 0 : e.secretKey,
          clientId: e == null ? void 0 : e.clientId,
        })),
      (this.gatewayUrls = Eoe(
        woe(e == null ? void 0 : e.gatewayUrls),
        e == null ? void 0 : e.clientId,
        e == null ? void 0 : e.secretKey
      )),
      (this.clientId = e == null ? void 0 : e.clientId);
  }
  resolveScheme(e) {
    return xE(e, this.gatewayUrls, 0, this.clientId);
  }
  async download(e, r) {
    return this.downloader.download(e, this.gatewayUrls, r);
  }
  async downloadJSON(e, r) {
    const i = await (await this.download(e, r)).json();
    return u2(i, this.gatewayUrls, this.clientId);
  }
  async upload(e, r) {
    const [n] = await this.uploadBatch([e], r);
    return n;
  }
  async uploadBatch(e, r) {
    if (((e = e.filter((a) => a !== void 0)), !e.length)) return [];
    const n = e.map((a) => bu(a) || typeof a == "string").every((a) => !!a);
    let i = [];
    if (n) i = await this.uploader.uploadBatch(e, r);
    else {
      const a = (await this.uploadAndReplaceFilesWithHashes(e, r)).map((s) =>
        typeof s == "string" ? s : JSON.stringify(s)
      );
      i = await this.uploader.uploadBatch(a, r);
    }
    return (r != null && r.uploadWithGatewayUrl) ||
      this.uploader.uploadWithGatewayUrl
      ? i.map((a) => this.resolveScheme(a))
      : i;
  }
  getGatewayUrls() {
    return this.gatewayUrls;
  }
  async uploadAndReplaceFilesWithHashes(e, r) {
    let n = e;
    n = T_(n, this.gatewayUrls);
    const i = C_(n);
    if (i.length) {
      const a = await this.uploader.uploadBatch(i, r);
      n = A_(n, a);
    }
    return (
      ((r != null && r.uploadWithGatewayUrl) ||
        this.uploader.uploadWithGatewayUrl) &&
        (n = u2(n, this.gatewayUrls, this.clientId)),
      n
    );
  }
}
const yv = [
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "interfaceId",
          type: "bytes4",
        },
      ],
      name: "supportsInterface",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  YO = [
    {
      inputs: [],
      name: "name",
      outputs: [
        {
          internalType: "string",
          name: "",
          type: "string",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "symbol",
      outputs: [
        {
          internalType: "string",
          name: "",
          type: "string",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "_tokenId",
          type: "uint256",
        },
      ],
      name: "tokenURI",
      outputs: [
        {
          internalType: "string",
          name: "",
          type: "string",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  XO = [
    {
      inputs: [
        {
          internalType: "uint256",
          name: "_id",
          type: "uint256",
        },
      ],
      name: "uri",
      outputs: [
        {
          internalType: "string",
          name: "",
          type: "string",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  Ri = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "spender",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
      ],
      name: "Approval",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "from",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "to",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
      ],
      name: "Transfer",
      type: "event",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          internalType: "address",
          name: "spender",
          type: "address",
        },
      ],
      name: "allowance",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "spender",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
      ],
      name: "approve",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "who",
          type: "address",
        },
      ],
      name: "balanceOf",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "totalSupply",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "to",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
      ],
      name: "transfer",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "from",
          type: "address",
        },
        {
          internalType: "address",
          name: "to",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
      ],
      name: "transferFrom",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  eF = [
    {
      inputs: [],
      name: "decimals",
      outputs: [
        {
          internalType: "uint8",
          name: "",
          type: "uint8",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "name",
      outputs: [
        {
          internalType: "string",
          name: "",
          type: "string",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "symbol",
      outputs: [
        {
          internalType: "string",
          name: "",
          type: "string",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
  ];
var Poe = function t(e, r) {
  if (e === r) return !0;
  if (e && r && typeof e == "object" && typeof r == "object") {
    if (e.constructor !== r.constructor) return !1;
    var n, i, a;
    if (Array.isArray(e)) {
      if (((n = e.length), n != r.length)) return !1;
      for (i = n; i-- !== 0; ) if (!t(e[i], r[i])) return !1;
      return !0;
    }
    if (e.constructor === RegExp)
      return e.source === r.source && e.flags === r.flags;
    if (e.valueOf !== Object.prototype.valueOf)
      return e.valueOf() === r.valueOf();
    if (e.toString !== Object.prototype.toString)
      return e.toString() === r.toString();
    if (((a = Object.keys(e)), (n = a.length), n !== Object.keys(r).length))
      return !1;
    for (i = n; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(r, a[i])) return !1;
    for (i = n; i-- !== 0; ) {
      var s = a[i];
      if (!t(e[s], r[s])) return !1;
    }
    return !0;
  }
  return e !== e && r !== r;
};
const tF = mn(Poe);
var Xy = {},
  Um = {},
  vo = {},
  Wm = {};
Wm.byteLength = Doe;
Wm.toByteArray = Foe;
Wm.fromByteArray = Uoe;
var Hs = [],
  Ma = [],
  Noe = typeof Uint8Array < "u" ? Uint8Array : Array,
  f3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var Yu = 0, Boe = f3.length; Yu < Boe; ++Yu)
  (Hs[Yu] = f3[Yu]), (Ma[f3.charCodeAt(Yu)] = Yu);
Ma[45] = 62;
Ma[95] = 63;
function rF(t) {
  var e = t.length;
  if (e % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var r = t.indexOf("=");
  r === -1 && (r = e);
  var n = r === e ? 0 : 4 - (r % 4);
  return [r, n];
}
function Doe(t) {
  var e = rF(t),
    r = e[0],
    n = e[1];
  return ((r + n) * 3) / 4 - n;
}
function Ooe(t, e, r) {
  return ((e + r) * 3) / 4 - r;
}
function Foe(t) {
  var e,
    r = rF(t),
    n = r[0],
    i = r[1],
    a = new Noe(Ooe(t, n, i)),
    s = 0,
    o = i > 0 ? n - 4 : n,
    c;
  for (c = 0; c < o; c += 4)
    (e =
      (Ma[t.charCodeAt(c)] << 18) |
      (Ma[t.charCodeAt(c + 1)] << 12) |
      (Ma[t.charCodeAt(c + 2)] << 6) |
      Ma[t.charCodeAt(c + 3)]),
      (a[s++] = (e >> 16) & 255),
      (a[s++] = (e >> 8) & 255),
      (a[s++] = e & 255);
  return (
    i === 2 &&
      ((e = (Ma[t.charCodeAt(c)] << 2) | (Ma[t.charCodeAt(c + 1)] >> 4)),
      (a[s++] = e & 255)),
    i === 1 &&
      ((e =
        (Ma[t.charCodeAt(c)] << 10) |
        (Ma[t.charCodeAt(c + 1)] << 4) |
        (Ma[t.charCodeAt(c + 2)] >> 2)),
      (a[s++] = (e >> 8) & 255),
      (a[s++] = e & 255)),
    a
  );
}
function Loe(t) {
  return (
    Hs[(t >> 18) & 63] + Hs[(t >> 12) & 63] + Hs[(t >> 6) & 63] + Hs[t & 63]
  );
}
function $oe(t, e, r) {
  for (var n, i = [], a = e; a < r; a += 3)
    (n =
      ((t[a] << 16) & 16711680) + ((t[a + 1] << 8) & 65280) + (t[a + 2] & 255)),
      i.push(Loe(n));
  return i.join("");
}
function Uoe(t) {
  for (
    var e, r = t.length, n = r % 3, i = [], a = 16383, s = 0, o = r - n;
    s < o;
    s += a
  )
    i.push($oe(t, s, s + a > o ? o : s + a));
  return (
    n === 1
      ? ((e = t[r - 1]), i.push(Hs[e >> 2] + Hs[(e << 4) & 63] + "=="))
      : n === 2 &&
        ((e = (t[r - 2] << 8) + t[r - 1]),
        i.push(Hs[e >> 10] + Hs[(e >> 4) & 63] + Hs[(e << 2) & 63] + "=")),
    i.join("")
  );
}
var gv = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
gv.read = function (t, e, r, n, i) {
  var a,
    s,
    o = i * 8 - n - 1,
    c = (1 << o) - 1,
    u = c >> 1,
    d = -7,
    m = r ? i - 1 : 0,
    v = r ? -1 : 1,
    E = t[e + m];
  for (
    m += v, a = E & ((1 << -d) - 1), E >>= -d, d += o;
    d > 0;
    a = a * 256 + t[e + m], m += v, d -= 8
  );
  for (
    s = a & ((1 << -d) - 1), a >>= -d, d += n;
    d > 0;
    s = s * 256 + t[e + m], m += v, d -= 8
  );
  if (a === 0) a = 1 - u;
  else {
    if (a === c) return s ? NaN : (E ? -1 : 1) * (1 / 0);
    (s = s + Math.pow(2, n)), (a = a - u);
  }
  return (E ? -1 : 1) * s * Math.pow(2, a - n);
};
gv.write = function (t, e, r, n, i, a) {
  var s,
    o,
    c,
    u = a * 8 - i - 1,
    d = (1 << u) - 1,
    m = d >> 1,
    v = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
    E = n ? 0 : a - 1,
    A = n ? 1 : -1,
    I = e < 0 || (e === 0 && 1 / e < 0) ? 1 : 0;
  for (
    e = Math.abs(e),
      isNaN(e) || e === 1 / 0
        ? ((o = isNaN(e) ? 1 : 0), (s = d))
        : ((s = Math.floor(Math.log(e) / Math.LN2)),
          e * (c = Math.pow(2, -s)) < 1 && (s--, (c *= 2)),
          s + m >= 1 ? (e += v / c) : (e += v * Math.pow(2, 1 - m)),
          e * c >= 2 && (s++, (c /= 2)),
          s + m >= d
            ? ((o = 0), (s = d))
            : s + m >= 1
            ? ((o = (e * c - 1) * Math.pow(2, i)), (s = s + m))
            : ((o = e * Math.pow(2, m - 1) * Math.pow(2, i)), (s = 0)));
    i >= 8;
    t[r + E] = o & 255, E += A, o /= 256, i -= 8
  );
  for (
    s = (s << i) | o, u += i;
    u > 0;
    t[r + E] = s & 255, E += A, s /= 256, u -= 8
  );
  t[r + E - A] |= I * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function (t) {
  const e = Wm,
    r = gv,
    n =
      typeof Symbol == "function" && typeof Symbol.for == "function"
        ? Symbol.for("nodejs.util.inspect.custom")
        : null;
  (t.Buffer = o), (t.SlowBuffer = S), (t.INSPECT_MAX_BYTES = 50);
  const i = 2147483647;
  (t.kMaxLength = i),
    (o.TYPED_ARRAY_SUPPORT = a()),
    !o.TYPED_ARRAY_SUPPORT &&
      typeof console < "u" &&
      typeof console.error == "function" &&
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
  function a() {
    try {
      const z = new Uint8Array(1),
        U = {
          foo: function () {
            return 42;
          },
        };
      return (
        Object.setPrototypeOf(U, Uint8Array.prototype),
        Object.setPrototypeOf(z, U),
        z.foo() === 42
      );
    } catch {
      return !1;
    }
  }
  Object.defineProperty(o.prototype, "parent", {
    enumerable: !0,
    get: function () {
      if (o.isBuffer(this)) return this.buffer;
    },
  }),
    Object.defineProperty(o.prototype, "offset", {
      enumerable: !0,
      get: function () {
        if (o.isBuffer(this)) return this.byteOffset;
      },
    });
  function s(z) {
    if (z > i)
      throw new RangeError(
        'The value "' + z + '" is invalid for option "size"'
      );
    const U = new Uint8Array(z);
    return Object.setPrototypeOf(U, o.prototype), U;
  }
  function o(z, U, L) {
    if (typeof z == "number") {
      if (typeof U == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return m(z);
    }
    return c(z, U, L);
  }
  o.poolSize = 8192;
  function c(z, U, L) {
    if (typeof z == "string") return v(z, U);
    if (ArrayBuffer.isView(z)) return A(z);
    if (z == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
          typeof z
      );
    if (
      Ce(z, ArrayBuffer) ||
      (z && Ce(z.buffer, ArrayBuffer)) ||
      (typeof SharedArrayBuffer < "u" &&
        (Ce(z, SharedArrayBuffer) || (z && Ce(z.buffer, SharedArrayBuffer))))
    )
      return I(z, U, L);
    if (typeof z == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const J = z.valueOf && z.valueOf();
    if (J != null && J !== z) return o.from(J, U, L);
    const fe = b(z);
    if (fe) return fe;
    if (
      typeof Symbol < "u" &&
      Symbol.toPrimitive != null &&
      typeof z[Symbol.toPrimitive] == "function"
    )
      return o.from(z[Symbol.toPrimitive]("string"), U, L);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
        typeof z
    );
  }
  (o.from = function (z, U, L) {
    return c(z, U, L);
  }),
    Object.setPrototypeOf(o.prototype, Uint8Array.prototype),
    Object.setPrototypeOf(o, Uint8Array);
  function u(z) {
    if (typeof z != "number")
      throw new TypeError('"size" argument must be of type number');
    if (z < 0)
      throw new RangeError(
        'The value "' + z + '" is invalid for option "size"'
      );
  }
  function d(z, U, L) {
    return (
      u(z),
      z <= 0
        ? s(z)
        : U !== void 0
        ? typeof L == "string"
          ? s(z).fill(U, L)
          : s(z).fill(U)
        : s(z)
    );
  }
  o.alloc = function (z, U, L) {
    return d(z, U, L);
  };
  function m(z) {
    return u(z), s(z < 0 ? 0 : w(z) | 0);
  }
  (o.allocUnsafe = function (z) {
    return m(z);
  }),
    (o.allocUnsafeSlow = function (z) {
      return m(z);
    });
  function v(z, U) {
    if (((typeof U != "string" || U === "") && (U = "utf8"), !o.isEncoding(U)))
      throw new TypeError("Unknown encoding: " + U);
    const L = k(z, U) | 0;
    let J = s(L);
    const fe = J.write(z, U);
    return fe !== L && (J = J.slice(0, fe)), J;
  }
  function E(z) {
    const U = z.length < 0 ? 0 : w(z.length) | 0,
      L = s(U);
    for (let J = 0; J < U; J += 1) L[J] = z[J] & 255;
    return L;
  }
  function A(z) {
    if (Ce(z, Uint8Array)) {
      const U = new Uint8Array(z);
      return I(U.buffer, U.byteOffset, U.byteLength);
    }
    return E(z);
  }
  function I(z, U, L) {
    if (U < 0 || z.byteLength < U)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (z.byteLength < U + (L || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let J;
    return (
      U === void 0 && L === void 0
        ? (J = new Uint8Array(z))
        : L === void 0
        ? (J = new Uint8Array(z, U))
        : (J = new Uint8Array(z, U, L)),
      Object.setPrototypeOf(J, o.prototype),
      J
    );
  }
  function b(z) {
    if (o.isBuffer(z)) {
      const U = w(z.length) | 0,
        L = s(U);
      return L.length === 0 || z.copy(L, 0, 0, U), L;
    }
    if (z.length !== void 0)
      return typeof z.length != "number" || me(z.length) ? s(0) : E(z);
    if (z.type === "Buffer" && Array.isArray(z.data)) return E(z.data);
  }
  function w(z) {
    if (z >= i)
      throw new RangeError(
        "Attempt to allocate Buffer larger than maximum size: 0x" +
          i.toString(16) +
          " bytes"
      );
    return z | 0;
  }
  function S(z) {
    return +z != z && (z = 0), o.alloc(+z);
  }
  (o.isBuffer = function (U) {
    return U != null && U._isBuffer === !0 && U !== o.prototype;
  }),
    (o.compare = function (U, L) {
      if (
        (Ce(U, Uint8Array) && (U = o.from(U, U.offset, U.byteLength)),
        Ce(L, Uint8Array) && (L = o.from(L, L.offset, L.byteLength)),
        !o.isBuffer(U) || !o.isBuffer(L))
      )
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      if (U === L) return 0;
      let J = U.length,
        fe = L.length;
      for (let ie = 0, le = Math.min(J, fe); ie < le; ++ie)
        if (U[ie] !== L[ie]) {
          (J = U[ie]), (fe = L[ie]);
          break;
        }
      return J < fe ? -1 : fe < J ? 1 : 0;
    }),
    (o.isEncoding = function (U) {
      switch (String(U).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return !0;
        default:
          return !1;
      }
    }),
    (o.concat = function (U, L) {
      if (!Array.isArray(U))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (U.length === 0) return o.alloc(0);
      let J;
      if (L === void 0) for (L = 0, J = 0; J < U.length; ++J) L += U[J].length;
      const fe = o.allocUnsafe(L);
      let ie = 0;
      for (J = 0; J < U.length; ++J) {
        let le = U[J];
        if (Ce(le, Uint8Array))
          ie + le.length > fe.length
            ? (o.isBuffer(le) || (le = o.from(le)), le.copy(fe, ie))
            : Uint8Array.prototype.set.call(fe, le, ie);
        else if (o.isBuffer(le)) le.copy(fe, ie);
        else throw new TypeError('"list" argument must be an Array of Buffers');
        ie += le.length;
      }
      return fe;
    });
  function k(z, U) {
    if (o.isBuffer(z)) return z.length;
    if (ArrayBuffer.isView(z) || Ce(z, ArrayBuffer)) return z.byteLength;
    if (typeof z != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
          typeof z
      );
    const L = z.length,
      J = arguments.length > 2 && arguments[2] === !0;
    if (!J && L === 0) return 0;
    let fe = !1;
    for (;;)
      switch (U) {
        case "ascii":
        case "latin1":
        case "binary":
          return L;
        case "utf8":
        case "utf-8":
          return $(z).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return L * 2;
        case "hex":
          return L >>> 1;
        case "base64":
          return ee(z).length;
        default:
          if (fe) return J ? -1 : $(z).length;
          (U = ("" + U).toLowerCase()), (fe = !0);
      }
  }
  o.byteLength = k;
  function N(z, U, L) {
    let J = !1;
    if (
      ((U === void 0 || U < 0) && (U = 0),
      U > this.length ||
        ((L === void 0 || L > this.length) && (L = this.length), L <= 0) ||
        ((L >>>= 0), (U >>>= 0), L <= U))
    )
      return "";
    for (z || (z = "utf8"); ; )
      switch (z) {
        case "hex":
          return f(this, U, L);
        case "utf8":
        case "utf-8":
          return h(this, U, L);
        case "ascii":
          return R(this, U, L);
        case "latin1":
        case "binary":
          return x(this, U, L);
        case "base64":
          return y(this, U, L);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return _(this, U, L);
        default:
          if (J) throw new TypeError("Unknown encoding: " + z);
          (z = (z + "").toLowerCase()), (J = !0);
      }
  }
  o.prototype._isBuffer = !0;
  function O(z, U, L) {
    const J = z[U];
    (z[U] = z[L]), (z[L] = J);
  }
  (o.prototype.swap16 = function () {
    const U = this.length;
    if (U % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let L = 0; L < U; L += 2) O(this, L, L + 1);
    return this;
  }),
    (o.prototype.swap32 = function () {
      const U = this.length;
      if (U % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let L = 0; L < U; L += 4) O(this, L, L + 3), O(this, L + 1, L + 2);
      return this;
    }),
    (o.prototype.swap64 = function () {
      const U = this.length;
      if (U % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let L = 0; L < U; L += 8)
        O(this, L, L + 7),
          O(this, L + 1, L + 6),
          O(this, L + 2, L + 5),
          O(this, L + 3, L + 4);
      return this;
    }),
    (o.prototype.toString = function () {
      const U = this.length;
      return U === 0
        ? ""
        : arguments.length === 0
        ? h(this, 0, U)
        : N.apply(this, arguments);
    }),
    (o.prototype.toLocaleString = o.prototype.toString),
    (o.prototype.equals = function (U) {
      if (!o.isBuffer(U)) throw new TypeError("Argument must be a Buffer");
      return this === U ? !0 : o.compare(this, U) === 0;
    }),
    (o.prototype.inspect = function () {
      let U = "";
      const L = t.INSPECT_MAX_BYTES;
      return (
        (U = this.toString("hex", 0, L)
          .replace(/(.{2})/g, "$1 ")
          .trim()),
        this.length > L && (U += " ... "),
        "<Buffer " + U + ">"
      );
    }),
    n && (o.prototype[n] = o.prototype.inspect),
    (o.prototype.compare = function (U, L, J, fe, ie) {
      if (
        (Ce(U, Uint8Array) && (U = o.from(U, U.offset, U.byteLength)),
        !o.isBuffer(U))
      )
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
            typeof U
        );
      if (
        (L === void 0 && (L = 0),
        J === void 0 && (J = U ? U.length : 0),
        fe === void 0 && (fe = 0),
        ie === void 0 && (ie = this.length),
        L < 0 || J > U.length || fe < 0 || ie > this.length)
      )
        throw new RangeError("out of range index");
      if (fe >= ie && L >= J) return 0;
      if (fe >= ie) return -1;
      if (L >= J) return 1;
      if (((L >>>= 0), (J >>>= 0), (fe >>>= 0), (ie >>>= 0), this === U))
        return 0;
      let le = ie - fe,
        nt = J - L;
      const Ee = Math.min(le, nt),
        we = this.slice(fe, ie),
        ft = U.slice(L, J);
      for (let xe = 0; xe < Ee; ++xe)
        if (we[xe] !== ft[xe]) {
          (le = we[xe]), (nt = ft[xe]);
          break;
        }
      return le < nt ? -1 : nt < le ? 1 : 0;
    });
  function F(z, U, L, J, fe) {
    if (z.length === 0) return -1;
    if (
      (typeof L == "string"
        ? ((J = L), (L = 0))
        : L > 2147483647
        ? (L = 2147483647)
        : L < -2147483648 && (L = -2147483648),
      (L = +L),
      me(L) && (L = fe ? 0 : z.length - 1),
      L < 0 && (L = z.length + L),
      L >= z.length)
    ) {
      if (fe) return -1;
      L = z.length - 1;
    } else if (L < 0)
      if (fe) L = 0;
      else return -1;
    if ((typeof U == "string" && (U = o.from(U, J)), o.isBuffer(U)))
      return U.length === 0 ? -1 : V(z, U, L, J, fe);
    if (typeof U == "number")
      return (
        (U = U & 255),
        typeof Uint8Array.prototype.indexOf == "function"
          ? fe
            ? Uint8Array.prototype.indexOf.call(z, U, L)
            : Uint8Array.prototype.lastIndexOf.call(z, U, L)
          : V(z, [U], L, J, fe)
      );
    throw new TypeError("val must be string, number or Buffer");
  }
  function V(z, U, L, J, fe) {
    let ie = 1,
      le = z.length,
      nt = U.length;
    if (
      J !== void 0 &&
      ((J = String(J).toLowerCase()),
      J === "ucs2" || J === "ucs-2" || J === "utf16le" || J === "utf-16le")
    ) {
      if (z.length < 2 || U.length < 2) return -1;
      (ie = 2), (le /= 2), (nt /= 2), (L /= 2);
    }
    function Ee(ft, xe) {
      return ie === 1 ? ft[xe] : ft.readUInt16BE(xe * ie);
    }
    let we;
    if (fe) {
      let ft = -1;
      for (we = L; we < le; we++)
        if (Ee(z, we) === Ee(U, ft === -1 ? 0 : we - ft)) {
          if ((ft === -1 && (ft = we), we - ft + 1 === nt)) return ft * ie;
        } else ft !== -1 && (we -= we - ft), (ft = -1);
    } else
      for (L + nt > le && (L = le - nt), we = L; we >= 0; we--) {
        let ft = !0;
        for (let xe = 0; xe < nt; xe++)
          if (Ee(z, we + xe) !== Ee(U, xe)) {
            ft = !1;
            break;
          }
        if (ft) return we;
      }
    return -1;
  }
  (o.prototype.includes = function (U, L, J) {
    return this.indexOf(U, L, J) !== -1;
  }),
    (o.prototype.indexOf = function (U, L, J) {
      return F(this, U, L, J, !0);
    }),
    (o.prototype.lastIndexOf = function (U, L, J) {
      return F(this, U, L, J, !1);
    });
  function j(z, U, L, J) {
    L = Number(L) || 0;
    const fe = z.length - L;
    J ? ((J = Number(J)), J > fe && (J = fe)) : (J = fe);
    const ie = U.length;
    J > ie / 2 && (J = ie / 2);
    let le;
    for (le = 0; le < J; ++le) {
      const nt = parseInt(U.substr(le * 2, 2), 16);
      if (me(nt)) return le;
      z[L + le] = nt;
    }
    return le;
  }
  function X(z, U, L, J) {
    return ce($(U, z.length - L), z, L, J);
  }
  function C(z, U, L, J) {
    return ce(W(U), z, L, J);
  }
  function l(z, U, L, J) {
    return ce(ee(U), z, L, J);
  }
  function p(z, U, L, J) {
    return ce(re(U, z.length - L), z, L, J);
  }
  (o.prototype.write = function (U, L, J, fe) {
    if (L === void 0) (fe = "utf8"), (J = this.length), (L = 0);
    else if (J === void 0 && typeof L == "string")
      (fe = L), (J = this.length), (L = 0);
    else if (isFinite(L))
      (L = L >>> 0),
        isFinite(J)
          ? ((J = J >>> 0), fe === void 0 && (fe = "utf8"))
          : ((fe = J), (J = void 0));
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const ie = this.length - L;
    if (
      ((J === void 0 || J > ie) && (J = ie),
      (U.length > 0 && (J < 0 || L < 0)) || L > this.length)
    )
      throw new RangeError("Attempt to write outside buffer bounds");
    fe || (fe = "utf8");
    let le = !1;
    for (;;)
      switch (fe) {
        case "hex":
          return j(this, U, L, J);
        case "utf8":
        case "utf-8":
          return X(this, U, L, J);
        case "ascii":
        case "latin1":
        case "binary":
          return C(this, U, L, J);
        case "base64":
          return l(this, U, L, J);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return p(this, U, L, J);
        default:
          if (le) throw new TypeError("Unknown encoding: " + fe);
          (fe = ("" + fe).toLowerCase()), (le = !0);
      }
  }),
    (o.prototype.toJSON = function () {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0),
      };
    });
  function y(z, U, L) {
    return U === 0 && L === z.length
      ? e.fromByteArray(z)
      : e.fromByteArray(z.slice(U, L));
  }
  function h(z, U, L) {
    L = Math.min(z.length, L);
    const J = [];
    let fe = U;
    for (; fe < L; ) {
      const ie = z[fe];
      let le = null,
        nt = ie > 239 ? 4 : ie > 223 ? 3 : ie > 191 ? 2 : 1;
      if (fe + nt <= L) {
        let Ee, we, ft, xe;
        switch (nt) {
          case 1:
            ie < 128 && (le = ie);
            break;
          case 2:
            (Ee = z[fe + 1]),
              (Ee & 192) === 128 &&
                ((xe = ((ie & 31) << 6) | (Ee & 63)), xe > 127 && (le = xe));
            break;
          case 3:
            (Ee = z[fe + 1]),
              (we = z[fe + 2]),
              (Ee & 192) === 128 &&
                (we & 192) === 128 &&
                ((xe = ((ie & 15) << 12) | ((Ee & 63) << 6) | (we & 63)),
                xe > 2047 && (xe < 55296 || xe > 57343) && (le = xe));
            break;
          case 4:
            (Ee = z[fe + 1]),
              (we = z[fe + 2]),
              (ft = z[fe + 3]),
              (Ee & 192) === 128 &&
                (we & 192) === 128 &&
                (ft & 192) === 128 &&
                ((xe =
                  ((ie & 15) << 18) |
                  ((Ee & 63) << 12) |
                  ((we & 63) << 6) |
                  (ft & 63)),
                xe > 65535 && xe < 1114112 && (le = xe));
        }
      }
      le === null
        ? ((le = 65533), (nt = 1))
        : le > 65535 &&
          ((le -= 65536),
          J.push(((le >>> 10) & 1023) | 55296),
          (le = 56320 | (le & 1023))),
        J.push(le),
        (fe += nt);
    }
    return T(J);
  }
  const g = 4096;
  function T(z) {
    const U = z.length;
    if (U <= g) return String.fromCharCode.apply(String, z);
    let L = "",
      J = 0;
    for (; J < U; )
      L += String.fromCharCode.apply(String, z.slice(J, (J += g)));
    return L;
  }
  function R(z, U, L) {
    let J = "";
    L = Math.min(z.length, L);
    for (let fe = U; fe < L; ++fe) J += String.fromCharCode(z[fe] & 127);
    return J;
  }
  function x(z, U, L) {
    let J = "";
    L = Math.min(z.length, L);
    for (let fe = U; fe < L; ++fe) J += String.fromCharCode(z[fe]);
    return J;
  }
  function f(z, U, L) {
    const J = z.length;
    (!U || U < 0) && (U = 0), (!L || L < 0 || L > J) && (L = J);
    let fe = "";
    for (let ie = U; ie < L; ++ie) fe += ge[z[ie]];
    return fe;
  }
  function _(z, U, L) {
    const J = z.slice(U, L);
    let fe = "";
    for (let ie = 0; ie < J.length - 1; ie += 2)
      fe += String.fromCharCode(J[ie] + J[ie + 1] * 256);
    return fe;
  }
  o.prototype.slice = function (U, L) {
    const J = this.length;
    (U = ~~U),
      (L = L === void 0 ? J : ~~L),
      U < 0 ? ((U += J), U < 0 && (U = 0)) : U > J && (U = J),
      L < 0 ? ((L += J), L < 0 && (L = 0)) : L > J && (L = J),
      L < U && (L = U);
    const fe = this.subarray(U, L);
    return Object.setPrototypeOf(fe, o.prototype), fe;
  };
  function P(z, U, L) {
    if (z % 1 !== 0 || z < 0) throw new RangeError("offset is not uint");
    if (z + U > L)
      throw new RangeError("Trying to access beyond buffer length");
  }
  (o.prototype.readUintLE = o.prototype.readUIntLE =
    function (U, L, J) {
      (U = U >>> 0), (L = L >>> 0), J || P(U, L, this.length);
      let fe = this[U],
        ie = 1,
        le = 0;
      for (; ++le < L && (ie *= 256); ) fe += this[U + le] * ie;
      return fe;
    }),
    (o.prototype.readUintBE = o.prototype.readUIntBE =
      function (U, L, J) {
        (U = U >>> 0), (L = L >>> 0), J || P(U, L, this.length);
        let fe = this[U + --L],
          ie = 1;
        for (; L > 0 && (ie *= 256); ) fe += this[U + --L] * ie;
        return fe;
      }),
    (o.prototype.readUint8 = o.prototype.readUInt8 =
      function (U, L) {
        return (U = U >>> 0), L || P(U, 1, this.length), this[U];
      }),
    (o.prototype.readUint16LE = o.prototype.readUInt16LE =
      function (U, L) {
        return (
          (U = U >>> 0), L || P(U, 2, this.length), this[U] | (this[U + 1] << 8)
        );
      }),
    (o.prototype.readUint16BE = o.prototype.readUInt16BE =
      function (U, L) {
        return (
          (U = U >>> 0), L || P(U, 2, this.length), (this[U] << 8) | this[U + 1]
        );
      }),
    (o.prototype.readUint32LE = o.prototype.readUInt32LE =
      function (U, L) {
        return (
          (U = U >>> 0),
          L || P(U, 4, this.length),
          (this[U] | (this[U + 1] << 8) | (this[U + 2] << 16)) +
            this[U + 3] * 16777216
        );
      }),
    (o.prototype.readUint32BE = o.prototype.readUInt32BE =
      function (U, L) {
        return (
          (U = U >>> 0),
          L || P(U, 4, this.length),
          this[U] * 16777216 +
            ((this[U + 1] << 16) | (this[U + 2] << 8) | this[U + 3])
        );
      }),
    (o.prototype.readBigUInt64LE = it(function (U) {
      (U = U >>> 0), he(U, "offset");
      const L = this[U],
        J = this[U + 7];
      (L === void 0 || J === void 0) && se(U, this.length - 8);
      const fe =
          L + this[++U] * 2 ** 8 + this[++U] * 2 ** 16 + this[++U] * 2 ** 24,
        ie = this[++U] + this[++U] * 2 ** 8 + this[++U] * 2 ** 16 + J * 2 ** 24;
      return BigInt(fe) + (BigInt(ie) << BigInt(32));
    })),
    (o.prototype.readBigUInt64BE = it(function (U) {
      (U = U >>> 0), he(U, "offset");
      const L = this[U],
        J = this[U + 7];
      (L === void 0 || J === void 0) && se(U, this.length - 8);
      const fe =
          L * 2 ** 24 + this[++U] * 2 ** 16 + this[++U] * 2 ** 8 + this[++U],
        ie = this[++U] * 2 ** 24 + this[++U] * 2 ** 16 + this[++U] * 2 ** 8 + J;
      return (BigInt(fe) << BigInt(32)) + BigInt(ie);
    })),
    (o.prototype.readIntLE = function (U, L, J) {
      (U = U >>> 0), (L = L >>> 0), J || P(U, L, this.length);
      let fe = this[U],
        ie = 1,
        le = 0;
      for (; ++le < L && (ie *= 256); ) fe += this[U + le] * ie;
      return (ie *= 128), fe >= ie && (fe -= Math.pow(2, 8 * L)), fe;
    }),
    (o.prototype.readIntBE = function (U, L, J) {
      (U = U >>> 0), (L = L >>> 0), J || P(U, L, this.length);
      let fe = L,
        ie = 1,
        le = this[U + --fe];
      for (; fe > 0 && (ie *= 256); ) le += this[U + --fe] * ie;
      return (ie *= 128), le >= ie && (le -= Math.pow(2, 8 * L)), le;
    }),
    (o.prototype.readInt8 = function (U, L) {
      return (
        (U = U >>> 0),
        L || P(U, 1, this.length),
        this[U] & 128 ? (255 - this[U] + 1) * -1 : this[U]
      );
    }),
    (o.prototype.readInt16LE = function (U, L) {
      (U = U >>> 0), L || P(U, 2, this.length);
      const J = this[U] | (this[U + 1] << 8);
      return J & 32768 ? J | 4294901760 : J;
    }),
    (o.prototype.readInt16BE = function (U, L) {
      (U = U >>> 0), L || P(U, 2, this.length);
      const J = this[U + 1] | (this[U] << 8);
      return J & 32768 ? J | 4294901760 : J;
    }),
    (o.prototype.readInt32LE = function (U, L) {
      return (
        (U = U >>> 0),
        L || P(U, 4, this.length),
        this[U] | (this[U + 1] << 8) | (this[U + 2] << 16) | (this[U + 3] << 24)
      );
    }),
    (o.prototype.readInt32BE = function (U, L) {
      return (
        (U = U >>> 0),
        L || P(U, 4, this.length),
        (this[U] << 24) | (this[U + 1] << 16) | (this[U + 2] << 8) | this[U + 3]
      );
    }),
    (o.prototype.readBigInt64LE = it(function (U) {
      (U = U >>> 0), he(U, "offset");
      const L = this[U],
        J = this[U + 7];
      (L === void 0 || J === void 0) && se(U, this.length - 8);
      const fe =
        this[U + 4] + this[U + 5] * 2 ** 8 + this[U + 6] * 2 ** 16 + (J << 24);
      return (
        (BigInt(fe) << BigInt(32)) +
        BigInt(
          L + this[++U] * 2 ** 8 + this[++U] * 2 ** 16 + this[++U] * 2 ** 24
        )
      );
    })),
    (o.prototype.readBigInt64BE = it(function (U) {
      (U = U >>> 0), he(U, "offset");
      const L = this[U],
        J = this[U + 7];
      (L === void 0 || J === void 0) && se(U, this.length - 8);
      const fe =
        (L << 24) + this[++U] * 2 ** 16 + this[++U] * 2 ** 8 + this[++U];
      return (
        (BigInt(fe) << BigInt(32)) +
        BigInt(
          this[++U] * 2 ** 24 + this[++U] * 2 ** 16 + this[++U] * 2 ** 8 + J
        )
      );
    })),
    (o.prototype.readFloatLE = function (U, L) {
      return (
        (U = U >>> 0), L || P(U, 4, this.length), r.read(this, U, !0, 23, 4)
      );
    }),
    (o.prototype.readFloatBE = function (U, L) {
      return (
        (U = U >>> 0), L || P(U, 4, this.length), r.read(this, U, !1, 23, 4)
      );
    }),
    (o.prototype.readDoubleLE = function (U, L) {
      return (
        (U = U >>> 0), L || P(U, 8, this.length), r.read(this, U, !0, 52, 8)
      );
    }),
    (o.prototype.readDoubleBE = function (U, L) {
      return (
        (U = U >>> 0), L || P(U, 8, this.length), r.read(this, U, !1, 52, 8)
      );
    });
  function M(z, U, L, J, fe, ie) {
    if (!o.isBuffer(z))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (U > fe || U < ie)
      throw new RangeError('"value" argument is out of bounds');
    if (L + J > z.length) throw new RangeError("Index out of range");
  }
  (o.prototype.writeUintLE = o.prototype.writeUIntLE =
    function (U, L, J, fe) {
      if (((U = +U), (L = L >>> 0), (J = J >>> 0), !fe)) {
        const nt = Math.pow(2, 8 * J) - 1;
        M(this, U, L, J, nt, 0);
      }
      let ie = 1,
        le = 0;
      for (this[L] = U & 255; ++le < J && (ie *= 256); )
        this[L + le] = (U / ie) & 255;
      return L + J;
    }),
    (o.prototype.writeUintBE = o.prototype.writeUIntBE =
      function (U, L, J, fe) {
        if (((U = +U), (L = L >>> 0), (J = J >>> 0), !fe)) {
          const nt = Math.pow(2, 8 * J) - 1;
          M(this, U, L, J, nt, 0);
        }
        let ie = J - 1,
          le = 1;
        for (this[L + ie] = U & 255; --ie >= 0 && (le *= 256); )
          this[L + ie] = (U / le) & 255;
        return L + J;
      }),
    (o.prototype.writeUint8 = o.prototype.writeUInt8 =
      function (U, L, J) {
        return (
          (U = +U),
          (L = L >>> 0),
          J || M(this, U, L, 1, 255, 0),
          (this[L] = U & 255),
          L + 1
        );
      }),
    (o.prototype.writeUint16LE = o.prototype.writeUInt16LE =
      function (U, L, J) {
        return (
          (U = +U),
          (L = L >>> 0),
          J || M(this, U, L, 2, 65535, 0),
          (this[L] = U & 255),
          (this[L + 1] = U >>> 8),
          L + 2
        );
      }),
    (o.prototype.writeUint16BE = o.prototype.writeUInt16BE =
      function (U, L, J) {
        return (
          (U = +U),
          (L = L >>> 0),
          J || M(this, U, L, 2, 65535, 0),
          (this[L] = U >>> 8),
          (this[L + 1] = U & 255),
          L + 2
        );
      }),
    (o.prototype.writeUint32LE = o.prototype.writeUInt32LE =
      function (U, L, J) {
        return (
          (U = +U),
          (L = L >>> 0),
          J || M(this, U, L, 4, 4294967295, 0),
          (this[L + 3] = U >>> 24),
          (this[L + 2] = U >>> 16),
          (this[L + 1] = U >>> 8),
          (this[L] = U & 255),
          L + 4
        );
      }),
    (o.prototype.writeUint32BE = o.prototype.writeUInt32BE =
      function (U, L, J) {
        return (
          (U = +U),
          (L = L >>> 0),
          J || M(this, U, L, 4, 4294967295, 0),
          (this[L] = U >>> 24),
          (this[L + 1] = U >>> 16),
          (this[L + 2] = U >>> 8),
          (this[L + 3] = U & 255),
          L + 4
        );
      });
  function D(z, U, L, J, fe) {
    G(U, J, fe, z, L, 7);
    let ie = Number(U & BigInt(4294967295));
    (z[L++] = ie),
      (ie = ie >> 8),
      (z[L++] = ie),
      (ie = ie >> 8),
      (z[L++] = ie),
      (ie = ie >> 8),
      (z[L++] = ie);
    let le = Number((U >> BigInt(32)) & BigInt(4294967295));
    return (
      (z[L++] = le),
      (le = le >> 8),
      (z[L++] = le),
      (le = le >> 8),
      (z[L++] = le),
      (le = le >> 8),
      (z[L++] = le),
      L
    );
  }
  function q(z, U, L, J, fe) {
    G(U, J, fe, z, L, 7);
    let ie = Number(U & BigInt(4294967295));
    (z[L + 7] = ie),
      (ie = ie >> 8),
      (z[L + 6] = ie),
      (ie = ie >> 8),
      (z[L + 5] = ie),
      (ie = ie >> 8),
      (z[L + 4] = ie);
    let le = Number((U >> BigInt(32)) & BigInt(4294967295));
    return (
      (z[L + 3] = le),
      (le = le >> 8),
      (z[L + 2] = le),
      (le = le >> 8),
      (z[L + 1] = le),
      (le = le >> 8),
      (z[L] = le),
      L + 8
    );
  }
  (o.prototype.writeBigUInt64LE = it(function (U, L = 0) {
    return D(this, U, L, BigInt(0), BigInt("0xffffffffffffffff"));
  })),
    (o.prototype.writeBigUInt64BE = it(function (U, L = 0) {
      return q(this, U, L, BigInt(0), BigInt("0xffffffffffffffff"));
    })),
    (o.prototype.writeIntLE = function (U, L, J, fe) {
      if (((U = +U), (L = L >>> 0), !fe)) {
        const Ee = Math.pow(2, 8 * J - 1);
        M(this, U, L, J, Ee - 1, -Ee);
      }
      let ie = 0,
        le = 1,
        nt = 0;
      for (this[L] = U & 255; ++ie < J && (le *= 256); )
        U < 0 && nt === 0 && this[L + ie - 1] !== 0 && (nt = 1),
          (this[L + ie] = (((U / le) >> 0) - nt) & 255);
      return L + J;
    }),
    (o.prototype.writeIntBE = function (U, L, J, fe) {
      if (((U = +U), (L = L >>> 0), !fe)) {
        const Ee = Math.pow(2, 8 * J - 1);
        M(this, U, L, J, Ee - 1, -Ee);
      }
      let ie = J - 1,
        le = 1,
        nt = 0;
      for (this[L + ie] = U & 255; --ie >= 0 && (le *= 256); )
        U < 0 && nt === 0 && this[L + ie + 1] !== 0 && (nt = 1),
          (this[L + ie] = (((U / le) >> 0) - nt) & 255);
      return L + J;
    }),
    (o.prototype.writeInt8 = function (U, L, J) {
      return (
        (U = +U),
        (L = L >>> 0),
        J || M(this, U, L, 1, 127, -128),
        U < 0 && (U = 255 + U + 1),
        (this[L] = U & 255),
        L + 1
      );
    }),
    (o.prototype.writeInt16LE = function (U, L, J) {
      return (
        (U = +U),
        (L = L >>> 0),
        J || M(this, U, L, 2, 32767, -32768),
        (this[L] = U & 255),
        (this[L + 1] = U >>> 8),
        L + 2
      );
    }),
    (o.prototype.writeInt16BE = function (U, L, J) {
      return (
        (U = +U),
        (L = L >>> 0),
        J || M(this, U, L, 2, 32767, -32768),
        (this[L] = U >>> 8),
        (this[L + 1] = U & 255),
        L + 2
      );
    }),
    (o.prototype.writeInt32LE = function (U, L, J) {
      return (
        (U = +U),
        (L = L >>> 0),
        J || M(this, U, L, 4, 2147483647, -2147483648),
        (this[L] = U & 255),
        (this[L + 1] = U >>> 8),
        (this[L + 2] = U >>> 16),
        (this[L + 3] = U >>> 24),
        L + 4
      );
    }),
    (o.prototype.writeInt32BE = function (U, L, J) {
      return (
        (U = +U),
        (L = L >>> 0),
        J || M(this, U, L, 4, 2147483647, -2147483648),
        U < 0 && (U = 4294967295 + U + 1),
        (this[L] = U >>> 24),
        (this[L + 1] = U >>> 16),
        (this[L + 2] = U >>> 8),
        (this[L + 3] = U & 255),
        L + 4
      );
    }),
    (o.prototype.writeBigInt64LE = it(function (U, L = 0) {
      return D(
        this,
        U,
        L,
        -BigInt("0x8000000000000000"),
        BigInt("0x7fffffffffffffff")
      );
    })),
    (o.prototype.writeBigInt64BE = it(function (U, L = 0) {
      return q(
        this,
        U,
        L,
        -BigInt("0x8000000000000000"),
        BigInt("0x7fffffffffffffff")
      );
    }));
  function B(z, U, L, J, fe, ie) {
    if (L + J > z.length) throw new RangeError("Index out of range");
    if (L < 0) throw new RangeError("Index out of range");
  }
  function H(z, U, L, J, fe) {
    return (
      (U = +U),
      (L = L >>> 0),
      fe || B(z, U, L, 4),
      r.write(z, U, L, J, 23, 4),
      L + 4
    );
  }
  (o.prototype.writeFloatLE = function (U, L, J) {
    return H(this, U, L, !0, J);
  }),
    (o.prototype.writeFloatBE = function (U, L, J) {
      return H(this, U, L, !1, J);
    });
  function Q(z, U, L, J, fe) {
    return (
      (U = +U),
      (L = L >>> 0),
      fe || B(z, U, L, 8),
      r.write(z, U, L, J, 52, 8),
      L + 8
    );
  }
  (o.prototype.writeDoubleLE = function (U, L, J) {
    return Q(this, U, L, !0, J);
  }),
    (o.prototype.writeDoubleBE = function (U, L, J) {
      return Q(this, U, L, !1, J);
    }),
    (o.prototype.copy = function (U, L, J, fe) {
      if (!o.isBuffer(U)) throw new TypeError("argument should be a Buffer");
      if (
        (J || (J = 0),
        !fe && fe !== 0 && (fe = this.length),
        L >= U.length && (L = U.length),
        L || (L = 0),
        fe > 0 && fe < J && (fe = J),
        fe === J || U.length === 0 || this.length === 0)
      )
        return 0;
      if (L < 0) throw new RangeError("targetStart out of bounds");
      if (J < 0 || J >= this.length) throw new RangeError("Index out of range");
      if (fe < 0) throw new RangeError("sourceEnd out of bounds");
      fe > this.length && (fe = this.length),
        U.length - L < fe - J && (fe = U.length - L + J);
      const ie = fe - J;
      return (
        this === U && typeof Uint8Array.prototype.copyWithin == "function"
          ? this.copyWithin(L, J, fe)
          : Uint8Array.prototype.set.call(U, this.subarray(J, fe), L),
        ie
      );
    }),
    (o.prototype.fill = function (U, L, J, fe) {
      if (typeof U == "string") {
        if (
          (typeof L == "string"
            ? ((fe = L), (L = 0), (J = this.length))
            : typeof J == "string" && ((fe = J), (J = this.length)),
          fe !== void 0 && typeof fe != "string")
        )
          throw new TypeError("encoding must be a string");
        if (typeof fe == "string" && !o.isEncoding(fe))
          throw new TypeError("Unknown encoding: " + fe);
        if (U.length === 1) {
          const le = U.charCodeAt(0);
          ((fe === "utf8" && le < 128) || fe === "latin1") && (U = le);
        }
      } else
        typeof U == "number"
          ? (U = U & 255)
          : typeof U == "boolean" && (U = Number(U));
      if (L < 0 || this.length < L || this.length < J)
        throw new RangeError("Out of range index");
      if (J <= L) return this;
      (L = L >>> 0), (J = J === void 0 ? this.length : J >>> 0), U || (U = 0);
      let ie;
      if (typeof U == "number") for (ie = L; ie < J; ++ie) this[ie] = U;
      else {
        const le = o.isBuffer(U) ? U : o.from(U, fe),
          nt = le.length;
        if (nt === 0)
          throw new TypeError(
            'The value "' + U + '" is invalid for argument "value"'
          );
        for (ie = 0; ie < J - L; ++ie) this[ie + L] = le[ie % nt];
      }
      return this;
    });
  const Z = {};
  function te(z, U, L) {
    Z[z] = class extends L {
      constructor() {
        super(),
          Object.defineProperty(this, "message", {
            value: U.apply(this, arguments),
            writable: !0,
            configurable: !0,
          }),
          (this.name = `${this.name} [${z}]`),
          this.stack,
          delete this.name;
      }
      get code() {
        return z;
      }
      set code(fe) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: fe,
          writable: !0,
        });
      }
      toString() {
        return `${this.name} [${z}]: ${this.message}`;
      }
    };
  }
  te(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function (z) {
      return z
        ? `${z} is outside of buffer bounds`
        : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ),
    te(
      "ERR_INVALID_ARG_TYPE",
      function (z, U) {
        return `The "${z}" argument must be of type number. Received type ${typeof U}`;
      },
      TypeError
    ),
    te(
      "ERR_OUT_OF_RANGE",
      function (z, U, L) {
        let J = `The value of "${z}" is out of range.`,
          fe = L;
        return (
          Number.isInteger(L) && Math.abs(L) > 2 ** 32
            ? (fe = Te(String(L)))
            : typeof L == "bigint" &&
              ((fe = String(L)),
              (L > BigInt(2) ** BigInt(32) || L < -(BigInt(2) ** BigInt(32))) &&
                (fe = Te(fe)),
              (fe += "n")),
          (J += ` It must be ${U}. Received ${fe}`),
          J
        );
      },
      RangeError
    );
  function Te(z) {
    let U = "",
      L = z.length;
    const J = z[0] === "-" ? 1 : 0;
    for (; L >= J + 4; L -= 3) U = `_${z.slice(L - 3, L)}${U}`;
    return `${z.slice(0, L)}${U}`;
  }
  function K(z, U, L) {
    he(U, "offset"),
      (z[U] === void 0 || z[U + L] === void 0) && se(U, z.length - (L + 1));
  }
  function G(z, U, L, J, fe, ie) {
    if (z > L || z < U) {
      const le = typeof U == "bigint" ? "n" : "";
      let nt;
      throw (
        (U === 0 || U === BigInt(0)
          ? (nt = `>= 0${le} and < 2${le} ** ${(ie + 1) * 8}${le}`)
          : (nt = `>= -(2${le} ** ${(ie + 1) * 8 - 1}${le}) and < 2 ** ${
              (ie + 1) * 8 - 1
            }${le}`),
        new Z.ERR_OUT_OF_RANGE("value", nt, z))
      );
    }
    K(J, fe, ie);
  }
  function he(z, U) {
    if (typeof z != "number") throw new Z.ERR_INVALID_ARG_TYPE(U, "number", z);
  }
  function se(z, U, L) {
    throw Math.floor(z) !== z
      ? (he(z, L), new Z.ERR_OUT_OF_RANGE("offset", "an integer", z))
      : U < 0
      ? new Z.ERR_BUFFER_OUT_OF_BOUNDS()
      : new Z.ERR_OUT_OF_RANGE("offset", `>= 0 and <= ${U}`, z);
  }
  const pe = /[^+/0-9A-Za-z-_]/g;
  function Y(z) {
    if (((z = z.split("=")[0]), (z = z.trim().replace(pe, "")), z.length < 2))
      return "";
    for (; z.length % 4 !== 0; ) z = z + "=";
    return z;
  }
  function $(z, U) {
    U = U || 1 / 0;
    let L;
    const J = z.length;
    let fe = null;
    const ie = [];
    for (let le = 0; le < J; ++le) {
      if (((L = z.charCodeAt(le)), L > 55295 && L < 57344)) {
        if (!fe) {
          if (L > 56319) {
            (U -= 3) > -1 && ie.push(239, 191, 189);
            continue;
          } else if (le + 1 === J) {
            (U -= 3) > -1 && ie.push(239, 191, 189);
            continue;
          }
          fe = L;
          continue;
        }
        if (L < 56320) {
          (U -= 3) > -1 && ie.push(239, 191, 189), (fe = L);
          continue;
        }
        L = (((fe - 55296) << 10) | (L - 56320)) + 65536;
      } else fe && (U -= 3) > -1 && ie.push(239, 191, 189);
      if (((fe = null), L < 128)) {
        if ((U -= 1) < 0) break;
        ie.push(L);
      } else if (L < 2048) {
        if ((U -= 2) < 0) break;
        ie.push((L >> 6) | 192, (L & 63) | 128);
      } else if (L < 65536) {
        if ((U -= 3) < 0) break;
        ie.push((L >> 12) | 224, ((L >> 6) & 63) | 128, (L & 63) | 128);
      } else if (L < 1114112) {
        if ((U -= 4) < 0) break;
        ie.push(
          (L >> 18) | 240,
          ((L >> 12) & 63) | 128,
          ((L >> 6) & 63) | 128,
          (L & 63) | 128
        );
      } else throw new Error("Invalid code point");
    }
    return ie;
  }
  function W(z) {
    const U = [];
    for (let L = 0; L < z.length; ++L) U.push(z.charCodeAt(L) & 255);
    return U;
  }
  function re(z, U) {
    let L, J, fe;
    const ie = [];
    for (let le = 0; le < z.length && !((U -= 2) < 0); ++le)
      (L = z.charCodeAt(le)),
        (J = L >> 8),
        (fe = L % 256),
        ie.push(fe),
        ie.push(J);
    return ie;
  }
  function ee(z) {
    return e.toByteArray(Y(z));
  }
  function ce(z, U, L, J) {
    let fe;
    for (fe = 0; fe < J && !(fe + L >= U.length || fe >= z.length); ++fe)
      U[fe + L] = z[fe];
    return fe;
  }
  function Ce(z, U) {
    return (
      z instanceof U ||
      (z != null &&
        z.constructor != null &&
        z.constructor.name != null &&
        z.constructor.name === U.name)
    );
  }
  function me(z) {
    return z !== z;
  }
  const ge = (function () {
    const z = "0123456789abcdef",
      U = new Array(256);
    for (let L = 0; L < 16; ++L) {
      const J = L * 16;
      for (let fe = 0; fe < 16; ++fe) U[J + fe] = z[L] + z[fe];
    }
    return U;
  })();
  function it(z) {
    return typeof BigInt > "u" ? ve : z;
  }
  function ve() {
    throw new Error("BigInt not supported");
  }
})(vo);
var Woe = function (e) {
    for (
      var r = new Buffer(e.length), n = 0, i = e.length - 1;
      n <= i;
      ++n, --i
    )
      (r[n] = e[i]), (r[i] = e[n]);
    return r;
  },
  nF = {
    exports: {},
  },
  d3 = {
    exports: {},
  },
  $S;
function Vt() {
  return (
    $S ||
      (($S = 1),
      (function (t, e) {
        (function (r, n) {
          t.exports = n();
        })(ke, function () {
          var r =
            r ||
            (function (n, i) {
              var a =
                  Object.create ||
                  (function () {
                    function b() {}
                    return function (w) {
                      var S;
                      return (
                        (b.prototype = w),
                        (S = new b()),
                        (b.prototype = null),
                        S
                      );
                    };
                  })(),
                s = {},
                o = (s.lib = {}),
                c = (o.Base = (function () {
                  return {
                    extend: function (b) {
                      var w = a(this);
                      return (
                        b && w.mixIn(b),
                        (!w.hasOwnProperty("init") || this.init === w.init) &&
                          (w.init = function () {
                            w.$super.init.apply(this, arguments);
                          }),
                        (w.init.prototype = w),
                        (w.$super = this),
                        w
                      );
                    },
                    create: function () {
                      var b = this.extend();
                      return b.init.apply(b, arguments), b;
                    },
                    init: function () {},
                    mixIn: function (b) {
                      for (var w in b) b.hasOwnProperty(w) && (this[w] = b[w]);
                      b.hasOwnProperty("toString") &&
                        (this.toString = b.toString);
                    },
                    clone: function () {
                      return this.init.prototype.extend(this);
                    },
                  };
                })()),
                u = (o.WordArray = c.extend({
                  init: function (b, w) {
                    (b = this.words = b || []),
                      w != i
                        ? (this.sigBytes = w)
                        : (this.sigBytes = b.length * 4);
                  },
                  toString: function (b) {
                    return (b || m).stringify(this);
                  },
                  concat: function (b) {
                    var w = this.words,
                      S = b.words,
                      k = this.sigBytes,
                      N = b.sigBytes;
                    if ((this.clamp(), k % 4))
                      for (var O = 0; O < N; O++) {
                        var F = (S[O >>> 2] >>> (24 - (O % 4) * 8)) & 255;
                        w[(k + O) >>> 2] |= F << (24 - ((k + O) % 4) * 8);
                      }
                    else
                      for (var O = 0; O < N; O += 4)
                        w[(k + O) >>> 2] = S[O >>> 2];
                    return (this.sigBytes += N), this;
                  },
                  clamp: function () {
                    var b = this.words,
                      w = this.sigBytes;
                    (b[w >>> 2] &= 4294967295 << (32 - (w % 4) * 8)),
                      (b.length = n.ceil(w / 4));
                  },
                  clone: function () {
                    var b = c.clone.call(this);
                    return (b.words = this.words.slice(0)), b;
                  },
                  random: function (b) {
                    for (
                      var w = [],
                        S = function (V) {
                          var V = V,
                            j = 987654321,
                            X = 4294967295;
                          return function () {
                            (j = (36969 * (j & 65535) + (j >> 16)) & X),
                              (V = (18e3 * (V & 65535) + (V >> 16)) & X);
                            var C = ((j << 16) + V) & X;
                            return (
                              (C /= 4294967296),
                              (C += 0.5),
                              C * (n.random() > 0.5 ? 1 : -1)
                            );
                          };
                        },
                        k = 0,
                        N;
                      k < b;
                      k += 4
                    ) {
                      var O = S((N || n.random()) * 4294967296);
                      (N = O() * 987654071), w.push((O() * 4294967296) | 0);
                    }
                    return new u.init(w, b);
                  },
                })),
                d = (s.enc = {}),
                m = (d.Hex = {
                  stringify: function (b) {
                    for (
                      var w = b.words, S = b.sigBytes, k = [], N = 0;
                      N < S;
                      N++
                    ) {
                      var O = (w[N >>> 2] >>> (24 - (N % 4) * 8)) & 255;
                      k.push((O >>> 4).toString(16)),
                        k.push((O & 15).toString(16));
                    }
                    return k.join("");
                  },
                  parse: function (b) {
                    for (var w = b.length, S = [], k = 0; k < w; k += 2)
                      S[k >>> 3] |=
                        parseInt(b.substr(k, 2), 16) << (24 - (k % 8) * 4);
                    return new u.init(S, w / 2);
                  },
                }),
                v = (d.Latin1 = {
                  stringify: function (b) {
                    for (
                      var w = b.words, S = b.sigBytes, k = [], N = 0;
                      N < S;
                      N++
                    ) {
                      var O = (w[N >>> 2] >>> (24 - (N % 4) * 8)) & 255;
                      k.push(String.fromCharCode(O));
                    }
                    return k.join("");
                  },
                  parse: function (b) {
                    for (var w = b.length, S = [], k = 0; k < w; k++)
                      S[k >>> 2] |=
                        (b.charCodeAt(k) & 255) << (24 - (k % 4) * 8);
                    return new u.init(S, w);
                  },
                }),
                E = (d.Utf8 = {
                  stringify: function (b) {
                    try {
                      return decodeURIComponent(escape(v.stringify(b)));
                    } catch {
                      throw new Error("Malformed UTF-8 data");
                    }
                  },
                  parse: function (b) {
                    return v.parse(unescape(encodeURIComponent(b)));
                  },
                }),
                A = (o.BufferedBlockAlgorithm = c.extend({
                  reset: function () {
                    (this._data = new u.init()), (this._nDataBytes = 0);
                  },
                  _append: function (b) {
                    typeof b == "string" && (b = E.parse(b)),
                      this._data.concat(b),
                      (this._nDataBytes += b.sigBytes);
                  },
                  _process: function (b) {
                    var w = this._data,
                      S = w.words,
                      k = w.sigBytes,
                      N = this.blockSize,
                      O = N * 4,
                      F = k / O;
                    b
                      ? (F = n.ceil(F))
                      : (F = n.max((F | 0) - this._minBufferSize, 0));
                    var V = F * N,
                      j = n.min(V * 4, k);
                    if (V) {
                      for (var X = 0; X < V; X += N) this._doProcessBlock(S, X);
                      var C = S.splice(0, V);
                      w.sigBytes -= j;
                    }
                    return new u.init(C, j);
                  },
                  clone: function () {
                    var b = c.clone.call(this);
                    return (b._data = this._data.clone()), b;
                  },
                  _minBufferSize: 0,
                }));
              o.Hasher = A.extend({
                cfg: c.extend(),
                init: function (b) {
                  (this.cfg = this.cfg.extend(b)), this.reset();
                },
                reset: function () {
                  A.reset.call(this), this._doReset();
                },
                update: function (b) {
                  return this._append(b), this._process(), this;
                },
                finalize: function (b) {
                  b && this._append(b);
                  var w = this._doFinalize();
                  return w;
                },
                blockSize: 16,
                _createHelper: function (b) {
                  return function (w, S) {
                    return new b.init(S).finalize(w);
                  };
                },
                _createHmacHelper: function (b) {
                  return function (w, S) {
                    return new I.HMAC.init(b, S).finalize(w);
                  };
                },
              });
              var I = (s.algo = {});
              return s;
            })(Math);
          return r;
        });
      })(d3)),
    d3.exports
  );
}
(function (t, e) {
  (function (r, n) {
    t.exports = n(Vt());
  })(ke, function (r) {
    return (
      (function (n) {
        var i = r,
          a = i.lib,
          s = a.WordArray,
          o = a.Hasher,
          c = i.algo,
          u = [],
          d = [];
        (function () {
          function E(w) {
            for (var S = n.sqrt(w), k = 2; k <= S; k++) if (!(w % k)) return !1;
            return !0;
          }
          function A(w) {
            return ((w - (w | 0)) * 4294967296) | 0;
          }
          for (var I = 2, b = 0; b < 64; )
            E(I) &&
              (b < 8 && (u[b] = A(n.pow(I, 1 / 2))),
              (d[b] = A(n.pow(I, 1 / 3))),
              b++),
              I++;
        })();
        var m = [],
          v = (c.SHA256 = o.extend({
            _doReset: function () {
              this._hash = new s.init(u.slice(0));
            },
            _doProcessBlock: function (E, A) {
              for (
                var I = this._hash.words,
                  b = I[0],
                  w = I[1],
                  S = I[2],
                  k = I[3],
                  N = I[4],
                  O = I[5],
                  F = I[6],
                  V = I[7],
                  j = 0;
                j < 64;
                j++
              ) {
                if (j < 16) m[j] = E[A + j] | 0;
                else {
                  var X = m[j - 15],
                    C =
                      ((X << 25) | (X >>> 7)) ^
                      ((X << 14) | (X >>> 18)) ^
                      (X >>> 3),
                    l = m[j - 2],
                    p =
                      ((l << 15) | (l >>> 17)) ^
                      ((l << 13) | (l >>> 19)) ^
                      (l >>> 10);
                  m[j] = C + m[j - 7] + p + m[j - 16];
                }
                var y = (N & O) ^ (~N & F),
                  h = (b & w) ^ (b & S) ^ (w & S),
                  g =
                    ((b << 30) | (b >>> 2)) ^
                    ((b << 19) | (b >>> 13)) ^
                    ((b << 10) | (b >>> 22)),
                  T =
                    ((N << 26) | (N >>> 6)) ^
                    ((N << 21) | (N >>> 11)) ^
                    ((N << 7) | (N >>> 25)),
                  R = V + T + y + d[j] + m[j],
                  x = g + h;
                (V = F),
                  (F = O),
                  (O = N),
                  (N = (k + R) | 0),
                  (k = S),
                  (S = w),
                  (w = b),
                  (b = (R + x) | 0);
              }
              (I[0] = (I[0] + b) | 0),
                (I[1] = (I[1] + w) | 0),
                (I[2] = (I[2] + S) | 0),
                (I[3] = (I[3] + k) | 0),
                (I[4] = (I[4] + N) | 0),
                (I[5] = (I[5] + O) | 0),
                (I[6] = (I[6] + F) | 0),
                (I[7] = (I[7] + V) | 0);
            },
            _doFinalize: function () {
              var E = this._data,
                A = E.words,
                I = this._nDataBytes * 8,
                b = E.sigBytes * 8;
              return (
                (A[b >>> 5] |= 128 << (24 - (b % 32))),
                (A[(((b + 64) >>> 9) << 4) + 14] = n.floor(I / 4294967296)),
                (A[(((b + 64) >>> 9) << 4) + 15] = I),
                (E.sigBytes = A.length * 4),
                this._process(),
                this._hash
              );
            },
            clone: function () {
              var E = o.clone.call(this);
              return (E._hash = this._hash.clone()), E;
            },
          }));
        (i.SHA256 = o._createHelper(v)),
          (i.HmacSHA256 = o._createHmacHelper(v));
      })(Math),
      r.SHA256
    );
  });
})(nF);
var bv = nF.exports,
  iF = {
    exports: {},
  };
(function (t, e) {
  (function (r, n) {
    t.exports = n();
  })(ke, function () {
    function r(s, o) {
      var c = o ? "└" : "├";
      return s ? (c += "─ ") : (c += "──┐"), c;
    }
    function n(s, o) {
      var c = [];
      for (var u in s)
        s.hasOwnProperty(u) && ((o && typeof s[u] == "function") || c.push(u));
      return c;
    }
    function i(s, o, c, u, d, m, v) {
      var E = "",
        A = 0,
        I,
        b,
        w = u.slice(0);
      if (
        (w.push([o, c]) &&
          u.length > 0 &&
          (u.forEach(function (k, N) {
            N > 0 && (E += (k[1] ? " " : "│") + "  "),
              !b && k[0] === o && (b = !0);
          }),
          (E += r(s, c) + s),
          d && (typeof o != "object" || o instanceof Date) && (E += ": " + o),
          b && (E += " (circular ref.)"),
          v(E)),
        !b && typeof o == "object")
      ) {
        var S = n(o, m);
        S.forEach(function (k) {
          (I = ++A === S.length), i(k, o[k], I, w, d, m, v);
        });
      }
    }
    var a = {};
    return (
      (a.asLines = function (s, o, c, u) {
        var d = typeof c != "function" ? c : !1;
        i(".", s, !1, [], o, d, u || c);
      }),
      (a.asTree = function (s, o, c) {
        var u = "";
        return (
          i(".", s, !1, [], o, c, function (d) {
            u +=
              d +
              `
`;
          }),
          u
        );
      }),
      a
    );
  });
})(iF);
var joe = iF.exports,
  vd = {},
  aF = {
    exports: {},
  },
  h3 = {
    exports: {},
  },
  US;
function vv() {
  return (
    US ||
      ((US = 1),
      (function (t, e) {
        (function (r, n) {
          t.exports = n(Vt());
        })(ke, function (r) {
          return (
            (function (n) {
              var i = r,
                a = i.lib,
                s = a.Base,
                o = a.WordArray,
                c = (i.x64 = {});
              (c.Word = s.extend({
                init: function (u, d) {
                  (this.high = u), (this.low = d);
                },
              })),
                (c.WordArray = s.extend({
                  init: function (u, d) {
                    (u = this.words = u || []),
                      d != n
                        ? (this.sigBytes = d)
                        : (this.sigBytes = u.length * 8);
                  },
                  toX32: function () {
                    for (
                      var u = this.words, d = u.length, m = [], v = 0;
                      v < d;
                      v++
                    ) {
                      var E = u[v];
                      m.push(E.high), m.push(E.low);
                    }
                    return o.create(m, this.sigBytes);
                  },
                  clone: function () {
                    for (
                      var u = s.clone.call(this),
                        d = (u.words = this.words.slice(0)),
                        m = d.length,
                        v = 0;
                      v < m;
                      v++
                    )
                      d[v] = d[v].clone();
                    return u;
                  },
                }));
            })(),
            r
          );
        });
      })(h3)),
    h3.exports
  );
}
var p3 = {
    exports: {},
  },
  WS;
function Hoe() {
  return (
    WS ||
      ((WS = 1),
      (function (t, e) {
        (function (r, n) {
          t.exports = n(Vt());
        })(ke, function (r) {
          return (
            (function () {
              if (typeof ArrayBuffer == "function") {
                var n = r,
                  i = n.lib,
                  a = i.WordArray,
                  s = a.init,
                  o = (a.init = function (c) {
                    if (
                      (c instanceof ArrayBuffer && (c = new Uint8Array(c)),
                      (c instanceof Int8Array ||
                        (typeof Uint8ClampedArray < "u" &&
                          c instanceof Uint8ClampedArray) ||
                        c instanceof Int16Array ||
                        c instanceof Uint16Array ||
                        c instanceof Int32Array ||
                        c instanceof Uint32Array ||
                        c instanceof Float32Array ||
                        c instanceof Float64Array) &&
                        (c = new Uint8Array(
                          c.buffer,
                          c.byteOffset,
                          c.byteLength
                        )),
                      c instanceof Uint8Array)
                    ) {
                      for (var u = c.byteLength, d = [], m = 0; m < u; m++)
                        d[m >>> 2] |= c[m] << (24 - (m % 4) * 8);
                      s.call(this, d, u);
                    } else s.apply(this, arguments);
                  });
                o.prototype = a;
              }
            })(),
            r.lib.WordArray
          );
        });
      })(p3)),
    p3.exports
  );
}
var m3 = {
    exports: {},
  },
  jS;
function zoe() {
  return (
    jS ||
      ((jS = 1),
      (function (t, e) {
        (function (r, n) {
          t.exports = n(Vt());
        })(ke, function (r) {
          return (
            (function () {
              var n = r,
                i = n.lib,
                a = i.WordArray,
                s = n.enc;
              (s.Utf16 = s.Utf16BE =
                {
                  stringify: function (c) {
                    for (
                      var u = c.words, d = c.sigBytes, m = [], v = 0;
                      v < d;
                      v += 2
                    ) {
                      var E = (u[v >>> 2] >>> (16 - (v % 4) * 8)) & 65535;
                      m.push(String.fromCharCode(E));
                    }
                    return m.join("");
                  },
                  parse: function (c) {
                    for (var u = c.length, d = [], m = 0; m < u; m++)
                      d[m >>> 1] |= c.charCodeAt(m) << (16 - (m % 2) * 16);
                    return a.create(d, u * 2);
                  },
                }),
                (s.Utf16LE = {
                  stringify: function (c) {
                    for (
                      var u = c.words, d = c.sigBytes, m = [], v = 0;
                      v < d;
                      v += 2
                    ) {
                      var E = o((u[v >>> 2] >>> (16 - (v % 4) * 8)) & 65535);
                      m.push(String.fromCharCode(E));
                    }
                    return m.join("");
                  },
                  parse: function (c) {
                    for (var u = c.length, d = [], m = 0; m < u; m++)
                      d[m >>> 1] |= o(c.charCodeAt(m) << (16 - (m % 2) * 16));
                    return a.create(d, u * 2);
                  },
                });
              function o(c) {
                return ((c << 8) & 4278255360) | ((c >>> 8) & 16711935);
              }
            })(),
            r.enc.Utf16
          );
        });
      })(m3)),
    m3.exports
  );
}
var y3 = {
    exports: {},
  },
  HS;
function xd() {
  return (
    HS ||
      ((HS = 1),
      (function (t, e) {
        (function (r, n) {
          t.exports = n(Vt());
        })(ke, function (r) {
          return (
            (function () {
              var n = r,
                i = n.lib,
                a = i.WordArray,
                s = n.enc;
              s.Base64 = {
                stringify: function (c) {
                  var u = c.words,
                    d = c.sigBytes,
                    m = this._map;
                  c.clamp();
                  for (var v = [], E = 0; E < d; E += 3)
                    for (
                      var A = (u[E >>> 2] >>> (24 - (E % 4) * 8)) & 255,
                        I =
                          (u[(E + 1) >>> 2] >>> (24 - ((E + 1) % 4) * 8)) & 255,
                        b =
                          (u[(E + 2) >>> 2] >>> (24 - ((E + 2) % 4) * 8)) & 255,
                        w = (A << 16) | (I << 8) | b,
                        S = 0;
                      S < 4 && E + S * 0.75 < d;
                      S++
                    )
                      v.push(m.charAt((w >>> (6 * (3 - S))) & 63));
                  var k = m.charAt(64);
                  if (k) for (; v.length % 4; ) v.push(k);
                  return v.join("");
                },
                parse: function (c) {
                  var u = c.length,
                    d = this._map,
                    m = this._reverseMap;
                  if (!m) {
                    m = this._reverseMap = [];
                    for (var v = 0; v < d.length; v++) m[d.charCodeAt(v)] = v;
                  }
                  var E = d.charAt(64);
                  if (E) {
                    var A = c.indexOf(E);
                    A !== -1 && (u = A);
                  }
                  return o(c, u, m);
                },
                _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
              };
              function o(c, u, d) {
                for (var m = [], v = 0, E = 0; E < u; E++)
                  if (E % 4) {
                    var A = d[c.charCodeAt(E - 1)] << ((E % 4) * 2),
                      I = d[c.charCodeAt(E)] >>> (6 - (E % 4) * 2);
                    (m[v >>> 2] |= (A | I) << (24 - (v % 4) * 8)), v++;
                  }
                return a.create(m, v);
              }
            })(),
            r.enc.Base64
          );
        });
      })(y3)),
    y3.exports
  );
}
var g3 = {
    exports: {},
  },
  zS;
function wd() {
  return (
    zS ||
      ((zS = 1),
      (function (t, e) {
        (function (r, n) {
          t.exports = n(Vt());
        })(ke, function (r) {
          return (
            (function (n) {
              var i = r,
                a = i.lib,
                s = a.WordArray,
                o = a.Hasher,
                c = i.algo,
                u = [];
              (function () {
                for (var I = 0; I < 64; I++)
                  u[I] = (n.abs(n.sin(I + 1)) * 4294967296) | 0;
              })();
              var d = (c.MD5 = o.extend({
                _doReset: function () {
                  this._hash = new s.init([
                    1732584193, 4023233417, 2562383102, 271733878,
                  ]);
                },
                _doProcessBlock: function (I, b) {
                  for (var w = 0; w < 16; w++) {
                    var S = b + w,
                      k = I[S];
                    I[S] =
                      (((k << 8) | (k >>> 24)) & 16711935) |
                      (((k << 24) | (k >>> 8)) & 4278255360);
                  }
                  var N = this._hash.words,
                    O = I[b + 0],
                    F = I[b + 1],
                    V = I[b + 2],
                    j = I[b + 3],
                    X = I[b + 4],
                    C = I[b + 5],
                    l = I[b + 6],
                    p = I[b + 7],
                    y = I[b + 8],
                    h = I[b + 9],
                    g = I[b + 10],
                    T = I[b + 11],
                    R = I[b + 12],
                    x = I[b + 13],
                    f = I[b + 14],
                    _ = I[b + 15],
                    P = N[0],
                    M = N[1],
                    D = N[2],
                    q = N[3];
                  (P = m(P, M, D, q, O, 7, u[0])),
                    (q = m(q, P, M, D, F, 12, u[1])),
                    (D = m(D, q, P, M, V, 17, u[2])),
                    (M = m(M, D, q, P, j, 22, u[3])),
                    (P = m(P, M, D, q, X, 7, u[4])),
                    (q = m(q, P, M, D, C, 12, u[5])),
                    (D = m(D, q, P, M, l, 17, u[6])),
                    (M = m(M, D, q, P, p, 22, u[7])),
                    (P = m(P, M, D, q, y, 7, u[8])),
                    (q = m(q, P, M, D, h, 12, u[9])),
                    (D = m(D, q, P, M, g, 17, u[10])),
                    (M = m(M, D, q, P, T, 22, u[11])),
                    (P = m(P, M, D, q, R, 7, u[12])),
                    (q = m(q, P, M, D, x, 12, u[13])),
                    (D = m(D, q, P, M, f, 17, u[14])),
                    (M = m(M, D, q, P, _, 22, u[15])),
                    (P = v(P, M, D, q, F, 5, u[16])),
                    (q = v(q, P, M, D, l, 9, u[17])),
                    (D = v(D, q, P, M, T, 14, u[18])),
                    (M = v(M, D, q, P, O, 20, u[19])),
                    (P = v(P, M, D, q, C, 5, u[20])),
                    (q = v(q, P, M, D, g, 9, u[21])),
                    (D = v(D, q, P, M, _, 14, u[22])),
                    (M = v(M, D, q, P, X, 20, u[23])),
                    (P = v(P, M, D, q, h, 5, u[24])),
                    (q = v(q, P, M, D, f, 9, u[25])),
                    (D = v(D, q, P, M, j, 14, u[26])),
                    (M = v(M, D, q, P, y, 20, u[27])),
                    (P = v(P, M, D, q, x, 5, u[28])),
                    (q = v(q, P, M, D, V, 9, u[29])),
                    (D = v(D, q, P, M, p, 14, u[30])),
                    (M = v(M, D, q, P, R, 20, u[31])),
                    (P = E(P, M, D, q, C, 4, u[32])),
                    (q = E(q, P, M, D, y, 11, u[33])),
                    (D = E(D, q, P, M, T, 16, u[34])),
                    (M = E(M, D, q, P, f, 23, u[35])),
                    (P = E(P, M, D, q, F, 4, u[36])),
                    (q = E(q, P, M, D, X, 11, u[37])),
                    (D = E(D, q, P, M, p, 16, u[38])),
                    (M = E(M, D, q, P, g, 23, u[39])),
                    (P = E(P, M, D, q, x, 4, u[40])),
                    (q = E(q, P, M, D, O, 11, u[41])),
                    (D = E(D, q, P, M, j, 16, u[42])),
                    (M = E(M, D, q, P, l, 23, u[43])),
                    (P = E(P, M, D, q, h, 4, u[44])),
                    (q = E(q, P, M, D, R, 11, u[45])),
                    (D = E(D, q, P, M, _, 16, u[46])),
                    (M = E(M, D, q, P, V, 23, u[47])),
                    (P = A(P, M, D, q, O, 6, u[48])),
                    (q = A(q, P, M, D, p, 10, u[49])),
                    (D = A(D, q, P, M, f, 15, u[50])),
                    (M = A(M, D, q, P, C, 21, u[51])),
                    (P = A(P, M, D, q, R, 6, u[52])),
                    (q = A(q, P, M, D, j, 10, u[53])),
                    (D = A(D, q, P, M, g, 15, u[54])),
                    (M = A(M, D, q, P, F, 21, u[55])),
                    (P = A(P, M, D, q, y, 6, u[56])),
                    (q = A(q, P, M, D, _, 10, u[57])),
                    (D = A(D, q, P, M, l, 15, u[58])),
                    (M = A(M, D, q, P, x, 21, u[59])),
                    (P = A(P, M, D, q, X, 6, u[60])),
                    (q = A(q, P, M, D, T, 10, u[61])),
                    (D = A(D, q, P, M, V, 15, u[62])),
                    (M = A(M, D, q, P, h, 21, u[63])),
                    (N[0] = (N[0] + P) | 0),
                    (N[1] = (N[1] + M) | 0),
                    (N[2] = (N[2] + D) | 0),
                    (N[3] = (N[3] + q) | 0);
                },
                _doFinalize: function () {
                  var I = this._data,
                    b = I.words,
                    w = this._nDataBytes * 8,
                    S = I.sigBytes * 8;
                  b[S >>> 5] |= 128 << (24 - (S % 32));
                  var k = n.floor(w / 4294967296),
                    N = w;
                  (b[(((S + 64) >>> 9) << 4) + 15] =
                    (((k << 8) | (k >>> 24)) & 16711935) |
                    (((k << 24) | (k >>> 8)) & 4278255360)),
                    (b[(((S + 64) >>> 9) << 4) + 14] =
                      (((N << 8) | (N >>> 24)) & 16711935) |
                      (((N << 24) | (N >>> 8)) & 4278255360)),
                    (I.sigBytes = (b.length + 1) * 4),
                    this._process();
                  for (var O = this._hash, F = O.words, V = 0; V < 4; V++) {
                    var j = F[V];
                    F[V] =
                      (((j << 8) | (j >>> 24)) & 16711935) |
                      (((j << 24) | (j >>> 8)) & 4278255360);
                  }
                  return O;
                },
                clone: function () {
                  var I = o.clone.call(this);
                  return (I._hash = this._hash.clone()), I;
                },
              }));
              function m(I, b, w, S, k, N, O) {
                var F = I + ((b & w) | (~b & S)) + k + O;
                return ((F << N) | (F >>> (32 - N))) + b;
              }
              function v(I, b, w, S, k, N, O) {
                var F = I + ((b & S) | (w & ~S)) + k + O;
                return ((F << N) | (F >>> (32 - N))) + b;
              }
              function E(I, b, w, S, k, N, O) {
                var F = I + (b ^ w ^ S) + k + O;
                return ((F << N) | (F >>> (32 - N))) + b;
              }
              function A(I, b, w, S, k, N, O) {
                var F = I + (w ^ (b | ~S)) + k + O;
                return ((F << N) | (F >>> (32 - N))) + b;
              }
              (i.MD5 = o._createHelper(d)),
                (i.HmacMD5 = o._createHmacHelper(d));
            })(Math),
            r.MD5
          );
        });
      })(g3)),
    g3.exports
  );
}
var b3 = {
    exports: {},
  },
  qS;
function wE() {
  return (
    qS ||
      ((qS = 1),
      (function (t, e) {
        (function (r, n) {
          t.exports = n(Vt());
        })(ke, function (r) {
          return (
            (function () {
              var n = r,
                i = n.lib,
                a = i.WordArray,
                s = i.Hasher,
                o = n.algo,
                c = [],
                u = (o.SHA1 = s.extend({
                  _doReset: function () {
                    this._hash = new a.init([
                      1732584193, 4023233417, 2562383102, 271733878, 3285377520,
                    ]);
                  },
                  _doProcessBlock: function (d, m) {
                    for (
                      var v = this._hash.words,
                        E = v[0],
                        A = v[1],
                        I = v[2],
                        b = v[3],
                        w = v[4],
                        S = 0;
                      S < 80;
                      S++
                    ) {
                      if (S < 16) c[S] = d[m + S] | 0;
                      else {
                        var k = c[S - 3] ^ c[S - 8] ^ c[S - 14] ^ c[S - 16];
                        c[S] = (k << 1) | (k >>> 31);
                      }
                      var N = ((E << 5) | (E >>> 27)) + w + c[S];
                      S < 20
                        ? (N += ((A & I) | (~A & b)) + 1518500249)
                        : S < 40
                        ? (N += (A ^ I ^ b) + 1859775393)
                        : S < 60
                        ? (N += ((A & I) | (A & b) | (I & b)) - 1894007588)
                        : (N += (A ^ I ^ b) - 899497514),
                        (w = b),
                        (b = I),
                        (I = (A << 30) | (A >>> 2)),
                        (A = E),
                        (E = N);
                    }
                    (v[0] = (v[0] + E) | 0),
                      (v[1] = (v[1] + A) | 0),
                      (v[2] = (v[2] + I) | 0),
                      (v[3] = (v[3] + b) | 0),
                      (v[4] = (v[4] + w) | 0);
                  },
                  _doFinalize: function () {
                    var d = this._data,
                      m = d.words,
                      v = this._nDataBytes * 8,
                      E = d.sigBytes * 8;
                    return (
                      (m[E >>> 5] |= 128 << (24 - (E % 32))),
                      (m[(((E + 64) >>> 9) << 4) + 14] = Math.floor(
                        v / 4294967296
                      )),
                      (m[(((E + 64) >>> 9) << 4) + 15] = v),
                      (d.sigBytes = m.length * 4),
                      this._process(),
                      this._hash
                    );
                  },
                  clone: function () {
                    var d = s.clone.call(this);
                    return (d._hash = this._hash.clone()), d;
                  },
                }));
              (n.SHA1 = s._createHelper(u)),
                (n.HmacSHA1 = s._createHmacHelper(u));
            })(),
            r.SHA1
          );
        });
      })(b3)),
    b3.exports
  );
}
var v3 = {
    exports: {},
  },
  VS;
function qoe() {
  return (
    VS ||
      ((VS = 1),
      (function (t, e) {
        (function (r, n, i) {
          t.exports = n(Vt(), bv);
        })(ke, function (r) {
          return (
            (function () {
              var n = r,
                i = n.lib,
                a = i.WordArray,
                s = n.algo,
                o = s.SHA256,
                c = (s.SHA224 = o.extend({
                  _doReset: function () {
                    this._hash = new a.init([
                      3238371032, 914150663, 812702999, 4144912697, 4290775857,
                      1750603025, 1694076839, 3204075428,
                    ]);
                  },
                  _doFinalize: function () {
                    var u = o._doFinalize.call(this);
                    return (u.sigBytes -= 4), u;
                  },
                }));
              (n.SHA224 = o._createHelper(c)),
                (n.HmacSHA224 = o._createHmacHelper(c));
            })(),
            r.SHA224
          );
        });
      })(v3)),
    v3.exports
  );
}
var x3 = {
    exports: {},
  },
  KS;
function sF() {
  return (
    KS ||
      ((KS = 1),
      (function (t, e) {
        (function (r, n, i) {
          t.exports = n(Vt(), vv());
        })(ke, function (r) {
          return (
            (function () {
              var n = r,
                i = n.lib,
                a = i.Hasher,
                s = n.x64,
                o = s.Word,
                c = s.WordArray,
                u = n.algo;
              function d() {
                return o.create.apply(o, arguments);
              }
              var m = [
                  d(1116352408, 3609767458),
                  d(1899447441, 602891725),
                  d(3049323471, 3964484399),
                  d(3921009573, 2173295548),
                  d(961987163, 4081628472),
                  d(1508970993, 3053834265),
                  d(2453635748, 2937671579),
                  d(2870763221, 3664609560),
                  d(3624381080, 2734883394),
                  d(310598401, 1164996542),
                  d(607225278, 1323610764),
                  d(1426881987, 3590304994),
                  d(1925078388, 4068182383),
                  d(2162078206, 991336113),
                  d(2614888103, 633803317),
                  d(3248222580, 3479774868),
                  d(3835390401, 2666613458),
                  d(4022224774, 944711139),
                  d(264347078, 2341262773),
                  d(604807628, 2007800933),
                  d(770255983, 1495990901),
                  d(1249150122, 1856431235),
                  d(1555081692, 3175218132),
                  d(1996064986, 2198950837),
                  d(2554220882, 3999719339),
                  d(2821834349, 766784016),
                  d(2952996808, 2566594879),
                  d(3210313671, 3203337956),
                  d(3336571891, 1034457026),
                  d(3584528711, 2466948901),
                  d(113926993, 3758326383),
                  d(338241895, 168717936),
                  d(666307205, 1188179964),
                  d(773529912, 1546045734),
                  d(1294757372, 1522805485),
                  d(1396182291, 2643833823),
                  d(1695183700, 2343527390),
                  d(1986661051, 1014477480),
                  d(2177026350, 1206759142),
                  d(2456956037, 344077627),
                  d(2730485921, 1290863460),
                  d(2820302411, 3158454273),
                  d(3259730800, 3505952657),
                  d(3345764771, 106217008),
                  d(3516065817, 3606008344),
                  d(3600352804, 1432725776),
                  d(4094571909, 1467031594),
                  d(275423344, 851169720),
                  d(430227734, 3100823752),
                  d(506948616, 1363258195),
                  d(659060556, 3750685593),
                  d(883997877, 3785050280),
                  d(958139571, 3318307427),
                  d(1322822218, 3812723403),
                  d(1537002063, 2003034995),
                  d(1747873779, 3602036899),
                  d(1955562222, 1575990012),
                  d(2024104815, 1125592928),
                  d(2227730452, 2716904306),
                  d(2361852424, 442776044),
                  d(2428436474, 593698344),
                  d(2756734187, 3733110249),
                  d(3204031479, 2999351573),
                  d(3329325298, 3815920427),
                  d(3391569614, 3928383900),
                  d(3515267271, 566280711),
                  d(3940187606, 3454069534),
                  d(4118630271, 4000239992),
                  d(116418474, 1914138554),
                  d(174292421, 2731055270),
                  d(289380356, 3203993006),
                  d(460393269, 320620315),
                  d(685471733, 587496836),
                  d(852142971, 1086792851),
                  d(1017036298, 365543100),
                  d(1126000580, 2618297676),
                  d(1288033470, 3409855158),
                  d(1501505948, 4234509866),
                  d(1607167915, 987167468),
                  d(1816402316, 1246189591),
                ],
                v = [];
              (function () {
                for (var A = 0; A < 80; A++) v[A] = d();
              })();
              var E = (u.SHA512 = a.extend({
                _doReset: function () {
                  this._hash = new c.init([
                    new o.init(1779033703, 4089235720),
                    new o.init(3144134277, 2227873595),
                    new o.init(1013904242, 4271175723),
                    new o.init(2773480762, 1595750129),
                    new o.init(1359893119, 2917565137),
                    new o.init(2600822924, 725511199),
                    new o.init(528734635, 4215389547),
                    new o.init(1541459225, 327033209),
                  ]);
                },
                _doProcessBlock: function (A, I) {
                  for (
                    var b = this._hash.words,
                      w = b[0],
                      S = b[1],
                      k = b[2],
                      N = b[3],
                      O = b[4],
                      F = b[5],
                      V = b[6],
                      j = b[7],
                      X = w.high,
                      C = w.low,
                      l = S.high,
                      p = S.low,
                      y = k.high,
                      h = k.low,
                      g = N.high,
                      T = N.low,
                      R = O.high,
                      x = O.low,
                      f = F.high,
                      _ = F.low,
                      P = V.high,
                      M = V.low,
                      D = j.high,
                      q = j.low,
                      B = X,
                      H = C,
                      Q = l,
                      Z = p,
                      te = y,
                      Te = h,
                      K = g,
                      G = T,
                      he = R,
                      se = x,
                      pe = f,
                      Y = _,
                      $ = P,
                      W = M,
                      re = D,
                      ee = q,
                      ce = 0;
                    ce < 80;
                    ce++
                  ) {
                    var Ce = v[ce];
                    if (ce < 16)
                      var me = (Ce.high = A[I + ce * 2] | 0),
                        ge = (Ce.low = A[I + ce * 2 + 1] | 0);
                    else {
                      var it = v[ce - 15],
                        ve = it.high,
                        z = it.low,
                        U =
                          ((ve >>> 1) | (z << 31)) ^
                          ((ve >>> 8) | (z << 24)) ^
                          (ve >>> 7),
                        L =
                          ((z >>> 1) | (ve << 31)) ^
                          ((z >>> 8) | (ve << 24)) ^
                          ((z >>> 7) | (ve << 25)),
                        J = v[ce - 2],
                        fe = J.high,
                        ie = J.low,
                        le =
                          ((fe >>> 19) | (ie << 13)) ^
                          ((fe << 3) | (ie >>> 29)) ^
                          (fe >>> 6),
                        nt =
                          ((ie >>> 19) | (fe << 13)) ^
                          ((ie << 3) | (fe >>> 29)) ^
                          ((ie >>> 6) | (fe << 26)),
                        Ee = v[ce - 7],
                        we = Ee.high,
                        ft = Ee.low,
                        xe = v[ce - 16],
                        Pe = xe.high,
                        hr = xe.low,
                        ge = L + ft,
                        me = U + we + (ge >>> 0 < L >>> 0 ? 1 : 0),
                        ge = ge + nt,
                        me = me + le + (ge >>> 0 < nt >>> 0 ? 1 : 0),
                        ge = ge + hr,
                        me = me + Pe + (ge >>> 0 < hr >>> 0 ? 1 : 0);
                      (Ce.high = me), (Ce.low = ge);
                    }
                    var Ne = (he & pe) ^ (~he & $),
                      Me = (se & Y) ^ (~se & W),
                      _r = (B & Q) ^ (B & te) ^ (Q & te),
                      Be = (H & Z) ^ (H & Te) ^ (Z & Te),
                      De =
                        ((B >>> 28) | (H << 4)) ^
                        ((B << 30) | (H >>> 2)) ^
                        ((B << 25) | (H >>> 7)),
                      pr =
                        ((H >>> 28) | (B << 4)) ^
                        ((H << 30) | (B >>> 2)) ^
                        ((H << 25) | (B >>> 7)),
                      Oe =
                        ((he >>> 14) | (se << 18)) ^
                        ((he >>> 18) | (se << 14)) ^
                        ((he << 23) | (se >>> 9)),
                      Fe =
                        ((se >>> 14) | (he << 18)) ^
                        ((se >>> 18) | (he << 14)) ^
                        ((se << 23) | (he >>> 9)),
                      mr = m[ce],
                      Le = mr.high,
                      Ie = mr.low,
                      At = ee + Fe,
                      Ae = re + Oe + (At >>> 0 < ee >>> 0 ? 1 : 0),
                      At = At + Me,
                      Ae = Ae + Ne + (At >>> 0 < Me >>> 0 ? 1 : 0),
                      At = At + Ie,
                      Ae = Ae + Le + (At >>> 0 < Ie >>> 0 ? 1 : 0),
                      At = At + ge,
                      Ae = Ae + me + (At >>> 0 < ge >>> 0 ? 1 : 0),
                      Re = pr + Be,
                      Er = De + _r + (Re >>> 0 < pr >>> 0 ? 1 : 0);
                    (re = $),
                      (ee = W),
                      ($ = pe),
                      (W = Y),
                      (pe = he),
                      (Y = se),
                      (se = (G + At) | 0),
                      (he = (K + Ae + (se >>> 0 < G >>> 0 ? 1 : 0)) | 0),
                      (K = te),
                      (G = Te),
                      (te = Q),
                      (Te = Z),
                      (Q = B),
                      (Z = H),
                      (H = (At + Re) | 0),
                      (B = (Ae + Er + (H >>> 0 < At >>> 0 ? 1 : 0)) | 0);
                  }
                  (C = w.low = C + H),
                    (w.high = X + B + (C >>> 0 < H >>> 0 ? 1 : 0)),
                    (p = S.low = p + Z),
                    (S.high = l + Q + (p >>> 0 < Z >>> 0 ? 1 : 0)),
                    (h = k.low = h + Te),
                    (k.high = y + te + (h >>> 0 < Te >>> 0 ? 1 : 0)),
                    (T = N.low = T + G),
                    (N.high = g + K + (T >>> 0 < G >>> 0 ? 1 : 0)),
                    (x = O.low = x + se),
                    (O.high = R + he + (x >>> 0 < se >>> 0 ? 1 : 0)),
                    (_ = F.low = _ + Y),
                    (F.high = f + pe + (_ >>> 0 < Y >>> 0 ? 1 : 0)),
                    (M = V.low = M + W),
                    (V.high = P + $ + (M >>> 0 < W >>> 0 ? 1 : 0)),
                    (q = j.low = q + ee),
                    (j.high = D + re + (q >>> 0 < ee >>> 0 ? 1 : 0));
                },
                _doFinalize: function () {
                  var A = this._data,
                    I = A.words,
                    b = this._nDataBytes * 8,
                    w = A.sigBytes * 8;
                  (I[w >>> 5] |= 128 << (24 - (w % 32))),
                    (I[(((w + 128) >>> 10) << 5) + 30] = Math.floor(
                      b / 4294967296
                    )),
                    (I[(((w + 128) >>> 10) << 5) + 31] = b),
                    (A.sigBytes = I.length * 4),
                    this._process();
                  var S = this._hash.toX32();
                  return S;
                },
                clone: function () {
                  var A = a.clone.call(this);
                  return (A._hash = this._hash.clone()), A;
                },
                blockSize: 1024 / 32,
              }));
              (n.SHA512 = a._createHelper(E)),
                (n.HmacSHA512 = a._createHmacHelper(E));
            })(),
            r.SHA512
          );
        });
      })(x3)),
    x3.exports
  );
}
var w3 = {
    exports: {},
  },
  GS;
function Voe() {
  return (
    GS ||
      ((GS = 1),
      (function (t, e) {
        (function (r, n, i) {
          t.exports = n(Vt(), vv(), sF());
        })(ke, function (r) {
          return (
            (function () {
              var n = r,
                i = n.x64,
                a = i.Word,
                s = i.WordArray,
                o = n.algo,
                c = o.SHA512,
                u = (o.SHA384 = c.extend({
                  _doReset: function () {
                    this._hash = new s.init([
                      new a.init(3418070365, 3238371032),
                      new a.init(1654270250, 914150663),
                      new a.init(2438529370, 812702999),
                      new a.init(355462360, 4144912697),
                      new a.init(1731405415, 4290775857),
                      new a.init(2394180231, 1750603025),
                      new a.init(3675008525, 1694076839),
                      new a.init(1203062813, 3204075428),
                    ]);
                  },
                  _doFinalize: function () {
                    var d = c._doFinalize.call(this);
                    return (d.sigBytes -= 16), d;
                  },
                }));
              (n.SHA384 = c._createHelper(u)),
                (n.HmacSHA384 = c._createHmacHelper(u));
            })(),
            r.SHA384
          );
        });
      })(w3)),
    w3.exports
  );
}
var _3 = {
    exports: {},
  },
  ZS;
function Koe() {
  return (
    ZS ||
      ((ZS = 1),
      (function (t, e) {
        (function (r, n, i) {
          t.exports = n(Vt(), vv());
        })(ke, function (r) {
          return (
            (function (n) {
              var i = r,
                a = i.lib,
                s = a.WordArray,
                o = a.Hasher,
                c = i.x64,
                u = c.Word,
                d = i.algo,
                m = [],
                v = [],
                E = [];
              (function () {
                for (var b = 1, w = 0, S = 0; S < 24; S++) {
                  m[b + 5 * w] = (((S + 1) * (S + 2)) / 2) % 64;
                  var k = w % 5,
                    N = (2 * b + 3 * w) % 5;
                  (b = k), (w = N);
                }
                for (var b = 0; b < 5; b++)
                  for (var w = 0; w < 5; w++)
                    v[b + 5 * w] = w + ((2 * b + 3 * w) % 5) * 5;
                for (var O = 1, F = 0; F < 24; F++) {
                  for (var V = 0, j = 0, X = 0; X < 7; X++) {
                    if (O & 1) {
                      var C = (1 << X) - 1;
                      C < 32 ? (j ^= 1 << C) : (V ^= 1 << (C - 32));
                    }
                    O & 128 ? (O = (O << 1) ^ 113) : (O <<= 1);
                  }
                  E[F] = u.create(V, j);
                }
              })();
              var A = [];
              (function () {
                for (var b = 0; b < 25; b++) A[b] = u.create();
              })();
              var I = (d.SHA3 = o.extend({
                cfg: o.cfg.extend({
                  outputLength: 512,
                }),
                _doReset: function () {
                  for (var b = (this._state = []), w = 0; w < 25; w++)
                    b[w] = new u.init();
                  this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
                },
                _doProcessBlock: function (b, w) {
                  for (
                    var S = this._state, k = this.blockSize / 2, N = 0;
                    N < k;
                    N++
                  ) {
                    var O = b[w + 2 * N],
                      F = b[w + 2 * N + 1];
                    (O =
                      (((O << 8) | (O >>> 24)) & 16711935) |
                      (((O << 24) | (O >>> 8)) & 4278255360)),
                      (F =
                        (((F << 8) | (F >>> 24)) & 16711935) |
                        (((F << 24) | (F >>> 8)) & 4278255360));
                    var V = S[N];
                    (V.high ^= F), (V.low ^= O);
                  }
                  for (var j = 0; j < 24; j++) {
                    for (var X = 0; X < 5; X++) {
                      for (var C = 0, l = 0, p = 0; p < 5; p++) {
                        var V = S[X + 5 * p];
                        (C ^= V.high), (l ^= V.low);
                      }
                      var y = A[X];
                      (y.high = C), (y.low = l);
                    }
                    for (var X = 0; X < 5; X++)
                      for (
                        var h = A[(X + 4) % 5],
                          g = A[(X + 1) % 5],
                          T = g.high,
                          R = g.low,
                          C = h.high ^ ((T << 1) | (R >>> 31)),
                          l = h.low ^ ((R << 1) | (T >>> 31)),
                          p = 0;
                        p < 5;
                        p++
                      ) {
                        var V = S[X + 5 * p];
                        (V.high ^= C), (V.low ^= l);
                      }
                    for (var x = 1; x < 25; x++) {
                      var V = S[x],
                        f = V.high,
                        _ = V.low,
                        P = m[x];
                      if (P < 32)
                        var C = (f << P) | (_ >>> (32 - P)),
                          l = (_ << P) | (f >>> (32 - P));
                      else
                        var C = (_ << (P - 32)) | (f >>> (64 - P)),
                          l = (f << (P - 32)) | (_ >>> (64 - P));
                      var M = A[v[x]];
                      (M.high = C), (M.low = l);
                    }
                    var D = A[0],
                      q = S[0];
                    (D.high = q.high), (D.low = q.low);
                    for (var X = 0; X < 5; X++)
                      for (var p = 0; p < 5; p++) {
                        var x = X + 5 * p,
                          V = S[x],
                          B = A[x],
                          H = A[((X + 1) % 5) + 5 * p],
                          Q = A[((X + 2) % 5) + 5 * p];
                        (V.high = B.high ^ (~H.high & Q.high)),
                          (V.low = B.low ^ (~H.low & Q.low));
                      }
                    var V = S[0],
                      Z = E[j];
                    (V.high ^= Z.high), (V.low ^= Z.low);
                  }
                },
                _doFinalize: function () {
                  var b = this._data,
                    w = b.words;
                  this._nDataBytes * 8;
                  var S = b.sigBytes * 8,
                    k = this.blockSize * 32;
                  (w[S >>> 5] |= 1 << (24 - (S % 32))),
                    (w[((n.ceil((S + 1) / k) * k) >>> 5) - 1] |= 128),
                    (b.sigBytes = w.length * 4),
                    this._process();
                  for (
                    var N = this._state,
                      O = this.cfg.outputLength / 8,
                      F = O / 8,
                      V = [],
                      j = 0;
                    j < F;
                    j++
                  ) {
                    var X = N[j],
                      C = X.high,
                      l = X.low;
                    (C =
                      (((C << 8) | (C >>> 24)) & 16711935) |
                      (((C << 24) | (C >>> 8)) & 4278255360)),
                      (l =
                        (((l << 8) | (l >>> 24)) & 16711935) |
                        (((l << 24) | (l >>> 8)) & 4278255360)),
                      V.push(l),
                      V.push(C);
                  }
                  return new s.init(V, O);
                },
                clone: function () {
                  for (
                    var b = o.clone.call(this),
                      w = (b._state = this._state.slice(0)),
                      S = 0;
                    S < 25;
                    S++
                  )
                    w[S] = w[S].clone();
                  return b;
                },
              }));
              (i.SHA3 = o._createHelper(I)),
                (i.HmacSHA3 = o._createHmacHelper(I));
            })(Math),
            r.SHA3
          );
        });
      })(_3)),
    _3.exports
  );
}
var E3 = {
    exports: {},
  },
  JS;
function Goe() {
  return (
    JS ||
      ((JS = 1),
      (function (t, e) {
        (function (r, n) {
          t.exports = n(Vt());
        })(ke, function (r) {
          /** @preserve
			(c) 2012 by Cédric Mesnil. All rights reserved.

			Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

			    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
			    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

			THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
			*/
          return (
            (function (n) {
              var i = r,
                a = i.lib,
                s = a.WordArray,
                o = a.Hasher,
                c = i.algo,
                u = s.create([
                  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4,
                  13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4,
                  9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8,
                  12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10,
                  14, 1, 3, 8, 11, 6, 15, 13,
                ]),
                d = s.create([
                  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11,
                  3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7,
                  14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15,
                  0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6,
                  2, 13, 14, 0, 3, 9, 11,
                ]),
                m = s.create([
                  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6,
                  8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6,
                  7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15,
                  14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8,
                  13, 12, 5, 12, 13, 14, 11, 8, 5, 6,
                ]),
                v = s.create([
                  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13,
                  15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11,
                  8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14,
                  14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14,
                  6, 8, 13, 6, 5, 15, 13, 11, 11,
                ]),
                E = s.create([
                  0, 1518500249, 1859775393, 2400959708, 2840853838,
                ]),
                A = s.create([
                  1352829926, 1548603684, 1836072691, 2053994217, 0,
                ]),
                I = (c.RIPEMD160 = o.extend({
                  _doReset: function () {
                    this._hash = s.create([
                      1732584193, 4023233417, 2562383102, 271733878, 3285377520,
                    ]);
                  },
                  _doProcessBlock: function (F, V) {
                    for (var j = 0; j < 16; j++) {
                      var X = V + j,
                        C = F[X];
                      F[X] =
                        (((C << 8) | (C >>> 24)) & 16711935) |
                        (((C << 24) | (C >>> 8)) & 4278255360);
                    }
                    var l = this._hash.words,
                      p = E.words,
                      y = A.words,
                      h = u.words,
                      g = d.words,
                      T = m.words,
                      R = v.words,
                      x,
                      f,
                      _,
                      P,
                      M,
                      D,
                      q,
                      B,
                      H,
                      Q;
                    (D = x = l[0]),
                      (q = f = l[1]),
                      (B = _ = l[2]),
                      (H = P = l[3]),
                      (Q = M = l[4]);
                    for (var Z, j = 0; j < 80; j += 1)
                      (Z = (x + F[V + h[j]]) | 0),
                        j < 16
                          ? (Z += b(f, _, P) + p[0])
                          : j < 32
                          ? (Z += w(f, _, P) + p[1])
                          : j < 48
                          ? (Z += S(f, _, P) + p[2])
                          : j < 64
                          ? (Z += k(f, _, P) + p[3])
                          : (Z += N(f, _, P) + p[4]),
                        (Z = Z | 0),
                        (Z = O(Z, T[j])),
                        (Z = (Z + M) | 0),
                        (x = M),
                        (M = P),
                        (P = O(_, 10)),
                        (_ = f),
                        (f = Z),
                        (Z = (D + F[V + g[j]]) | 0),
                        j < 16
                          ? (Z += N(q, B, H) + y[0])
                          : j < 32
                          ? (Z += k(q, B, H) + y[1])
                          : j < 48
                          ? (Z += S(q, B, H) + y[2])
                          : j < 64
                          ? (Z += w(q, B, H) + y[3])
                          : (Z += b(q, B, H) + y[4]),
                        (Z = Z | 0),
                        (Z = O(Z, R[j])),
                        (Z = (Z + Q) | 0),
                        (D = Q),
                        (Q = H),
                        (H = O(B, 10)),
                        (B = q),
                        (q = Z);
                    (Z = (l[1] + _ + H) | 0),
                      (l[1] = (l[2] + P + Q) | 0),
                      (l[2] = (l[3] + M + D) | 0),
                      (l[3] = (l[4] + x + q) | 0),
                      (l[4] = (l[0] + f + B) | 0),
                      (l[0] = Z);
                  },
                  _doFinalize: function () {
                    var F = this._data,
                      V = F.words,
                      j = this._nDataBytes * 8,
                      X = F.sigBytes * 8;
                    (V[X >>> 5] |= 128 << (24 - (X % 32))),
                      (V[(((X + 64) >>> 9) << 4) + 14] =
                        (((j << 8) | (j >>> 24)) & 16711935) |
                        (((j << 24) | (j >>> 8)) & 4278255360)),
                      (F.sigBytes = (V.length + 1) * 4),
                      this._process();
                    for (var C = this._hash, l = C.words, p = 0; p < 5; p++) {
                      var y = l[p];
                      l[p] =
                        (((y << 8) | (y >>> 24)) & 16711935) |
                        (((y << 24) | (y >>> 8)) & 4278255360);
                    }
                    return C;
                  },
                  clone: function () {
                    var F = o.clone.call(this);
                    return (F._hash = this._hash.clone()), F;
                  },
                }));
              function b(F, V, j) {
                return F ^ V ^ j;
              }
              function w(F, V, j) {
                return (F & V) | (~F & j);
              }
              function S(F, V, j) {
                return (F | ~V) ^ j;
              }
              function k(F, V, j) {
                return (F & j) | (V & ~j);
              }
              function N(F, V, j) {
                return F ^ (V | ~j);
              }
              function O(F, V) {
                return (F << V) | (F >>> (32 - V));
              }
              (i.RIPEMD160 = o._createHelper(I)),
                (i.HmacRIPEMD160 = o._createHmacHelper(I));
            })(),
            r.RIPEMD160
          );
        });
      })(E3)),
    E3.exports
  );
}
var T3 = {
    exports: {},
  },
  QS;
function _E() {
  return (
    QS ||
      ((QS = 1),
      (function (t, e) {
        (function (r, n) {
          t.exports = n(Vt());
        })(ke, function (r) {
          (function () {
            var n = r,
              i = n.lib,
              a = i.Base,
              s = n.enc,
              o = s.Utf8,
              c = n.algo;
            c.HMAC = a.extend({
              init: function (u, d) {
                (u = this._hasher = new u.init()),
                  typeof d == "string" && (d = o.parse(d));
                var m = u.blockSize,
                  v = m * 4;
                d.sigBytes > v && (d = u.finalize(d)), d.clamp();
                for (
                  var E = (this._oKey = d.clone()),
                    A = (this._iKey = d.clone()),
                    I = E.words,
                    b = A.words,
                    w = 0;
                  w < m;
                  w++
                )
                  (I[w] ^= 1549556828), (b[w] ^= 909522486);
                (E.sigBytes = A.sigBytes = v), this.reset();
              },
              reset: function () {
                var u = this._hasher;
                u.reset(), u.update(this._iKey);
              },
              update: function (u) {
                return this._hasher.update(u), this;
              },
              finalize: function (u) {
                var d = this._hasher,
                  m = d.finalize(u);
                d.reset();
                var v = d.finalize(this._oKey.clone().concat(m));
                return v;
              },
            });
          })();
        });
      })(T3)),
    T3.exports
  );
}
var C3 = {
    exports: {},
  },
  YS;
function Zoe() {
  return (
    YS ||
      ((YS = 1),
      (function (t, e) {
        (function (r, n, i) {
          t.exports = n(Vt(), wE(), _E());
        })(ke, function (r) {
          return (
            (function () {
              var n = r,
                i = n.lib,
                a = i.Base,
                s = i.WordArray,
                o = n.algo,
                c = o.SHA1,
                u = o.HMAC,
                d = (o.PBKDF2 = a.extend({
                  cfg: a.extend({
                    keySize: 128 / 32,
                    hasher: c,
                    iterations: 1,
                  }),
                  init: function (m) {
                    this.cfg = this.cfg.extend(m);
                  },
                  compute: function (m, v) {
                    for (
                      var E = this.cfg,
                        A = u.create(E.hasher, m),
                        I = s.create(),
                        b = s.create([1]),
                        w = I.words,
                        S = b.words,
                        k = E.keySize,
                        N = E.iterations;
                      w.length < k;

                    ) {
                      var O = A.update(v).finalize(b);
                      A.reset();
                      for (
                        var F = O.words, V = F.length, j = O, X = 1;
                        X < N;
                        X++
                      ) {
                        (j = A.finalize(j)), A.reset();
                        for (var C = j.words, l = 0; l < V; l++) F[l] ^= C[l];
                      }
                      I.concat(O), S[0]++;
                    }
                    return (I.sigBytes = k * 4), I;
                  },
                }));
              n.PBKDF2 = function (m, v, E) {
                return d.create(E).compute(m, v);
              };
            })(),
            r.PBKDF2
          );
        });
      })(C3)),
    C3.exports
  );
}
var A3 = {
    exports: {},
  },
  XS;
function Lu() {
  return (
    XS ||
      ((XS = 1),
      (function (t, e) {
        (function (r, n, i) {
          t.exports = n(Vt(), wE(), _E());
        })(ke, function (r) {
          return (
            (function () {
              var n = r,
                i = n.lib,
                a = i.Base,
                s = i.WordArray,
                o = n.algo,
                c = o.MD5,
                u = (o.EvpKDF = a.extend({
                  cfg: a.extend({
                    keySize: 128 / 32,
                    hasher: c,
                    iterations: 1,
                  }),
                  init: function (d) {
                    this.cfg = this.cfg.extend(d);
                  },
                  compute: function (d, m) {
                    for (
                      var v = this.cfg,
                        E = v.hasher.create(),
                        A = s.create(),
                        I = A.words,
                        b = v.keySize,
                        w = v.iterations;
                      I.length < b;

                    ) {
                      S && E.update(S);
                      var S = E.update(d).finalize(m);
                      E.reset();
                      for (var k = 1; k < w; k++)
                        (S = E.finalize(S)), E.reset();
                      A.concat(S);
                    }
                    return (A.sigBytes = b * 4), A;
                  },
                }));
              n.EvpKDF = function (d, m, v) {
                return u.create(v).compute(d, m);
              };
            })(),
            r.EvpKDF
          );
        });
      })(A3)),
    A3.exports
  );
}
var k3 = {
    exports: {},
  },
  e7;
function ei() {
  return (
    e7 ||
      ((e7 = 1),
      (function (t, e) {
        (function (r, n, i) {
          t.exports = n(Vt(), Lu());
        })(ke, function (r) {
          r.lib.Cipher ||
            (function (n) {
              var i = r,
                a = i.lib,
                s = a.Base,
                o = a.WordArray,
                c = a.BufferedBlockAlgorithm,
                u = i.enc;
              u.Utf8;
              var d = u.Base64,
                m = i.algo,
                v = m.EvpKDF,
                E = (a.Cipher = c.extend({
                  cfg: s.extend(),
                  createEncryptor: function (C, l) {
                    return this.create(this._ENC_XFORM_MODE, C, l);
                  },
                  createDecryptor: function (C, l) {
                    return this.create(this._DEC_XFORM_MODE, C, l);
                  },
                  init: function (C, l, p) {
                    (this.cfg = this.cfg.extend(p)),
                      (this._xformMode = C),
                      (this._key = l),
                      this.reset();
                  },
                  reset: function () {
                    c.reset.call(this), this._doReset();
                  },
                  process: function (C) {
                    return this._append(C), this._process();
                  },
                  finalize: function (C) {
                    C && this._append(C);
                    var l = this._doFinalize();
                    return l;
                  },
                  keySize: 128 / 32,
                  ivSize: 128 / 32,
                  _ENC_XFORM_MODE: 1,
                  _DEC_XFORM_MODE: 2,
                  _createHelper: (function () {
                    function C(l) {
                      return typeof l == "string" ? X : F;
                    }
                    return function (l) {
                      return {
                        encrypt: function (p, y, h) {
                          return C(y).encrypt(l, p, y, h);
                        },
                        decrypt: function (p, y, h) {
                          return C(y).decrypt(l, p, y, h);
                        },
                      };
                    };
                  })(),
                }));
              a.StreamCipher = E.extend({
                _doFinalize: function () {
                  var C = this._process(!0);
                  return C;
                },
                blockSize: 1,
              });
              var A = (i.mode = {}),
                I = (a.BlockCipherMode = s.extend({
                  createEncryptor: function (C, l) {
                    return this.Encryptor.create(C, l);
                  },
                  createDecryptor: function (C, l) {
                    return this.Decryptor.create(C, l);
                  },
                  init: function (C, l) {
                    (this._cipher = C), (this._iv = l);
                  },
                })),
                b = (A.CBC = (function () {
                  var C = I.extend();
                  (C.Encryptor = C.extend({
                    processBlock: function (p, y) {
                      var h = this._cipher,
                        g = h.blockSize;
                      l.call(this, p, y, g),
                        h.encryptBlock(p, y),
                        (this._prevBlock = p.slice(y, y + g));
                    },
                  })),
                    (C.Decryptor = C.extend({
                      processBlock: function (p, y) {
                        var h = this._cipher,
                          g = h.blockSize,
                          T = p.slice(y, y + g);
                        h.decryptBlock(p, y),
                          l.call(this, p, y, g),
                          (this._prevBlock = T);
                      },
                    }));
                  function l(p, y, h) {
                    var g = this._iv;
                    if (g) {
                      var T = g;
                      this._iv = n;
                    } else var T = this._prevBlock;
                    for (var R = 0; R < h; R++) p[y + R] ^= T[R];
                  }
                  return C;
                })()),
                w = (i.pad = {}),
                S = (w.Pkcs7 = {
                  pad: function (C, l) {
                    for (
                      var p = l * 4,
                        y = p - (C.sigBytes % p),
                        h = (y << 24) | (y << 16) | (y << 8) | y,
                        g = [],
                        T = 0;
                      T < y;
                      T += 4
                    )
                      g.push(h);
                    var R = o.create(g, y);
                    C.concat(R);
                  },
                  unpad: function (C) {
                    var l = C.words[(C.sigBytes - 1) >>> 2] & 255;
                    C.sigBytes -= l;
                  },
                });
              a.BlockCipher = E.extend({
                cfg: E.cfg.extend({
                  mode: b,
                  padding: S,
                }),
                reset: function () {
                  E.reset.call(this);
                  var C = this.cfg,
                    l = C.iv,
                    p = C.mode;
                  if (this._xformMode == this._ENC_XFORM_MODE)
                    var y = p.createEncryptor;
                  else {
                    var y = p.createDecryptor;
                    this._minBufferSize = 1;
                  }
                  this._mode && this._mode.__creator == y
                    ? this._mode.init(this, l && l.words)
                    : ((this._mode = y.call(p, this, l && l.words)),
                      (this._mode.__creator = y));
                },
                _doProcessBlock: function (C, l) {
                  this._mode.processBlock(C, l);
                },
                _doFinalize: function () {
                  var C = this.cfg.padding;
                  if (this._xformMode == this._ENC_XFORM_MODE) {
                    C.pad(this._data, this.blockSize);
                    var l = this._process(!0);
                  } else {
                    var l = this._process(!0);
                    C.unpad(l);
                  }
                  return l;
                },
                blockSize: 128 / 32,
              });
              var k = (a.CipherParams = s.extend({
                  init: function (C) {
                    this.mixIn(C);
                  },
                  toString: function (C) {
                    return (C || this.formatter).stringify(this);
                  },
                })),
                N = (i.format = {}),
                O = (N.OpenSSL = {
                  stringify: function (C) {
                    var l = C.ciphertext,
                      p = C.salt;
                    if (p)
                      var y = o
                        .create([1398893684, 1701076831])
                        .concat(p)
                        .concat(l);
                    else var y = l;
                    return y.toString(d);
                  },
                  parse: function (C) {
                    var l = d.parse(C),
                      p = l.words;
                    if (p[0] == 1398893684 && p[1] == 1701076831) {
                      var y = o.create(p.slice(2, 4));
                      p.splice(0, 4), (l.sigBytes -= 16);
                    }
                    return k.create({
                      ciphertext: l,
                      salt: y,
                    });
                  },
                }),
                F = (a.SerializableCipher = s.extend({
                  cfg: s.extend({
                    format: O,
                  }),
                  encrypt: function (C, l, p, y) {
                    y = this.cfg.extend(y);
                    var h = C.createEncryptor(p, y),
                      g = h.finalize(l),
                      T = h.cfg;
                    return k.create({
                      ciphertext: g,
                      key: p,
                      iv: T.iv,
                      algorithm: C,
                      mode: T.mode,
                      padding: T.padding,
                      blockSize: C.blockSize,
                      formatter: y.format,
                    });
                  },
                  decrypt: function (C, l, p, y) {
                    (y = this.cfg.extend(y)), (l = this._parse(l, y.format));
                    var h = C.createDecryptor(p, y).finalize(l.ciphertext);
                    return h;
                  },
                  _parse: function (C, l) {
                    return typeof C == "string" ? l.parse(C, this) : C;
                  },
                })),
                V = (i.kdf = {}),
                j = (V.OpenSSL = {
                  execute: function (C, l, p, y) {
                    y || (y = o.random(64 / 8));
                    var h = v
                        .create({
                          keySize: l + p,
                        })
                        .compute(C, y),
                      g = o.create(h.words.slice(l), p * 4);
                    return (
                      (h.sigBytes = l * 4),
                      k.create({
                        key: h,
                        iv: g,
                        salt: y,
                      })
                    );
                  },
                }),
                X = (a.PasswordBasedCipher = F.extend({
                  cfg: F.cfg.extend({
                    kdf: j,
                  }),
                  encrypt: function (C, l, p, y) {
                    y = this.cfg.extend(y);
                    var h = y.kdf.execute(p, C.keySize, C.ivSize);
                    y.iv = h.iv;
                    var g = F.encrypt.call(this, C, l, h.key, y);
                    return g.mixIn(h), g;
                  },
                  decrypt: function (C, l, p, y) {
                    (y = this.cfg.extend(y)), (l = this._parse(l, y.format));
                    var h = y.kdf.execute(p, C.keySize, C.ivSize, l.salt);
                    y.iv = h.iv;
                    var g = F.decrypt.call(this, C, l, h.key, y);
                    return g;
                  },
                }));
            })();
        });
      })(k3)),
    k3.exports
  );
}
var S3 = {
    exports: {},
  },
  t7;
function Joe() {
  return (
    t7 ||
      ((t7 = 1),
      (function (t, e) {
        (function (r, n, i) {
          t.exports = n(Vt(), ei());
        })(ke, function (r) {
          return (
            (r.mode.CFB = (function () {
              var n = r.lib.BlockCipherMode.extend();
              (n.Encryptor = n.extend({
                processBlock: function (a, s) {
                  var o = this._cipher,
                    c = o.blockSize;
                  i.call(this, a, s, c, o),
                    (this._prevBlock = a.slice(s, s + c));
                },
              })),
                (n.Decryptor = n.extend({
                  processBlock: function (a, s) {
                    var o = this._cipher,
                      c = o.blockSize,
                      u = a.slice(s, s + c);
                    i.call(this, a, s, c, o), (this._prevBlock = u);
                  },
                }));
              function i(a, s, o, c) {
                var u = this._iv;
                if (u) {
                  var d = u.slice(0);
                  this._iv = void 0;
                } else var d = this._prevBlock;
                c.encryptBlock(d, 0);
                for (var m = 0; m < o; m++) a[s + m] ^= d[m];
              }
              return n;
            })()),
            r.mode.CFB
          );
        });
      })(S3)),
    S3.exports
  );
}
var M3 = {
    exports: {},
  },
  r7;
function Qoe() {
  return (
    r7 ||
      ((r7 = 1),
      (function (t, e) {
        (function (r, n, i) {
          t.exports = n(Vt(), ei());
        })(ke, function (r) {
          return (
            (r.mode.CTR = (function () {
              var n = r.lib.BlockCipherMode.extend(),
                i = (n.Encryptor = n.extend({
                  processBlock: function (a, s) {
                    var o = this._cipher,
                      c = o.blockSize,
                      u = this._iv,
                      d = this._counter;
                    u &&
                      ((d = this._counter = u.slice(0)), (this._iv = void 0));
                    var m = d.slice(0);
                    o.encryptBlock(m, 0), (d[c - 1] = (d[c - 1] + 1) | 0);
                    for (var v = 0; v < c; v++) a[s + v] ^= m[v];
                  },
                }));
              return (n.Decryptor = i), n;
            })()),
            r.mode.CTR
          );
        });
      })(M3)),
    M3.exports
  );
}
var I3 = {
    exports: {},
  },
  n7;
function Yoe() {
  return (
    n7 ||
      ((n7 = 1),
      (function (t, e) {
        (function (r, n, i) {
          t.exports = n(Vt(), ei());
        })(ke, function (r) {
          /** @preserve
           * Counter block mode compatible with  Dr Brian Gladman fileenc.c
           * derived from CryptoJS.mode.CTR
           * Jan Hruby jhruby.web@gmail.com
           */
          return (
            (r.mode.CTRGladman = (function () {
              var n = r.lib.BlockCipherMode.extend();
              function i(o) {
                if (((o >> 24) & 255) === 255) {
                  var c = (o >> 16) & 255,
                    u = (o >> 8) & 255,
                    d = o & 255;
                  c === 255
                    ? ((c = 0),
                      u === 255 ? ((u = 0), d === 255 ? (d = 0) : ++d) : ++u)
                    : ++c,
                    (o = 0),
                    (o += c << 16),
                    (o += u << 8),
                    (o += d);
                } else o += 1 << 24;
                return o;
              }
              function a(o) {
                return (o[0] = i(o[0])) === 0 && (o[1] = i(o[1])), o;
              }
              var s = (n.Encryptor = n.extend({
                processBlock: function (o, c) {
                  var u = this._cipher,
                    d = u.blockSize,
                    m = this._iv,
                    v = this._counter;
                  m && ((v = this._counter = m.slice(0)), (this._iv = void 0)),
                    a(v);
                  var E = v.slice(0);
                  u.encryptBlock(E, 0);
                  for (var A = 0; A < d; A++) o[c + A] ^= E[A];
                },
              }));
              return (n.Decryptor = s), n;
            })()),
            r.mode.CTRGladman
          );
        });
      })(I3)),
    I3.exports
  );
}
var R3 = {
    exports: {},
  },
  i7;
function Xoe() {
  return (
    i7 ||
      ((i7 = 1),
      (function (t, e) {
        (function (r, n, i) {
          t.exports = n(Vt(), ei());
        })(ke, function (r) {
          return (
            (r.mode.OFB = (function () {
              var n = r.lib.BlockCipherMode.extend(),
                i = (n.Encryptor = n.extend({
                  processBlock: function (a, s) {
                    var o = this._cipher,
                      c = o.blockSize,
                      u = this._iv,
                      d = this._keystream;
                    u &&
                      ((d = this._keystream = u.slice(0)), (this._iv = void 0)),
                      o.encryptBlock(d, 0);
                    for (var m = 0; m < c; m++) a[s + m] ^= d[m];
                  },
                }));
              return (n.Decryptor = i), n;
            })()),
            r.mode.OFB
          );
        });
      })(R3)),
    R3.exports
  );
}
var P3 = {
    exports: {},
  },
  a7;
function ece() {
  return (
    a7 ||
      ((a7 = 1),
      (function (t, e) {
        (function (r, n, i) {
          t.exports = n(Vt(), ei());
        })(ke, function (r) {
          return (
            (r.mode.ECB = (function () {
              var n = r.lib.BlockCipherMode.extend();
              return (
                (n.Encryptor = n.extend({
                  processBlock: function (i, a) {
                    this._cipher.encryptBlock(i, a);
                  },
                })),
                (n.Decryptor = n.extend({
                  processBlock: function (i, a) {
                    this._cipher.decryptBlock(i, a);
                  },
                })),
                n
              );
            })()),
            r.mode.ECB
          );
        });
      })(P3)),
    P3.exports
  );
}
var N3 = {
    exports: {},
  },
  s7;
function tce() {
  return (
    s7 ||
      ((s7 = 1),
      (function (t, e) {
        (function (r, n, i) {
          t.exports = n(Vt(), ei());
        })(ke, function (r) {
          return (
            (r.pad.AnsiX923 = {
              pad: function (n, i) {
                var a = n.sigBytes,
                  s = i * 4,
                  o = s - (a % s),
                  c = a + o - 1;
                n.clamp(),
                  (n.words[c >>> 2] |= o << (24 - (c % 4) * 8)),
                  (n.sigBytes += o);
              },
              unpad: function (n) {
                var i = n.words[(n.sigBytes - 1) >>> 2] & 255;
                n.sigBytes -= i;
              },
            }),
            r.pad.Ansix923
          );
        });
      })(N3)),
    N3.exports
  );
}
var B3 = {
    exports: {},
  },
  o7;
function rce() {
  return (
    o7 ||
      ((o7 = 1),
      (function (t, e) {
        (function (r, n, i) {
          t.exports = n(Vt(), ei());
        })(ke, function (r) {
          return (
            (r.pad.Iso10126 = {
              pad: function (n, i) {
                var a = i * 4,
                  s = a - (n.sigBytes % a);
                n.concat(r.lib.WordArray.random(s - 1)).concat(
                  r.lib.WordArray.create([s << 24], 1)
                );
              },
              unpad: function (n) {
                var i = n.words[(n.sigBytes - 1) >>> 2] & 255;
                n.sigBytes -= i;
              },
            }),
            r.pad.Iso10126
          );
        });
      })(B3)),
    B3.exports
  );
}
var D3 = {
    exports: {},
  },
  c7;
function nce() {
  return (
    c7 ||
      ((c7 = 1),
      (function (t, e) {
        (function (r, n, i) {
          t.exports = n(Vt(), ei());
        })(ke, function (r) {
          return (
            (r.pad.Iso97971 = {
              pad: function (n, i) {
                n.concat(r.lib.WordArray.create([2147483648], 1)),
                  r.pad.ZeroPadding.pad(n, i);
              },
              unpad: function (n) {
                r.pad.ZeroPadding.unpad(n), n.sigBytes--;
              },
            }),
            r.pad.Iso97971
          );
        });
      })(D3)),
    D3.exports
  );
}
var O3 = {
    exports: {},
  },
  l7;
function ice() {
  return (
    l7 ||
      ((l7 = 1),
      (function (t, e) {
        (function (r, n, i) {
          t.exports = n(Vt(), ei());
        })(ke, function (r) {
          return (
            (r.pad.ZeroPadding = {
              pad: function (n, i) {
                var a = i * 4;
                n.clamp(), (n.sigBytes += a - (n.sigBytes % a || a));
              },
              unpad: function (n) {
                for (
                  var i = n.words, a = n.sigBytes - 1;
                  !((i[a >>> 2] >>> (24 - (a % 4) * 8)) & 255);

                )
                  a--;
                n.sigBytes = a + 1;
              },
            }),
            r.pad.ZeroPadding
          );
        });
      })(O3)),
    O3.exports
  );
}
var F3 = {
    exports: {},
  },
  u7;
function ace() {
  return (
    u7 ||
      ((u7 = 1),
      (function (t, e) {
        (function (r, n, i) {
          t.exports = n(Vt(), ei());
        })(ke, function (r) {
          return (
            (r.pad.NoPadding = {
              pad: function () {},
              unpad: function () {},
            }),
            r.pad.NoPadding
          );
        });
      })(F3)),
    F3.exports
  );
}
var L3 = {
    exports: {},
  },
  f7;
function sce() {
  return (
    f7 ||
      ((f7 = 1),
      (function (t, e) {
        (function (r, n, i) {
          t.exports = n(Vt(), ei());
        })(ke, function (r) {
          return (
            (function (n) {
              var i = r,
                a = i.lib,
                s = a.CipherParams,
                o = i.enc,
                c = o.Hex,
                u = i.format;
              u.Hex = {
                stringify: function (d) {
                  return d.ciphertext.toString(c);
                },
                parse: function (d) {
                  var m = c.parse(d);
                  return s.create({
                    ciphertext: m,
                  });
                },
              };
            })(),
            r.format.Hex
          );
        });
      })(L3)),
    L3.exports
  );
}
var $3 = {
    exports: {},
  },
  d7;
function oce() {
  return (
    d7 ||
      ((d7 = 1),
      (function (t, e) {
        (function (r, n, i) {
          t.exports = n(Vt(), xd(), wd(), Lu(), ei());
        })(ke, function (r) {
          return (
            (function () {
              var n = r,
                i = n.lib,
                a = i.BlockCipher,
                s = n.algo,
                o = [],
                c = [],
                u = [],
                d = [],
                m = [],
                v = [],
                E = [],
                A = [],
                I = [],
                b = [];
              (function () {
                for (var k = [], N = 0; N < 256; N++)
                  N < 128 ? (k[N] = N << 1) : (k[N] = (N << 1) ^ 283);
                for (var O = 0, F = 0, N = 0; N < 256; N++) {
                  var V = F ^ (F << 1) ^ (F << 2) ^ (F << 3) ^ (F << 4);
                  (V = (V >>> 8) ^ (V & 255) ^ 99), (o[O] = V), (c[V] = O);
                  var j = k[O],
                    X = k[j],
                    C = k[X],
                    l = (k[V] * 257) ^ (V * 16843008);
                  (u[O] = (l << 24) | (l >>> 8)),
                    (d[O] = (l << 16) | (l >>> 16)),
                    (m[O] = (l << 8) | (l >>> 24)),
                    (v[O] = l);
                  var l =
                    (C * 16843009) ^ (X * 65537) ^ (j * 257) ^ (O * 16843008);
                  (E[V] = (l << 24) | (l >>> 8)),
                    (A[V] = (l << 16) | (l >>> 16)),
                    (I[V] = (l << 8) | (l >>> 24)),
                    (b[V] = l),
                    O
                      ? ((O = j ^ k[k[k[C ^ j]]]), (F ^= k[k[F]]))
                      : (O = F = 1);
                }
              })();
              var w = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54],
                S = (s.AES = a.extend({
                  _doReset: function () {
                    if (!(this._nRounds && this._keyPriorReset === this._key)) {
                      for (
                        var k = (this._keyPriorReset = this._key),
                          N = k.words,
                          O = k.sigBytes / 4,
                          F = (this._nRounds = O + 6),
                          V = (F + 1) * 4,
                          j = (this._keySchedule = []),
                          X = 0;
                        X < V;
                        X++
                      )
                        if (X < O) j[X] = N[X];
                        else {
                          var C = j[X - 1];
                          X % O
                            ? O > 6 &&
                              X % O == 4 &&
                              (C =
                                (o[C >>> 24] << 24) |
                                (o[(C >>> 16) & 255] << 16) |
                                (o[(C >>> 8) & 255] << 8) |
                                o[C & 255])
                            : ((C = (C << 8) | (C >>> 24)),
                              (C =
                                (o[C >>> 24] << 24) |
                                (o[(C >>> 16) & 255] << 16) |
                                (o[(C >>> 8) & 255] << 8) |
                                o[C & 255]),
                              (C ^= w[(X / O) | 0] << 24)),
                            (j[X] = j[X - O] ^ C);
                        }
                      for (
                        var l = (this._invKeySchedule = []), p = 0;
                        p < V;
                        p++
                      ) {
                        var X = V - p;
                        if (p % 4) var C = j[X];
                        else var C = j[X - 4];
                        p < 4 || X <= 4
                          ? (l[p] = C)
                          : (l[p] =
                              E[o[C >>> 24]] ^
                              A[o[(C >>> 16) & 255]] ^
                              I[o[(C >>> 8) & 255]] ^
                              b[o[C & 255]]);
                      }
                    }
                  },
                  encryptBlock: function (k, N) {
                    this._doCryptBlock(k, N, this._keySchedule, u, d, m, v, o);
                  },
                  decryptBlock: function (k, N) {
                    var O = k[N + 1];
                    (k[N + 1] = k[N + 3]),
                      (k[N + 3] = O),
                      this._doCryptBlock(
                        k,
                        N,
                        this._invKeySchedule,
                        E,
                        A,
                        I,
                        b,
                        c
                      );
                    var O = k[N + 1];
                    (k[N + 1] = k[N + 3]), (k[N + 3] = O);
                  },
                  _doCryptBlock: function (k, N, O, F, V, j, X, C) {
                    for (
                      var l = this._nRounds,
                        p = k[N] ^ O[0],
                        y = k[N + 1] ^ O[1],
                        h = k[N + 2] ^ O[2],
                        g = k[N + 3] ^ O[3],
                        T = 4,
                        R = 1;
                      R < l;
                      R++
                    ) {
                      var x =
                          F[p >>> 24] ^
                          V[(y >>> 16) & 255] ^
                          j[(h >>> 8) & 255] ^
                          X[g & 255] ^
                          O[T++],
                        f =
                          F[y >>> 24] ^
                          V[(h >>> 16) & 255] ^
                          j[(g >>> 8) & 255] ^
                          X[p & 255] ^
                          O[T++],
                        _ =
                          F[h >>> 24] ^
                          V[(g >>> 16) & 255] ^
                          j[(p >>> 8) & 255] ^
                          X[y & 255] ^
                          O[T++],
                        P =
                          F[g >>> 24] ^
                          V[(p >>> 16) & 255] ^
                          j[(y >>> 8) & 255] ^
                          X[h & 255] ^
                          O[T++];
                      (p = x), (y = f), (h = _), (g = P);
                    }
                    var x =
                        ((C[p >>> 24] << 24) |
                          (C[(y >>> 16) & 255] << 16) |
                          (C[(h >>> 8) & 255] << 8) |
                          C[g & 255]) ^
                        O[T++],
                      f =
                        ((C[y >>> 24] << 24) |
                          (C[(h >>> 16) & 255] << 16) |
                          (C[(g >>> 8) & 255] << 8) |
                          C[p & 255]) ^
                        O[T++],
                      _ =
                        ((C[h >>> 24] << 24) |
                          (C[(g >>> 16) & 255] << 16) |
                          (C[(p >>> 8) & 255] << 8) |
                          C[y & 255]) ^
                        O[T++],
                      P =
                        ((C[g >>> 24] << 24) |
                          (C[(p >>> 16) & 255] << 16) |
                          (C[(y >>> 8) & 255] << 8) |
                          C[h & 255]) ^
                        O[T++];
                    (k[N] = x), (k[N + 1] = f), (k[N + 2] = _), (k[N + 3] = P);
                  },
                  keySize: 256 / 32,
                }));
              n.AES = a._createHelper(S);
            })(),
            r.AES
          );
        });
      })($3)),
    $3.exports
  );
}
var U3 = {
    exports: {},
  },
  h7;
function cce() {
  return (
    h7 ||
      ((h7 = 1),
      (function (t, e) {
        (function (r, n, i) {
          t.exports = n(Vt(), xd(), wd(), Lu(), ei());
        })(ke, function (r) {
          return (
            (function () {
              var n = r,
                i = n.lib,
                a = i.WordArray,
                s = i.BlockCipher,
                o = n.algo,
                c = [
                  57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2,
                  59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39,
                  31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37,
                  29, 21, 13, 5, 28, 20, 12, 4,
                ],
                u = [
                  14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26,
                  8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51,
                  45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32,
                ],
                d = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28],
                m = [
                  {
                    0: 8421888,
                    268435456: 32768,
                    536870912: 8421378,
                    805306368: 2,
                    1073741824: 512,
                    1342177280: 8421890,
                    1610612736: 8389122,
                    1879048192: 8388608,
                    2147483648: 514,
                    2415919104: 8389120,
                    2684354560: 33280,
                    2952790016: 8421376,
                    3221225472: 32770,
                    3489660928: 8388610,
                    3758096384: 0,
                    4026531840: 33282,
                    134217728: 0,
                    402653184: 8421890,
                    671088640: 33282,
                    939524096: 32768,
                    1207959552: 8421888,
                    1476395008: 512,
                    1744830464: 8421378,
                    2013265920: 2,
                    2281701376: 8389120,
                    2550136832: 33280,
                    2818572288: 8421376,
                    3087007744: 8389122,
                    3355443200: 8388610,
                    3623878656: 32770,
                    3892314112: 514,
                    4160749568: 8388608,
                    1: 32768,
                    268435457: 2,
                    536870913: 8421888,
                    805306369: 8388608,
                    1073741825: 8421378,
                    1342177281: 33280,
                    1610612737: 512,
                    1879048193: 8389122,
                    2147483649: 8421890,
                    2415919105: 8421376,
                    2684354561: 8388610,
                    2952790017: 33282,
                    3221225473: 514,
                    3489660929: 8389120,
                    3758096385: 32770,
                    4026531841: 0,
                    134217729: 8421890,
                    402653185: 8421376,
                    671088641: 8388608,
                    939524097: 512,
                    1207959553: 32768,
                    1476395009: 8388610,
                    1744830465: 2,
                    2013265921: 33282,
                    2281701377: 32770,
                    2550136833: 8389122,
                    2818572289: 514,
                    3087007745: 8421888,
                    3355443201: 8389120,
                    3623878657: 0,
                    3892314113: 33280,
                    4160749569: 8421378,
                  },
                  {
                    0: 1074282512,
                    16777216: 16384,
                    33554432: 524288,
                    50331648: 1074266128,
                    67108864: 1073741840,
                    83886080: 1074282496,
                    100663296: 1073758208,
                    117440512: 16,
                    134217728: 540672,
                    150994944: 1073758224,
                    167772160: 1073741824,
                    184549376: 540688,
                    201326592: 524304,
                    218103808: 0,
                    234881024: 16400,
                    251658240: 1074266112,
                    8388608: 1073758208,
                    25165824: 540688,
                    41943040: 16,
                    58720256: 1073758224,
                    75497472: 1074282512,
                    92274688: 1073741824,
                    109051904: 524288,
                    125829120: 1074266128,
                    142606336: 524304,
                    159383552: 0,
                    176160768: 16384,
                    192937984: 1074266112,
                    209715200: 1073741840,
                    226492416: 540672,
                    243269632: 1074282496,
                    260046848: 16400,
                    268435456: 0,
                    285212672: 1074266128,
                    301989888: 1073758224,
                    318767104: 1074282496,
                    335544320: 1074266112,
                    352321536: 16,
                    369098752: 540688,
                    385875968: 16384,
                    402653184: 16400,
                    419430400: 524288,
                    436207616: 524304,
                    452984832: 1073741840,
                    469762048: 540672,
                    486539264: 1073758208,
                    503316480: 1073741824,
                    520093696: 1074282512,
                    276824064: 540688,
                    293601280: 524288,
                    310378496: 1074266112,
                    327155712: 16384,
                    343932928: 1073758208,
                    360710144: 1074282512,
                    377487360: 16,
                    394264576: 1073741824,
                    411041792: 1074282496,
                    427819008: 1073741840,
                    444596224: 1073758224,
                    461373440: 524304,
                    478150656: 0,
                    494927872: 16400,
                    511705088: 1074266128,
                    528482304: 540672,
                  },
                  {
                    0: 260,
                    1048576: 0,
                    2097152: 67109120,
                    3145728: 65796,
                    4194304: 65540,
                    5242880: 67108868,
                    6291456: 67174660,
                    7340032: 67174400,
                    8388608: 67108864,
                    9437184: 67174656,
                    10485760: 65792,
                    11534336: 67174404,
                    12582912: 67109124,
                    13631488: 65536,
                    14680064: 4,
                    15728640: 256,
                    524288: 67174656,
                    1572864: 67174404,
                    2621440: 0,
                    3670016: 67109120,
                    4718592: 67108868,
                    5767168: 65536,
                    6815744: 65540,
                    7864320: 260,
                    8912896: 4,
                    9961472: 256,
                    11010048: 67174400,
                    12058624: 65796,
                    13107200: 65792,
                    14155776: 67109124,
                    15204352: 67174660,
                    16252928: 67108864,
                    16777216: 67174656,
                    17825792: 65540,
                    18874368: 65536,
                    19922944: 67109120,
                    20971520: 256,
                    22020096: 67174660,
                    23068672: 67108868,
                    24117248: 0,
                    25165824: 67109124,
                    26214400: 67108864,
                    27262976: 4,
                    28311552: 65792,
                    29360128: 67174400,
                    30408704: 260,
                    31457280: 65796,
                    32505856: 67174404,
                    17301504: 67108864,
                    18350080: 260,
                    19398656: 67174656,
                    20447232: 0,
                    21495808: 65540,
                    22544384: 67109120,
                    23592960: 256,
                    24641536: 67174404,
                    25690112: 65536,
                    26738688: 67174660,
                    27787264: 65796,
                    28835840: 67108868,
                    29884416: 67109124,
                    30932992: 67174400,
                    31981568: 4,
                    33030144: 65792,
                  },
                  {
                    0: 2151682048,
                    65536: 2147487808,
                    131072: 4198464,
                    196608: 2151677952,
                    262144: 0,
                    327680: 4198400,
                    393216: 2147483712,
                    458752: 4194368,
                    524288: 2147483648,
                    589824: 4194304,
                    655360: 64,
                    720896: 2147487744,
                    786432: 2151678016,
                    851968: 4160,
                    917504: 4096,
                    983040: 2151682112,
                    32768: 2147487808,
                    98304: 64,
                    163840: 2151678016,
                    229376: 2147487744,
                    294912: 4198400,
                    360448: 2151682112,
                    425984: 0,
                    491520: 2151677952,
                    557056: 4096,
                    622592: 2151682048,
                    688128: 4194304,
                    753664: 4160,
                    819200: 2147483648,
                    884736: 4194368,
                    950272: 4198464,
                    1015808: 2147483712,
                    1048576: 4194368,
                    1114112: 4198400,
                    1179648: 2147483712,
                    1245184: 0,
                    1310720: 4160,
                    1376256: 2151678016,
                    1441792: 2151682048,
                    1507328: 2147487808,
                    1572864: 2151682112,
                    1638400: 2147483648,
                    1703936: 2151677952,
                    1769472: 4198464,
                    1835008: 2147487744,
                    1900544: 4194304,
                    1966080: 64,
                    2031616: 4096,
                    1081344: 2151677952,
                    1146880: 2151682112,
                    1212416: 0,
                    1277952: 4198400,
                    1343488: 4194368,
                    1409024: 2147483648,
                    1474560: 2147487808,
                    1540096: 64,
                    1605632: 2147483712,
                    1671168: 4096,
                    1736704: 2147487744,
                    1802240: 2151678016,
                    1867776: 4160,
                    1933312: 2151682048,
                    1998848: 4194304,
                    2064384: 4198464,
                  },
                  {
                    0: 128,
                    4096: 17039360,
                    8192: 262144,
                    12288: 536870912,
                    16384: 537133184,
                    20480: 16777344,
                    24576: 553648256,
                    28672: 262272,
                    32768: 16777216,
                    36864: 537133056,
                    40960: 536871040,
                    45056: 553910400,
                    49152: 553910272,
                    53248: 0,
                    57344: 17039488,
                    61440: 553648128,
                    2048: 17039488,
                    6144: 553648256,
                    10240: 128,
                    14336: 17039360,
                    18432: 262144,
                    22528: 537133184,
                    26624: 553910272,
                    30720: 536870912,
                    34816: 537133056,
                    38912: 0,
                    43008: 553910400,
                    47104: 16777344,
                    51200: 536871040,
                    55296: 553648128,
                    59392: 16777216,
                    63488: 262272,
                    65536: 262144,
                    69632: 128,
                    73728: 536870912,
                    77824: 553648256,
                    81920: 16777344,
                    86016: 553910272,
                    90112: 537133184,
                    94208: 16777216,
                    98304: 553910400,
                    102400: 553648128,
                    106496: 17039360,
                    110592: 537133056,
                    114688: 262272,
                    118784: 536871040,
                    122880: 0,
                    126976: 17039488,
                    67584: 553648256,
                    71680: 16777216,
                    75776: 17039360,
                    79872: 537133184,
                    83968: 536870912,
                    88064: 17039488,
                    92160: 128,
                    96256: 553910272,
                    100352: 262272,
                    104448: 553910400,
                    108544: 0,
                    112640: 553648128,
                    116736: 16777344,
                    120832: 262144,
                    124928: 537133056,
                    129024: 536871040,
                  },
                  {
                    0: 268435464,
                    256: 8192,
                    512: 270532608,
                    768: 270540808,
                    1024: 268443648,
                    1280: 2097152,
                    1536: 2097160,
                    1792: 268435456,
                    2048: 0,
                    2304: 268443656,
                    2560: 2105344,
                    2816: 8,
                    3072: 270532616,
                    3328: 2105352,
                    3584: 8200,
                    3840: 270540800,
                    128: 270532608,
                    384: 270540808,
                    640: 8,
                    896: 2097152,
                    1152: 2105352,
                    1408: 268435464,
                    1664: 268443648,
                    1920: 8200,
                    2176: 2097160,
                    2432: 8192,
                    2688: 268443656,
                    2944: 270532616,
                    3200: 0,
                    3456: 270540800,
                    3712: 2105344,
                    3968: 268435456,
                    4096: 268443648,
                    4352: 270532616,
                    4608: 270540808,
                    4864: 8200,
                    5120: 2097152,
                    5376: 268435456,
                    5632: 268435464,
                    5888: 2105344,
                    6144: 2105352,
                    6400: 0,
                    6656: 8,
                    6912: 270532608,
                    7168: 8192,
                    7424: 268443656,
                    7680: 270540800,
                    7936: 2097160,
                    4224: 8,
                    4480: 2105344,
                    4736: 2097152,
                    4992: 268435464,
                    5248: 268443648,
                    5504: 8200,
                    5760: 270540808,
                    6016: 270532608,
                    6272: 270540800,
                    6528: 270532616,
                    6784: 8192,
                    7040: 2105352,
                    7296: 2097160,
                    7552: 0,
                    7808: 268435456,
                    8064: 268443656,
                  },
                  {
                    0: 1048576,
                    16: 33555457,
                    32: 1024,
                    48: 1049601,
                    64: 34604033,
                    80: 0,
                    96: 1,
                    112: 34603009,
                    128: 33555456,
                    144: 1048577,
                    160: 33554433,
                    176: 34604032,
                    192: 34603008,
                    208: 1025,
                    224: 1049600,
                    240: 33554432,
                    8: 34603009,
                    24: 0,
                    40: 33555457,
                    56: 34604032,
                    72: 1048576,
                    88: 33554433,
                    104: 33554432,
                    120: 1025,
                    136: 1049601,
                    152: 33555456,
                    168: 34603008,
                    184: 1048577,
                    200: 1024,
                    216: 34604033,
                    232: 1,
                    248: 1049600,
                    256: 33554432,
                    272: 1048576,
                    288: 33555457,
                    304: 34603009,
                    320: 1048577,
                    336: 33555456,
                    352: 34604032,
                    368: 1049601,
                    384: 1025,
                    400: 34604033,
                    416: 1049600,
                    432: 1,
                    448: 0,
                    464: 34603008,
                    480: 33554433,
                    496: 1024,
                    264: 1049600,
                    280: 33555457,
                    296: 34603009,
                    312: 1,
                    328: 33554432,
                    344: 1048576,
                    360: 1025,
                    376: 34604032,
                    392: 33554433,
                    408: 34603008,
                    424: 0,
                    440: 34604033,
                    456: 1049601,
                    472: 1024,
                    488: 33555456,
                    504: 1048577,
                  },
                  {
                    0: 134219808,
                    1: 131072,
                    2: 134217728,
                    3: 32,
                    4: 131104,
                    5: 134350880,
                    6: 134350848,
                    7: 2048,
                    8: 134348800,
                    9: 134219776,
                    10: 133120,
                    11: 134348832,
                    12: 2080,
                    13: 0,
                    14: 134217760,
                    15: 133152,
                    2147483648: 2048,
                    2147483649: 134350880,
                    2147483650: 134219808,
                    2147483651: 134217728,
                    2147483652: 134348800,
                    2147483653: 133120,
                    2147483654: 133152,
                    2147483655: 32,
                    2147483656: 134217760,
                    2147483657: 2080,
                    2147483658: 131104,
                    2147483659: 134350848,
                    2147483660: 0,
                    2147483661: 134348832,
                    2147483662: 134219776,
                    2147483663: 131072,
                    16: 133152,
                    17: 134350848,
                    18: 32,
                    19: 2048,
                    20: 134219776,
                    21: 134217760,
                    22: 134348832,
                    23: 131072,
                    24: 0,
                    25: 131104,
                    26: 134348800,
                    27: 134219808,
                    28: 134350880,
                    29: 133120,
                    30: 2080,
                    31: 134217728,
                    2147483664: 131072,
                    2147483665: 2048,
                    2147483666: 134348832,
                    2147483667: 133152,
                    2147483668: 32,
                    2147483669: 134348800,
                    2147483670: 134217728,
                    2147483671: 134219808,
                    2147483672: 134350880,
                    2147483673: 134217760,
                    2147483674: 134219776,
                    2147483675: 0,
                    2147483676: 133120,
                    2147483677: 2080,
                    2147483678: 131104,
                    2147483679: 134350848,
                  },
                ],
                v = [
                  4160749569, 528482304, 33030144, 2064384, 129024, 8064, 504,
                  2147483679,
                ],
                E = (o.DES = s.extend({
                  _doReset: function () {
                    for (
                      var w = this._key, S = w.words, k = [], N = 0;
                      N < 56;
                      N++
                    ) {
                      var O = c[N] - 1;
                      k[N] = (S[O >>> 5] >>> (31 - (O % 32))) & 1;
                    }
                    for (var F = (this._subKeys = []), V = 0; V < 16; V++) {
                      for (var j = (F[V] = []), X = d[V], N = 0; N < 24; N++)
                        (j[(N / 6) | 0] |=
                          k[(u[N] - 1 + X) % 28] << (31 - (N % 6))),
                          (j[4 + ((N / 6) | 0)] |=
                            k[28 + ((u[N + 24] - 1 + X) % 28)] <<
                            (31 - (N % 6)));
                      j[0] = (j[0] << 1) | (j[0] >>> 31);
                      for (var N = 1; N < 7; N++)
                        j[N] = j[N] >>> ((N - 1) * 4 + 3);
                      j[7] = (j[7] << 5) | (j[7] >>> 27);
                    }
                    for (var C = (this._invSubKeys = []), N = 0; N < 16; N++)
                      C[N] = F[15 - N];
                  },
                  encryptBlock: function (w, S) {
                    this._doCryptBlock(w, S, this._subKeys);
                  },
                  decryptBlock: function (w, S) {
                    this._doCryptBlock(w, S, this._invSubKeys);
                  },
                  _doCryptBlock: function (w, S, k) {
                    (this._lBlock = w[S]),
                      (this._rBlock = w[S + 1]),
                      A.call(this, 4, 252645135),
                      A.call(this, 16, 65535),
                      I.call(this, 2, 858993459),
                      I.call(this, 8, 16711935),
                      A.call(this, 1, 1431655765);
                    for (var N = 0; N < 16; N++) {
                      for (
                        var O = k[N],
                          F = this._lBlock,
                          V = this._rBlock,
                          j = 0,
                          X = 0;
                        X < 8;
                        X++
                      )
                        j |= m[X][((V ^ O[X]) & v[X]) >>> 0];
                      (this._lBlock = V), (this._rBlock = F ^ j);
                    }
                    var C = this._lBlock;
                    (this._lBlock = this._rBlock),
                      (this._rBlock = C),
                      A.call(this, 1, 1431655765),
                      I.call(this, 8, 16711935),
                      I.call(this, 2, 858993459),
                      A.call(this, 16, 65535),
                      A.call(this, 4, 252645135),
                      (w[S] = this._lBlock),
                      (w[S + 1] = this._rBlock);
                  },
                  keySize: 64 / 32,
                  ivSize: 64 / 32,
                  blockSize: 64 / 32,
                }));
              function A(w, S) {
                var k = ((this._lBlock >>> w) ^ this._rBlock) & S;
                (this._rBlock ^= k), (this._lBlock ^= k << w);
              }
              function I(w, S) {
                var k = ((this._rBlock >>> w) ^ this._lBlock) & S;
                (this._lBlock ^= k), (this._rBlock ^= k << w);
              }
              n.DES = s._createHelper(E);
              var b = (o.TripleDES = s.extend({
                _doReset: function () {
                  var w = this._key,
                    S = w.words;
                  (this._des1 = E.createEncryptor(a.create(S.slice(0, 2)))),
                    (this._des2 = E.createEncryptor(a.create(S.slice(2, 4)))),
                    (this._des3 = E.createEncryptor(a.create(S.slice(4, 6))));
                },
                encryptBlock: function (w, S) {
                  this._des1.encryptBlock(w, S),
                    this._des2.decryptBlock(w, S),
                    this._des3.encryptBlock(w, S);
                },
                decryptBlock: function (w, S) {
                  this._des3.decryptBlock(w, S),
                    this._des2.encryptBlock(w, S),
                    this._des1.decryptBlock(w, S);
                },
                keySize: 192 / 32,
                ivSize: 64 / 32,
                blockSize: 64 / 32,
              }));
              n.TripleDES = s._createHelper(b);
            })(),
            r.TripleDES
          );
        });
      })(U3)),
    U3.exports
  );
}
var W3 = {
    exports: {},
  },
  p7;
function lce() {
  return (
    p7 ||
      ((p7 = 1),
      (function (t, e) {
        (function (r, n, i) {
          t.exports = n(Vt(), xd(), wd(), Lu(), ei());
        })(ke, function (r) {
          return (
            (function () {
              var n = r,
                i = n.lib,
                a = i.StreamCipher,
                s = n.algo,
                o = (s.RC4 = a.extend({
                  _doReset: function () {
                    for (
                      var d = this._key,
                        m = d.words,
                        v = d.sigBytes,
                        E = (this._S = []),
                        A = 0;
                      A < 256;
                      A++
                    )
                      E[A] = A;
                    for (var A = 0, I = 0; A < 256; A++) {
                      var b = A % v,
                        w = (m[b >>> 2] >>> (24 - (b % 4) * 8)) & 255;
                      I = (I + E[A] + w) % 256;
                      var S = E[A];
                      (E[A] = E[I]), (E[I] = S);
                    }
                    this._i = this._j = 0;
                  },
                  _doProcessBlock: function (d, m) {
                    d[m] ^= c.call(this);
                  },
                  keySize: 256 / 32,
                  ivSize: 0,
                }));
              function c() {
                for (
                  var d = this._S, m = this._i, v = this._j, E = 0, A = 0;
                  A < 4;
                  A++
                ) {
                  (m = (m + 1) % 256), (v = (v + d[m]) % 256);
                  var I = d[m];
                  (d[m] = d[v]),
                    (d[v] = I),
                    (E |= d[(d[m] + d[v]) % 256] << (24 - A * 8));
                }
                return (this._i = m), (this._j = v), E;
              }
              n.RC4 = a._createHelper(o);
              var u = (s.RC4Drop = o.extend({
                cfg: o.cfg.extend({
                  drop: 192,
                }),
                _doReset: function () {
                  o._doReset.call(this);
                  for (var d = this.cfg.drop; d > 0; d--) c.call(this);
                },
              }));
              n.RC4Drop = a._createHelper(u);
            })(),
            r.RC4
          );
        });
      })(W3)),
    W3.exports
  );
}
var j3 = {
    exports: {},
  },
  m7;
function uce() {
  return (
    m7 ||
      ((m7 = 1),
      (function (t, e) {
        (function (r, n, i) {
          t.exports = n(Vt(), xd(), wd(), Lu(), ei());
        })(ke, function (r) {
          return (
            (function () {
              var n = r,
                i = n.lib,
                a = i.StreamCipher,
                s = n.algo,
                o = [],
                c = [],
                u = [],
                d = (s.Rabbit = a.extend({
                  _doReset: function () {
                    for (
                      var v = this._key.words, E = this.cfg.iv, A = 0;
                      A < 4;
                      A++
                    )
                      v[A] =
                        (((v[A] << 8) | (v[A] >>> 24)) & 16711935) |
                        (((v[A] << 24) | (v[A] >>> 8)) & 4278255360);
                    var I = (this._X = [
                        v[0],
                        (v[3] << 16) | (v[2] >>> 16),
                        v[1],
                        (v[0] << 16) | (v[3] >>> 16),
                        v[2],
                        (v[1] << 16) | (v[0] >>> 16),
                        v[3],
                        (v[2] << 16) | (v[1] >>> 16),
                      ]),
                      b = (this._C = [
                        (v[2] << 16) | (v[2] >>> 16),
                        (v[0] & 4294901760) | (v[1] & 65535),
                        (v[3] << 16) | (v[3] >>> 16),
                        (v[1] & 4294901760) | (v[2] & 65535),
                        (v[0] << 16) | (v[0] >>> 16),
                        (v[2] & 4294901760) | (v[3] & 65535),
                        (v[1] << 16) | (v[1] >>> 16),
                        (v[3] & 4294901760) | (v[0] & 65535),
                      ]);
                    this._b = 0;
                    for (var A = 0; A < 4; A++) m.call(this);
                    for (var A = 0; A < 8; A++) b[A] ^= I[(A + 4) & 7];
                    if (E) {
                      var w = E.words,
                        S = w[0],
                        k = w[1],
                        N =
                          (((S << 8) | (S >>> 24)) & 16711935) |
                          (((S << 24) | (S >>> 8)) & 4278255360),
                        O =
                          (((k << 8) | (k >>> 24)) & 16711935) |
                          (((k << 24) | (k >>> 8)) & 4278255360),
                        F = (N >>> 16) | (O & 4294901760),
                        V = (O << 16) | (N & 65535);
                      (b[0] ^= N),
                        (b[1] ^= F),
                        (b[2] ^= O),
                        (b[3] ^= V),
                        (b[4] ^= N),
                        (b[5] ^= F),
                        (b[6] ^= O),
                        (b[7] ^= V);
                      for (var A = 0; A < 4; A++) m.call(this);
                    }
                  },
                  _doProcessBlock: function (v, E) {
                    var A = this._X;
                    m.call(this),
                      (o[0] = A[0] ^ (A[5] >>> 16) ^ (A[3] << 16)),
                      (o[1] = A[2] ^ (A[7] >>> 16) ^ (A[5] << 16)),
                      (o[2] = A[4] ^ (A[1] >>> 16) ^ (A[7] << 16)),
                      (o[3] = A[6] ^ (A[3] >>> 16) ^ (A[1] << 16));
                    for (var I = 0; I < 4; I++)
                      (o[I] =
                        (((o[I] << 8) | (o[I] >>> 24)) & 16711935) |
                        (((o[I] << 24) | (o[I] >>> 8)) & 4278255360)),
                        (v[E + I] ^= o[I]);
                  },
                  blockSize: 128 / 32,
                  ivSize: 64 / 32,
                }));
              function m() {
                for (var v = this._X, E = this._C, A = 0; A < 8; A++)
                  c[A] = E[A];
                (E[0] = (E[0] + 1295307597 + this._b) | 0),
                  (E[1] =
                    (E[1] + 3545052371 + (E[0] >>> 0 < c[0] >>> 0 ? 1 : 0)) |
                    0),
                  (E[2] =
                    (E[2] + 886263092 + (E[1] >>> 0 < c[1] >>> 0 ? 1 : 0)) | 0),
                  (E[3] =
                    (E[3] + 1295307597 + (E[2] >>> 0 < c[2] >>> 0 ? 1 : 0)) |
                    0),
                  (E[4] =
                    (E[4] + 3545052371 + (E[3] >>> 0 < c[3] >>> 0 ? 1 : 0)) |
                    0),
                  (E[5] =
                    (E[5] + 886263092 + (E[4] >>> 0 < c[4] >>> 0 ? 1 : 0)) | 0),
                  (E[6] =
                    (E[6] + 1295307597 + (E[5] >>> 0 < c[5] >>> 0 ? 1 : 0)) |
                    0),
                  (E[7] =
                    (E[7] + 3545052371 + (E[6] >>> 0 < c[6] >>> 0 ? 1 : 0)) |
                    0),
                  (this._b = E[7] >>> 0 < c[7] >>> 0 ? 1 : 0);
                for (var A = 0; A < 8; A++) {
                  var I = v[A] + E[A],
                    b = I & 65535,
                    w = I >>> 16,
                    S = ((((b * b) >>> 17) + b * w) >>> 15) + w * w,
                    k = (((I & 4294901760) * I) | 0) + (((I & 65535) * I) | 0);
                  u[A] = S ^ k;
                }
                (v[0] =
                  (u[0] +
                    ((u[7] << 16) | (u[7] >>> 16)) +
                    ((u[6] << 16) | (u[6] >>> 16))) |
                  0),
                  (v[1] = (u[1] + ((u[0] << 8) | (u[0] >>> 24)) + u[7]) | 0),
                  (v[2] =
                    (u[2] +
                      ((u[1] << 16) | (u[1] >>> 16)) +
                      ((u[0] << 16) | (u[0] >>> 16))) |
                    0),
                  (v[3] = (u[3] + ((u[2] << 8) | (u[2] >>> 24)) + u[1]) | 0),
                  (v[4] =
                    (u[4] +
                      ((u[3] << 16) | (u[3] >>> 16)) +
                      ((u[2] << 16) | (u[2] >>> 16))) |
                    0),
                  (v[5] = (u[5] + ((u[4] << 8) | (u[4] >>> 24)) + u[3]) | 0),
                  (v[6] =
                    (u[6] +
                      ((u[5] << 16) | (u[5] >>> 16)) +
                      ((u[4] << 16) | (u[4] >>> 16))) |
                    0),
                  (v[7] = (u[7] + ((u[6] << 8) | (u[6] >>> 24)) + u[5]) | 0);
              }
              n.Rabbit = a._createHelper(d);
            })(),
            r.Rabbit
          );
        });
      })(j3)),
    j3.exports
  );
}
var H3 = {
    exports: {},
  },
  y7;
function fce() {
  return (
    y7 ||
      ((y7 = 1),
      (function (t, e) {
        (function (r, n, i) {
          t.exports = n(Vt(), xd(), wd(), Lu(), ei());
        })(ke, function (r) {
          return (
            (function () {
              var n = r,
                i = n.lib,
                a = i.StreamCipher,
                s = n.algo,
                o = [],
                c = [],
                u = [],
                d = (s.RabbitLegacy = a.extend({
                  _doReset: function () {
                    var v = this._key.words,
                      E = this.cfg.iv,
                      A = (this._X = [
                        v[0],
                        (v[3] << 16) | (v[2] >>> 16),
                        v[1],
                        (v[0] << 16) | (v[3] >>> 16),
                        v[2],
                        (v[1] << 16) | (v[0] >>> 16),
                        v[3],
                        (v[2] << 16) | (v[1] >>> 16),
                      ]),
                      I = (this._C = [
                        (v[2] << 16) | (v[2] >>> 16),
                        (v[0] & 4294901760) | (v[1] & 65535),
                        (v[3] << 16) | (v[3] >>> 16),
                        (v[1] & 4294901760) | (v[2] & 65535),
                        (v[0] << 16) | (v[0] >>> 16),
                        (v[2] & 4294901760) | (v[3] & 65535),
                        (v[1] << 16) | (v[1] >>> 16),
                        (v[3] & 4294901760) | (v[0] & 65535),
                      ]);
                    this._b = 0;
                    for (var b = 0; b < 4; b++) m.call(this);
                    for (var b = 0; b < 8; b++) I[b] ^= A[(b + 4) & 7];
                    if (E) {
                      var w = E.words,
                        S = w[0],
                        k = w[1],
                        N =
                          (((S << 8) | (S >>> 24)) & 16711935) |
                          (((S << 24) | (S >>> 8)) & 4278255360),
                        O =
                          (((k << 8) | (k >>> 24)) & 16711935) |
                          (((k << 24) | (k >>> 8)) & 4278255360),
                        F = (N >>> 16) | (O & 4294901760),
                        V = (O << 16) | (N & 65535);
                      (I[0] ^= N),
                        (I[1] ^= F),
                        (I[2] ^= O),
                        (I[3] ^= V),
                        (I[4] ^= N),
                        (I[5] ^= F),
                        (I[6] ^= O),
                        (I[7] ^= V);
                      for (var b = 0; b < 4; b++) m.call(this);
                    }
                  },
                  _doProcessBlock: function (v, E) {
                    var A = this._X;
                    m.call(this),
                      (o[0] = A[0] ^ (A[5] >>> 16) ^ (A[3] << 16)),
                      (o[1] = A[2] ^ (A[7] >>> 16) ^ (A[5] << 16)),
                      (o[2] = A[4] ^ (A[1] >>> 16) ^ (A[7] << 16)),
                      (o[3] = A[6] ^ (A[3] >>> 16) ^ (A[1] << 16));
                    for (var I = 0; I < 4; I++)
                      (o[I] =
                        (((o[I] << 8) | (o[I] >>> 24)) & 16711935) |
                        (((o[I] << 24) | (o[I] >>> 8)) & 4278255360)),
                        (v[E + I] ^= o[I]);
                  },
                  blockSize: 128 / 32,
                  ivSize: 64 / 32,
                }));
              function m() {
                for (var v = this._X, E = this._C, A = 0; A < 8; A++)
                  c[A] = E[A];
                (E[0] = (E[0] + 1295307597 + this._b) | 0),
                  (E[1] =
                    (E[1] + 3545052371 + (E[0] >>> 0 < c[0] >>> 0 ? 1 : 0)) |
                    0),
                  (E[2] =
                    (E[2] + 886263092 + (E[1] >>> 0 < c[1] >>> 0 ? 1 : 0)) | 0),
                  (E[3] =
                    (E[3] + 1295307597 + (E[2] >>> 0 < c[2] >>> 0 ? 1 : 0)) |
                    0),
                  (E[4] =
                    (E[4] + 3545052371 + (E[3] >>> 0 < c[3] >>> 0 ? 1 : 0)) |
                    0),
                  (E[5] =
                    (E[5] + 886263092 + (E[4] >>> 0 < c[4] >>> 0 ? 1 : 0)) | 0),
                  (E[6] =
                    (E[6] + 1295307597 + (E[5] >>> 0 < c[5] >>> 0 ? 1 : 0)) |
                    0),
                  (E[7] =
                    (E[7] + 3545052371 + (E[6] >>> 0 < c[6] >>> 0 ? 1 : 0)) |
                    0),
                  (this._b = E[7] >>> 0 < c[7] >>> 0 ? 1 : 0);
                for (var A = 0; A < 8; A++) {
                  var I = v[A] + E[A],
                    b = I & 65535,
                    w = I >>> 16,
                    S = ((((b * b) >>> 17) + b * w) >>> 15) + w * w,
                    k = (((I & 4294901760) * I) | 0) + (((I & 65535) * I) | 0);
                  u[A] = S ^ k;
                }
                (v[0] =
                  (u[0] +
                    ((u[7] << 16) | (u[7] >>> 16)) +
                    ((u[6] << 16) | (u[6] >>> 16))) |
                  0),
                  (v[1] = (u[1] + ((u[0] << 8) | (u[0] >>> 24)) + u[7]) | 0),
                  (v[2] =
                    (u[2] +
                      ((u[1] << 16) | (u[1] >>> 16)) +
                      ((u[0] << 16) | (u[0] >>> 16))) |
                    0),
                  (v[3] = (u[3] + ((u[2] << 8) | (u[2] >>> 24)) + u[1]) | 0),
                  (v[4] =
                    (u[4] +
                      ((u[3] << 16) | (u[3] >>> 16)) +
                      ((u[2] << 16) | (u[2] >>> 16))) |
                    0),
                  (v[5] = (u[5] + ((u[4] << 8) | (u[4] >>> 24)) + u[3]) | 0),
                  (v[6] =
                    (u[6] +
                      ((u[5] << 16) | (u[5] >>> 16)) +
                      ((u[4] << 16) | (u[4] >>> 16))) |
                    0),
                  (v[7] = (u[7] + ((u[6] << 8) | (u[6] >>> 24)) + u[5]) | 0);
              }
              n.RabbitLegacy = a._createHelper(d);
            })(),
            r.RabbitLegacy
          );
        });
      })(H3)),
    H3.exports
  );
}
(function (t, e) {
  (function (r, n, i) {
    t.exports = n(
      Vt(),
      vv(),
      Hoe(),
      zoe(),
      xd(),
      wd(),
      wE(),
      bv,
      qoe(),
      sF(),
      Voe(),
      Koe(),
      Goe(),
      _E(),
      Zoe(),
      Lu(),
      ei(),
      Joe(),
      Qoe(),
      Yoe(),
      Xoe(),
      ece(),
      tce(),
      rce(),
      nce(),
      ice(),
      ace(),
      sce(),
      oce(),
      cce(),
      lce(),
      uce(),
      fce()
    );
  })(ke, function (r) {
    return r;
  });
})(aF);
var dce = aF.exports,
  hce =
    (ke && ke.__importDefault) ||
    function (t) {
      return t && t.__esModule
        ? t
        : {
            default: t,
          };
    };
Object.defineProperty(vd, "__esModule", {
  value: !0,
});
vd.Base = void 0;
const Ta = vo,
  z3 = hce(dce);
class vc {
  print() {
    vc.print(this);
  }
  _bufferIndexOf(e, r) {
    for (let n = 0; n < e.length; n++) if (r.equals(e[n])) return n;
    return -1;
  }
  static bufferify(e) {
    if (!Ta.Buffer.isBuffer(e)) {
      if (typeof e == "object" && e.words)
        return Ta.Buffer.from(e.toString(z3.default.enc.Hex), "hex");
      if (vc.isHexString(e)) return Ta.Buffer.from(e.replace(/^0x/, ""), "hex");
      if (typeof e == "string") return Ta.Buffer.from(e);
      if (typeof e == "number") {
        let r = e.toString();
        return r.length % 2 && (r = `0${r}`), Ta.Buffer.from(r, "hex");
      } else if (ArrayBuffer.isView(e))
        return Ta.Buffer.from(e.buffer, e.byteOffset, e.byteLength);
    }
    return e;
  }
  static isHexString(e) {
    return typeof e == "string" && /^(0x)?[0-9A-Fa-f]*$/.test(e);
  }
  static print(e) {
    console.log(e.toString());
  }
  bufferToHex(e, r = !0) {
    return vc.bufferToHex(e, r);
  }
  static bufferToHex(e, r = !0) {
    return `${r ? "0x" : ""}${(e || Ta.Buffer.alloc(0)).toString("hex")}`;
  }
  bufferify(e) {
    return vc.bufferify(e);
  }
  bufferifyFn(e) {
    return (r) => {
      const n = e(r);
      return Ta.Buffer.isBuffer(n)
        ? n
        : this._isHexString(n)
        ? Ta.Buffer.from(n.replace("0x", ""), "hex")
        : typeof n == "string"
        ? Ta.Buffer.from(n)
        : ArrayBuffer.isView(n)
        ? Ta.Buffer.from(n.buffer, n.byteOffset, n.byteLength)
        : Ta.Buffer.from(
            e(z3.default.enc.Hex.parse(r.toString("hex"))).toString(
              z3.default.enc.Hex
            ),
            "hex"
          );
    };
  }
  _isHexString(e) {
    return vc.isHexString(e);
  }
  _log2(e) {
    return e === 1 ? 0 : 1 + this._log2((e / 2) | 0);
  }
  _zip(e, r) {
    return e.map((n, i) => [n, r[i]]);
  }
}
vd.Base = vc;
vd.default = vc;
var xv =
  (ke && ke.__importDefault) ||
  function (t) {
    return t && t.__esModule
      ? t
      : {
          default: t,
        };
  };
Object.defineProperty(Um, "__esModule", {
  value: !0,
});
Um.MerkleTree = void 0;
const yr = vo,
  wo = xv(Woe),
  g7 = xv(bv),
  pce = xv(joe),
  mce = xv(vd);
class Pa extends mce.default {
  constructor(e, r = g7.default, n = {}) {
    if (
      (super(),
      (this.duplicateOdd = !1),
      (this.hashLeaves = !1),
      (this.isBitcoinTree = !1),
      (this.leaves = []),
      (this.layers = []),
      (this.sortLeaves = !1),
      (this.sortPairs = !1),
      (this.sort = !1),
      (this.fillDefaultHash = null),
      (this.isBitcoinTree = !!n.isBitcoinTree),
      (this.hashLeaves = !!n.hashLeaves),
      (this.sortLeaves = !!n.sortLeaves),
      (this.sortPairs = !!n.sortPairs),
      n.fillDefaultHash)
    )
      if (typeof n.fillDefaultHash == "function")
        this.fillDefaultHash = n.fillDefaultHash;
      else if (
        yr.Buffer.isBuffer(n.fillDefaultHash) ||
        typeof n.fillDefaultHash == "string"
      )
        this.fillDefaultHash = (i, a) => n.fillDefaultHash;
      else
        throw new Error(
          'method "fillDefaultHash" must be a function, Buffer, or string'
        );
    (this.sort = !!n.sort),
      this.sort && ((this.sortLeaves = !0), (this.sortPairs = !0)),
      (this.duplicateOdd = !!n.duplicateOdd),
      (this.hashFn = this.bufferifyFn(r)),
      this.processLeaves(e);
  }
  processLeaves(e) {
    if (
      (this.hashLeaves && (e = e.map(this.hashFn)),
      (this.leaves = e.map(this.bufferify)),
      this.sortLeaves && (this.leaves = this.leaves.sort(yr.Buffer.compare)),
      this.fillDefaultHash)
    )
      for (
        let r = 0;
        r < Math.pow(2, Math.ceil(Math.log2(this.leaves.length)));
        r++
      )
        r >= this.leaves.length &&
          this.leaves.push(
            this.bufferify(this.fillDefaultHash(r, this.hashFn))
          );
    (this.layers = [this.leaves]), this._createHashes(this.leaves);
  }
  _createHashes(e) {
    for (; e.length > 1; ) {
      const r = this.layers.length;
      this.layers.push([]);
      for (let n = 0; n < e.length; n += 2) {
        if (n + 1 === e.length && e.length % 2 === 1) {
          let u = e[e.length - 1],
            d = u;
          if (this.isBitcoinTree) {
            (u = yr.Buffer.concat([wo.default(u), wo.default(u)])),
              (d = this.hashFn(u)),
              (d = wo.default(this.hashFn(d))),
              this.layers[r].push(d);
            continue;
          } else if (!this.duplicateOdd) {
            this.layers[r].push(e[n]);
            continue;
          }
        }
        const i = e[n],
          a = n + 1 === e.length ? i : e[n + 1];
        let s = null,
          o = null;
        this.isBitcoinTree
          ? (o = [wo.default(i), wo.default(a)])
          : (o = [i, a]),
          this.sortPairs && o.sort(yr.Buffer.compare),
          (s = yr.Buffer.concat(o));
        let c = this.hashFn(s);
        this.isBitcoinTree && (c = wo.default(this.hashFn(c))),
          this.layers[r].push(c);
      }
      e = this.layers[r];
    }
  }
  addLeaf(e, r = !1) {
    r && (e = this.hashFn(e)), this.processLeaves(this.leaves.concat(e));
  }
  addLeaves(e, r = !1) {
    r && (e = e.map(this.hashFn)), this.processLeaves(this.leaves.concat(e));
  }
  getLeaves(e) {
    return Array.isArray(e)
      ? (this.hashLeaves &&
          ((e = e.map(this.hashFn)),
          this.sortLeaves && (e = e.sort(yr.Buffer.compare))),
        this.leaves.filter((r) => this._bufferIndexOf(e, r) !== -1))
      : this.leaves;
  }
  getLeaf(e) {
    return e < 0 || e > this.leaves.length - 1
      ? yr.Buffer.from([])
      : this.leaves[e];
  }
  getLeafIndex(e) {
    e = this.bufferify(e);
    const r = this.getLeaves();
    for (let n = 0; n < r.length; n++) if (r[n].equals(e)) return n;
    return -1;
  }
  getLeafCount() {
    return this.leaves.length;
  }
  getHexLeaves() {
    return this.leaves.map((e) => this.bufferToHex(e));
  }
  static marshalLeaves(e) {
    return JSON.stringify(
      e.map((r) => Pa.bufferToHex(r)),
      null,
      2
    );
  }
  static unmarshalLeaves(e) {
    let r = null;
    if (typeof e == "string") r = JSON.parse(e);
    else if (e instanceof Object) r = e;
    else throw new Error("Expected type of string or object");
    if (!r) return [];
    if (!Array.isArray(r)) throw new Error("Expected JSON string to be array");
    return r.map(Pa.bufferify);
  }
  getLayers() {
    return this.layers;
  }
  getHexLayers() {
    return this.layers.reduce(
      (e, r) => (
        Array.isArray(r)
          ? e.push(r.map((n) => this.bufferToHex(n)))
          : e.push(r),
        e
      ),
      []
    );
  }
  getLayersFlat() {
    const e = this.layers.reduce(
      (r, n) => (Array.isArray(n) ? r.unshift(...n) : r.unshift(n), r),
      []
    );
    return e.unshift(yr.Buffer.from([0])), e;
  }
  getHexLayersFlat() {
    return this.getLayersFlat().map((e) => this.bufferToHex(e));
  }
  getLayerCount() {
    return this.getLayers().length;
  }
  getRoot() {
    return this.layers.length === 0
      ? yr.Buffer.from([])
      : this.layers[this.layers.length - 1][0] || yr.Buffer.from([]);
  }
  getHexRoot() {
    return this.bufferToHex(this.getRoot());
  }
  getProof(e, r) {
    if (typeof e > "u") throw new Error("leaf is required");
    e = this.bufferify(e);
    const n = [];
    if (!Number.isInteger(r)) {
      r = -1;
      for (let i = 0; i < this.leaves.length; i++)
        yr.Buffer.compare(e, this.leaves[i]) === 0 && (r = i);
    }
    if (r <= -1) return [];
    for (let i = 0; i < this.layers.length; i++) {
      const a = this.layers[i],
        s = r % 2,
        o = s
          ? r - 1
          : this.isBitcoinTree &&
            r === a.length - 1 &&
            i < this.layers.length - 1
          ? r
          : r + 1;
      o < a.length &&
        n.push({
          position: s ? "left" : "right",
          data: a[o],
        }),
        (r = (r / 2) | 0);
    }
    return n;
  }
  getHexProof(e, r) {
    return this.getProof(e, r).map((n) => this.bufferToHex(n.data));
  }
  getPositionalHexProof(e, r) {
    return this.getProof(e, r).map((n) => [
      n.position === "left" ? 0 : 1,
      this.bufferToHex(n.data),
    ]);
  }
  static marshalProof(e) {
    const r = e.map((n) =>
      typeof n == "string"
        ? n
        : yr.Buffer.isBuffer(n)
        ? Pa.bufferToHex(n)
        : {
            position: n.position,
            data: Pa.bufferToHex(n.data),
          }
    );
    return JSON.stringify(r, null, 2);
  }
  static unmarshalProof(e) {
    let r = null;
    if (typeof e == "string") r = JSON.parse(e);
    else if (e instanceof Object) r = e;
    else throw new Error("Expected type of string or object");
    if (!r) return [];
    if (!Array.isArray(r)) throw new Error("Expected JSON string to be array");
    return r.map((n) => {
      if (typeof n == "string") return Pa.bufferify(n);
      if (n instanceof Object)
        return {
          position: n.position,
          data: Pa.bufferify(n.data),
        };
      throw new Error("Expected item to be of type string or object");
    });
  }
  getProofIndices(e, r) {
    const n = Math.pow(2, r);
    let i = new Set();
    for (const u of e) {
      let d = n + u;
      for (; d > 1; ) i.add(d ^ 1), (d = (d / 2) | 0);
    }
    const a = e.map((u) => n + u),
      s = Array.from(i)
        .sort((u, d) => u - d)
        .reverse();
    i = a.concat(s);
    const o = new Set(),
      c = [];
    for (let u of i)
      if (!o.has(u))
        for (c.push(u); u > 1 && (o.add(u), !!o.has(u ^ 1)); ) u = (u / 2) | 0;
    return c.filter((u) => !e.includes(u - n));
  }
  getProofIndicesForUnevenTree(e, r) {
    const n = Math.ceil(Math.log2(r)),
      i = [];
    for (let o = 0; o < n; o++)
      r % 2 !== 0 &&
        i.push({
          index: o,
          leavesCount: r,
        }),
        (r = Math.ceil(r / 2));
    const a = [];
    let s = e;
    for (let o = 0; o < n; o++) {
      let u = s
        .map((m) => (m % 2 === 0 ? m + 1 : m - 1))
        .filter((m) => !s.includes(m));
      const d = i.find(({ index: m }) => m === o);
      d && s.includes(d.leavesCount - 1) && (u = u.slice(0, -1)),
        a.push(u),
        (s = [
          ...new Set(
            s.map((m) =>
              m % 2 === 0 ? m / 2 : m % 2 === 0 ? (m + 1) / 2 : (m - 1) / 2
            )
          ),
        ]);
    }
    return a;
  }
  getMultiProof(e, r) {
    if (
      (r || ((r = e), (e = this.getLayersFlat())),
      this.isUnevenTree() && r.every(Number.isInteger))
    )
      return this.getMultiProofForUnevenTree(r);
    if (!r.every(Number.isInteger)) {
      let i = r;
      this.sortPairs && (i = i.sort(yr.Buffer.compare));
      let a = i
        .map((u) => this._bufferIndexOf(this.leaves, u))
        .sort((u, d) => (u === d ? 0 : u > d ? 1 : -1));
      if (!a.every((u) => u !== -1))
        throw new Error("Element does not exist in Merkle tree");
      const s = [],
        o = [];
      let c = [];
      for (let u = 0; u < this.layers.length; u++) {
        const d = this.layers[u];
        for (let m = 0; m < a.length; m++) {
          const v = a[m],
            E = this._getPairNode(d, v);
          s.push(d[v]), E && o.push(E), c.push((v / 2) | 0);
        }
        (a = c.filter((m, v, E) => E.indexOf(m) === v)), (c = []);
      }
      return o.filter((u) => !s.includes(u));
    }
    return this.getProofIndices(r, this._log2((e.length / 2) | 0)).map(
      (i) => e[i]
    );
  }
  getMultiProofForUnevenTree(e, r) {
    r || ((r = e), (e = this.getLayers()));
    let n = [],
      i = r;
    for (const a of e) {
      const s = [];
      for (const c of i) {
        if (c % 2 === 0) {
          const d = c + 1;
          if (!i.includes(d) && a[d]) {
            s.push(a[d]);
            continue;
          }
        }
        const u = c - 1;
        if (!i.includes(u) && a[u]) {
          s.push(a[u]);
          continue;
        }
      }
      n = n.concat(s);
      const o = new Set();
      for (const c of i) {
        if (c % 2 === 0) {
          o.add(c / 2);
          continue;
        }
        if (c % 2 === 0) {
          o.add((c + 1) / 2);
          continue;
        }
        o.add((c - 1) / 2);
      }
      i = Array.from(o);
    }
    return n;
  }
  getHexMultiProof(e, r) {
    return this.getMultiProof(e, r).map((n) => this.bufferToHex(n));
  }
  getProofFlags(e, r) {
    if (!Array.isArray(e) || e.length <= 0) throw new Error("Invalid Inputs!");
    let n;
    if (
      (e.every(Number.isInteger)
        ? (n = e.sort((o, c) => (o === c ? 0 : o > c ? 1 : -1)))
        : (n = e
            .map((o) => this._bufferIndexOf(this.leaves, o))
            .sort((o, c) => (o === c ? 0 : o > c ? 1 : -1))),
      !n.every((o) => o !== -1))
    )
      throw new Error("Element does not exist in Merkle tree");
    const i = r.map((o) => this.bufferify(o)),
      a = [],
      s = [];
    for (let o = 0; o < this.layers.length; o++) {
      const c = this.layers[o];
      n = n.reduce((u, d) => {
        if (!a.includes(c[d])) {
          const v = this._getPairNode(c, d),
            E = i.includes(c[d]) || i.includes(v);
          v && s.push(!E), a.push(c[d]), a.push(v);
        }
        return u.push((d / 2) | 0), u;
      }, []);
    }
    return s;
  }
  verify(e, r, n) {
    let i = this.bufferify(r);
    if (((n = this.bufferify(n)), !Array.isArray(e) || !r || !n)) return !1;
    for (let a = 0; a < e.length; a++) {
      const s = e[a];
      let o = null,
        c = null;
      if (typeof s == "string") (o = this.bufferify(s)), (c = !0);
      else if (Array.isArray(s)) (c = s[0] === 0), (o = this.bufferify(s[1]));
      else if (yr.Buffer.isBuffer(s)) (o = s), (c = !0);
      else if (s instanceof Object)
        (o = this.bufferify(s.data)), (c = s.position === "left");
      else throw new Error("Expected node to be of type string or object");
      const u = [];
      this.isBitcoinTree
        ? (u.push(wo.default(i)),
          u[c ? "unshift" : "push"](wo.default(o)),
          (i = this.hashFn(yr.Buffer.concat(u))),
          (i = wo.default(this.hashFn(i))))
        : this.sortPairs
        ? yr.Buffer.compare(i, o) === -1
          ? (u.push(i, o), (i = this.hashFn(yr.Buffer.concat(u))))
          : (u.push(o, i), (i = this.hashFn(yr.Buffer.concat(u))))
        : (u.push(i),
          u[c ? "unshift" : "push"](o),
          (i = this.hashFn(yr.Buffer.concat(u))));
    }
    return yr.Buffer.compare(i, n) === 0;
  }
  verifyMultiProof(e, r, n, i, a) {
    if (this.isUnevenTree())
      return this.verifyMultiProofForUnevenTree(e, r, n, i, a);
    const o = Math.ceil(Math.log2(i));
    (e = this.bufferify(e)),
      (n = n.map((m) => this.bufferify(m))),
      (a = a.map((m) => this.bufferify(m)));
    const c = {};
    for (const [m, v] of this._zip(r, n)) c[Math.pow(2, o) + m] = v;
    for (const [m, v] of this._zip(this.getProofIndices(r, o), a)) c[m] = v;
    let u = Object.keys(c)
      .map((m) => +m)
      .sort((m, v) => m - v);
    u = u.slice(0, u.length - 1);
    let d = 0;
    for (; d < u.length; ) {
      const m = u[d];
      if (m >= 2 && {}.hasOwnProperty.call(c, m ^ 1)) {
        let v = [c[m - (m % 2)], c[m - (m % 2) + 1]];
        this.sortPairs && (v = v.sort(yr.Buffer.compare));
        const E = v[1] ? this.hashFn(yr.Buffer.concat(v)) : v[0];
        (c[(m / 2) | 0] = E), u.push((m / 2) | 0);
      }
      d += 1;
    }
    return !r.length || ({}.hasOwnProperty.call(c, 1) && c[1].equals(e));
  }
  verifyMultiProofWithFlags(e, r, n, i) {
    (e = this.bufferify(e)),
      (r = r.map(this.bufferify)),
      (n = n.map(this.bufferify));
    const a = r.length,
      s = i.length,
      o = [];
    let c = 0,
      u = 0,
      d = 0;
    for (let m = 0; m < s; m++) {
      const v = i[m] ? (c < a ? r[c++] : o[u++]) : n[d++],
        E = c < a ? r[c++] : o[u++],
        A = [v, E].sort(yr.Buffer.compare);
      o[m] = this.hashFn(yr.Buffer.concat(A));
    }
    return yr.Buffer.compare(o[s - 1], e) === 0;
  }
  verifyMultiProofForUnevenTree(e, r, n, i, a) {
    (e = this.bufferify(e)),
      (n = n.map((o) => this.bufferify(o))),
      (a = a.map((o) => this.bufferify(o)));
    const s = this.calculateRootForUnevenTree(r, n, i, a);
    return e.equals(s);
  }
  getDepth() {
    return this.getLayers().length - 1;
  }
  getLayersAsObject() {
    const e = this.getLayers().map((n) =>
        n.map((i) => this.bufferToHex(i, !1))
      ),
      r = [];
    for (let n = 0; n < e.length; n++) {
      const i = [];
      for (let a = 0; a < e[n].length; a++) {
        const s = {
          [e[n][a]]: null,
        };
        if (r.length) {
          s[e[n][a]] = {};
          const o = r.shift(),
            c = Object.keys(o)[0];
          if (((s[e[n][a]][c] = o[c]), r.length)) {
            const u = r.shift(),
              d = Object.keys(u)[0];
            s[e[n][a]][d] = u[d];
          }
        }
        i.push(s);
      }
      r.push(...i);
    }
    return r[0];
  }
  static verify(e, r, n, i = g7.default, a = {}) {
    return new Pa([], i, a).verify(e, r, n);
  }
  static getMultiProof(e, r) {
    return new Pa([]).getMultiProof(e, r);
  }
  resetTree() {
    (this.leaves = []), (this.layers = []);
  }
  _getPairNode(e, r) {
    const n = r % 2 === 0 ? r + 1 : r - 1;
    return n < e.length ? e[n] : null;
  }
  _toTreeString() {
    const e = this.getLayersAsObject();
    return pce.default.asTree(e, !0);
  }
  toString() {
    return this._toTreeString();
  }
  isUnevenTree(e) {
    const r = (e == null ? void 0 : e.length) || this.getDepth();
    return !this.isPowOf2(r);
  }
  isPowOf2(e) {
    return e && !(e & (e - 1));
  }
  calculateRootForUnevenTree(e, r, n, i) {
    const a = this._zip(e, r).sort(([m], [v]) => m - v),
      s = a.map(([m]) => m),
      o = this.getProofIndicesForUnevenTree(s, n);
    let c = 0;
    const u = [];
    for (let m = 0; m < o.length; m++) {
      const v = o[m],
        E = c;
      (c += v.length), (u[m] = this._zip(v, i.slice(E, c)));
    }
    const d = [a];
    for (let m = 0; m < u.length; m++) {
      const v = u[m]
          .concat(d[m])
          .sort(([b], [w]) => b - w)
          .map(([, b]) => b),
        E = d[m].map(([b]) => b),
        A = [
          ...new Set(
            E.map((b) =>
              b % 2 === 0 ? b / 2 : b % 2 === 0 ? (b + 1) / 2 : (b - 1) / 2
            )
          ),
        ],
        I = [];
      for (let b = 0; b < A.length; b++) {
        const w = A[b],
          S = v[b * 2],
          k = v[b * 2 + 1],
          N = k ? this.hashFn(yr.Buffer.concat([S, k])) : S;
        I.push([w, N]);
      }
      d.push(I);
    }
    return d[d.length - 1][0][1];
  }
}
Um.MerkleTree = Pa;
typeof window < "u" && (window.MerkleTree = Pa);
Um.default = Pa;
var jm = {},
  oF =
    (ke && ke.__importDefault) ||
    function (t) {
      return t && t.__esModule
        ? t
        : {
            default: t,
          };
    };
Object.defineProperty(jm, "__esModule", {
  value: !0,
});
jm.MerkleMountainRange = void 0;
const ih = vo,
  yce = oF(bv),
  gce = oF(vd);
class cF extends gce.default {
  constructor(e = yce.default, r = [], n, i, a) {
    super(),
      (this.root = ih.Buffer.alloc(0)),
      (this.size = 0),
      (this.width = 0),
      (this.hashes = {}),
      (this.data = {}),
      (r = r.map(this.bufferify)),
      (this.hashFn = this.bufferifyFn(e)),
      (this.hashLeafFn = n),
      (this.peakBaggingFn = i),
      (this.hashBranchFn = a);
    for (const s of r) this.append(s);
  }
  append(e) {
    e = this.bufferify(e);
    const r = this.hashFn(e),
      n = this.bufferToHex(r);
    (!this.data[n] || this.bufferToHex(this.hashFn(this.data[n])) !== n) &&
      (this.data[n] = e);
    const i = this.hashLeaf(this.size + 1, r);
    (this.hashes[this.size + 1] = i), (this.width += 1);
    const a = this.getPeakIndexes(this.width);
    this.size = this.getSize(this.width);
    const s = [];
    for (let o = 0; o < a.length; o++) s[o] = this._getOrCreateNode(a[o]);
    this.root = this.peakBagging(this.width, s);
  }
  hashLeaf(e, r) {
    return (
      (r = this.bufferify(r)),
      this.hashLeafFn
        ? this.bufferify(this.hashLeafFn(e, r))
        : this.hashFn(ih.Buffer.concat([this.bufferify(e), r]))
    );
  }
  hashBranch(e, r, n) {
    return this.hashBranchFn
      ? this.bufferify(this.hashBranchFn(e, r, n))
      : this.hashFn(
          ih.Buffer.concat([
            this.bufferify(e),
            this.bufferify(r),
            this.bufferify(n),
          ])
        );
  }
  getPeaks() {
    const e = this.getPeakIndexes(this.width),
      r = [];
    for (let n = 0; n < e.length; n++) r[n] = this.hashes[e[n]];
    return r;
  }
  getLeafIndex(e) {
    return e % 2 === 1 ? this.getSize(e) : this.getSize(e - 1) + 1;
  }
  getPeakIndexes(e) {
    const r = this.numOfPeaks(e),
      n = [];
    let i = 0,
      a = 0;
    for (
      let s = 255;
      s > 0 &&
      !(
        e & (1 << (s - 1)) &&
        ((a = a + (1 << s) - 1), (n[i++] = a), n.length >= r)
      );
      s--
    );
    if (i !== n.length) throw new Error("invalid bit calculation");
    return n;
  }
  numOfPeaks(e) {
    let r = e,
      n = 0;
    for (; r > 0; ) r % 2 === 1 && n++, (r = r >> 1);
    return n;
  }
  peakBagging(e, r) {
    const n = this.getSize(e);
    if (this.numOfPeaks(e) !== r.length)
      throw new Error("received invalid number of peaks");
    return e === 0 && !r.length
      ? ih.Buffer.alloc(0)
      : this.peakBaggingFn
      ? this.bufferify(this.peakBaggingFn(n, r))
      : this.hashFn(
          ih.Buffer.concat([this.bufferify(n), ...r.map(this.bufferify)])
        );
  }
  getSize(e) {
    return (e << 1) - this.numOfPeaks(e);
  }
  getRoot() {
    return this.root;
  }
  getHexRoot() {
    return this.bufferToHex(this.getRoot());
  }
  getNode(e) {
    return this.hashes[e];
  }
  mountainHeight(e) {
    let r = 1;
    for (; 1 << r <= e + r; ) r++;
    return r - 1;
  }
  heightAt(e) {
    let r = e,
      n = 0,
      i = 0;
    for (; r > n; )
      (r -= (1 << i) - 1), (i = this.mountainHeight(r)), (n = (1 << i) - 1);
    return i - (n - r);
  }
  isLeaf(e) {
    return this.heightAt(e) === 1;
  }
  getChildren(e) {
    const r = e - (1 << (this.heightAt(e) - 1)),
      n = e - 1;
    if (r === n) throw new Error("not a parent");
    return [r, n];
  }
  getMerkleProof(e) {
    if (e > this.size) throw new Error("out of range");
    if (!this.isLeaf(e)) throw new Error("not a leaf");
    const r = this.root,
      n = this.width,
      i = this.getPeakIndexes(this.width),
      a = [];
    let s = 0;
    for (let m = 0; m < i.length; m++)
      (a[m] = this.hashes[i[m]]), i[m] >= e && s === 0 && (s = i[m]);
    let o = 0,
      c = 0,
      u = this.heightAt(s);
    const d = [];
    for (; s !== e; )
      u--,
        ([o, c] = this.getChildren(s)),
        (s = e <= o ? o : c),
        (d[u - 1] = this.hashes[e <= o ? c : o]);
    return {
      root: r,
      width: n,
      peakBagging: a,
      siblings: d,
    };
  }
  verify(e, r, n, i, a, s) {
    if (((i = this.bufferify(i)), this.getSize(r) < n))
      throw new Error("index is out of range");
    if (!e.equals(this.peakBagging(r, a)))
      throw new Error("invalid root hash from the peaks");
    let c = 0,
      u;
    const d = this.getPeakIndexes(r);
    for (let b = 0; b < d.length; b++)
      if (d[b] >= n) {
        (u = a[b]), (c = d[b]);
        break;
      }
    if (!u) throw new Error("target not found");
    let m = s.length + 1;
    const v = new Array(m);
    let E = 0,
      A = 0;
    for (; m > 0 && ((v[--m] = c), c !== n); )
      ([E, A] = this.getChildren(c)), (c = n > E ? A : E);
    let I;
    for (; m < v.length; )
      (c = v[m]),
        m === 0
          ? (I = this.hashLeaf(c, this.hashFn(i)))
          : c - 1 === v[m - 1]
          ? (I = this.hashBranch(c, s[m - 1], I))
          : (I = this.hashBranch(c, I, s[m - 1])),
        m++;
    if (!I.equals(u)) throw new Error("hashed peak is invalid");
    return !0;
  }
  peaksToPeakMap(e, r) {
    const n = {};
    let i = 0,
      a = 0,
      s = r.length;
    for (let o = 1; o <= 32; o++)
      (i = 32 - o), (a = 1 << (o - 1)), e & a ? (n[i] = r[--s]) : (n[i] = 0);
    if (s !== 0) throw new Error("invalid number of peaks");
    return n;
  }
  peakMapToPeaks(e, r) {
    const n = this.numOfPeaks(e),
      i = new Array(n);
    let a = 0;
    for (let s = 0; s < 32; s++) r[s] !== 0 && (i[a++] = r[s]);
    if (a !== n) throw new Error("invalid number of peaks");
    return i;
  }
  peakUpdate(e, r, n) {
    const i = {},
      a = e + 1;
    let s = this.getLeafIndex(a),
      o = this.hashLeaf(s, n),
      c = 0,
      u = 0,
      d = !1,
      m = !1,
      v = !1;
    for (let E = 1; E <= 32; E++)
      (c = 32 - E),
        v
          ? (i[c] = r[c])
          : ((u = 1 << (E - 1)),
            (d = (e & u) !== 0),
            (m = (a & u) !== 0),
            s++,
            d && (o = this.hashBranch(s, r[c], o)),
            m ? (d ? (i[c] = r[c]) : (i[c] = o), (v = !0)) : (i[c] = 0));
    return i;
  }
  rollUp(e, r, n, i) {
    if (!e.equals(this.peakBagging(r, n)))
      throw new Error("invalid root hash from the peaks");
    let a = r,
      s = this.peaksToPeakMap(r, n);
    for (let o = 0; o < i.length; o++) (s = this.peakUpdate(a, s, i[o])), a++;
    return this.peakBagging(a, this.peakMapToPeaks(a, s));
  }
  _getOrCreateNode(e) {
    if (e > this.size) throw new Error("out of range");
    if (!this.hashes[e]) {
      const [r, n] = this.getChildren(e),
        i = this._getOrCreateNode(r),
        a = this._getOrCreateNode(n);
      this.hashes[e] = this.hashBranch(e, i, a);
    }
    return this.hashes[e];
  }
}
jm.MerkleMountainRange = cF;
jm.default = cF;
(function (t) {
  var e =
    (ke && ke.__importDefault) ||
    function (i) {
      return i && i.__esModule
        ? i
        : {
            default: i,
          };
    };
  Object.defineProperty(t, "__esModule", {
    value: !0,
  }),
    (t.MerkleTree = void 0);
  const r = e(Um);
  t.MerkleTree = r.default;
  var n = jm;
  Object.defineProperty(t, "MerkleMountainRange", {
    enumerable: !0,
    get: function () {
      return n.MerkleMountainRange;
    },
  }),
    (t.default = r.default);
})(Xy);
const lF = [
    {
      inputs: [],
      name: "contractType",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32",
        },
      ],
      stateMutability: "pure",
      type: "function",
    },
    {
      inputs: [],
      name: "contractURI",
      outputs: [
        {
          internalType: "string",
          name: "",
          type: "string",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "contractVersion",
      outputs: [
        {
          internalType: "uint8",
          name: "",
          type: "uint8",
        },
      ],
      stateMutability: "pure",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "string",
          name: "_uri",
          type: "string",
        },
      ],
      name: "setContractURI",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  bce = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "index",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "string",
          name: "revealedURI",
          type: "string",
        },
      ],
      name: "TokenURIRevealed",
      type: "event",
    },
    {
      inputs: [
        {
          internalType: "bytes",
          name: "data",
          type: "bytes",
        },
        {
          internalType: "bytes",
          name: "key",
          type: "bytes",
        },
      ],
      name: "encryptDecrypt",
      outputs: [
        {
          internalType: "bytes",
          name: "result",
          type: "bytes",
        },
      ],
      stateMutability: "pure",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "identifier",
          type: "uint256",
        },
      ],
      name: "encryptedBaseURI",
      outputs: [
        {
          internalType: "bytes",
          name: "",
          type: "bytes",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "identifier",
          type: "uint256",
        },
        {
          internalType: "bytes",
          name: "key",
          type: "bytes",
        },
      ],
      name: "reveal",
      outputs: [
        {
          internalType: "string",
          name: "revealedURI",
          type: "string",
        },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  ti = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "_owner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "_operator",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "bool",
          name: "_approved",
          type: "bool",
        },
      ],
      name: "ApprovalForAll",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "_operator",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "_from",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "_to",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256[]",
          name: "_ids",
          type: "uint256[]",
        },
        {
          indexed: !1,
          internalType: "uint256[]",
          name: "_values",
          type: "uint256[]",
        },
      ],
      name: "TransferBatch",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "_operator",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "_from",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "_to",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "_id",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "_value",
          type: "uint256",
        },
      ],
      name: "TransferSingle",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "string",
          name: "_value",
          type: "string",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "_id",
          type: "uint256",
        },
      ],
      name: "URI",
      type: "event",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_owner",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "_id",
          type: "uint256",
        },
      ],
      name: "balanceOf",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address[]",
          name: "_owners",
          type: "address[]",
        },
        {
          internalType: "uint256[]",
          name: "_ids",
          type: "uint256[]",
        },
      ],
      name: "balanceOfBatch",
      outputs: [
        {
          internalType: "uint256[]",
          name: "",
          type: "uint256[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_owner",
          type: "address",
        },
        {
          internalType: "address",
          name: "_operator",
          type: "address",
        },
      ],
      name: "isApprovedForAll",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_from",
          type: "address",
        },
        {
          internalType: "address",
          name: "_to",
          type: "address",
        },
        {
          internalType: "uint256[]",
          name: "_ids",
          type: "uint256[]",
        },
        {
          internalType: "uint256[]",
          name: "_values",
          type: "uint256[]",
        },
        {
          internalType: "bytes",
          name: "_data",
          type: "bytes",
        },
      ],
      name: "safeBatchTransferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_from",
          type: "address",
        },
        {
          internalType: "address",
          name: "_to",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "_id",
          type: "uint256",
        },
        {
          internalType: "uint256",
          name: "_value",
          type: "uint256",
        },
        {
          internalType: "bytes",
          name: "_data",
          type: "bytes",
        },
      ],
      name: "safeTransferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_operator",
          type: "address",
        },
        {
          internalType: "bool",
          name: "_approved",
          type: "bool",
        },
      ],
      name: "setApprovalForAll",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  yn = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "approved",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "Approval",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "bool",
          name: "approved",
          type: "bool",
        },
      ],
      name: "ApprovalForAll",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "from",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "to",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "Transfer",
      type: "event",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "to",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "approve",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "owner",
          type: "address",
        },
      ],
      name: "balanceOf",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "getApproved",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          internalType: "address",
          name: "operator",
          type: "address",
        },
      ],
      name: "isApprovedForAll",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "ownerOf",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "from",
          type: "address",
        },
        {
          internalType: "address",
          name: "to",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "safeTransferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "from",
          type: "address",
        },
        {
          internalType: "address",
          name: "to",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          internalType: "bytes",
          name: "data",
          type: "bytes",
        },
      ],
      name: "safeTransferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          internalType: "bool",
          name: "_approved",
          type: "bool",
        },
      ],
      name: "setApprovalForAll",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "from",
          type: "address",
        },
        {
          internalType: "address",
          name: "to",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "transferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  EE = [
    {
      inputs: [
        {
          internalType: "address",
          name: "_trustedForwarder",
          type: "address",
        },
        {
          internalType: "contract IContractPublisher",
          name: "_prevPublisher",
          type: "address",
        },
      ],
      stateMutability: "nonpayable",
      type: "constructor",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "publisher",
          type: "address",
        },
        {
          components: [
            {
              internalType: "string",
              name: "contractId",
              type: "string",
            },
            {
              internalType: "uint256",
              name: "publishTimestamp",
              type: "uint256",
            },
            {
              internalType: "string",
              name: "publishMetadataUri",
              type: "string",
            },
            {
              internalType: "bytes32",
              name: "bytecodeHash",
              type: "bytes32",
            },
            {
              internalType: "address",
              name: "implementation",
              type: "address",
            },
          ],
          indexed: !1,
          internalType: "struct IContractPublisher.CustomContractInstance",
          name: "publishedContract",
          type: "tuple",
        },
      ],
      name: "ContractPublished",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "publisher",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "string",
          name: "contractId",
          type: "string",
        },
      ],
      name: "ContractUnpublished",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "bool",
          name: "isPaused",
          type: "bool",
        },
      ],
      name: "Paused",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "publisher",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "string",
          name: "prevURI",
          type: "string",
        },
        {
          indexed: !1,
          internalType: "string",
          name: "newURI",
          type: "string",
        },
      ],
      name: "PublisherProfileUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          indexed: !0,
          internalType: "bytes32",
          name: "previousAdminRole",
          type: "bytes32",
        },
        {
          indexed: !0,
          internalType: "bytes32",
          name: "newAdminRole",
          type: "bytes32",
        },
      ],
      name: "RoleAdminChanged",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "account",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "sender",
          type: "address",
        },
      ],
      name: "RoleGranted",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "account",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "sender",
          type: "address",
        },
      ],
      name: "RoleRevoked",
      type: "event",
    },
    {
      inputs: [],
      name: "DEFAULT_ADMIN_ROLE",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_publisher",
          type: "address",
        },
      ],
      name: "getAllPublishedContracts",
      outputs: [
        {
          components: [
            {
              internalType: "string",
              name: "contractId",
              type: "string",
            },
            {
              internalType: "uint256",
              name: "publishTimestamp",
              type: "uint256",
            },
            {
              internalType: "string",
              name: "publishMetadataUri",
              type: "string",
            },
            {
              internalType: "bytes32",
              name: "bytecodeHash",
              type: "bytes32",
            },
            {
              internalType: "address",
              name: "implementation",
              type: "address",
            },
          ],
          internalType: "struct IContractPublisher.CustomContractInstance[]",
          name: "published",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_publisher",
          type: "address",
        },
        {
          internalType: "string",
          name: "_contractId",
          type: "string",
        },
      ],
      name: "getPublishedContract",
      outputs: [
        {
          components: [
            {
              internalType: "string",
              name: "contractId",
              type: "string",
            },
            {
              internalType: "uint256",
              name: "publishTimestamp",
              type: "uint256",
            },
            {
              internalType: "string",
              name: "publishMetadataUri",
              type: "string",
            },
            {
              internalType: "bytes32",
              name: "bytecodeHash",
              type: "bytes32",
            },
            {
              internalType: "address",
              name: "implementation",
              type: "address",
            },
          ],
          internalType: "struct IContractPublisher.CustomContractInstance",
          name: "published",
          type: "tuple",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_publisher",
          type: "address",
        },
        {
          internalType: "string",
          name: "_contractId",
          type: "string",
        },
      ],
      name: "getPublishedContractVersions",
      outputs: [
        {
          components: [
            {
              internalType: "string",
              name: "contractId",
              type: "string",
            },
            {
              internalType: "uint256",
              name: "publishTimestamp",
              type: "uint256",
            },
            {
              internalType: "string",
              name: "publishMetadataUri",
              type: "string",
            },
            {
              internalType: "bytes32",
              name: "bytecodeHash",
              type: "bytes32",
            },
            {
              internalType: "address",
              name: "implementation",
              type: "address",
            },
          ],
          internalType: "struct IContractPublisher.CustomContractInstance[]",
          name: "published",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "string",
          name: "compilerMetadataUri",
          type: "string",
        },
      ],
      name: "getPublishedUriFromCompilerUri",
      outputs: [
        {
          internalType: "string[]",
          name: "publishedMetadataUris",
          type: "string[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "publisher",
          type: "address",
        },
      ],
      name: "getPublisherProfileUri",
      outputs: [
        {
          internalType: "string",
          name: "uri",
          type: "string",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
      ],
      name: "getRoleAdmin",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          internalType: "uint256",
          name: "index",
          type: "uint256",
        },
      ],
      name: "getRoleMember",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
      ],
      name: "getRoleMemberCount",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          internalType: "address",
          name: "account",
          type: "address",
        },
      ],
      name: "grantRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          internalType: "address",
          name: "account",
          type: "address",
        },
      ],
      name: "hasRole",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "isPaused",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "forwarder",
          type: "address",
        },
      ],
      name: "isTrustedForwarder",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes[]",
          name: "data",
          type: "bytes[]",
        },
      ],
      name: "multicall",
      outputs: [
        {
          internalType: "bytes[]",
          name: "results",
          type: "bytes[]",
        },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "prevPublisher",
      outputs: [
        {
          internalType: "contract IContractPublisher",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_publisher",
          type: "address",
        },
        {
          internalType: "string",
          name: "_contractId",
          type: "string",
        },
        {
          internalType: "string",
          name: "_publishMetadataUri",
          type: "string",
        },
        {
          internalType: "string",
          name: "_compilerMetadataUri",
          type: "string",
        },
        {
          internalType: "bytes32",
          name: "_bytecodeHash",
          type: "bytes32",
        },
        {
          internalType: "address",
          name: "_implementation",
          type: "address",
        },
      ],
      name: "publishContract",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          internalType: "address",
          name: "account",
          type: "address",
        },
      ],
      name: "renounceRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          internalType: "address",
          name: "account",
          type: "address",
        },
      ],
      name: "revokeRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bool",
          name: "_pause",
          type: "bool",
        },
      ],
      name: "setPause",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "publisher",
          type: "address",
        },
        {
          internalType: "string",
          name: "uri",
          type: "string",
        },
      ],
      name: "setPublisherProfileUri",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "interfaceId",
          type: "bytes4",
        },
      ],
      name: "supportsInterface",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_publisher",
          type: "address",
        },
        {
          internalType: "string",
          name: "_contractId",
          type: "string",
        },
      ],
      name: "unpublishContract",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ];
var vce = {
    chain: "ETH",
    chainId: 1,
    explorers: [
      {
        name: "etherscan",
        url: "https://etherscan.io",
        standard: "EIP3091",
      },
      {
        name: "blockscout",
        url: "https://eth.blockscout.com",
        standard: "EIP3091",
      },
    ],
    faucets: [],
    features: [
      {
        name: "EIP1559",
      },
      {
        name: "EIP155",
      },
    ],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/ethereum/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://ethereum.org",
    name: "Ethereum Mainnet",
    nativeCurrency: {
      name: "Ether",
      symbol: "ETH",
      decimals: 18,
    },
    redFlags: [],
    rpc: [
      "https://ethereum.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://mainnet.infura.io/v3/${INFURA_API_KEY}",
      "wss://mainnet.infura.io/ws/v3/${INFURA_API_KEY}",
      "https://eth-mainnet.g.alchemy.com/v2/${ALCHEMY_API_KEY}",
      "https://api.mycryptoapi.com/eth",
      "https://cloudflare-eth.com",
      "https://ethereum.publicnode.com",
      "wss://ethereum.publicnode.com",
      "https://mainnet.gateway.tenderly.co",
      "wss://mainnet.gateway.tenderly.co",
    ],
    shortName: "eth",
    slug: "ethereum",
    testnet: !1,
  },
  xce = {
    chain: "ETH",
    chainId: 5,
    explorers: [
      {
        name: "etherscan-goerli",
        url: "https://goerli.etherscan.io",
        standard: "EIP3091",
      },
      {
        name: "blockscout-goerli",
        url: "https://eth-goerli.blockscout.com",
        standard: "EIP3091",
      },
    ],
    faucets: [
      "https://faucet.paradigm.xyz/",
      "http://fauceth.komputing.org?chain=5&address=${ADDRESS}",
      "https://goerli-faucet.slock.it?address=${ADDRESS}",
      "https://faucet.goerli.mudit.blog",
    ],
    features: [],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/ethereum/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://goerli.net/#about",
    name: "Goerli",
    nativeCurrency: {
      name: "Goerli Ether",
      symbol: "ETH",
      decimals: 18,
    },
    redFlags: [],
    rpc: [
      "https://goerli.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://goerli.infura.io/v3/${INFURA_API_KEY}",
      "wss://goerli.infura.io/v3/${INFURA_API_KEY}",
      "https://eth-goerli.g.alchemy.com/v2/${ALCHEMY_API_KEY}",
      "https://rpc.goerli.mudit.blog/",
      "https://ethereum-goerli.publicnode.com",
      "wss://ethereum-goerli.publicnode.com",
      "https://goerli.gateway.tenderly.co",
      "wss://goerli.gateway.tenderly.co",
    ],
    shortName: "gor",
    slug: "goerli",
    testnet: !0,
  },
  wce = {
    chain: "ETH",
    chainId: 10,
    explorers: [
      {
        name: "etherscan",
        url: "https://optimistic.etherscan.io",
        standard: "EIP3091",
      },
      {
        name: "blockscout",
        url: "https://optimism.blockscout.com",
        standard: "EIP3091",
      },
    ],
    faucets: [],
    features: [],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/optimism/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://optimism.io",
    name: "OP Mainnet",
    nativeCurrency: {
      name: "Ether",
      symbol: "ETH",
      decimals: 18,
    },
    redFlags: [],
    rpc: [
      "https://optimism.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://optimism-mainnet.infura.io/v3/${INFURA_API_KEY}",
      "https://opt-mainnet.g.alchemy.com/v2/${ALCHEMY_API_KEY}",
      "https://mainnet.optimism.io",
      "https://optimism.publicnode.com",
      "wss://optimism.publicnode.com",
      "https://optimism.gateway.tenderly.co",
      "wss://optimism.gateway.tenderly.co",
    ],
    shortName: "oeth",
    slug: "optimism",
    testnet: !1,
  },
  _ce = {
    chain: "BSC",
    chainId: 56,
    explorers: [
      {
        name: "bscscan",
        url: "https://bscscan.com",
        standard: "EIP3091",
      },
    ],
    faucets: [],
    features: [],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/binance-coin/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://www.bnbchain.org/en",
    name: "BNB Smart Chain Mainnet",
    nativeCurrency: {
      name: "BNB Chain Native Token",
      symbol: "BNB",
      decimals: 18,
    },
    redFlags: [],
    rpc: [
      "https://binance.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "wss://bsc-ws-node.nariox.org",
      "wss://bsc.publicnode.com",
      "https://bsc.publicnode.com",
      "https://bsc-dataseed4.ninicoin.io",
      "https://bsc-dataseed3.ninicoin.io",
      "https://bsc-dataseed2.ninicoin.io",
      "https://bsc-dataseed1.ninicoin.io",
      "https://bsc-dataseed4.defibit.io",
      "https://bsc-dataseed3.defibit.io",
      "https://bsc-dataseed2.defibit.io",
      "https://bsc-dataseed1.defibit.io",
      "https://bsc-dataseed4.bnbchain.org",
      "https://bsc-dataseed3.bnbchain.org",
      "https://bsc-dataseed2.bnbchain.org",
      "https://bsc-dataseed1.bnbchain.org",
    ],
    shortName: "bnb",
    slug: "binance",
    testnet: !1,
  },
  Ece = {
    chain: "BSC",
    chainId: 97,
    explorers: [
      {
        name: "bscscan-testnet",
        url: "https://testnet.bscscan.com",
        standard: "EIP3091",
      },
    ],
    faucets: ["https://testnet.bnbchain.org/faucet-smart"],
    features: [],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/binance-coin/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://www.bnbchain.org/en",
    name: "BNB Smart Chain Testnet",
    nativeCurrency: {
      name: "BNB Chain Native Token",
      symbol: "BNB",
      decimals: 18,
    },
    redFlags: [],
    rpc: [
      "https://binance-testnet.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "wss://bsc-testnet.publicnode.com",
      "https://bsc-testnet.publicnode.com",
      "https://data-seed-prebsc-2-s3.bnbchain.org:8545",
      "https://data-seed-prebsc-1-s3.bnbchain.org:8545",
      "https://data-seed-prebsc-2-s2.bnbchain.org:8545",
      "https://data-seed-prebsc-1-s2.bnbchain.org:8545",
      "https://data-seed-prebsc-2-s1.bnbchain.org:8545",
      "https://data-seed-prebsc-1-s1.bnbchain.org:8545",
    ],
    shortName: "bnbt",
    slug: "binance-testnet",
    testnet: !0,
  },
  TE = {
    chain: "Polygon",
    chainId: 137,
    explorers: [
      {
        name: "polygonscan",
        url: "https://polygonscan.com",
        standard: "EIP3091",
      },
    ],
    faucets: [],
    features: [],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/polygon/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://polygon.technology/",
    name: "Polygon Mainnet",
    nativeCurrency: {
      name: "MATIC",
      symbol: "MATIC",
      decimals: 18,
    },
    redFlags: [],
    rpc: [
      "https://polygon.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://polygon-mainnet.infura.io/v3/${INFURA_API_KEY}",
      "https://polygon-mainnet.g.alchemy.com/v2/${ALCHEMY_API_KEY}",
      "https://polygon-rpc.com/",
      "https://rpc-mainnet.matic.network",
      "https://matic-mainnet.chainstacklabs.com",
      "https://rpc-mainnet.maticvigil.com",
      "https://rpc-mainnet.matic.quiknode.pro",
      "https://matic-mainnet-full-rpc.bwarelabs.com",
      "https://polygon-bor.publicnode.com",
      "wss://polygon-bor.publicnode.com",
      "https://polygon.gateway.tenderly.co",
      "wss://polygon.gateway.tenderly.co",
    ],
    shortName: "matic",
    slug: "polygon",
    testnet: !1,
  },
  Tce = {
    chain: "FTM",
    chainId: 250,
    explorers: [
      {
        name: "ftmscan",
        url: "https://ftmscan.com",
        standard: "EIP3091",
      },
    ],
    faucets: [],
    features: [],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/fantom/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://fantom.foundation",
    name: "Fantom Opera",
    nativeCurrency: {
      name: "Fantom",
      symbol: "FTM",
      decimals: 18,
    },
    redFlags: [],
    rpc: [
      "https://fantom.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "wss://fantom.publicnode.com",
      "https://fantom.publicnode.com",
      "https://rpc.ftm.tools",
    ],
    shortName: "ftm",
    slug: "fantom",
    testnet: !1,
  },
  Cce = {
    chain: "ETH",
    chainId: 420,
    explorers: [
      {
        name: "blockscout",
        url: "https://optimism-goerli.blockscout.com",
        standard: "EIP3091",
      },
    ],
    faucets: ["https://coinbase.com/faucets/optimism-goerli-faucet"],
    features: [],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/optimism/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://optimism.io",
    name: "Optimism Goerli Testnet",
    nativeCurrency: {
      name: "Goerli Ether",
      symbol: "ETH",
      decimals: 18,
    },
    redFlags: [],
    rpc: [
      "https://optimism-goerli.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://optimism-goerli.infura.io/v3/${INFURA_API_KEY}",
      "https://opt-goerli.g.alchemy.com/v2/${ALCHEMY_API_KEY}",
      "https://goerli.optimism.io",
      "https://optimism-goerli.publicnode.com",
      "wss://optimism-goerli.publicnode.com",
      "https://optimism-goerli.gateway.tenderly.co",
      "wss://optimism-goerli.gateway.tenderly.co",
    ],
    shortName: "ogor",
    slug: "optimism-goerli",
    testnet: !0,
  },
  Ace = {
    chain: "ETH",
    chainId: 1337,
    explorers: [],
    faucets: [],
    features: [],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/ethereum/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    name: "Localhost",
    nativeCurrency: {
      name: "Ether",
      symbol: "ETH",
      decimals: 18,
    },
    redFlags: [],
    rpc: [
      "https://localhost.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "http://localhost:8545",
    ],
    shortName: "local",
    slug: "localhost",
    testnet: !0,
  },
  kce = {
    chain: "FTM",
    chainId: 4002,
    explorers: [
      {
        name: "ftmscan",
        url: "https://testnet.ftmscan.com",
        standard: "EIP3091",
      },
    ],
    faucets: ["https://faucet.fantom.network"],
    features: [],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/fantom/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL:
      "https://docs.fantom.foundation/quick-start/short-guide#fantom-testnet",
    name: "Fantom Testnet",
    nativeCurrency: {
      name: "Fantom",
      symbol: "FTM",
      decimals: 18,
    },
    redFlags: [],
    rpc: [
      "https://fantom-testnet.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "wss://fantom-testnet.publicnode.com",
      "https://fantom-testnet.publicnode.com",
      "https://rpc.testnet.fantom.network",
    ],
    shortName: "tftm",
    slug: "fantom-testnet",
    testnet: !0,
  },
  Sce = {
    chain: "ETH",
    chainId: 8453,
    explorers: [
      {
        name: "basescan",
        url: "https://basescan.org",
        standard: "none",
      },
      {
        name: "basescout",
        url: "https://base.blockscout.com",
        standard: "EIP3091",
      },
    ],
    faucets: [],
    features: [],
    icon: {
      url: "ipfs://QmW5Vn15HeRkScMfPcW12ZdZcC2yUASpu6eCsECRdEmjjj/base-512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://base.org",
    name: "Base",
    nativeCurrency: {
      name: "Ether",
      symbol: "ETH",
      decimals: 18,
    },
    redFlags: [],
    rpc: [
      "https://base.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://mainnet.base.org/",
      "https://developer-access-mainnet.base.org/",
      "https://base.gateway.tenderly.co",
      "wss://base.gateway.tenderly.co",
      "https://base.publicnode.com",
      "wss://base.publicnode.com",
    ],
    shortName: "base",
    slug: "base",
    status: "active",
    testnet: !1,
  },
  Mce = {
    chain: "ETH",
    chainId: 42161,
    explorers: [
      {
        name: "Arbitrum Explorer",
        url: "https://explorer.arbitrum.io",
        standard: "EIP3091",
      },
      {
        name: "Arbiscan",
        url: "https://arbiscan.io",
        standard: "EIP3091",
      },
    ],
    faucets: [],
    features: [],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/arbitrum/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://arbitrum.io",
    name: "Arbitrum One",
    nativeCurrency: {
      name: "Ether",
      symbol: "ETH",
      decimals: 18,
    },
    redFlags: [],
    rpc: [
      "https://arbitrum.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://arbitrum-mainnet.infura.io/v3/${INFURA_API_KEY}",
      "https://arb-mainnet.g.alchemy.com/v2/${ALCHEMY_API_KEY}",
      "https://arb1.arbitrum.io/rpc",
      "https://arbitrum-one.publicnode.com",
      "wss://arbitrum-one.publicnode.com",
    ],
    shortName: "arb1",
    slug: "arbitrum",
    testnet: !1,
  },
  Ice = {
    chain: "AVAX",
    chainId: 43113,
    explorers: [
      {
        name: "snowtrace",
        url: "https://testnet.snowtrace.io",
        standard: "EIP3091",
      },
    ],
    faucets: [
      "https://faucet.avax.network/",
      "https://faucet.avax-test.network/",
    ],
    features: [],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/avalanche/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://cchain.explorer.avax-test.network",
    name: "Avalanche Fuji Testnet",
    nativeCurrency: {
      name: "Avalanche",
      symbol: "AVAX",
      decimals: 18,
    },
    redFlags: [],
    rpc: [
      "https://avalanche-fuji.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://avalanche-fuji.infura.io/v3/${INFURA_API_KEY}",
      "https://api.avax-test.network/ext/bc/C/rpc",
      "https://avalanche-fuji-c-chain.publicnode.com",
      "wss://avalanche-fuji-c-chain.publicnode.com",
    ],
    shortName: "Fuji",
    slug: "avalanche-fuji",
    testnet: !0,
  },
  Rce = {
    chain: "AVAX",
    chainId: 43114,
    explorers: [
      {
        name: "snowtrace",
        url: "https://snowtrace.io",
        standard: "EIP3091",
      },
    ],
    faucets: [],
    features: [
      {
        name: "EIP1559",
      },
    ],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/avalanche/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://www.avax.network/",
    name: "Avalanche C-Chain",
    nativeCurrency: {
      name: "Avalanche",
      symbol: "AVAX",
      decimals: 18,
    },
    redFlags: [],
    rpc: [
      "https://avalanche.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://avalanche-mainnet.infura.io/v3/${INFURA_API_KEY}",
      "https://api.avax.network/ext/bc/C/rpc",
      "https://avalanche-c-chain.publicnode.com",
      "wss://avalanche-c-chain.publicnode.com",
    ],
    shortName: "avax",
    slug: "avalanche",
    testnet: !1,
  },
  Pce = {
    chain: "Polygon",
    chainId: 80001,
    explorers: [
      {
        name: "polygonscan",
        url: "https://mumbai.polygonscan.com",
        standard: "EIP3091",
      },
    ],
    faucets: ["https://faucet.polygon.technology/"],
    features: [],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/polygon/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://polygon.technology/",
    name: "Mumbai",
    nativeCurrency: {
      name: "MATIC",
      symbol: "MATIC",
      decimals: 18,
    },
    redFlags: [],
    rpc: [
      "https://mumbai.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://polygon-mumbai.infura.io/v3/${INFURA_API_KEY}",
      "https://polygon-mumbai.g.alchemy.com/v2/${ALCHEMY_API_KEY}",
      "https://rpc-mumbai.maticvigil.com",
      "https://polygon-mumbai-bor.publicnode.com",
      "wss://polygon-mumbai-bor.publicnode.com",
      "https://polygon-mumbai.gateway.tenderly.co",
      "wss://polygon-mumbai.gateway.tenderly.co",
    ],
    shortName: "maticmum",
    slug: "mumbai",
    testnet: !0,
  },
  Nce = {
    chain: "ETH",
    chainId: 84531,
    explorers: [
      {
        name: "basescan",
        url: "https://goerli.basescan.org",
        standard: "none",
      },
      {
        name: "basescout",
        url: "https://base-goerli.blockscout.com",
        standard: "EIP3091",
      },
    ],
    faucets: ["https://www.coinbase.com/faucets/base-ethereum-goerli-faucet"],
    features: [],
    icon: {
      url: "ipfs://QmW5Vn15HeRkScMfPcW12ZdZcC2yUASpu6eCsECRdEmjjj/base-512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://base.org",
    name: "Base Goerli Testnet",
    nativeCurrency: {
      name: "Goerli Ether",
      symbol: "ETH",
      decimals: 18,
    },
    redFlags: [],
    rpc: [
      "https://base-goerli.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "wss://base-goerli.publicnode.com",
      "https://base-goerli.publicnode.com",
      "wss://base-goerli.gateway.tenderly.co",
      "https://base-goerli.gateway.tenderly.co",
      "https://goerli.base.org",
    ],
    shortName: "basegor",
    slug: "base-goerli",
    testnet: !0,
  },
  Bce = {
    chain: "ETH",
    chainId: 421613,
    explorers: [
      {
        name: "Arbitrum Goerli Rollup Explorer",
        url: "https://goerli-rollup-explorer.arbitrum.io",
        standard: "EIP3091",
      },
    ],
    faucets: [],
    features: [],
    icon: {
      url: "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/arbitrum/512.png",
      width: 512,
      height: 512,
      format: "png",
    },
    infoURL: "https://arbitrum.io/",
    name: "Arbitrum Goerli",
    nativeCurrency: {
      name: "Arbitrum Goerli Ether",
      symbol: "AGOR",
      decimals: 18,
    },
    redFlags: [],
    rpc: [
      "https://arbitrum-goerli.rpc.thirdweb.com/${THIRDWEB_API_KEY}",
      "https://arbitrum-goerli.infura.io/v3/${INFURA_API_KEY}",
      "https://arb-goerli.g.alchemy.com/v2/${ALCHEMY_API_KEY}",
      "https://goerli-rollup.arbitrum.io/rpc",
      "https://arbitrum-goerli.publicnode.com",
      "wss://arbitrum-goerli.publicnode.com",
    ],
    shortName: "arb-goerli",
    slug: "arbitrum-goerli",
    testnet: !0,
  };
function Dce(t, e) {
  let r =
    arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "http";
  const n = [];
  if (
    (t.rpc.forEach((i) => {
      if (
        !(r === "http" && !i.startsWith("http")) &&
        !(r === "ws" && !i.startsWith("ws"))
      )
        if (i.includes("${THIRDWEB_API_KEY}"))
          e
            ? n.push(
                i.replace("${THIRDWEB_API_KEY}", e) +
                  (typeof globalThis < "u" && "APP_BUNDLE_ID" in globalThis
                    ? `/?bundleId=${globalThis.APP_BUNDLE_ID}`
                    : "")
              )
            : n.push(i.replace("${THIRDWEB_API_KEY}", ""));
        else {
          if (i.includes("${")) return;
          n.push(i);
        }
    }),
    n.length === 0)
  )
    throw new Error(
      `No RPC available for chainId "${t.chainId}" with mode ${r}`
    );
  return n;
}
const wv = [
  vce,
  xce,
  Sce,
  Nce,
  TE,
  Pce,
  Mce,
  Bce,
  wce,
  Cce,
  _ce,
  Ece,
  Tce,
  kce,
  Rce,
  Ice,
  Ace,
];
function Oce(t) {
  if (t.length >= 255) throw new TypeError("Alphabet too long");
  for (var e = new Uint8Array(256), r = 0; r < e.length; r++) e[r] = 255;
  for (var n = 0; n < t.length; n++) {
    var i = t.charAt(n),
      a = i.charCodeAt(0);
    if (e[a] !== 255) throw new TypeError(i + " is ambiguous");
    e[a] = n;
  }
  var s = t.length,
    o = t.charAt(0),
    c = Math.log(s) / Math.log(256),
    u = Math.log(256) / Math.log(s);
  function d(E) {
    if (
      (E instanceof Uint8Array ||
        (ArrayBuffer.isView(E)
          ? (E = new Uint8Array(E.buffer, E.byteOffset, E.byteLength))
          : Array.isArray(E) && (E = Uint8Array.from(E))),
      !(E instanceof Uint8Array))
    )
      throw new TypeError("Expected Uint8Array");
    if (E.length === 0) return "";
    for (var A = 0, I = 0, b = 0, w = E.length; b !== w && E[b] === 0; )
      b++, A++;
    for (var S = ((w - b) * u + 1) >>> 0, k = new Uint8Array(S); b !== w; ) {
      for (
        var N = E[b], O = 0, F = S - 1;
        (N !== 0 || O < I) && F !== -1;
        F--, O++
      )
        (N += (256 * k[F]) >>> 0), (k[F] = N % s >>> 0), (N = (N / s) >>> 0);
      if (N !== 0) throw new Error("Non-zero carry");
      (I = O), b++;
    }
    for (var V = S - I; V !== S && k[V] === 0; ) V++;
    for (var j = o.repeat(A); V < S; ++V) j += t.charAt(k[V]);
    return j;
  }
  function m(E) {
    if (typeof E != "string") throw new TypeError("Expected String");
    if (E.length === 0) return new Uint8Array();
    for (var A = 0, I = 0, b = 0; E[A] === o; ) I++, A++;
    for (
      var w = ((E.length - A) * c + 1) >>> 0, S = new Uint8Array(w);
      E[A];

    ) {
      var k = e[E.charCodeAt(A)];
      if (k === 255) return;
      for (var N = 0, O = w - 1; (k !== 0 || N < b) && O !== -1; O--, N++)
        (k += (s * S[O]) >>> 0), (S[O] = k % 256 >>> 0), (k = (k / 256) >>> 0);
      if (k !== 0) throw new Error("Non-zero carry");
      (b = N), A++;
    }
    for (var F = w - b; F !== w && S[F] === 0; ) F++;
    for (var V = new Uint8Array(I + (w - F)), j = I; F !== w; ) V[j++] = S[F++];
    return V;
  }
  function v(E) {
    var A = m(E);
    if (A) return A;
    throw new Error("Non-base" + s + " character");
  }
  return {
    encode: d,
    decodeUnsafe: m,
    decode: v,
  };
}
var Fce = Oce;
const Lce = Fce,
  $ce = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var Uce = Lce($ce);
const Wce = mn(Uce),
  uF = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "deployer",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "deployment",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "chainId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "string",
          name: "metadataUri",
          type: "string",
        },
      ],
      name: "Added",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "deployer",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "deployment",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "chainId",
          type: "uint256",
        },
      ],
      name: "Deleted",
      type: "event",
    },
    {
      inputs: [],
      name: "OPERATOR_ROLE",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "_msgData",
      outputs: [
        {
          internalType: "bytes",
          name: "",
          type: "bytes",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "_msgSender",
      outputs: [
        {
          internalType: "address",
          name: "sender",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_deployer",
          type: "address",
        },
        {
          internalType: "address",
          name: "_deployment",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "_chainId",
          type: "uint256",
        },
        {
          internalType: "string",
          name: "metadataUri",
          type: "string",
        },
      ],
      name: "add",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "contractType",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32",
        },
      ],
      stateMutability: "pure",
      type: "function",
    },
    {
      inputs: [],
      name: "contractVersion",
      outputs: [
        {
          internalType: "uint8",
          name: "",
          type: "uint8",
        },
      ],
      stateMutability: "pure",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_deployer",
          type: "address",
        },
      ],
      name: "count",
      outputs: [
        {
          internalType: "uint256",
          name: "deploymentCount",
          type: "uint256",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_deployer",
          type: "address",
        },
      ],
      name: "getAll",
      outputs: [
        {
          components: [
            {
              internalType: "address",
              name: "deploymentAddress",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "chainId",
              type: "uint256",
            },
            {
              internalType: "string",
              name: "metadataURI",
              type: "string",
            },
          ],
          internalType: "struct ITWMultichainRegistry.Deployment[]",
          name: "allDeployments",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "_chainId",
          type: "uint256",
        },
        {
          internalType: "address",
          name: "_deployment",
          type: "address",
        },
      ],
      name: "getMetadataUri",
      outputs: [
        {
          internalType: "string",
          name: "metadataUri",
          type: "string",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_deployer",
          type: "address",
        },
        {
          internalType: "address",
          name: "_deployment",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "_chainId",
          type: "uint256",
        },
      ],
      name: "remove",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  jce = [
    {
      inputs: [
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256",
        },
      ],
      name: "burn",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "account",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256",
        },
      ],
      name: "burnFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  fF = [
    {
      anonymous: !1,
      inputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "startTimestamp",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "maxClaimableSupply",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "supplyClaimed",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "quantityLimitPerWallet",
              type: "uint256",
            },
            {
              internalType: "bytes32",
              name: "merkleRoot",
              type: "bytes32",
            },
            {
              internalType: "uint256",
              name: "pricePerToken",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
            {
              internalType: "string",
              name: "metadata",
              type: "string",
            },
          ],
          indexed: !1,
          internalType: "struct IClaimCondition.ClaimCondition[]",
          name: "claimConditions",
          type: "tuple[]",
        },
        {
          indexed: !1,
          internalType: "bool",
          name: "resetEligibility",
          type: "bool",
        },
      ],
      name: "ClaimConditionsUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "claimConditionIndex",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "claimer",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "receiver",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "startTokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "quantityClaimed",
          type: "uint256",
        },
      ],
      name: "TokensClaimed",
      type: "event",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "receiver",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "quantity",
          type: "uint256",
        },
        {
          internalType: "address",
          name: "currency",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "pricePerToken",
          type: "uint256",
        },
        {
          components: [
            {
              internalType: "bytes32[]",
              name: "proof",
              type: "bytes32[]",
            },
            {
              internalType: "uint256",
              name: "quantityLimitPerWallet",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "pricePerToken",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
          ],
          internalType: "struct IDrop.AllowlistProof",
          name: "allowlistProof",
          type: "tuple",
        },
        {
          internalType: "bytes",
          name: "data",
          type: "bytes",
        },
      ],
      name: "claim",
      outputs: [],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "startTimestamp",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "maxClaimableSupply",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "supplyClaimed",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "quantityLimitPerWallet",
              type: "uint256",
            },
            {
              internalType: "bytes32",
              name: "merkleRoot",
              type: "bytes32",
            },
            {
              internalType: "uint256",
              name: "pricePerToken",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
            {
              internalType: "string",
              name: "metadata",
              type: "string",
            },
          ],
          internalType: "struct IClaimCondition.ClaimCondition[]",
          name: "phases",
          type: "tuple[]",
        },
        {
          internalType: "bool",
          name: "resetClaimEligibility",
          type: "bool",
        },
      ],
      name: "setClaimConditions",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  Hce = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "spender",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
      ],
      name: "Approval",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "startTimestamp",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "maxClaimableSupply",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "supplyClaimed",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "quantityLimitPerTransaction",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "waitTimeInSecondsBetweenClaims",
              type: "uint256",
            },
            {
              internalType: "bytes32",
              name: "merkleRoot",
              type: "bytes32",
            },
            {
              internalType: "uint256",
              name: "pricePerToken",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
          ],
          indexed: !1,
          internalType: "struct IDropClaimCondition_V2.ClaimCondition[]",
          name: "claimConditions",
          type: "tuple[]",
        },
      ],
      name: "ClaimConditionsUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "string",
          name: "prevURI",
          type: "string",
        },
        {
          indexed: !1,
          internalType: "string",
          name: "newURI",
          type: "string",
        },
      ],
      name: "ContractURIUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "uint256",
          name: "maxTotalSupply",
          type: "uint256",
        },
      ],
      name: "MaxTotalSupplyUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "uint256",
          name: "count",
          type: "uint256",
        },
      ],
      name: "MaxWalletClaimCountUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "claimConditionIndex",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "claimer",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "receiver",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "quantityClaimed",
          type: "uint256",
        },
      ],
      name: "TokensClaimed",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "from",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "to",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
      ],
      name: "Transfer",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "wallet",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "count",
          type: "uint256",
        },
      ],
      name: "WalletClaimCountUpdated",
      type: "event",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          internalType: "address",
          name: "spender",
          type: "address",
        },
      ],
      name: "allowance",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "spender",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256",
        },
      ],
      name: "approve",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "account",
          type: "address",
        },
      ],
      name: "balanceOf",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "receiver",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "quantity",
          type: "uint256",
        },
        {
          internalType: "address",
          name: "currency",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "pricePerToken",
          type: "uint256",
        },
        {
          internalType: "bytes32[]",
          name: "proofs",
          type: "bytes32[]",
        },
        {
          internalType: "uint256",
          name: "proofMaxQuantityPerTransaction",
          type: "uint256",
        },
      ],
      name: "claim",
      outputs: [],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "startTimestamp",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "maxClaimableSupply",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "supplyClaimed",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "quantityLimitPerTransaction",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "waitTimeInSecondsBetweenClaims",
              type: "uint256",
            },
            {
              internalType: "bytes32",
              name: "merkleRoot",
              type: "bytes32",
            },
            {
              internalType: "uint256",
              name: "pricePerToken",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
          ],
          internalType: "struct IDropClaimCondition_V2.ClaimCondition[]",
          name: "phases",
          type: "tuple[]",
        },
        {
          internalType: "bool",
          name: "resetClaimEligibility",
          type: "bool",
        },
      ],
      name: "setClaimConditions",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "totalSupply",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "to",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256",
        },
      ],
      name: "transfer",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "from",
          type: "address",
        },
        {
          internalType: "address",
          name: "to",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256",
        },
      ],
      name: "transferFrom",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  dF = [
    {
      anonymous: !1,
      inputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "startTimestamp",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "maxClaimableSupply",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "supplyClaimed",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "quantityLimitPerWallet",
              type: "uint256",
            },
            {
              internalType: "bytes32",
              name: "merkleRoot",
              type: "bytes32",
            },
            {
              internalType: "uint256",
              name: "pricePerToken",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
            {
              internalType: "string",
              name: "metadata",
              type: "string",
            },
          ],
          indexed: !1,
          internalType: "struct IClaimCondition.ClaimCondition",
          name: "condition",
          type: "tuple",
        },
        {
          indexed: !1,
          internalType: "bool",
          name: "resetEligibility",
          type: "bool",
        },
      ],
      name: "ClaimConditionUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "claimer",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "receiver",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "startTokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "quantityClaimed",
          type: "uint256",
        },
      ],
      name: "TokensClaimed",
      type: "event",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "receiver",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "quantity",
          type: "uint256",
        },
        {
          internalType: "address",
          name: "currency",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "pricePerToken",
          type: "uint256",
        },
        {
          components: [
            {
              internalType: "bytes32[]",
              name: "proof",
              type: "bytes32[]",
            },
            {
              internalType: "uint256",
              name: "quantityLimitPerWallet",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "pricePerToken",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
          ],
          internalType: "struct IDropSinglePhase.AllowlistProof",
          name: "allowlistProof",
          type: "tuple",
        },
        {
          internalType: "bytes",
          name: "data",
          type: "bytes",
        },
      ],
      name: "claim",
      outputs: [],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "startTimestamp",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "maxClaimableSupply",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "supplyClaimed",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "quantityLimitPerWallet",
              type: "uint256",
            },
            {
              internalType: "bytes32",
              name: "merkleRoot",
              type: "bytes32",
            },
            {
              internalType: "uint256",
              name: "pricePerToken",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
            {
              internalType: "string",
              name: "metadata",
              type: "string",
            },
          ],
          internalType: "struct IClaimCondition.ClaimCondition",
          name: "phase",
          type: "tuple",
        },
        {
          internalType: "bool",
          name: "resetClaimEligibility",
          type: "bool",
        },
      ],
      name: "setClaimConditions",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  hF = [
    {
      anonymous: !1,
      inputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "startTimestamp",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "maxClaimableSupply",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "supplyClaimed",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "quantityLimitPerTransaction",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "waitTimeInSecondsBetweenClaims",
              type: "uint256",
            },
            {
              internalType: "bytes32",
              name: "merkleRoot",
              type: "bytes32",
            },
            {
              internalType: "uint256",
              name: "pricePerToken",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
          ],
          indexed: !1,
          internalType: "struct IClaimCondition_V1.ClaimCondition",
          name: "condition",
          type: "tuple",
        },
        {
          indexed: !1,
          internalType: "bool",
          name: "resetEligibility",
          type: "bool",
        },
      ],
      name: "ClaimConditionUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "claimer",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "receiver",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "startTokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "quantityClaimed",
          type: "uint256",
        },
      ],
      name: "TokensClaimed",
      type: "event",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "receiver",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "quantity",
          type: "uint256",
        },
        {
          internalType: "address",
          name: "currency",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "pricePerToken",
          type: "uint256",
        },
        {
          components: [
            {
              internalType: "bytes32[]",
              name: "proof",
              type: "bytes32[]",
            },
            {
              internalType: "uint256",
              name: "maxQuantityInAllowlist",
              type: "uint256",
            },
          ],
          internalType: "struct IDropSinglePhase_V1.AllowlistProof",
          name: "allowlistProof",
          type: "tuple",
        },
        {
          internalType: "bytes",
          name: "data",
          type: "bytes",
        },
      ],
      name: "claim",
      outputs: [],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "startTimestamp",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "maxClaimableSupply",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "supplyClaimed",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "quantityLimitPerTransaction",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "waitTimeInSecondsBetweenClaims",
              type: "uint256",
            },
            {
              internalType: "bytes32",
              name: "merkleRoot",
              type: "bytes32",
            },
            {
              internalType: "uint256",
              name: "pricePerToken",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
          ],
          internalType: "struct IClaimCondition_V1.ClaimCondition",
          name: "phase",
          type: "tuple",
        },
        {
          internalType: "bool",
          name: "resetClaimEligibility",
          type: "bool",
        },
      ],
      name: "setClaimConditions",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  zce = [
    {
      inputs: [],
      name: "DOMAIN_SEPARATOR",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "owner",
          type: "address",
        },
      ],
      name: "nonces",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          internalType: "address",
          name: "spender",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
        {
          internalType: "uint256",
          name: "deadline",
          type: "uint256",
        },
        {
          internalType: "uint8",
          name: "v",
          type: "uint8",
        },
        {
          internalType: "bytes32",
          name: "r",
          type: "bytes32",
        },
        {
          internalType: "bytes32",
          name: "s",
          type: "bytes32",
        },
      ],
      name: "permit",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  pF = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "mintedTo",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "quantityMinted",
          type: "uint256",
        },
      ],
      name: "TokensMinted",
      type: "event",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "to",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256",
        },
      ],
      name: "mintTo",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  CE = [
    {
      inputs: [
        {
          internalType: "bytes[]",
          name: "data",
          type: "bytes[]",
        },
      ],
      name: "multicall",
      outputs: [
        {
          internalType: "bytes[]",
          name: "results",
          type: "bytes[]",
        },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  qce = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "signer",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "mintedTo",
          type: "address",
        },
        {
          components: [
            {
              internalType: "address",
              name: "to",
              type: "address",
            },
            {
              internalType: "address",
              name: "primarySaleRecipient",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "quantity",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "price",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
            {
              internalType: "uint128",
              name: "validityStartTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "validityEndTimestamp",
              type: "uint128",
            },
            {
              internalType: "bytes32",
              name: "uid",
              type: "bytes32",
            },
          ],
          indexed: !1,
          internalType: "struct ISignatureMintERC20.MintRequest",
          name: "mintRequest",
          type: "tuple",
        },
      ],
      name: "TokensMintedWithSignature",
      type: "event",
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "address",
              name: "to",
              type: "address",
            },
            {
              internalType: "address",
              name: "primarySaleRecipient",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "quantity",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "price",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
            {
              internalType: "uint128",
              name: "validityStartTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "validityEndTimestamp",
              type: "uint128",
            },
            {
              internalType: "bytes32",
              name: "uid",
              type: "bytes32",
            },
          ],
          internalType: "struct ISignatureMintERC20.MintRequest",
          name: "req",
          type: "tuple",
        },
        {
          internalType: "bytes",
          name: "signature",
          type: "bytes",
        },
      ],
      name: "mintWithSignature",
      outputs: [
        {
          internalType: "address",
          name: "signer",
          type: "address",
        },
      ],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "address",
              name: "to",
              type: "address",
            },
            {
              internalType: "address",
              name: "primarySaleRecipient",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "quantity",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "price",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
            {
              internalType: "uint128",
              name: "validityStartTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "validityEndTimestamp",
              type: "uint128",
            },
            {
              internalType: "bytes32",
              name: "uid",
              type: "bytes32",
            },
          ],
          internalType: "struct ISignatureMintERC20.MintRequest",
          name: "req",
          type: "tuple",
        },
        {
          internalType: "bytes",
          name: "signature",
          type: "bytes",
        },
      ],
      name: "verify",
      outputs: [
        {
          internalType: "bool",
          name: "success",
          type: "bool",
        },
        {
          internalType: "address",
          name: "signer",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  Vce = [
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "burn",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  Kce = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "claimer",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "receiver",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "startTokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "quantityClaimed",
          type: "uint256",
        },
      ],
      name: "TokensClaimed",
      type: "event",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_receiver",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "_quantity",
          type: "uint256",
        },
      ],
      name: "claim",
      outputs: [],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_claimer",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "_quantity",
          type: "uint256",
        },
      ],
      name: "verifyClaim",
      outputs: [],
      stateMutability: "view",
      type: "function",
    },
  ],
  mF = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "index",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "string",
          name: "revealedURI",
          type: "string",
        },
      ],
      name: "TokenURIRevealed",
      type: "event",
    },
    {
      inputs: [
        {
          internalType: "bytes",
          name: "data",
          type: "bytes",
        },
        {
          internalType: "bytes",
          name: "key",
          type: "bytes",
        },
      ],
      name: "encryptDecrypt",
      outputs: [
        {
          internalType: "bytes",
          name: "result",
          type: "bytes",
        },
      ],
      stateMutability: "pure",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "identifier",
          type: "uint256",
        },
        {
          internalType: "bytes",
          name: "key",
          type: "bytes",
        },
      ],
      name: "reveal",
      outputs: [
        {
          internalType: "string",
          name: "revealedURI",
          type: "string",
        },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  Gce = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "approved",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "Approval",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "bool",
          name: "approved",
          type: "bool",
        },
      ],
      name: "ApprovalForAll",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "startTimestamp",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "maxClaimableSupply",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "supplyClaimed",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "quantityLimitPerTransaction",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "waitTimeInSecondsBetweenClaims",
              type: "uint256",
            },
            {
              internalType: "bytes32",
              name: "merkleRoot",
              type: "bytes32",
            },
            {
              internalType: "uint256",
              name: "pricePerToken",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
          ],
          indexed: !1,
          internalType: "struct IDropClaimCondition_V2.ClaimCondition[]",
          name: "claimConditions",
          type: "tuple[]",
        },
      ],
      name: "ClaimConditionsUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "uint256",
          name: "maxTotalSupply",
          type: "uint256",
        },
      ],
      name: "MaxTotalSupplyUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "uint256",
          name: "count",
          type: "uint256",
        },
      ],
      name: "MaxWalletClaimCountUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "uint256",
          name: "endTokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "string",
          name: "revealedURI",
          type: "string",
        },
      ],
      name: "NFTRevealed",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "claimConditionIndex",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "claimer",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "receiver",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "startTokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "quantityClaimed",
          type: "uint256",
        },
      ],
      name: "TokensClaimed",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "uint256",
          name: "startTokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "endTokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "string",
          name: "baseURI",
          type: "string",
        },
        {
          indexed: !1,
          internalType: "bytes",
          name: "encryptedBaseURI",
          type: "bytes",
        },
      ],
      name: "TokensLazyMinted",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "from",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "to",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "Transfer",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "wallet",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "count",
          type: "uint256",
        },
      ],
      name: "WalletClaimCountUpdated",
      type: "event",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "to",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "approve",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "owner",
          type: "address",
        },
      ],
      name: "balanceOf",
      outputs: [
        {
          internalType: "uint256",
          name: "balance",
          type: "uint256",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "receiver",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "quantity",
          type: "uint256",
        },
        {
          internalType: "address",
          name: "currency",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "pricePerToken",
          type: "uint256",
        },
        {
          internalType: "bytes32[]",
          name: "proofs",
          type: "bytes32[]",
        },
        {
          internalType: "uint256",
          name: "proofMaxQuantityPerTransaction",
          type: "uint256",
        },
      ],
      name: "claim",
      outputs: [],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "getApproved",
      outputs: [
        {
          internalType: "address",
          name: "operator",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          internalType: "address",
          name: "operator",
          type: "address",
        },
      ],
      name: "isApprovedForAll",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256",
        },
        {
          internalType: "string",
          name: "baseURIForTokens",
          type: "string",
        },
        {
          internalType: "bytes",
          name: "encryptedBaseURI",
          type: "bytes",
        },
      ],
      name: "lazyMint",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "ownerOf",
      outputs: [
        {
          internalType: "address",
          name: "owner",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "from",
          type: "address",
        },
        {
          internalType: "address",
          name: "to",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "safeTransferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "from",
          type: "address",
        },
        {
          internalType: "address",
          name: "to",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          internalType: "bytes",
          name: "data",
          type: "bytes",
        },
      ],
      name: "safeTransferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          internalType: "bool",
          name: "_approved",
          type: "bool",
        },
      ],
      name: "setApprovalForAll",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "startTimestamp",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "maxClaimableSupply",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "supplyClaimed",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "quantityLimitPerTransaction",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "waitTimeInSecondsBetweenClaims",
              type: "uint256",
            },
            {
              internalType: "bytes32",
              name: "merkleRoot",
              type: "bytes32",
            },
            {
              internalType: "uint256",
              name: "pricePerToken",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
          ],
          internalType: "struct IDropClaimCondition_V2.ClaimCondition[]",
          name: "phases",
          type: "tuple[]",
        },
        {
          internalType: "bool",
          name: "resetClaimEligibility",
          type: "bool",
        },
      ],
      name: "setClaimConditions",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "interfaceId",
          type: "bytes4",
        },
      ],
      name: "supportsInterface",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "from",
          type: "address",
        },
        {
          internalType: "address",
          name: "to",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "transferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  Zce = [
    {
      inputs: [
        {
          internalType: "uint256",
          name: "_index",
          type: "uint256",
        },
      ],
      name: "tokenByIndex",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_owner",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "_index",
          type: "uint256",
        },
      ],
      name: "tokenOfOwnerByIndex",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  Jce = [
    {
      inputs: [],
      name: "ApprovalCallerNotOwnerNorApproved",
      type: "error",
    },
    {
      inputs: [],
      name: "ApprovalQueryForNonexistentToken",
      type: "error",
    },
    {
      inputs: [],
      name: "BalanceQueryForZeroAddress",
      type: "error",
    },
    {
      inputs: [],
      name: "InvalidQueryRange",
      type: "error",
    },
    {
      inputs: [],
      name: "MintERC2309QuantityExceedsLimit",
      type: "error",
    },
    {
      inputs: [],
      name: "MintToZeroAddress",
      type: "error",
    },
    {
      inputs: [],
      name: "MintZeroQuantity",
      type: "error",
    },
    {
      inputs: [],
      name: "OwnerQueryForNonexistentToken",
      type: "error",
    },
    {
      inputs: [],
      name: "OwnershipNotInitializedForExtraData",
      type: "error",
    },
    {
      inputs: [],
      name: "TransferCallerNotOwnerNorApproved",
      type: "error",
    },
    {
      inputs: [],
      name: "TransferFromIncorrectOwner",
      type: "error",
    },
    {
      inputs: [],
      name: "TransferToNonERC721ReceiverImplementer",
      type: "error",
    },
    {
      inputs: [],
      name: "TransferToZeroAddress",
      type: "error",
    },
    {
      inputs: [],
      name: "URIQueryForNonexistentToken",
      type: "error",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "approved",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "Approval",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "bool",
          name: "approved",
          type: "bool",
        },
      ],
      name: "ApprovalForAll",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "fromTokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "toTokenId",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "from",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "to",
          type: "address",
        },
      ],
      name: "ConsecutiveTransfer",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "from",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "to",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "Transfer",
      type: "event",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "to",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "approve",
      outputs: [],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "owner",
          type: "address",
        },
      ],
      name: "balanceOf",
      outputs: [
        {
          internalType: "uint256",
          name: "balance",
          type: "uint256",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "explicitOwnershipOf",
      outputs: [
        {
          components: [
            {
              internalType: "address",
              name: "addr",
              type: "address",
            },
            {
              internalType: "uint64",
              name: "startTimestamp",
              type: "uint64",
            },
            {
              internalType: "bool",
              name: "burned",
              type: "bool",
            },
            {
              internalType: "uint24",
              name: "extraData",
              type: "uint24",
            },
          ],
          internalType: "struct IERC721AUpgradeable.TokenOwnership",
          name: "",
          type: "tuple",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "getApproved",
      outputs: [
        {
          internalType: "address",
          name: "operator",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          internalType: "address",
          name: "operator",
          type: "address",
        },
      ],
      name: "isApprovedForAll",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "name",
      outputs: [
        {
          internalType: "string",
          name: "",
          type: "string",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "ownerOf",
      outputs: [
        {
          internalType: "address",
          name: "owner",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "from",
          type: "address",
        },
        {
          internalType: "address",
          name: "to",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "safeTransferFrom",
      outputs: [],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "from",
          type: "address",
        },
        {
          internalType: "address",
          name: "to",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          internalType: "bytes",
          name: "data",
          type: "bytes",
        },
      ],
      name: "safeTransferFrom",
      outputs: [],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          internalType: "bool",
          name: "_approved",
          type: "bool",
        },
      ],
      name: "setApprovalForAll",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "interfaceId",
          type: "bytes4",
        },
      ],
      name: "supportsInterface",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "symbol",
      outputs: [
        {
          internalType: "string",
          name: "",
          type: "string",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "tokenURI",
      outputs: [
        {
          internalType: "string",
          name: "",
          type: "string",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "owner",
          type: "address",
        },
      ],
      name: "tokensOfOwner",
      outputs: [
        {
          internalType: "uint256[]",
          name: "",
          type: "uint256[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "start",
          type: "uint256",
        },
        {
          internalType: "uint256",
          name: "stop",
          type: "uint256",
        },
      ],
      name: "tokensOfOwnerIn",
      outputs: [
        {
          internalType: "uint256[]",
          name: "",
          type: "uint256[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "totalSupply",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "from",
          type: "address",
        },
        {
          internalType: "address",
          name: "to",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "transferFrom",
      outputs: [],
      stateMutability: "payable",
      type: "function",
    },
  ],
  Qce = [
    {
      inputs: [],
      name: "totalSupply",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  _v = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "startTokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "endTokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "string",
          name: "baseURI",
          type: "string",
        },
        {
          indexed: !1,
          internalType: "bytes",
          name: "encryptedBaseURI",
          type: "bytes",
        },
      ],
      name: "TokensLazyMinted",
      type: "event",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256",
        },
        {
          internalType: "string",
          name: "baseURIForTokens",
          type: "string",
        },
        {
          internalType: "bytes",
          name: "extraData",
          type: "bytes",
        },
      ],
      name: "lazyMint",
      outputs: [
        {
          internalType: "uint256",
          name: "batchId",
          type: "uint256",
        },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  yF = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "mintedTo",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenIdMinted",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "string",
          name: "uri",
          type: "string",
        },
      ],
      name: "TokensMinted",
      type: "event",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "to",
          type: "address",
        },
        {
          internalType: "string",
          name: "uri",
          type: "string",
        },
      ],
      name: "mintTo",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256",
        },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  Yce = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "signer",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "mintedTo",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenIdMinted",
          type: "uint256",
        },
        {
          components: [
            {
              internalType: "address",
              name: "to",
              type: "address",
            },
            {
              internalType: "address",
              name: "royaltyRecipient",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "royaltyBps",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "primarySaleRecipient",
              type: "address",
            },
            {
              internalType: "string",
              name: "uri",
              type: "string",
            },
            {
              internalType: "uint256",
              name: "quantity",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "pricePerToken",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
            {
              internalType: "uint128",
              name: "validityStartTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "validityEndTimestamp",
              type: "uint128",
            },
            {
              internalType: "bytes32",
              name: "uid",
              type: "bytes32",
            },
          ],
          indexed: !1,
          internalType: "struct ISignatureMintERC721.MintRequest",
          name: "mintRequest",
          type: "tuple",
        },
      ],
      name: "TokensMintedWithSignature",
      type: "event",
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "address",
              name: "to",
              type: "address",
            },
            {
              internalType: "address",
              name: "royaltyRecipient",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "royaltyBps",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "primarySaleRecipient",
              type: "address",
            },
            {
              internalType: "string",
              name: "uri",
              type: "string",
            },
            {
              internalType: "uint256",
              name: "quantity",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "pricePerToken",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
            {
              internalType: "uint128",
              name: "validityStartTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "validityEndTimestamp",
              type: "uint128",
            },
            {
              internalType: "bytes32",
              name: "uid",
              type: "bytes32",
            },
          ],
          internalType: "struct ISignatureMintERC721.MintRequest",
          name: "req",
          type: "tuple",
        },
        {
          internalType: "bytes",
          name: "signature",
          type: "bytes",
        },
      ],
      name: "mintWithSignature",
      outputs: [
        {
          internalType: "address",
          name: "signer",
          type: "address",
        },
      ],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "address",
              name: "to",
              type: "address",
            },
            {
              internalType: "address",
              name: "royaltyRecipient",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "royaltyBps",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "primarySaleRecipient",
              type: "address",
            },
            {
              internalType: "string",
              name: "uri",
              type: "string",
            },
            {
              internalType: "uint256",
              name: "quantity",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "pricePerToken",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
            {
              internalType: "uint128",
              name: "validityStartTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "validityEndTimestamp",
              type: "uint128",
            },
            {
              internalType: "bytes32",
              name: "uid",
              type: "bytes32",
            },
          ],
          internalType: "struct ISignatureMintERC721.MintRequest",
          name: "req",
          type: "tuple",
        },
        {
          internalType: "bytes",
          name: "signature",
          type: "bytes",
        },
      ],
      name: "verify",
      outputs: [
        {
          internalType: "bool",
          name: "success",
          type: "bool",
        },
        {
          internalType: "address",
          name: "signer",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  Xce = [
    {
      inputs: [
        {
          components: [
            {
              internalType: "address",
              name: "to",
              type: "address",
            },
            {
              internalType: "address",
              name: "royaltyRecipient",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "royaltyBps",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "primarySaleRecipient",
              type: "address",
            },
            {
              internalType: "string",
              name: "uri",
              type: "string",
            },
            {
              internalType: "uint256",
              name: "price",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
            {
              internalType: "uint128",
              name: "validityStartTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "validityEndTimestamp",
              type: "uint128",
            },
            {
              internalType: "bytes32",
              name: "uid",
              type: "bytes32",
            },
          ],
          internalType: "struct ITokenERC721.MintRequest",
          name: "_req",
          type: "tuple",
        },
        {
          internalType: "bytes",
          name: "_signature",
          type: "bytes",
        },
      ],
      name: "mintWithSignature",
      outputs: [
        {
          internalType: "uint256",
          name: "tokenIdMinted",
          type: "uint256",
        },
      ],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "address",
              name: "to",
              type: "address",
            },
            {
              internalType: "address",
              name: "royaltyRecipient",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "royaltyBps",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "primarySaleRecipient",
              type: "address",
            },
            {
              internalType: "string",
              name: "uri",
              type: "string",
            },
            {
              internalType: "uint256",
              name: "price",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
            {
              internalType: "uint128",
              name: "validityStartTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "validityEndTimestamp",
              type: "uint128",
            },
            {
              internalType: "bytes32",
              name: "uid",
              type: "bytes32",
            },
          ],
          internalType: "struct ITokenERC721.MintRequest",
          name: "_req",
          type: "tuple",
        },
        {
          internalType: "bytes",
          name: "_signature",
          type: "bytes",
        },
      ],
      name: "verify",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
        {
          internalType: "address",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  ele = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "string",
          name: "tier",
          type: "string",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "startTokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "endTokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "string",
          name: "baseURI",
          type: "string",
        },
        {
          indexed: !1,
          internalType: "bytes",
          name: "encryptedBaseURI",
          type: "bytes",
        },
      ],
      name: "TokensLazyMinted",
      type: "event",
    },
    {
      inputs: [],
      name: "getBaseURICount",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "_index",
          type: "uint256",
        },
      ],
      name: "getBatchIdAtIndex",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "getMetadataForAllTiers",
      outputs: [
        {
          components: [
            {
              internalType: "string",
              name: "tier",
              type: "string",
            },
            {
              components: [
                {
                  internalType: "uint256",
                  name: "startIdInclusive",
                  type: "uint256",
                },
                {
                  internalType: "uint256",
                  name: "endIdNonInclusive",
                  type: "uint256",
                },
              ],
              internalType: "struct LazyMintWithTier.TokenRange[]",
              name: "ranges",
              type: "tuple[]",
            },
            {
              internalType: "string[]",
              name: "baseURIs",
              type: "string[]",
            },
          ],
          internalType: "struct LazyMintWithTier.TierMetadata[]",
          name: "metadataForAllTiers",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "_amount",
          type: "uint256",
        },
        {
          internalType: "string",
          name: "_baseURIForTokens",
          type: "string",
        },
        {
          internalType: "string",
          name: "_tier",
          type: "string",
        },
        {
          internalType: "bytes",
          name: "_data",
          type: "bytes",
        },
      ],
      name: "lazyMint",
      outputs: [
        {
          internalType: "uint256",
          name: "batchId",
          type: "uint256",
        },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  tle = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "uint256",
          name: "_fromTokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "_toTokenId",
          type: "uint256",
        },
      ],
      name: "BatchMetadataUpdate",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "uint256",
          name: "_tokenId",
          type: "uint256",
        },
      ],
      name: "MetadataUpdate",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "string",
          name: "name",
          type: "string",
        },
        {
          indexed: !1,
          internalType: "string",
          name: "description",
          type: "string",
        },
        {
          indexed: !1,
          internalType: "string",
          name: "imageURI",
          type: "string",
        },
        {
          indexed: !1,
          internalType: "string",
          name: "animationURI",
          type: "string",
        },
      ],
      name: "SharedMetadataUpdated",
      type: "event",
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "string",
              name: "name",
              type: "string",
            },
            {
              internalType: "string",
              name: "description",
              type: "string",
            },
            {
              internalType: "string",
              name: "imageURI",
              type: "string",
            },
            {
              internalType: "string",
              name: "animationURI",
              type: "string",
            },
          ],
          internalType: "struct ISharedMetadata.SharedMetadataInfo",
          name: "_metadata",
          type: "tuple",
        },
      ],
      name: "setSharedMetadata",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "sharedMetadata",
      outputs: [
        {
          internalType: "string",
          name: "name",
          type: "string",
        },
        {
          internalType: "string",
          name: "description",
          type: "string",
        },
        {
          internalType: "string",
          name: "imageURI",
          type: "string",
        },
        {
          internalType: "string",
          name: "animationURI",
          type: "string",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "interfaceId",
          type: "bytes4",
        },
      ],
      name: "supportsInterface",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  rle = [
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
      ],
      name: "Access_MissingRoleOrAdmin",
      type: "error",
    },
    {
      inputs: [],
      name: "Access_OnlyAdmin",
      type: "error",
    },
    {
      inputs: [],
      name: "Access_WithdrawNotAllowed",
      type: "error",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "proposedAddress",
          type: "address",
        },
      ],
      name: "Admin_InvalidUpgradeAddress",
      type: "error",
    },
    {
      inputs: [],
      name: "Admin_UnableToFinalizeNotOpenEdition",
      type: "error",
    },
    {
      inputs: [],
      name: "ExternalMetadataRenderer_CallFailed",
      type: "error",
    },
    {
      inputs: [],
      name: "InvalidMintSchedule",
      type: "error",
    },
    {
      inputs: [],
      name: "MarketFilterDAOAddressNotSupportedForChain",
      type: "error",
    },
    {
      inputs: [],
      name: "MintFee_FundsSendFailure",
      type: "error",
    },
    {
      inputs: [],
      name: "Mint_SoldOut",
      type: "error",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "operator",
          type: "address",
        },
      ],
      name: "OperatorNotAllowed",
      type: "error",
    },
    {
      inputs: [],
      name: "Presale_Inactive",
      type: "error",
    },
    {
      inputs: [],
      name: "Presale_MerkleNotApproved",
      type: "error",
    },
    {
      inputs: [],
      name: "Presale_TooManyForAddress",
      type: "error",
    },
    {
      inputs: [],
      name: "Purchase_TooManyForAddress",
      type: "error",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "correctPrice",
          type: "uint256",
        },
      ],
      name: "Purchase_WrongPrice",
      type: "error",
    },
    {
      inputs: [],
      name: "RemoteOperatorFilterRegistryCallFailed",
      type: "error",
    },
    {
      inputs: [],
      name: "Sale_Inactive",
      type: "error",
    },
    {
      inputs: [
        {
          internalType: "uint16",
          name: "maxRoyaltyBPS",
          type: "uint16",
        },
      ],
      name: "Setup_RoyaltyPercentageTooHigh",
      type: "error",
    },
    {
      inputs: [],
      name: "Withdraw_FundsSendFailure",
      type: "error",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "newAddress",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "changedBy",
          type: "address",
        },
      ],
      name: "FundsRecipientChanged",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "withdrawnBy",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "withdrawnTo",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "amount",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "address",
          name: "feeRecipient",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "feeAmount",
          type: "uint256",
        },
      ],
      name: "FundsWithdrawn",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "sender",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "tokenContract",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "quantity",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "string",
          name: "comment",
          type: "string",
        },
      ],
      name: "MintComment",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "uint256",
          name: "mintFeeAmount",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "address",
          name: "mintFeeRecipient",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "bool",
          name: "success",
          type: "bool",
        },
      ],
      name: "MintFeePayout",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "sender",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "numberOfMints",
          type: "uint256",
        },
      ],
      name: "OpenMintFinalized",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "to",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "quantity",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "pricePerToken",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "firstPurchasedTokenId",
          type: "uint256",
        },
      ],
      name: "Sale",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "changedBy",
          type: "address",
        },
      ],
      name: "SalesConfigChanged",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "address",
          name: "sender",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "contract IMetadataRenderer",
          name: "renderer",
          type: "address",
        },
      ],
      name: "UpdatedMetadataRenderer",
      type: "event",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "to",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "quantity",
          type: "uint256",
        },
      ],
      name: "adminMint",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256",
        },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address[]",
          name: "to",
          type: "address[]",
        },
      ],
      name: "adminMintAirdrop",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256",
        },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "user",
          type: "address",
        },
      ],
      name: "isAdmin",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "minter",
          type: "address",
        },
      ],
      name: "mintedPerAddress",
      outputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "totalMints",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "presaleMints",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "publicMints",
              type: "uint256",
            },
          ],
          internalType: "struct IERC721Drop.AddressMintDetails",
          name: "",
          type: "tuple",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "owner",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "quantity",
          type: "uint256",
        },
      ],
      name: "purchase",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256",
        },
      ],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "quantity",
          type: "uint256",
        },
        {
          internalType: "uint256",
          name: "maxQuantity",
          type: "uint256",
        },
        {
          internalType: "uint256",
          name: "pricePerToken",
          type: "uint256",
        },
        {
          internalType: "bytes32[]",
          name: "merkleProof",
          type: "bytes32[]",
        },
      ],
      name: "purchasePresale",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256",
        },
      ],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [],
      name: "saleDetails",
      outputs: [
        {
          components: [
            {
              internalType: "bool",
              name: "publicSaleActive",
              type: "bool",
            },
            {
              internalType: "bool",
              name: "presaleActive",
              type: "bool",
            },
            {
              internalType: "uint256",
              name: "publicSalePrice",
              type: "uint256",
            },
            {
              internalType: "uint64",
              name: "publicSaleStart",
              type: "uint64",
            },
            {
              internalType: "uint64",
              name: "publicSaleEnd",
              type: "uint64",
            },
            {
              internalType: "uint64",
              name: "presaleStart",
              type: "uint64",
            },
            {
              internalType: "uint64",
              name: "presaleEnd",
              type: "uint64",
            },
            {
              internalType: "bytes32",
              name: "presaleMerkleRoot",
              type: "bytes32",
            },
            {
              internalType: "uint256",
              name: "maxSalePurchasePerAddress",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "totalMinted",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "maxSupply",
              type: "uint256",
            },
          ],
          internalType: "struct IERC721Drop.SaleDetails",
          name: "",
          type: "tuple",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "contract IMetadataRenderer",
          name: "newRenderer",
          type: "address",
        },
        {
          internalType: "bytes",
          name: "setupRenderer",
          type: "bytes",
        },
      ],
      name: "setMetadataRenderer",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint104",
          name: "publicSalePrice",
          type: "uint104",
        },
        {
          internalType: "uint32",
          name: "maxSalePurchasePerAddress",
          type: "uint32",
        },
        {
          internalType: "uint64",
          name: "publicSaleStart",
          type: "uint64",
        },
        {
          internalType: "uint64",
          name: "publicSaleEnd",
          type: "uint64",
        },
        {
          internalType: "uint64",
          name: "presaleStart",
          type: "uint64",
        },
        {
          internalType: "uint64",
          name: "presaleEnd",
          type: "uint64",
        },
        {
          internalType: "bytes32",
          name: "presaleMerkleRoot",
          type: "bytes32",
        },
      ],
      name: "setSaleConfiguration",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  nle = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "mintedTo",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenIdMinted",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "string",
          name: "uri",
          type: "string",
        },
      ],
      name: "TokensMinted",
      type: "event",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "cancel",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "to",
          type: "address",
        },
        {
          internalType: "string",
          name: "uri",
          type: "string",
        },
      ],
      name: "mintTo",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256",
        },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "revoke",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  gF = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "uint256",
          name: "_fromTokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "_toTokenId",
          type: "uint256",
        },
      ],
      name: "BatchMetadataUpdate",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "uint256",
          name: "_tokenId",
          type: "uint256",
        },
      ],
      name: "MetadataUpdate",
      type: "event",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "_tokenId",
          type: "uint256",
        },
        {
          internalType: "string",
          name: "_uri",
          type: "string",
        },
      ],
      name: "setTokenURI",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "interfaceId",
          type: "bytes4",
        },
      ],
      name: "supportsInterface",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  ile = [
    {
      inputs: [
        {
          internalType: "address",
          name: "account",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "id",
          type: "uint256",
        },
        {
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
      ],
      name: "burn",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "account",
          type: "address",
        },
        {
          internalType: "uint256[]",
          name: "ids",
          type: "uint256[]",
        },
        {
          internalType: "uint256[]",
          name: "values",
          type: "uint256[]",
        },
      ],
      name: "burnBatch",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  ale = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "claimer",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "receiver",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "quantityClaimed",
          type: "uint256",
        },
      ],
      name: "TokensClaimed",
      type: "event",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_receiver",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "_tokenId",
          type: "uint256",
        },
        {
          internalType: "uint256",
          name: "_quantity",
          type: "uint256",
        },
      ],
      name: "claim",
      outputs: [],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_claimer",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "_tokenId",
          type: "uint256",
        },
        {
          internalType: "uint256",
          name: "_quantity",
          type: "uint256",
        },
      ],
      name: "verifyClaim",
      outputs: [],
      stateMutability: "view",
      type: "function",
    },
  ],
  sle = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          components: [
            {
              internalType: "uint256",
              name: "startTimestamp",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "maxClaimableSupply",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "supplyClaimed",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "quantityLimitPerWallet",
              type: "uint256",
            },
            {
              internalType: "bytes32",
              name: "merkleRoot",
              type: "bytes32",
            },
            {
              internalType: "uint256",
              name: "pricePerToken",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
            {
              internalType: "string",
              name: "metadata",
              type: "string",
            },
          ],
          indexed: !1,
          internalType: "struct IClaimCondition.ClaimCondition[]",
          name: "claimConditions",
          type: "tuple[]",
        },
        {
          indexed: !1,
          internalType: "bool",
          name: "resetEligibility",
          type: "bool",
        },
      ],
      name: "ClaimConditionsUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "claimConditionIndex",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "claimer",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "receiver",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "quantityClaimed",
          type: "uint256",
        },
      ],
      name: "TokensClaimed",
      type: "event",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "receiver",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          internalType: "uint256",
          name: "quantity",
          type: "uint256",
        },
        {
          internalType: "address",
          name: "currency",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "pricePerToken",
          type: "uint256",
        },
        {
          components: [
            {
              internalType: "bytes32[]",
              name: "proof",
              type: "bytes32[]",
            },
            {
              internalType: "uint256",
              name: "quantityLimitPerWallet",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "pricePerToken",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
          ],
          internalType: "struct IDrop1155.AllowlistProof",
          name: "allowlistProof",
          type: "tuple",
        },
        {
          internalType: "bytes",
          name: "data",
          type: "bytes",
        },
      ],
      name: "claim",
      outputs: [],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          components: [
            {
              internalType: "uint256",
              name: "startTimestamp",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "maxClaimableSupply",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "supplyClaimed",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "quantityLimitPerWallet",
              type: "uint256",
            },
            {
              internalType: "bytes32",
              name: "merkleRoot",
              type: "bytes32",
            },
            {
              internalType: "uint256",
              name: "pricePerToken",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
            {
              internalType: "string",
              name: "metadata",
              type: "string",
            },
          ],
          internalType: "struct IClaimCondition.ClaimCondition[]",
          name: "phases",
          type: "tuple[]",
        },
        {
          internalType: "bool",
          name: "resetClaimEligibility",
          type: "bool",
        },
      ],
      name: "setClaimConditions",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  bF = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "account",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "bool",
          name: "approved",
          type: "bool",
        },
      ],
      name: "ApprovalForAll",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          components: [
            {
              internalType: "uint256",
              name: "startTimestamp",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "maxClaimableSupply",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "supplyClaimed",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "quantityLimitPerTransaction",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "waitTimeInSecondsBetweenClaims",
              type: "uint256",
            },
            {
              internalType: "bytes32",
              name: "merkleRoot",
              type: "bytes32",
            },
            {
              internalType: "uint256",
              name: "pricePerToken",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
          ],
          indexed: !1,
          internalType: "struct IDropClaimCondition_V2.ClaimCondition[]",
          name: "claimConditions",
          type: "tuple[]",
        },
      ],
      name: "ClaimConditionsUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "maxTotalSupply",
          type: "uint256",
        },
      ],
      name: "MaxTotalSupplyUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "count",
          type: "uint256",
        },
      ],
      name: "MaxWalletClaimCountUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "address",
          name: "saleRecipient",
          type: "address",
        },
      ],
      name: "SaleRecipientForTokenUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "claimConditionIndex",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "claimer",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "address",
          name: "receiver",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "quantityClaimed",
          type: "uint256",
        },
      ],
      name: "TokensClaimed",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "uint256",
          name: "startTokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "endTokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "string",
          name: "baseURI",
          type: "string",
        },
      ],
      name: "TokensLazyMinted",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "from",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "to",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256[]",
          name: "ids",
          type: "uint256[]",
        },
        {
          indexed: !1,
          internalType: "uint256[]",
          name: "values",
          type: "uint256[]",
        },
      ],
      name: "TransferBatch",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "from",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "to",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "id",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
      ],
      name: "TransferSingle",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "string",
          name: "value",
          type: "string",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "id",
          type: "uint256",
        },
      ],
      name: "URI",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "wallet",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "count",
          type: "uint256",
        },
      ],
      name: "WalletClaimCountUpdated",
      type: "event",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "account",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "id",
          type: "uint256",
        },
      ],
      name: "balanceOf",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address[]",
          name: "accounts",
          type: "address[]",
        },
        {
          internalType: "uint256[]",
          name: "ids",
          type: "uint256[]",
        },
      ],
      name: "balanceOfBatch",
      outputs: [
        {
          internalType: "uint256[]",
          name: "",
          type: "uint256[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "receiver",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          internalType: "uint256",
          name: "quantity",
          type: "uint256",
        },
        {
          internalType: "address",
          name: "currency",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "pricePerToken",
          type: "uint256",
        },
        {
          internalType: "bytes32[]",
          name: "proofs",
          type: "bytes32[]",
        },
        {
          internalType: "uint256",
          name: "proofMaxQuantityPerTransaction",
          type: "uint256",
        },
      ],
      name: "claim",
      outputs: [],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "account",
          type: "address",
        },
        {
          internalType: "address",
          name: "operator",
          type: "address",
        },
      ],
      name: "isApprovedForAll",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256",
        },
        {
          internalType: "string",
          name: "baseURIForTokens",
          type: "string",
        },
      ],
      name: "lazyMint",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "from",
          type: "address",
        },
        {
          internalType: "address",
          name: "to",
          type: "address",
        },
        {
          internalType: "uint256[]",
          name: "ids",
          type: "uint256[]",
        },
        {
          internalType: "uint256[]",
          name: "amounts",
          type: "uint256[]",
        },
        {
          internalType: "bytes",
          name: "data",
          type: "bytes",
        },
      ],
      name: "safeBatchTransferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "from",
          type: "address",
        },
        {
          internalType: "address",
          name: "to",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "id",
          type: "uint256",
        },
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256",
        },
        {
          internalType: "bytes",
          name: "data",
          type: "bytes",
        },
      ],
      name: "safeTransferFrom",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "operator",
          type: "address",
        },
        {
          internalType: "bool",
          name: "approved",
          type: "bool",
        },
      ],
      name: "setApprovalForAll",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          components: [
            {
              internalType: "uint256",
              name: "startTimestamp",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "maxClaimableSupply",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "supplyClaimed",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "quantityLimitPerTransaction",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "waitTimeInSecondsBetweenClaims",
              type: "uint256",
            },
            {
              internalType: "bytes32",
              name: "merkleRoot",
              type: "bytes32",
            },
            {
              internalType: "uint256",
              name: "pricePerToken",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
          ],
          internalType: "struct IDropClaimCondition_V2.ClaimCondition[]",
          name: "phases",
          type: "tuple[]",
        },
        {
          internalType: "bool",
          name: "resetClaimEligibility",
          type: "bool",
        },
      ],
      name: "setClaimConditions",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "interfaceId",
          type: "bytes4",
        },
      ],
      name: "supportsInterface",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  ole = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          components: [
            {
              internalType: "uint256",
              name: "startTimestamp",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "maxClaimableSupply",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "supplyClaimed",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "quantityLimitPerWallet",
              type: "uint256",
            },
            {
              internalType: "bytes32",
              name: "merkleRoot",
              type: "bytes32",
            },
            {
              internalType: "uint256",
              name: "pricePerToken",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
            {
              internalType: "string",
              name: "metadata",
              type: "string",
            },
          ],
          indexed: !1,
          internalType: "struct IClaimCondition.ClaimCondition",
          name: "condition",
          type: "tuple",
        },
        {
          indexed: !1,
          internalType: "bool",
          name: "resetEligibility",
          type: "bool",
        },
      ],
      name: "ClaimConditionUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "claimer",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "receiver",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "quantityClaimed",
          type: "uint256",
        },
      ],
      name: "TokensClaimed",
      type: "event",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "receiver",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          internalType: "uint256",
          name: "quantity",
          type: "uint256",
        },
        {
          internalType: "address",
          name: "currency",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "pricePerToken",
          type: "uint256",
        },
        {
          components: [
            {
              internalType: "bytes32[]",
              name: "proof",
              type: "bytes32[]",
            },
            {
              internalType: "uint256",
              name: "quantityLimitPerWallet",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "pricePerToken",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
          ],
          internalType: "struct IDropSinglePhase1155.AllowlistProof",
          name: "allowlistProof",
          type: "tuple",
        },
        {
          internalType: "bytes",
          name: "data",
          type: "bytes",
        },
      ],
      name: "claim",
      outputs: [],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          components: [
            {
              internalType: "uint256",
              name: "startTimestamp",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "maxClaimableSupply",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "supplyClaimed",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "quantityLimitPerWallet",
              type: "uint256",
            },
            {
              internalType: "bytes32",
              name: "merkleRoot",
              type: "bytes32",
            },
            {
              internalType: "uint256",
              name: "pricePerToken",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
            {
              internalType: "string",
              name: "metadata",
              type: "string",
            },
          ],
          internalType: "struct IClaimCondition.ClaimCondition",
          name: "phase",
          type: "tuple",
        },
        {
          internalType: "bool",
          name: "resetClaimEligibility",
          type: "bool",
        },
      ],
      name: "setClaimConditions",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  cle = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          components: [
            {
              internalType: "uint256",
              name: "startTimestamp",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "maxClaimableSupply",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "supplyClaimed",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "quantityLimitPerTransaction",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "waitTimeInSecondsBetweenClaims",
              type: "uint256",
            },
            {
              internalType: "bytes32",
              name: "merkleRoot",
              type: "bytes32",
            },
            {
              internalType: "uint256",
              name: "pricePerToken",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
          ],
          indexed: !1,
          internalType: "struct IClaimCondition_V1.ClaimCondition",
          name: "condition",
          type: "tuple",
        },
        {
          indexed: !1,
          internalType: "bool",
          name: "resetEligibility",
          type: "bool",
        },
      ],
      name: "ClaimConditionUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "claimer",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "receiver",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "quantityClaimed",
          type: "uint256",
        },
      ],
      name: "TokensClaimed",
      type: "event",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "receiver",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          internalType: "uint256",
          name: "quantity",
          type: "uint256",
        },
        {
          internalType: "address",
          name: "currency",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "pricePerToken",
          type: "uint256",
        },
        {
          components: [
            {
              internalType: "bytes32[]",
              name: "proof",
              type: "bytes32[]",
            },
            {
              internalType: "uint256",
              name: "maxQuantityInAllowlist",
              type: "uint256",
            },
          ],
          internalType: "struct IDropSinglePhase1155_V1.AllowlistProof",
          name: "allowlistProof",
          type: "tuple",
        },
        {
          internalType: "bytes",
          name: "data",
          type: "bytes",
        },
      ],
      name: "claim",
      outputs: [],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          components: [
            {
              internalType: "uint256",
              name: "startTimestamp",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "maxClaimableSupply",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "supplyClaimed",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "quantityLimitPerTransaction",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "waitTimeInSecondsBetweenClaims",
              type: "uint256",
            },
            {
              internalType: "bytes32",
              name: "merkleRoot",
              type: "bytes32",
            },
            {
              internalType: "uint256",
              name: "pricePerToken",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
          ],
          internalType: "struct IClaimCondition_V1.ClaimCondition",
          name: "phase",
          type: "tuple",
        },
        {
          internalType: "bool",
          name: "resetClaimEligibility",
          type: "bool",
        },
      ],
      name: "setClaimConditions",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  lle = [
    {
      inputs: [
        {
          internalType: "uint256",
          name: "id",
          type: "uint256",
        },
      ],
      name: "totalSupply",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  ule = [
    {
      inputs: [],
      name: "nextTokenIdToMint",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  vF = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "mintedTo",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenIdMinted",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "string",
          name: "uri",
          type: "string",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "quantityMinted",
          type: "uint256",
        },
      ],
      name: "TokensMinted",
      type: "event",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "to",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          internalType: "string",
          name: "uri",
          type: "string",
        },
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256",
        },
      ],
      name: "mintTo",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  fle = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "signer",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "mintedTo",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenIdMinted",
          type: "uint256",
        },
        {
          components: [
            {
              internalType: "address",
              name: "to",
              type: "address",
            },
            {
              internalType: "address",
              name: "royaltyRecipient",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "royaltyBps",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "primarySaleRecipient",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "tokenId",
              type: "uint256",
            },
            {
              internalType: "string",
              name: "uri",
              type: "string",
            },
            {
              internalType: "uint256",
              name: "quantity",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "pricePerToken",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
            {
              internalType: "uint128",
              name: "validityStartTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "validityEndTimestamp",
              type: "uint128",
            },
            {
              internalType: "bytes32",
              name: "uid",
              type: "bytes32",
            },
          ],
          indexed: !1,
          internalType: "struct ISignatureMintERC1155.MintRequest",
          name: "mintRequest",
          type: "tuple",
        },
      ],
      name: "TokensMintedWithSignature",
      type: "event",
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "address",
              name: "to",
              type: "address",
            },
            {
              internalType: "address",
              name: "royaltyRecipient",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "royaltyBps",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "primarySaleRecipient",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "tokenId",
              type: "uint256",
            },
            {
              internalType: "string",
              name: "uri",
              type: "string",
            },
            {
              internalType: "uint256",
              name: "quantity",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "pricePerToken",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
            {
              internalType: "uint128",
              name: "validityStartTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "validityEndTimestamp",
              type: "uint128",
            },
            {
              internalType: "bytes32",
              name: "uid",
              type: "bytes32",
            },
          ],
          internalType: "struct ISignatureMintERC1155.MintRequest",
          name: "req",
          type: "tuple",
        },
        {
          internalType: "bytes",
          name: "signature",
          type: "bytes",
        },
      ],
      name: "mintWithSignature",
      outputs: [
        {
          internalType: "address",
          name: "signer",
          type: "address",
        },
      ],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "address",
              name: "to",
              type: "address",
            },
            {
              internalType: "address",
              name: "royaltyRecipient",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "royaltyBps",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "primarySaleRecipient",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "tokenId",
              type: "uint256",
            },
            {
              internalType: "string",
              name: "uri",
              type: "string",
            },
            {
              internalType: "uint256",
              name: "quantity",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "pricePerToken",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
            {
              internalType: "uint128",
              name: "validityStartTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "validityEndTimestamp",
              type: "uint128",
            },
            {
              internalType: "bytes32",
              name: "uid",
              type: "bytes32",
            },
          ],
          internalType: "struct ISignatureMintERC1155.MintRequest",
          name: "req",
          type: "tuple",
        },
        {
          internalType: "bytes",
          name: "signature",
          type: "bytes",
        },
      ],
      name: "verify",
      outputs: [
        {
          internalType: "bool",
          name: "success",
          type: "bool",
        },
        {
          internalType: "address",
          name: "signer",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  dle = [
    {
      inputs: [
        {
          internalType: "address",
          name: "forwarder",
          type: "address",
        },
      ],
      name: "isTrustedForwarder",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  hle = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "string",
          name: "prevURI",
          type: "string",
        },
        {
          indexed: !1,
          internalType: "string",
          name: "newURI",
          type: "string",
        },
      ],
      name: "AppURIUpdated",
      type: "event",
    },
    {
      inputs: [],
      name: "appURI",
      outputs: [
        {
          internalType: "string",
          name: "",
          type: "string",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "string",
          name: "_uri",
          type: "string",
        },
      ],
      name: "setAppURI",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  ple = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "string",
          name: "prevURI",
          type: "string",
        },
        {
          indexed: !1,
          internalType: "string",
          name: "newURI",
          type: "string",
        },
      ],
      name: "ContractURIUpdated",
      type: "event",
    },
    {
      inputs: [],
      name: "contractURI",
      outputs: [
        {
          internalType: "string",
          name: "",
          type: "string",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "string",
          name: "_uri",
          type: "string",
        },
      ],
      name: "setContractURI",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  mle = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "listingId",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "buyer",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "bool",
          name: "approved",
          type: "bool",
        },
      ],
      name: "BuyerApprovedForListing",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "listingCreator",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "listingId",
          type: "uint256",
        },
      ],
      name: "CancelledListing",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "listingId",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "currency",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "pricePerToken",
          type: "uint256",
        },
      ],
      name: "CurrencyApprovedForListing",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "listingCreator",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "listingId",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "assetContract",
          type: "address",
        },
        {
          components: [
            {
              internalType: "uint256",
              name: "listingId",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "listingCreator",
              type: "address",
            },
            {
              internalType: "address",
              name: "assetContract",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "tokenId",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "quantity",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "pricePerToken",
              type: "uint256",
            },
            {
              internalType: "uint128",
              name: "startTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "endTimestamp",
              type: "uint128",
            },
            {
              internalType: "bool",
              name: "reserved",
              type: "bool",
            },
            {
              internalType: "enum IDirectListings.TokenType",
              name: "tokenType",
              type: "uint8",
            },
            {
              internalType: "enum IDirectListings.Status",
              name: "status",
              type: "uint8",
            },
          ],
          indexed: !1,
          internalType: "struct IDirectListings.Listing",
          name: "listing",
          type: "tuple",
        },
      ],
      name: "NewListing",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "listingCreator",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "listingId",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "assetContract",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "address",
          name: "buyer",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "quantityBought",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "totalPricePaid",
          type: "uint256",
        },
      ],
      name: "NewSale",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "listingCreator",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "listingId",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "assetContract",
          type: "address",
        },
        {
          components: [
            {
              internalType: "uint256",
              name: "listingId",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "listingCreator",
              type: "address",
            },
            {
              internalType: "address",
              name: "assetContract",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "tokenId",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "quantity",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "pricePerToken",
              type: "uint256",
            },
            {
              internalType: "uint128",
              name: "startTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "endTimestamp",
              type: "uint128",
            },
            {
              internalType: "bool",
              name: "reserved",
              type: "bool",
            },
            {
              internalType: "enum IDirectListings.TokenType",
              name: "tokenType",
              type: "uint8",
            },
            {
              internalType: "enum IDirectListings.Status",
              name: "status",
              type: "uint8",
            },
          ],
          indexed: !1,
          internalType: "struct IDirectListings.Listing",
          name: "listing",
          type: "tuple",
        },
      ],
      name: "UpdatedListing",
      type: "event",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "_listingId",
          type: "uint256",
        },
        {
          internalType: "address",
          name: "_buyer",
          type: "address",
        },
        {
          internalType: "bool",
          name: "_toApprove",
          type: "bool",
        },
      ],
      name: "approveBuyerForListing",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "_listingId",
          type: "uint256",
        },
        {
          internalType: "address",
          name: "_currency",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "_pricePerTokenInCurrency",
          type: "uint256",
        },
      ],
      name: "approveCurrencyForListing",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "_listingId",
          type: "uint256",
        },
        {
          internalType: "address",
          name: "_buyFor",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "_quantity",
          type: "uint256",
        },
        {
          internalType: "address",
          name: "_currency",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "_expectedTotalPrice",
          type: "uint256",
        },
      ],
      name: "buyFromListing",
      outputs: [],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "_listingId",
          type: "uint256",
        },
      ],
      name: "cancelListing",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "address",
              name: "assetContract",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "tokenId",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "quantity",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "pricePerToken",
              type: "uint256",
            },
            {
              internalType: "uint128",
              name: "startTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "endTimestamp",
              type: "uint128",
            },
            {
              internalType: "bool",
              name: "reserved",
              type: "bool",
            },
          ],
          internalType: "struct IDirectListings.ListingParameters",
          name: "_params",
          type: "tuple",
        },
      ],
      name: "createListing",
      outputs: [
        {
          internalType: "uint256",
          name: "listingId",
          type: "uint256",
        },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "_startId",
          type: "uint256",
        },
        {
          internalType: "uint256",
          name: "_endId",
          type: "uint256",
        },
      ],
      name: "getAllListings",
      outputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "listingId",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "listingCreator",
              type: "address",
            },
            {
              internalType: "address",
              name: "assetContract",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "tokenId",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "quantity",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "pricePerToken",
              type: "uint256",
            },
            {
              internalType: "uint128",
              name: "startTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "endTimestamp",
              type: "uint128",
            },
            {
              internalType: "bool",
              name: "reserved",
              type: "bool",
            },
            {
              internalType: "enum IDirectListings.TokenType",
              name: "tokenType",
              type: "uint8",
            },
            {
              internalType: "enum IDirectListings.Status",
              name: "status",
              type: "uint8",
            },
          ],
          internalType: "struct IDirectListings.Listing[]",
          name: "listings",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "_startId",
          type: "uint256",
        },
        {
          internalType: "uint256",
          name: "_endId",
          type: "uint256",
        },
      ],
      name: "getAllValidListings",
      outputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "listingId",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "listingCreator",
              type: "address",
            },
            {
              internalType: "address",
              name: "assetContract",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "tokenId",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "quantity",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "pricePerToken",
              type: "uint256",
            },
            {
              internalType: "uint128",
              name: "startTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "endTimestamp",
              type: "uint128",
            },
            {
              internalType: "bool",
              name: "reserved",
              type: "bool",
            },
            {
              internalType: "enum IDirectListings.TokenType",
              name: "tokenType",
              type: "uint8",
            },
            {
              internalType: "enum IDirectListings.Status",
              name: "status",
              type: "uint8",
            },
          ],
          internalType: "struct IDirectListings.Listing[]",
          name: "listings",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "_listingId",
          type: "uint256",
        },
      ],
      name: "getListing",
      outputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "listingId",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "listingCreator",
              type: "address",
            },
            {
              internalType: "address",
              name: "assetContract",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "tokenId",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "quantity",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "pricePerToken",
              type: "uint256",
            },
            {
              internalType: "uint128",
              name: "startTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "endTimestamp",
              type: "uint128",
            },
            {
              internalType: "bool",
              name: "reserved",
              type: "bool",
            },
            {
              internalType: "enum IDirectListings.TokenType",
              name: "tokenType",
              type: "uint8",
            },
            {
              internalType: "enum IDirectListings.Status",
              name: "status",
              type: "uint8",
            },
          ],
          internalType: "struct IDirectListings.Listing",
          name: "listing",
          type: "tuple",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "totalListings",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "_listingId",
          type: "uint256",
        },
        {
          components: [
            {
              internalType: "address",
              name: "assetContract",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "tokenId",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "quantity",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "pricePerToken",
              type: "uint256",
            },
            {
              internalType: "uint128",
              name: "startTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "endTimestamp",
              type: "uint128",
            },
            {
              internalType: "bool",
              name: "reserved",
              type: "bool",
            },
          ],
          internalType: "struct IDirectListings.ListingParameters",
          name: "_params",
          type: "tuple",
        },
      ],
      name: "updateListing",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  yle = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "auctionId",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "assetContract",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "closer",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "address",
          name: "auctionCreator",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "address",
          name: "winningBidder",
          type: "address",
        },
      ],
      name: "AuctionClosed",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "auctionCreator",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "auctionId",
          type: "uint256",
        },
      ],
      name: "CancelledAuction",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "auctionCreator",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "auctionId",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "assetContract",
          type: "address",
        },
        {
          components: [
            {
              internalType: "uint256",
              name: "auctionId",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "auctionCreator",
              type: "address",
            },
            {
              internalType: "address",
              name: "assetContract",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "tokenId",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "quantity",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "minimumBidAmount",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "buyoutBidAmount",
              type: "uint256",
            },
            {
              internalType: "uint64",
              name: "timeBufferInSeconds",
              type: "uint64",
            },
            {
              internalType: "uint64",
              name: "bidBufferBps",
              type: "uint64",
            },
            {
              internalType: "uint64",
              name: "startTimestamp",
              type: "uint64",
            },
            {
              internalType: "uint64",
              name: "endTimestamp",
              type: "uint64",
            },
            {
              internalType: "enum IEnglishAuctions.TokenType",
              name: "tokenType",
              type: "uint8",
            },
            {
              internalType: "enum IEnglishAuctions.Status",
              name: "status",
              type: "uint8",
            },
          ],
          indexed: !1,
          internalType: "struct IEnglishAuctions.Auction",
          name: "auction",
          type: "tuple",
        },
      ],
      name: "NewAuction",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "auctionId",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "bidder",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "assetContract",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "bidAmount",
          type: "uint256",
        },
        {
          components: [
            {
              internalType: "uint256",
              name: "auctionId",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "auctionCreator",
              type: "address",
            },
            {
              internalType: "address",
              name: "assetContract",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "tokenId",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "quantity",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "minimumBidAmount",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "buyoutBidAmount",
              type: "uint256",
            },
            {
              internalType: "uint64",
              name: "timeBufferInSeconds",
              type: "uint64",
            },
            {
              internalType: "uint64",
              name: "bidBufferBps",
              type: "uint64",
            },
            {
              internalType: "uint64",
              name: "startTimestamp",
              type: "uint64",
            },
            {
              internalType: "uint64",
              name: "endTimestamp",
              type: "uint64",
            },
            {
              internalType: "enum IEnglishAuctions.TokenType",
              name: "tokenType",
              type: "uint8",
            },
            {
              internalType: "enum IEnglishAuctions.Status",
              name: "status",
              type: "uint8",
            },
          ],
          indexed: !1,
          internalType: "struct IEnglishAuctions.Auction",
          name: "auction",
          type: "tuple",
        },
      ],
      name: "NewBid",
      type: "event",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "_auctionId",
          type: "uint256",
        },
        {
          internalType: "uint256",
          name: "_bidAmount",
          type: "uint256",
        },
      ],
      name: "bidInAuction",
      outputs: [],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "_auctionId",
          type: "uint256",
        },
      ],
      name: "cancelAuction",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "_auctionId",
          type: "uint256",
        },
      ],
      name: "collectAuctionPayout",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "_auctionId",
          type: "uint256",
        },
      ],
      name: "collectAuctionTokens",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "address",
              name: "assetContract",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "tokenId",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "quantity",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "minimumBidAmount",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "buyoutBidAmount",
              type: "uint256",
            },
            {
              internalType: "uint64",
              name: "timeBufferInSeconds",
              type: "uint64",
            },
            {
              internalType: "uint64",
              name: "bidBufferBps",
              type: "uint64",
            },
            {
              internalType: "uint64",
              name: "startTimestamp",
              type: "uint64",
            },
            {
              internalType: "uint64",
              name: "endTimestamp",
              type: "uint64",
            },
          ],
          internalType: "struct IEnglishAuctions.AuctionParameters",
          name: "_params",
          type: "tuple",
        },
      ],
      name: "createAuction",
      outputs: [
        {
          internalType: "uint256",
          name: "auctionId",
          type: "uint256",
        },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "_startId",
          type: "uint256",
        },
        {
          internalType: "uint256",
          name: "_endId",
          type: "uint256",
        },
      ],
      name: "getAllAuctions",
      outputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "auctionId",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "auctionCreator",
              type: "address",
            },
            {
              internalType: "address",
              name: "assetContract",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "tokenId",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "quantity",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "minimumBidAmount",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "buyoutBidAmount",
              type: "uint256",
            },
            {
              internalType: "uint64",
              name: "timeBufferInSeconds",
              type: "uint64",
            },
            {
              internalType: "uint64",
              name: "bidBufferBps",
              type: "uint64",
            },
            {
              internalType: "uint64",
              name: "startTimestamp",
              type: "uint64",
            },
            {
              internalType: "uint64",
              name: "endTimestamp",
              type: "uint64",
            },
            {
              internalType: "enum IEnglishAuctions.TokenType",
              name: "tokenType",
              type: "uint8",
            },
            {
              internalType: "enum IEnglishAuctions.Status",
              name: "status",
              type: "uint8",
            },
          ],
          internalType: "struct IEnglishAuctions.Auction[]",
          name: "auctions",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "_startId",
          type: "uint256",
        },
        {
          internalType: "uint256",
          name: "_endId",
          type: "uint256",
        },
      ],
      name: "getAllValidAuctions",
      outputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "auctionId",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "auctionCreator",
              type: "address",
            },
            {
              internalType: "address",
              name: "assetContract",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "tokenId",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "quantity",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "minimumBidAmount",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "buyoutBidAmount",
              type: "uint256",
            },
            {
              internalType: "uint64",
              name: "timeBufferInSeconds",
              type: "uint64",
            },
            {
              internalType: "uint64",
              name: "bidBufferBps",
              type: "uint64",
            },
            {
              internalType: "uint64",
              name: "startTimestamp",
              type: "uint64",
            },
            {
              internalType: "uint64",
              name: "endTimestamp",
              type: "uint64",
            },
            {
              internalType: "enum IEnglishAuctions.TokenType",
              name: "tokenType",
              type: "uint8",
            },
            {
              internalType: "enum IEnglishAuctions.Status",
              name: "status",
              type: "uint8",
            },
          ],
          internalType: "struct IEnglishAuctions.Auction[]",
          name: "auctions",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "_auctionId",
          type: "uint256",
        },
      ],
      name: "getAuction",
      outputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "auctionId",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "auctionCreator",
              type: "address",
            },
            {
              internalType: "address",
              name: "assetContract",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "tokenId",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "quantity",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "minimumBidAmount",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "buyoutBidAmount",
              type: "uint256",
            },
            {
              internalType: "uint64",
              name: "timeBufferInSeconds",
              type: "uint64",
            },
            {
              internalType: "uint64",
              name: "bidBufferBps",
              type: "uint64",
            },
            {
              internalType: "uint64",
              name: "startTimestamp",
              type: "uint64",
            },
            {
              internalType: "uint64",
              name: "endTimestamp",
              type: "uint64",
            },
            {
              internalType: "enum IEnglishAuctions.TokenType",
              name: "tokenType",
              type: "uint8",
            },
            {
              internalType: "enum IEnglishAuctions.Status",
              name: "status",
              type: "uint8",
            },
          ],
          internalType: "struct IEnglishAuctions.Auction",
          name: "auction",
          type: "tuple",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "_auctionId",
          type: "uint256",
        },
      ],
      name: "getWinningBid",
      outputs: [
        {
          internalType: "address",
          name: "bidder",
          type: "address",
        },
        {
          internalType: "address",
          name: "currency",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "bidAmount",
          type: "uint256",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "_auctionId",
          type: "uint256",
        },
      ],
      name: "isAuctionExpired",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "_auctionId",
          type: "uint256",
        },
        {
          internalType: "uint256",
          name: "_bidAmount",
          type: "uint256",
        },
      ],
      name: "isNewWinningBid",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  gle = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "offeror",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "offerId",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "assetContract",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "address",
          name: "seller",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "quantityBought",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "totalPricePaid",
          type: "uint256",
        },
      ],
      name: "AcceptedOffer",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "offeror",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "offerId",
          type: "uint256",
        },
      ],
      name: "CancelledOffer",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "offeror",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "offerId",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "assetContract",
          type: "address",
        },
        {
          components: [
            {
              internalType: "uint256",
              name: "offerId",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "offeror",
              type: "address",
            },
            {
              internalType: "address",
              name: "assetContract",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "tokenId",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "quantity",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "totalPrice",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "expirationTimestamp",
              type: "uint256",
            },
            {
              internalType: "enum IOffers.TokenType",
              name: "tokenType",
              type: "uint8",
            },
            {
              internalType: "enum IOffers.Status",
              name: "status",
              type: "uint8",
            },
          ],
          indexed: !1,
          internalType: "struct IOffers.Offer",
          name: "offer",
          type: "tuple",
        },
      ],
      name: "NewOffer",
      type: "event",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "_offerId",
          type: "uint256",
        },
      ],
      name: "acceptOffer",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "_offerId",
          type: "uint256",
        },
      ],
      name: "cancelOffer",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "_startId",
          type: "uint256",
        },
        {
          internalType: "uint256",
          name: "_endId",
          type: "uint256",
        },
      ],
      name: "getAllOffers",
      outputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "offerId",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "offeror",
              type: "address",
            },
            {
              internalType: "address",
              name: "assetContract",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "tokenId",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "quantity",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "totalPrice",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "expirationTimestamp",
              type: "uint256",
            },
            {
              internalType: "enum IOffers.TokenType",
              name: "tokenType",
              type: "uint8",
            },
            {
              internalType: "enum IOffers.Status",
              name: "status",
              type: "uint8",
            },
          ],
          internalType: "struct IOffers.Offer[]",
          name: "offers",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "_startId",
          type: "uint256",
        },
        {
          internalType: "uint256",
          name: "_endId",
          type: "uint256",
        },
      ],
      name: "getAllValidOffers",
      outputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "offerId",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "offeror",
              type: "address",
            },
            {
              internalType: "address",
              name: "assetContract",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "tokenId",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "quantity",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "totalPrice",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "expirationTimestamp",
              type: "uint256",
            },
            {
              internalType: "enum IOffers.TokenType",
              name: "tokenType",
              type: "uint8",
            },
            {
              internalType: "enum IOffers.Status",
              name: "status",
              type: "uint8",
            },
          ],
          internalType: "struct IOffers.Offer[]",
          name: "offers",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "_offerId",
          type: "uint256",
        },
      ],
      name: "getOffer",
      outputs: [
        {
          components: [
            {
              internalType: "uint256",
              name: "offerId",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "offeror",
              type: "address",
            },
            {
              internalType: "address",
              name: "assetContract",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "tokenId",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "quantity",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "totalPrice",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "expirationTimestamp",
              type: "uint256",
            },
            {
              internalType: "enum IOffers.TokenType",
              name: "tokenType",
              type: "uint8",
            },
            {
              internalType: "enum IOffers.Status",
              name: "status",
              type: "uint8",
            },
          ],
          internalType: "struct IOffers.Offer",
          name: "offer",
          type: "tuple",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "address",
              name: "assetContract",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "tokenId",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "quantity",
              type: "uint256",
            },
            {
              internalType: "address",
              name: "currency",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "totalPrice",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "expirationTimestamp",
              type: "uint256",
            },
          ],
          internalType: "struct IOffers.OfferParams",
          name: "_params",
          type: "tuple",
        },
      ],
      name: "makeOffer",
      outputs: [
        {
          internalType: "uint256",
          name: "offerId",
          type: "uint256",
        },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  ble = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "packId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "address",
          name: "recipient",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "totalPacksCreated",
          type: "uint256",
        },
      ],
      name: "PackCreated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "opener",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "packId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "amountToOpen",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "requestId",
          type: "uint256",
        },
      ],
      name: "PackOpenRequested",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "packId",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "opener",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "numOfPacksOpened",
          type: "uint256",
        },
        {
          components: [
            {
              internalType: "address",
              name: "assetContract",
              type: "address",
            },
            {
              internalType: "enum ITokenBundle.TokenType",
              name: "tokenType",
              type: "uint8",
            },
            {
              internalType: "uint256",
              name: "tokenId",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "totalAmount",
              type: "uint256",
            },
          ],
          indexed: !1,
          internalType: "struct ITokenBundle.Token[]",
          name: "rewardUnitsDistributed",
          type: "tuple[]",
        },
      ],
      name: "PackOpened",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "packId",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "requestId",
          type: "uint256",
        },
      ],
      name: "PackRandomnessFulfilled",
      type: "event",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_opener",
          type: "address",
        },
      ],
      name: "canClaimRewards",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "claimRewards",
      outputs: [
        {
          components: [
            {
              internalType: "address",
              name: "assetContract",
              type: "address",
            },
            {
              internalType: "enum ITokenBundle.TokenType",
              name: "tokenType",
              type: "uint8",
            },
            {
              internalType: "uint256",
              name: "tokenId",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "totalAmount",
              type: "uint256",
            },
          ],
          internalType: "struct ITokenBundle.Token[]",
          name: "rewardUnits",
          type: "tuple[]",
        },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "address",
              name: "assetContract",
              type: "address",
            },
            {
              internalType: "enum ITokenBundle.TokenType",
              name: "tokenType",
              type: "uint8",
            },
            {
              internalType: "uint256",
              name: "tokenId",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "totalAmount",
              type: "uint256",
            },
          ],
          internalType: "struct ITokenBundle.Token[]",
          name: "contents",
          type: "tuple[]",
        },
        {
          internalType: "uint256[]",
          name: "numOfRewardUnits",
          type: "uint256[]",
        },
        {
          internalType: "string",
          name: "packUri",
          type: "string",
        },
        {
          internalType: "uint128",
          name: "openStartTimestamp",
          type: "uint128",
        },
        {
          internalType: "uint128",
          name: "amountDistributedPerOpen",
          type: "uint128",
        },
        {
          internalType: "address",
          name: "recipient",
          type: "address",
        },
      ],
      name: "createPack",
      outputs: [
        {
          internalType: "uint256",
          name: "packId",
          type: "uint256",
        },
        {
          internalType: "uint256",
          name: "packTotalSupply",
          type: "uint256",
        },
      ],
      stateMutability: "payable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "packId",
          type: "uint256",
        },
        {
          internalType: "uint256",
          name: "amountToOpen",
          type: "uint256",
        },
      ],
      name: "openPack",
      outputs: [
        {
          internalType: "uint256",
          name: "requestId",
          type: "uint256",
        },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "_packId",
          type: "uint256",
        },
        {
          internalType: "uint256",
          name: "_amountToOpen",
          type: "uint256",
        },
        {
          internalType: "uint32",
          name: "_callBackGasLimit",
          type: "uint32",
        },
      ],
      name: "openPackAndClaimRewards",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256",
        },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  vle = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          indexed: !0,
          internalType: "bytes32",
          name: "previousAdminRole",
          type: "bytes32",
        },
        {
          indexed: !0,
          internalType: "bytes32",
          name: "newAdminRole",
          type: "bytes32",
        },
      ],
      name: "RoleAdminChanged",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "account",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "sender",
          type: "address",
        },
      ],
      name: "RoleGranted",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "account",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "sender",
          type: "address",
        },
      ],
      name: "RoleRevoked",
      type: "event",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
      ],
      name: "getRoleAdmin",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          internalType: "address",
          name: "account",
          type: "address",
        },
      ],
      name: "grantRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          internalType: "address",
          name: "account",
          type: "address",
        },
      ],
      name: "hasRole",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          internalType: "address",
          name: "account",
          type: "address",
        },
      ],
      name: "renounceRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          internalType: "address",
          name: "account",
          type: "address",
        },
      ],
      name: "revokeRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  xle = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          indexed: !0,
          internalType: "bytes32",
          name: "previousAdminRole",
          type: "bytes32",
        },
        {
          indexed: !0,
          internalType: "bytes32",
          name: "newAdminRole",
          type: "bytes32",
        },
      ],
      name: "RoleAdminChanged",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "account",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "sender",
          type: "address",
        },
      ],
      name: "RoleGranted",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "account",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "sender",
          type: "address",
        },
      ],
      name: "RoleRevoked",
      type: "event",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
      ],
      name: "getRoleAdmin",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          internalType: "uint256",
          name: "index",
          type: "uint256",
        },
      ],
      name: "getRoleMember",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
      ],
      name: "getRoleMemberCount",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          internalType: "address",
          name: "account",
          type: "address",
        },
      ],
      name: "grantRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          internalType: "address",
          name: "account",
          type: "address",
        },
      ],
      name: "hasRole",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          internalType: "address",
          name: "account",
          type: "address",
        },
      ],
      name: "renounceRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          internalType: "address",
          name: "account",
          type: "address",
        },
      ],
      name: "revokeRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  wle = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "address",
          name: "platformFeeRecipient",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "flatFee",
          type: "uint256",
        },
      ],
      name: "FlatPlatformFeeUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "platformFeeRecipient",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "platformFeeBps",
          type: "uint256",
        },
      ],
      name: "PlatformFeeInfoUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "enum IPlatformFee.PlatformFeeType",
          name: "feeType",
          type: "uint8",
        },
      ],
      name: "PlatformFeeTypeUpdated",
      type: "event",
    },
    {
      inputs: [],
      name: "getPlatformFeeInfo",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address",
        },
        {
          internalType: "uint16",
          name: "",
          type: "uint16",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_platformFeeRecipient",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "_platformFeeBps",
          type: "uint256",
        },
      ],
      name: "setPlatformFeeInfo",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  _le = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "recipient",
          type: "address",
        },
      ],
      name: "PrimarySaleRecipientUpdated",
      type: "event",
    },
    {
      inputs: [],
      name: "primarySaleRecipient",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_saleRecipient",
          type: "address",
        },
      ],
      name: "setPrimarySaleRecipient",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  Ele = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "newRoyaltyRecipient",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "newRoyaltyBps",
          type: "uint256",
        },
      ],
      name: "DefaultRoyalty",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "royaltyRecipient",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "royaltyBps",
          type: "uint256",
        },
      ],
      name: "RoyaltyForToken",
      type: "event",
    },
    {
      inputs: [],
      name: "getDefaultRoyaltyInfo",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address",
        },
        {
          internalType: "uint16",
          name: "",
          type: "uint16",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "getRoyaltyInfoForToken",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address",
        },
        {
          internalType: "uint16",
          name: "",
          type: "uint16",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          internalType: "uint256",
          name: "salePrice",
          type: "uint256",
        },
      ],
      name: "royaltyInfo",
      outputs: [
        {
          internalType: "address",
          name: "receiver",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "royaltyAmount",
          type: "uint256",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_royaltyRecipient",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "_royaltyBps",
          type: "uint256",
        },
      ],
      name: "setDefaultRoyaltyInfo",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          internalType: "address",
          name: "recipient",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "bps",
          type: "uint256",
        },
      ],
      name: "setRoyaltyInfoForToken",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "interfaceId",
          type: "bytes4",
        },
      ],
      name: "supportsInterface",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  Tle = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "prevOwner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnerUpdated",
      type: "event",
    },
    {
      inputs: [],
      name: "owner",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_newOwner",
          type: "address",
        },
      ],
      name: "setOwner",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  Cle = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "tokenAddress",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "recipient",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "amount",
          type: "uint256",
        },
      ],
      name: "AirdropFailed",
      type: "event",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "tokenAddress",
          type: "address",
        },
        {
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
        {
          components: [
            {
              internalType: "address",
              name: "recipient",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "amount",
              type: "uint256",
            },
          ],
          internalType: "struct IAirdropERC20.AirdropContent[]",
          name: "contents",
          type: "tuple[]",
        },
      ],
      name: "airdropERC20",
      outputs: [],
      stateMutability: "payable",
      type: "function",
    },
  ],
  Ale = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "tokenAddress",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "recipient",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
      ],
      name: "AirdropFailed",
      type: "event",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "tokenAddress",
          type: "address",
        },
        {
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
        {
          components: [
            {
              internalType: "address",
              name: "recipient",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "tokenId",
              type: "uint256",
            },
          ],
          internalType: "struct IAirdropERC721.AirdropContent[]",
          name: "contents",
          type: "tuple[]",
        },
      ],
      name: "airdropERC721",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  kle = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "tokenAddress",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "recipient",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "tokenId",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "amount",
          type: "uint256",
        },
      ],
      name: "AirdropFailed",
      type: "event",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "tokenAddress",
          type: "address",
        },
        {
          internalType: "address",
          name: "tokenOwner",
          type: "address",
        },
        {
          components: [
            {
              internalType: "address",
              name: "recipient",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "tokenId",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "amount",
              type: "uint256",
            },
          ],
          internalType: "struct IAirdropERC1155.AirdropContent[]",
          name: "contents",
          type: "tuple[]",
        },
      ],
      name: "airdropERC1155",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  Sle = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "account",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "accountAdmin",
          type: "address",
        },
      ],
      name: "AccountCreated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "account",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "signer",
          type: "address",
        },
      ],
      name: "SignerAdded",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "account",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "signer",
          type: "address",
        },
      ],
      name: "SignerRemoved",
      type: "event",
    },
    {
      inputs: [],
      name: "accountImplementation",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "admin",
          type: "address",
        },
        {
          internalType: "bytes",
          name: "_data",
          type: "bytes",
        },
      ],
      name: "createAccount",
      outputs: [
        {
          internalType: "address",
          name: "account",
          type: "address",
        },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "signer",
          type: "address",
        },
      ],
      name: "getAccountsOfSigner",
      outputs: [
        {
          internalType: "address[]",
          name: "accounts",
          type: "address[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "adminSigner",
          type: "address",
        },
        {
          internalType: "bytes",
          name: "data",
          type: "bytes",
        },
      ],
      name: "getAddress",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "getAllAccounts",
      outputs: [
        {
          internalType: "address[]",
          name: "",
          type: "address[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  Mle = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "signer",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "bool",
          name: "isAdmin",
          type: "bool",
        },
      ],
      name: "AdminUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "authorizingSigner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "targetSigner",
          type: "address",
        },
        {
          components: [
            {
              internalType: "address",
              name: "signer",
              type: "address",
            },
            {
              internalType: "address[]",
              name: "approvedTargets",
              type: "address[]",
            },
            {
              internalType: "uint256",
              name: "nativeTokenLimitPerTransaction",
              type: "uint256",
            },
            {
              internalType: "uint128",
              name: "permissionStartTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "permissionEndTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "reqValidityStartTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "reqValidityEndTimestamp",
              type: "uint128",
            },
            {
              internalType: "bytes32",
              name: "uid",
              type: "bytes32",
            },
          ],
          indexed: !1,
          internalType: "struct IAccountPermissions.SignerPermissionRequest",
          name: "permissions",
          type: "tuple",
        },
      ],
      name: "SignerPermissionsUpdated",
      type: "event",
    },
    {
      inputs: [],
      name: "getAllActiveSigners",
      outputs: [
        {
          components: [
            {
              internalType: "address",
              name: "signer",
              type: "address",
            },
            {
              internalType: "address[]",
              name: "approvedTargets",
              type: "address[]",
            },
            {
              internalType: "uint256",
              name: "nativeTokenLimitPerTransaction",
              type: "uint256",
            },
            {
              internalType: "uint128",
              name: "startTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "endTimestamp",
              type: "uint128",
            },
          ],
          internalType: "struct IAccountPermissions.SignerPermissions[]",
          name: "signers",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "getAllAdmins",
      outputs: [
        {
          internalType: "address[]",
          name: "admins",
          type: "address[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "getAllSigners",
      outputs: [
        {
          components: [
            {
              internalType: "address",
              name: "signer",
              type: "address",
            },
            {
              internalType: "address[]",
              name: "approvedTargets",
              type: "address[]",
            },
            {
              internalType: "uint256",
              name: "nativeTokenLimitPerTransaction",
              type: "uint256",
            },
            {
              internalType: "uint128",
              name: "startTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "endTimestamp",
              type: "uint128",
            },
          ],
          internalType: "struct IAccountPermissions.SignerPermissions[]",
          name: "signers",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "signer",
          type: "address",
        },
      ],
      name: "getPermissionsForSigner",
      outputs: [
        {
          components: [
            {
              internalType: "address",
              name: "signer",
              type: "address",
            },
            {
              internalType: "address[]",
              name: "approvedTargets",
              type: "address[]",
            },
            {
              internalType: "uint256",
              name: "nativeTokenLimitPerTransaction",
              type: "uint256",
            },
            {
              internalType: "uint128",
              name: "startTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "endTimestamp",
              type: "uint128",
            },
          ],
          internalType: "struct IAccountPermissions.SignerPermissions",
          name: "permissions",
          type: "tuple",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "signer",
          type: "address",
        },
      ],
      name: "isActiveSigner",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "signer",
          type: "address",
        },
      ],
      name: "isAdmin",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "account",
          type: "address",
        },
        {
          internalType: "bool",
          name: "isAdmin",
          type: "bool",
        },
      ],
      name: "setAdmin",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "address",
              name: "signer",
              type: "address",
            },
            {
              internalType: "address[]",
              name: "approvedTargets",
              type: "address[]",
            },
            {
              internalType: "uint256",
              name: "nativeTokenLimitPerTransaction",
              type: "uint256",
            },
            {
              internalType: "uint128",
              name: "permissionStartTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "permissionEndTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "reqValidityStartTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "reqValidityEndTimestamp",
              type: "uint128",
            },
            {
              internalType: "bytes32",
              name: "uid",
              type: "bytes32",
            },
          ],
          internalType: "struct IAccountPermissions.SignerPermissionRequest",
          name: "req",
          type: "tuple",
        },
        {
          internalType: "bytes",
          name: "signature",
          type: "bytes",
        },
      ],
      name: "setPermissionsForSigner",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "address",
              name: "signer",
              type: "address",
            },
            {
              internalType: "address[]",
              name: "approvedTargets",
              type: "address[]",
            },
            {
              internalType: "uint256",
              name: "nativeTokenLimitPerTransaction",
              type: "uint256",
            },
            {
              internalType: "uint128",
              name: "permissionStartTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "permissionEndTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "reqValidityStartTimestamp",
              type: "uint128",
            },
            {
              internalType: "uint128",
              name: "reqValidityEndTimestamp",
              type: "uint128",
            },
            {
              internalType: "bytes32",
              name: "uid",
              type: "bytes32",
            },
          ],
          internalType: "struct IAccountPermissions.SignerPermissionRequest",
          name: "req",
          type: "tuple",
        },
        {
          internalType: "bytes",
          name: "signature",
          type: "bytes",
        },
      ],
      name: "verifySignerPermissionRequest",
      outputs: [
        {
          internalType: "bool",
          name: "success",
          type: "bool",
        },
        {
          internalType: "address",
          name: "signer",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  Ile = [
    {
      inputs: [
        {
          components: [
            {
              internalType: "address",
              name: "sender",
              type: "address",
            },
            {
              internalType: "uint256",
              name: "nonce",
              type: "uint256",
            },
            {
              internalType: "bytes",
              name: "initCode",
              type: "bytes",
            },
            {
              internalType: "bytes",
              name: "callData",
              type: "bytes",
            },
            {
              internalType: "uint256",
              name: "callGasLimit",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "verificationGasLimit",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "preVerificationGas",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "maxFeePerGas",
              type: "uint256",
            },
            {
              internalType: "uint256",
              name: "maxPriorityFeePerGas",
              type: "uint256",
            },
            {
              internalType: "bytes",
              name: "paymasterAndData",
              type: "bytes",
            },
            {
              internalType: "bytes",
              name: "signature",
              type: "bytes",
            },
          ],
          internalType: "struct UserOperation",
          name: "userOp",
          type: "tuple",
        },
        {
          internalType: "bytes32",
          name: "userOpHash",
          type: "bytes32",
        },
        {
          internalType: "uint256",
          name: "missingAccountFunds",
          type: "uint256",
        },
      ],
      name: "validateUserOp",
      outputs: [
        {
          internalType: "uint256",
          name: "validationData",
          type: "uint256",
        },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
  ];
var oa = {};
const Rle = Pt(FY),
  Ple = Pt(_Q),
  Nle = Pt(tY),
  Ble = Pt(qee),
  Dle = Pt(YJ),
  Ole = Pt(BY),
  Fle = Pt(ste),
  Lle = Pt(xte),
  $le = Pt(pQ),
  Ule = Pt(JJ),
  b7 = Pt(Zee),
  Wle = Pt(Pre),
  jle = Pt(lte),
  Hle = Pt(oQ),
  zle = Pt(yQ),
  qle = Pt(See),
  v7 = Pt(QQ),
  Vle = Pt(Oee),
  Kle = Pt(Dre),
  Gle = Pt(Ate),
  Zle = Pt(Bte);
(function (t) {
  var e =
      (ke && ke.__createBinding) ||
      (Object.create
        ? function (l, p, y, h) {
            h === void 0 && (h = y),
              Object.defineProperty(l, h, {
                enumerable: !0,
                get: function () {
                  return p[y];
                },
              });
          }
        : function (l, p, y, h) {
            h === void 0 && (h = y), (l[h] = p[y]);
          }),
    r =
      (ke && ke.__setModuleDefault) ||
      (Object.create
        ? function (l, p) {
            Object.defineProperty(l, "default", {
              enumerable: !0,
              value: p,
            });
          }
        : function (l, p) {
            l.default = p;
          }),
    n =
      (ke && ke.__importStar) ||
      function (l) {
        if (l && l.__esModule) return l;
        var p = {};
        if (l != null)
          for (var y in l)
            y !== "default" &&
              Object.prototype.hasOwnProperty.call(l, y) &&
              e(p, l, y);
        return r(p, l), p;
      };
  Object.defineProperty(t, "__esModule", {
    value: !0,
  }),
    (t.formatBytes32String =
      t.Utf8ErrorFuncs =
      t.toUtf8String =
      t.toUtf8CodePoints =
      t.toUtf8Bytes =
      t._toEscapedUtf8String =
      t.nameprep =
      t.hexDataSlice =
      t.hexDataLength =
      t.hexZeroPad =
      t.hexValue =
      t.hexStripZeros =
      t.hexConcat =
      t.isHexString =
      t.hexlify =
      t.base64 =
      t.base58 =
      t.TransactionDescription =
      t.LogDescription =
      t.Interface =
      t.SigningKey =
      t.HDNode =
      t.defaultPath =
      t.isBytesLike =
      t.isBytes =
      t.zeroPad =
      t.stripZeros =
      t.concat =
      t.arrayify =
      t.shallowCopy =
      t.resolveProperties =
      t.getStatic =
      t.defineReadOnly =
      t.deepCopy =
      t.checkProperties =
      t.poll =
      t.fetchJson =
      t._fetchData =
      t.RLP =
      t.Logger =
      t.checkResultErrors =
      t.FormatTypes =
      t.ParamType =
      t.FunctionFragment =
      t.EventFragment =
      t.ErrorFragment =
      t.ConstructorFragment =
      t.Fragment =
      t.defaultAbiCoder =
      t.AbiCoder =
        void 0),
    (t.Indexed =
      t.Utf8ErrorReason =
      t.UnicodeNormalizationForm =
      t.SupportedAlgorithm =
      t.mnemonicToSeed =
      t.isValidMnemonic =
      t.entropyToMnemonic =
      t.mnemonicToEntropy =
      t.getAccountPath =
      t.verifyTypedData =
      t.verifyMessage =
      t.recoverPublicKey =
      t.computePublicKey =
      t.recoverAddress =
      t.computeAddress =
      t.getJsonWalletAddress =
      t.TransactionTypes =
      t.serializeTransaction =
      t.parseTransaction =
      t.accessListify =
      t.joinSignature =
      t.splitSignature =
      t.soliditySha256 =
      t.solidityKeccak256 =
      t.solidityPack =
      t.shuffled =
      t.randomBytes =
      t.sha512 =
      t.sha256 =
      t.ripemd160 =
      t.keccak256 =
      t.computeHmac =
      t.commify =
      t.parseUnits =
      t.formatUnits =
      t.parseEther =
      t.formatEther =
      t.isAddress =
      t.getCreate2Address =
      t.getContractAddress =
      t.getIcapAddress =
      t.getAddress =
      t._TypedDataEncoder =
      t.id =
      t.isValidName =
      t.namehash =
      t.hashMessage =
      t.dnsEncode =
      t.parseBytes32String =
        void 0);
  var i = Rle;
  Object.defineProperty(t, "AbiCoder", {
    enumerable: !0,
    get: function () {
      return i.AbiCoder;
    },
  }),
    Object.defineProperty(t, "checkResultErrors", {
      enumerable: !0,
      get: function () {
        return i.checkResultErrors;
      },
    }),
    Object.defineProperty(t, "ConstructorFragment", {
      enumerable: !0,
      get: function () {
        return i.ConstructorFragment;
      },
    }),
    Object.defineProperty(t, "defaultAbiCoder", {
      enumerable: !0,
      get: function () {
        return i.defaultAbiCoder;
      },
    }),
    Object.defineProperty(t, "ErrorFragment", {
      enumerable: !0,
      get: function () {
        return i.ErrorFragment;
      },
    }),
    Object.defineProperty(t, "EventFragment", {
      enumerable: !0,
      get: function () {
        return i.EventFragment;
      },
    }),
    Object.defineProperty(t, "FormatTypes", {
      enumerable: !0,
      get: function () {
        return i.FormatTypes;
      },
    }),
    Object.defineProperty(t, "Fragment", {
      enumerable: !0,
      get: function () {
        return i.Fragment;
      },
    }),
    Object.defineProperty(t, "FunctionFragment", {
      enumerable: !0,
      get: function () {
        return i.FunctionFragment;
      },
    }),
    Object.defineProperty(t, "Indexed", {
      enumerable: !0,
      get: function () {
        return i.Indexed;
      },
    }),
    Object.defineProperty(t, "Interface", {
      enumerable: !0,
      get: function () {
        return i.Interface;
      },
    }),
    Object.defineProperty(t, "LogDescription", {
      enumerable: !0,
      get: function () {
        return i.LogDescription;
      },
    }),
    Object.defineProperty(t, "ParamType", {
      enumerable: !0,
      get: function () {
        return i.ParamType;
      },
    }),
    Object.defineProperty(t, "TransactionDescription", {
      enumerable: !0,
      get: function () {
        return i.TransactionDescription;
      },
    });
  var a = Ple;
  Object.defineProperty(t, "getAddress", {
    enumerable: !0,
    get: function () {
      return a.getAddress;
    },
  }),
    Object.defineProperty(t, "getCreate2Address", {
      enumerable: !0,
      get: function () {
        return a.getCreate2Address;
      },
    }),
    Object.defineProperty(t, "getContractAddress", {
      enumerable: !0,
      get: function () {
        return a.getContractAddress;
      },
    }),
    Object.defineProperty(t, "getIcapAddress", {
      enumerable: !0,
      get: function () {
        return a.getIcapAddress;
      },
    }),
    Object.defineProperty(t, "isAddress", {
      enumerable: !0,
      get: function () {
        return a.isAddress;
      },
    });
  var s = n(Nle);
  t.base64 = s;
  var o = Ble;
  Object.defineProperty(t, "base58", {
    enumerable: !0,
    get: function () {
      return o.Base58;
    },
  });
  var c = Dle;
  Object.defineProperty(t, "arrayify", {
    enumerable: !0,
    get: function () {
      return c.arrayify;
    },
  }),
    Object.defineProperty(t, "concat", {
      enumerable: !0,
      get: function () {
        return c.concat;
      },
    }),
    Object.defineProperty(t, "hexConcat", {
      enumerable: !0,
      get: function () {
        return c.hexConcat;
      },
    }),
    Object.defineProperty(t, "hexDataSlice", {
      enumerable: !0,
      get: function () {
        return c.hexDataSlice;
      },
    }),
    Object.defineProperty(t, "hexDataLength", {
      enumerable: !0,
      get: function () {
        return c.hexDataLength;
      },
    }),
    Object.defineProperty(t, "hexlify", {
      enumerable: !0,
      get: function () {
        return c.hexlify;
      },
    }),
    Object.defineProperty(t, "hexStripZeros", {
      enumerable: !0,
      get: function () {
        return c.hexStripZeros;
      },
    }),
    Object.defineProperty(t, "hexValue", {
      enumerable: !0,
      get: function () {
        return c.hexValue;
      },
    }),
    Object.defineProperty(t, "hexZeroPad", {
      enumerable: !0,
      get: function () {
        return c.hexZeroPad;
      },
    }),
    Object.defineProperty(t, "isBytes", {
      enumerable: !0,
      get: function () {
        return c.isBytes;
      },
    }),
    Object.defineProperty(t, "isBytesLike", {
      enumerable: !0,
      get: function () {
        return c.isBytesLike;
      },
    }),
    Object.defineProperty(t, "isHexString", {
      enumerable: !0,
      get: function () {
        return c.isHexString;
      },
    }),
    Object.defineProperty(t, "joinSignature", {
      enumerable: !0,
      get: function () {
        return c.joinSignature;
      },
    }),
    Object.defineProperty(t, "zeroPad", {
      enumerable: !0,
      get: function () {
        return c.zeroPad;
      },
    }),
    Object.defineProperty(t, "splitSignature", {
      enumerable: !0,
      get: function () {
        return c.splitSignature;
      },
    }),
    Object.defineProperty(t, "stripZeros", {
      enumerable: !0,
      get: function () {
        return c.stripZeros;
      },
    });
  var u = Ole;
  Object.defineProperty(t, "_TypedDataEncoder", {
    enumerable: !0,
    get: function () {
      return u._TypedDataEncoder;
    },
  }),
    Object.defineProperty(t, "dnsEncode", {
      enumerable: !0,
      get: function () {
        return u.dnsEncode;
      },
    }),
    Object.defineProperty(t, "hashMessage", {
      enumerable: !0,
      get: function () {
        return u.hashMessage;
      },
    }),
    Object.defineProperty(t, "id", {
      enumerable: !0,
      get: function () {
        return u.id;
      },
    }),
    Object.defineProperty(t, "isValidName", {
      enumerable: !0,
      get: function () {
        return u.isValidName;
      },
    }),
    Object.defineProperty(t, "namehash", {
      enumerable: !0,
      get: function () {
        return u.namehash;
      },
    });
  var d = Fle;
  Object.defineProperty(t, "defaultPath", {
    enumerable: !0,
    get: function () {
      return d.defaultPath;
    },
  }),
    Object.defineProperty(t, "entropyToMnemonic", {
      enumerable: !0,
      get: function () {
        return d.entropyToMnemonic;
      },
    }),
    Object.defineProperty(t, "getAccountPath", {
      enumerable: !0,
      get: function () {
        return d.getAccountPath;
      },
    }),
    Object.defineProperty(t, "HDNode", {
      enumerable: !0,
      get: function () {
        return d.HDNode;
      },
    }),
    Object.defineProperty(t, "isValidMnemonic", {
      enumerable: !0,
      get: function () {
        return d.isValidMnemonic;
      },
    }),
    Object.defineProperty(t, "mnemonicToEntropy", {
      enumerable: !0,
      get: function () {
        return d.mnemonicToEntropy;
      },
    }),
    Object.defineProperty(t, "mnemonicToSeed", {
      enumerable: !0,
      get: function () {
        return d.mnemonicToSeed;
      },
    });
  var m = Lle;
  Object.defineProperty(t, "getJsonWalletAddress", {
    enumerable: !0,
    get: function () {
      return m.getJsonWalletAddress;
    },
  });
  var v = $le;
  Object.defineProperty(t, "keccak256", {
    enumerable: !0,
    get: function () {
      return v.keccak256;
    },
  });
  var E = Ule;
  Object.defineProperty(t, "Logger", {
    enumerable: !0,
    get: function () {
      return E.Logger;
    },
  });
  var A = b7;
  Object.defineProperty(t, "computeHmac", {
    enumerable: !0,
    get: function () {
      return A.computeHmac;
    },
  }),
    Object.defineProperty(t, "ripemd160", {
      enumerable: !0,
      get: function () {
        return A.ripemd160;
      },
    }),
    Object.defineProperty(t, "sha256", {
      enumerable: !0,
      get: function () {
        return A.sha256;
      },
    }),
    Object.defineProperty(t, "sha512", {
      enumerable: !0,
      get: function () {
        return A.sha512;
      },
    });
  var I = Wle;
  Object.defineProperty(t, "solidityKeccak256", {
    enumerable: !0,
    get: function () {
      return I.keccak256;
    },
  }),
    Object.defineProperty(t, "solidityPack", {
      enumerable: !0,
      get: function () {
        return I.pack;
      },
    }),
    Object.defineProperty(t, "soliditySha256", {
      enumerable: !0,
      get: function () {
        return I.sha256;
      },
    });
  var b = jle;
  Object.defineProperty(t, "randomBytes", {
    enumerable: !0,
    get: function () {
      return b.randomBytes;
    },
  }),
    Object.defineProperty(t, "shuffled", {
      enumerable: !0,
      get: function () {
        return b.shuffled;
      },
    });
  var w = Hle;
  Object.defineProperty(t, "checkProperties", {
    enumerable: !0,
    get: function () {
      return w.checkProperties;
    },
  }),
    Object.defineProperty(t, "deepCopy", {
      enumerable: !0,
      get: function () {
        return w.deepCopy;
      },
    }),
    Object.defineProperty(t, "defineReadOnly", {
      enumerable: !0,
      get: function () {
        return w.defineReadOnly;
      },
    }),
    Object.defineProperty(t, "getStatic", {
      enumerable: !0,
      get: function () {
        return w.getStatic;
      },
    }),
    Object.defineProperty(t, "resolveProperties", {
      enumerable: !0,
      get: function () {
        return w.resolveProperties;
      },
    }),
    Object.defineProperty(t, "shallowCopy", {
      enumerable: !0,
      get: function () {
        return w.shallowCopy;
      },
    });
  var S = n(zle);
  t.RLP = S;
  var k = qle;
  Object.defineProperty(t, "computePublicKey", {
    enumerable: !0,
    get: function () {
      return k.computePublicKey;
    },
  }),
    Object.defineProperty(t, "recoverPublicKey", {
      enumerable: !0,
      get: function () {
        return k.recoverPublicKey;
      },
    }),
    Object.defineProperty(t, "SigningKey", {
      enumerable: !0,
      get: function () {
        return k.SigningKey;
      },
    });
  var N = v7;
  Object.defineProperty(t, "formatBytes32String", {
    enumerable: !0,
    get: function () {
      return N.formatBytes32String;
    },
  }),
    Object.defineProperty(t, "nameprep", {
      enumerable: !0,
      get: function () {
        return N.nameprep;
      },
    }),
    Object.defineProperty(t, "parseBytes32String", {
      enumerable: !0,
      get: function () {
        return N.parseBytes32String;
      },
    }),
    Object.defineProperty(t, "_toEscapedUtf8String", {
      enumerable: !0,
      get: function () {
        return N._toEscapedUtf8String;
      },
    }),
    Object.defineProperty(t, "toUtf8Bytes", {
      enumerable: !0,
      get: function () {
        return N.toUtf8Bytes;
      },
    }),
    Object.defineProperty(t, "toUtf8CodePoints", {
      enumerable: !0,
      get: function () {
        return N.toUtf8CodePoints;
      },
    }),
    Object.defineProperty(t, "toUtf8String", {
      enumerable: !0,
      get: function () {
        return N.toUtf8String;
      },
    }),
    Object.defineProperty(t, "Utf8ErrorFuncs", {
      enumerable: !0,
      get: function () {
        return N.Utf8ErrorFuncs;
      },
    });
  var O = Vle;
  Object.defineProperty(t, "accessListify", {
    enumerable: !0,
    get: function () {
      return O.accessListify;
    },
  }),
    Object.defineProperty(t, "computeAddress", {
      enumerable: !0,
      get: function () {
        return O.computeAddress;
      },
    }),
    Object.defineProperty(t, "parseTransaction", {
      enumerable: !0,
      get: function () {
        return O.parse;
      },
    }),
    Object.defineProperty(t, "recoverAddress", {
      enumerable: !0,
      get: function () {
        return O.recoverAddress;
      },
    }),
    Object.defineProperty(t, "serializeTransaction", {
      enumerable: !0,
      get: function () {
        return O.serialize;
      },
    }),
    Object.defineProperty(t, "TransactionTypes", {
      enumerable: !0,
      get: function () {
        return O.TransactionTypes;
      },
    });
  var F = Kle;
  Object.defineProperty(t, "commify", {
    enumerable: !0,
    get: function () {
      return F.commify;
    },
  }),
    Object.defineProperty(t, "formatEther", {
      enumerable: !0,
      get: function () {
        return F.formatEther;
      },
    }),
    Object.defineProperty(t, "parseEther", {
      enumerable: !0,
      get: function () {
        return F.parseEther;
      },
    }),
    Object.defineProperty(t, "formatUnits", {
      enumerable: !0,
      get: function () {
        return F.formatUnits;
      },
    }),
    Object.defineProperty(t, "parseUnits", {
      enumerable: !0,
      get: function () {
        return F.parseUnits;
      },
    });
  var V = Gle;
  Object.defineProperty(t, "verifyMessage", {
    enumerable: !0,
    get: function () {
      return V.verifyMessage;
    },
  }),
    Object.defineProperty(t, "verifyTypedData", {
      enumerable: !0,
      get: function () {
        return V.verifyTypedData;
      },
    });
  var j = Zle;
  Object.defineProperty(t, "_fetchData", {
    enumerable: !0,
    get: function () {
      return j._fetchData;
    },
  }),
    Object.defineProperty(t, "fetchJson", {
      enumerable: !0,
      get: function () {
        return j.fetchJson;
      },
    }),
    Object.defineProperty(t, "poll", {
      enumerable: !0,
      get: function () {
        return j.poll;
      },
    });
  var X = b7;
  Object.defineProperty(t, "SupportedAlgorithm", {
    enumerable: !0,
    get: function () {
      return X.SupportedAlgorithm;
    },
  });
  var C = v7;
  Object.defineProperty(t, "UnicodeNormalizationForm", {
    enumerable: !0,
    get: function () {
      return C.UnicodeNormalizationForm;
    },
  }),
    Object.defineProperty(t, "Utf8ErrorReason", {
      enumerable: !0,
      get: function () {
        return C.Utf8ErrorReason;
      },
    });
})(oa);
const xF = [
  {
    inputs: [],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "from",
            type: "address",
          },
          {
            internalType: "address",
            name: "to",
            type: "address",
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "gas",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256",
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes",
          },
        ],
        internalType: "struct Forwarder.ForwardRequest",
        name: "req",
        type: "tuple",
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes",
      },
    ],
    name: "execute",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
      {
        internalType: "bytes",
        name: "",
        type: "bytes",
      },
    ],
    stateMutability: "payable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address",
      },
    ],
    name: "getNonce",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "from",
            type: "address",
          },
          {
            internalType: "address",
            name: "to",
            type: "address",
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "gas",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256",
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes",
          },
        ],
        internalType: "struct Forwarder.ForwardRequest",
        name: "req",
        type: "tuple",
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes",
      },
    ],
    name: "verify",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
];
var wF = {
  exports: {},
};
(function (t) {
  var e = Object.prototype.hasOwnProperty,
    r = "~";
  function n() {}
  Object.create &&
    ((n.prototype = Object.create(null)), new n().__proto__ || (r = !1));
  function i(c, u, d) {
    (this.fn = c), (this.context = u), (this.once = d || !1);
  }
  function a(c, u, d, m, v) {
    if (typeof d != "function")
      throw new TypeError("The listener must be a function");
    var E = new i(d, m || c, v),
      A = r ? r + u : u;
    return (
      c._events[A]
        ? c._events[A].fn
          ? (c._events[A] = [c._events[A], E])
          : c._events[A].push(E)
        : ((c._events[A] = E), c._eventsCount++),
      c
    );
  }
  function s(c, u) {
    --c._eventsCount === 0 ? (c._events = new n()) : delete c._events[u];
  }
  function o() {
    (this._events = new n()), (this._eventsCount = 0);
  }
  (o.prototype.eventNames = function () {
    var u = [],
      d,
      m;
    if (this._eventsCount === 0) return u;
    for (m in (d = this._events)) e.call(d, m) && u.push(r ? m.slice(1) : m);
    return Object.getOwnPropertySymbols
      ? u.concat(Object.getOwnPropertySymbols(d))
      : u;
  }),
    (o.prototype.listeners = function (u) {
      var d = r ? r + u : u,
        m = this._events[d];
      if (!m) return [];
      if (m.fn) return [m.fn];
      for (var v = 0, E = m.length, A = new Array(E); v < E; v++)
        A[v] = m[v].fn;
      return A;
    }),
    (o.prototype.listenerCount = function (u) {
      var d = r ? r + u : u,
        m = this._events[d];
      return m ? (m.fn ? 1 : m.length) : 0;
    }),
    (o.prototype.emit = function (u, d, m, v, E, A) {
      var I = r ? r + u : u;
      if (!this._events[I]) return !1;
      var b = this._events[I],
        w = arguments.length,
        S,
        k;
      if (b.fn) {
        switch ((b.once && this.removeListener(u, b.fn, void 0, !0), w)) {
          case 1:
            return b.fn.call(b.context), !0;
          case 2:
            return b.fn.call(b.context, d), !0;
          case 3:
            return b.fn.call(b.context, d, m), !0;
          case 4:
            return b.fn.call(b.context, d, m, v), !0;
          case 5:
            return b.fn.call(b.context, d, m, v, E), !0;
          case 6:
            return b.fn.call(b.context, d, m, v, E, A), !0;
        }
        for (k = 1, S = new Array(w - 1); k < w; k++) S[k - 1] = arguments[k];
        b.fn.apply(b.context, S);
      } else {
        var N = b.length,
          O;
        for (k = 0; k < N; k++)
          switch (
            (b[k].once && this.removeListener(u, b[k].fn, void 0, !0), w)
          ) {
            case 1:
              b[k].fn.call(b[k].context);
              break;
            case 2:
              b[k].fn.call(b[k].context, d);
              break;
            case 3:
              b[k].fn.call(b[k].context, d, m);
              break;
            case 4:
              b[k].fn.call(b[k].context, d, m, v);
              break;
            default:
              if (!S)
                for (O = 1, S = new Array(w - 1); O < w; O++)
                  S[O - 1] = arguments[O];
              b[k].fn.apply(b[k].context, S);
          }
      }
      return !0;
    }),
    (o.prototype.on = function (u, d, m) {
      return a(this, u, d, m, !1);
    }),
    (o.prototype.once = function (u, d, m) {
      return a(this, u, d, m, !0);
    }),
    (o.prototype.removeListener = function (u, d, m, v) {
      var E = r ? r + u : u;
      if (!this._events[E]) return this;
      if (!d) return s(this, E), this;
      var A = this._events[E];
      if (A.fn)
        A.fn === d && (!v || A.once) && (!m || A.context === m) && s(this, E);
      else {
        for (var I = 0, b = [], w = A.length; I < w; I++)
          (A[I].fn !== d || (v && !A[I].once) || (m && A[I].context !== m)) &&
            b.push(A[I]);
        b.length ? (this._events[E] = b.length === 1 ? b[0] : b) : s(this, E);
      }
      return this;
    }),
    (o.prototype.removeAllListeners = function (u) {
      var d;
      return (
        u
          ? ((d = r ? r + u : u), this._events[d] && s(this, d))
          : ((this._events = new n()), (this._eventsCount = 0)),
        this
      );
    }),
    (o.prototype.off = o.prototype.removeListener),
    (o.prototype.addListener = o.prototype.on),
    (o.prefixed = r),
    (o.EventEmitter = o),
    (t.exports = o);
})(wF);
var Jle = wF.exports;
const Mf = mn(Jle),
  Qle = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        EventEmitter: Mf,
        default: Mf,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  );
var x7 = {};
const w7 = 256,
  q3 = "0|[1-9]\\d*",
  Yle = `(${q3})\\.(${q3})\\.(${q3})`,
  Xle = new RegExp(Yle);
function S_(t) {
  if (t.length > w7) throw new Error(`version is longer than ${w7} characters`);
  const e = t.trim().match(Xle);
  if (!e || (e == null ? void 0 : e.length) !== 4)
    throw new Error(
      `${t} is not a valid semantic version. Should be in the format of major.minor.patch. Ex: 0.4.1`
    );
  const r = Number(e[1]),
    n = Number(e[2]),
    i = Number(e[3]),
    a = [r, n, i].join(".");
  return {
    major: r,
    minor: n,
    patch: i,
    versionString: a,
  };
}
function eue(t, e) {
  const r = S_(t),
    n = S_(e);
  if (n.major > r.major) return !0;
  const i = n.major === r.major;
  if (i && n.minor > r.minor) return !0;
  const a = n.minor === r.minor;
  return i && a && n.patch > r.patch;
}
const hi = ne
    .union([
      ne.string(),
      ne.number(),
      ne.bigint(),
      ne.custom((t) => ae.isBigNumber(t)),
    ])
    .transform((t) => ae.from(t)),
  Tn = hi.transform((t) => t.toString()),
  tue = ne
    .union([ne.bigint(), ne.custom((t) => ae.isBigNumber(t))])
    .transform((t) => ae.from(t).toString());
function AE(t) {
  return !!(t && t._isSigner);
}
function _F(t) {
  return !!(t && t._isProvider);
}
const EF = 50,
  TF = 250,
  rue = {
    timeLimitMs: EF,
    sizeLimit: TF,
  };
class nue extends JD {
  constructor(e, r) {
    let n =
      arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : rue;
    super(e, r),
      (this._timeLimitMs = n.timeLimitMs || TF),
      (this._sizeLimit = n.sizeLimit || EF),
      (this._pendingBatchAggregator = null),
      (this._pendingBatch = null);
  }
  sendCurrentBatch(e) {
    this._pendingBatchAggregator && clearTimeout(this._pendingBatchAggregator);
    const r = this._pendingBatch || [];
    (this._pendingBatch = null), (this._pendingBatchAggregator = null);
    const n = r.map((i) => i.request);
    return (
      this.emit("debug", {
        action: "requestBatch",
        request: fi(e),
        provider: this,
      }),
      Ou(this.connection, JSON.stringify(n)).then(
        (i) => {
          this.emit("debug", {
            action: "response",
            request: n,
            response: i,
            provider: this,
          }),
            r.forEach((a, s) => {
              const o = i[s];
              if (o)
                if (o.error) {
                  const c = new Error(o.error.message);
                  (c.code = o.error.code), (c.data = o.error.data), a.reject(c);
                } else a.resolve(o.result);
              else a.reject(new Error("No response for request"));
            });
        },
        (i) => {
          this.emit("debug", {
            action: "response",
            error: i,
            request: n,
            provider: this,
          }),
            r.forEach((a) => {
              a.reject(i);
            });
        }
      )
    );
  }
  send(e, r) {
    const n = {
      method: e,
      params: r,
      id: this._nextId++,
      jsonrpc: "2.0",
    };
    this._pendingBatch === null && (this._pendingBatch = []);
    const i = {
        request: n,
        resolve: null,
        reject: null,
      },
      a = new Promise((s, o) => {
        (i.resolve = s), (i.reject = o);
      });
    return (
      this._pendingBatch.push(i),
      this._pendingBatch.length === this._sizeLimit && this.sendCurrentBatch(n),
      this._pendingBatchAggregator ||
        (this._pendingBatchAggregator = setTimeout(() => {
          this.sendCurrentBatch(n);
        }, this._timeLimitMs)),
      a
    );
  }
}
const iue = ne.object({
    rpc: ne.array(ne.string().url()),
    chainId: ne.number(),
    nativeCurrency: ne.object({
      name: ne.string(),
      symbol: ne.string(),
      decimals: ne.number(),
    }),
    slug: ne.string(),
  }),
  M_ = ne
    .object({
      supportedChains: ne.array(iue).default(wv),
      clientId: ne.string().optional(),
      secretKey: ne.string().optional(),
      readonlySettings: ne
        .object({
          rpcUrl: ne.string().url(),
          chainId: ne.number().optional(),
        })
        .optional(),
      gasSettings: ne
        .object({
          maxPriceInGwei: ne
            .number()
            .min(1, "gas price cannot be less than 1")
            .default(300),
          speed: ne.enum(["standard", "fast", "fastest"]).default("fastest"),
        })
        .default({
          maxPriceInGwei: 300,
          speed: "fastest",
        }),
      gasless: ne
        .union([
          ne.object({
            openzeppelin: ne.object({
              relayerUrl: ne.string().url(),
              relayerForwarderAddress: ne.string().optional(),
              useEOAForwarder: ne.boolean().default(!1),
              domainName: ne.string().default("GSNv2 Forwarder"),
              domainVersion: ne.string().default("0.0.1"),
            }),
            experimentalChainlessSupport: ne.boolean().default(!1),
          }),
          ne.object({
            biconomy: ne.object({
              apiId: ne.string(),
              apiKey: ne.string(),
              deadlineSeconds: ne
                .number()
                .min(1, "deadlineSeconds cannot be les than 1")
                .default(3600),
            }),
          }),
        ])
        .optional(),
      gatewayUrls: ne.array(ne.string()).optional(),
    })
    .default({
      gasSettings: {
        maxPriceInGwei: 300,
        speed: "fastest",
      },
    });
var _7 = {
  name: "@thirdweb-dev/sdk",
  version: "3.10.67",
  description: "The main thirdweb SDK.",
  repository: "https://github.com/thirdweb-dev/js/tree/main/packages/sdk",
  license: "Apache-2.0",
  main: "dist/thirdweb-dev-sdk.cjs.js",
  module: "dist/thirdweb-dev-sdk.esm.js",
  browser: {
    "./dist/thirdweb-dev-sdk.esm.js": "./dist/thirdweb-dev-sdk.browser.esm.js",
  },
  exports: {
    ".": {
      module: {
        browser: "./dist/thirdweb-dev-sdk.browser.esm.js",
        default: "./dist/thirdweb-dev-sdk.esm.js",
      },
      default: "./dist/thirdweb-dev-sdk.cjs.js",
    },
    "./evm": {
      module: {
        browser: "./evm/dist/thirdweb-dev-sdk-evm.browser.esm.js",
        default: "./evm/dist/thirdweb-dev-sdk-evm.esm.js",
      },
      default: "./evm/dist/thirdweb-dev-sdk-evm.cjs.js",
    },
    "./solana": {
      module: {
        browser: "./solana/dist/thirdweb-dev-sdk-solana.browser.esm.js",
        default: "./solana/dist/thirdweb-dev-sdk-solana.esm.js",
      },
      default: "./solana/dist/thirdweb-dev-sdk-solana.cjs.js",
    },
    "./evm/zksync": {
      module: {
        browser: "./evm/zksync/dist/thirdweb-dev-sdk-evm-zksync.browser.esm.js",
        default: "./evm/zksync/dist/thirdweb-dev-sdk-evm-zksync.esm.js",
      },
      default: "./evm/zksync/dist/thirdweb-dev-sdk-evm-zksync.cjs.js",
    },
    "./evm/functions": {
      module: {
        browser:
          "./evm/functions/dist/thirdweb-dev-sdk-evm-functions.browser.esm.js",
        default: "./evm/functions/dist/thirdweb-dev-sdk-evm-functions.esm.js",
      },
      default: "./evm/functions/dist/thirdweb-dev-sdk-evm-functions.cjs.js",
    },
    "./solana/server": {
      module: {
        browser:
          "./solana/server/dist/thirdweb-dev-sdk-solana-server.browser.esm.js",
        default: "./solana/server/dist/thirdweb-dev-sdk-solana-server.esm.js",
      },
      default: "./solana/server/dist/thirdweb-dev-sdk-solana-server.cjs.js",
    },
    "./package.json": "./package.json",
  },
  files: ["dist/", "evm/", "solana/", "server/"],
  preconstruct: {
    entrypoints: [
      "index.ts",
      "evm/index.ts",
      "evm/functions/index.ts",
      "evm/zksync/index.ts",
      "solana/index.ts",
      "solana/server/index.ts",
    ],
    exports: {
      envConditions: ["browser"],
    },
  },
  sideEffects: !1,
  scripts: {
    format: "prettier --write 'src/**/*'",
    lint: "eslint src/",
    fix: "eslint src/ --fix",
    clean: "rm -rf dist/",
    "generate-docs":
      "pnpm generate-docs:evm && pnpm generate-docs:solana && pnpm generate-snippets",
    "generate-docs:evm":
      "api-extractor run --local --config ./config/api-extractor-evm.json && api-documenter markdown -i ./temp -o ./docs/evm && rm -rf ./temp-evm && mv ./temp ./temp-evm",
    "generate-docs:solana":
      "api-extractor run --local --config ./config/api-extractor-solana.json && api-documenter markdown -i ./temp -o ./docs/solana && rm -rf ./temp-solana && mv ./temp ./temp-solana",
    "generate-snippets":
      "node ./scripts/generate-snippets.mjs && node ./scripts/generate-feature-snippets-evm.mjs",
    build: "tsc && preconstruct build",
    "test:evm:all":
      "SWC_NODE_PROJECT=./tsconfig.test.json nyc --reporter lcovonly --report-dir ./coverage/evm mocha --config './test/evm/.mocharc.json' --timeout 90000 --parallel './test/evm/**/*.test.ts'",
    "test:evm": "make test-evm",
    "test:evm:single":
      "SWC_NODE_PROJECT=./tsconfig.test.json mocha --config './test/evm/.mocharc.json' --timeout 90000",
    "node:solana:start":
      "DEBUG='amman:(info|error|debug)' amman start --forceClone",
    "node:solana:stop": "amman stop",
    "test:solana:all":
      "SWC_NODE_PROJECT=./tsconfig.test.json nyc --reporter lcovonly --report-dir ./coverage/solana  mocha --config './test/solana/.mocharc.json' --timeout 30000 --parallel './test/solana/**/*.test.ts'",
    "test:solana": "make test-sol",
    "test:solana:single":
      "SWC_NODE_PROJECT=./tsconfig.test.json mocha --config './test/solana/.mocharc.json' --timeout 30000",
    push: "yalc push",
  },
  devDependencies: {
    "@aws-sdk/client-secrets-manager": "^3.378.0",
    "@ethersproject/abstract-provider": "^5.7.0",
    "@metaplex-foundation/amman": "^0.12.1",
    "@metaplex-foundation/amman-client": "^0.2.4",
    "@metaplex-foundation/js": "^0.19.2",
    "@metaplex-foundation/mpl-token-metadata": "^2.12.0",
    "@microsoft/api-documenter": "^7.22.30",
    "@microsoft/api-extractor": "^7.36.3",
    "@microsoft/tsdoc": "^0.14.1",
    "@nomiclabs/hardhat-ethers": "^2.2.3",
    "@preconstruct/cli": "2.7.0",
    "@project-serum/anchor": "^0.25.0",
    "@solana/spl-token": "^0.3.5",
    "@solana/web3.js": "^1.62.0",
    "@swc-node/register": "^1.6.6",
    "@swc/core": "^1.3.71",
    "@thirdweb-dev/tsconfig": "workspace:*",
    "@types/bn.js": "^5.1.1",
    "@types/chai": "^4.3.5",
    "@types/deep-equal-in-any-order": "^1.0.1",
    "@types/mocha": "^10.0.0",
    "@types/node": "^18.17.1",
    "@types/uuid": "^9.0.2",
    "@typescript-eslint/eslint-plugin": "^6.2.0",
    "@typescript-eslint/parser": "^6.2.0",
    chai: "^4.3.6",
    "deep-equal-in-any-order": "^1.1.18",
    "dotenv-mono": "^1.3.10",
    eslint: "^8.45.0",
    "eslint-config-prettier": "^8.9.0",
    "eslint-config-thirdweb": "workspace:*",
    "eslint-plugin-better-tree-shaking": "0.0.3",
    "eslint-plugin-import": "^2.26.0",
    "eslint-plugin-inclusive-language": "^2.2.0",
    "eslint-plugin-prettier": "^5.0.0",
    "eslint-plugin-tsdoc": "^0.2.16",
    ethers: "^5.7.2",
    "ethers-aws-kms-signer": "^1.3.2",
    hardhat: "^2.17.0",
    mocha: "^10.2.0",
    nyc: "^15.1.0",
    prettier: "^3.0.0",
    typescript: "^5.1.6",
    "zksync-web3": "^0.14.3",
  },
  peerDependencies: {
    "@aws-sdk/client-secrets-manager": "^3.215.0",
    "@metaplex-foundation/js": "^0.17.6",
    "@metaplex-foundation/mpl-token-metadata": "^2.3.3",
    "@project-serum/anchor": "^0.25.0",
    "@solana/spl-token": "^0.3.5",
    "@solana/web3.js": "^1.62.0",
    ethers: "^5",
    "ethers-aws-kms-signer": "^1.3.2",
    "zksync-web3": "^0.14.3",
  },
  peerDependenciesMeta: {
    "@aws-sdk/client-secrets-manager": {
      optional: !0,
    },
    "ethers-aws-kms-signer": {
      optional: !0,
    },
    "@solana/spl-token": {
      optional: !0,
    },
    "@solana/web3.js": {
      optional: !0,
    },
    "@project-serum/anchor": {
      optional: !0,
    },
    "@metaplex-foundation/mpl-token-metadata": {
      optional: !0,
    },
    "@metaplex-foundation/js": {
      optional: !0,
    },
    "zksync-web3": {
      optional: !0,
    },
  },
  dependencies: {
    "@thirdweb-dev/chains": "workspace:*",
    "@thirdweb-dev/contracts-js": "workspace:*",
    "@thirdweb-dev/generated-abis": "workspace:*",
    "@thirdweb-dev/storage": "workspace:*",
    abitype: "^0.2.5",
    "bn.js": "^5.2.1",
    bs58: "^5.0.0",
    buffer: "^6.0.3",
    "cross-fetch": "^3.1.8",
    eventemitter3: "^5.0.1",
    "fast-deep-equal": "^3.1.3",
    merkletreejs: "^0.2.24",
    "tiny-invariant": "^1.2.0",
    tweetnacl: "^1.0.3",
    uuid: "^9.0.0",
    yaml: "^2.3.1",
    zod: "^3.20.2",
  },
  bugs: {
    url: "https://github.com/thirdweb-dev/js/issues",
  },
  author: "thirdweb eng <eng@thirdweb.com>",
};
function aue(t) {
  return t.supportedChains.reduce((e, r) => ((e[r.chainId] = r), e), {});
}
function Es(t, e) {
  if (typeof t == "string" && oue(t)) return I_(t, e);
  const r = M_.parse(e);
  kE(t) &&
    (r.supportedChains = [
      t,
      ...r.supportedChains.filter((s) => s.chainId !== t.chainId),
    ]);
  const n = aue(r);
  let i = "",
    a;
  try {
    (a = sue(t, r)), (i = Dce(n[a], r.clientId)[0]);
  } catch {}
  if ((i || (i = `https://${a || t}.rpc.thirdweb.com/${r.clientId || ""}`), !i))
    throw new Error(
      `No rpc url found for chain ${t}. Please provide a valid rpc url via the 'supportedChains' property of the sdk options.`
    );
  return I_(i, e, a);
}
function sue(t, e) {
  if (kE(t)) return t.chainId;
  if (typeof t == "number") return t;
  {
    const r = e.supportedChains.reduce(
      (n, i) => ((n[i.slug] = i.chainId), n),
      {}
    );
    if (t in r) return r[t];
  }
  throw new Error(
    `Cannot resolve chainId from: ${t} - please pass the chainId instead and specify it in the 'supportedChains' property of the SDK options.`
  );
}
function kE(t) {
  return typeof t != "string" && typeof t != "number" && !AE(t) && !_F(t);
}
function oue(t) {
  const e = t.match(/^(ws|http)s?:/i);
  if (e)
    switch (e[1].toLowerCase()) {
      case "http":
      case "https":
      case "ws":
      case "wss":
        return !0;
    }
  return !1;
}
const E7 = new Map();
function I_(t, e, r) {
  try {
    const n = {};
    let i = "none";
    if (cue(t)) {
      if (e != null && e.secretKey)
        throw new Error("Cannot use secretKey in browser context");
      if (e != null && e.clientId) {
        const o = new URL(t);
        (o.pathname = e.clientId),
          (n["x-client-id"] = e.clientId),
          (t = o.toString()),
          (i = "clientId");
      }
      typeof globalThis < "u" &&
        "TW_AUTH_TOKEN" in globalThis &&
        typeof globalThis.TW_AUTH_TOKEN == "string" &&
        ((n.authorization = `Bearer ${globalThis.TW_AUTH_TOKEN}`),
        (i = "twAuthToken")),
        typeof globalThis < "u" &&
          "TW_CLI_AUTH_TOKEN" in globalThis &&
          typeof globalThis.TW_CLI_AUTH_TOKEN == "string" &&
          (n["x-authorize-wallet"] = "true");
      const s =
        typeof globalThis < "u" && "APP_BUNDLE_ID" in globalThis
          ? globalThis.APP_BUNDLE_ID
          : void 0;
      t.includes("bundleId") || (t = t + (s ? `?bundleId=${s}` : "")),
        (n["x-sdk-version"] = _7.version),
        (n["x-sdk-name"] = _7.name),
        (n["x-sdk-platform"] = s
          ? "react-native"
          : Coe()
          ? window.bridge !== void 0
            ? "webGL"
            : "browser"
          : "node");
    }
    const a = t.match(/^(ws|http)s?:/i);
    if (a)
      switch (a[1].toLowerCase()) {
        case "http":
        case "https":
          const s = `${t}-${r || -1}-${i}`,
            o = E7.get(s);
          if (o) return o;
          const c = r
            ? new nue(
                {
                  url: t,
                  headers: n,
                },
                r
              )
            : new xre({
                url: t,
                headers: n,
              });
          return E7.set(s, c), c;
        case "ws":
        case "wss":
          return new cv(t, r);
      }
  } catch {}
  return XD(t);
}
function cue(t) {
  return new URL(t).hostname.endsWith(".thirdweb.com");
}
function Jn(t, e) {
  let r, n;
  if (
    (AE(t)
      ? ((r = t), t.provider && (n = t.provider))
      : _F(t)
      ? (n = t)
      : (n = Es(t, e)),
    e != null &&
      e.readonlySettings &&
      (n = I_(e.readonlySettings.rpcUrl, e, e.readonlySettings.chainId)),
    !n)
  )
    throw r
      ? new Error(
          "No provider passed to the SDK! Please make sure that your signer is connected to a provider!"
        )
      : new Error(
          "No provider found! Make sure to specify which network to connect to, or pass a signer or provider to the SDK!"
        );
  return [r, n];
}
let V3;
const K3 = new Map();
async function CF(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  V3 || (V3 = Jn("ethereum")[1]);
  let r;
  K3.has(t)
    ? (r = K3.get(t))
    : (r = V3.resolveName(t).then((i) =>
        i
          ? {
              address: i,
              expirationTime: new Date(Date.now() + 1e3 * 60 * 5),
            }
          : {
              address: null,
              expirationTime: new Date(Date.now() + 1e3 * 30),
            }
      ));
  const n = await r;
  return (
    n.expirationTime < new Date() && (K3.delete(t), e === 0 && CF(t, e + 1)),
    n.address
  );
}
const lue = ne
    .custom(
      (t) =>
        typeof t == "string" && (t.endsWith(".eth") || t.endsWith(".cb.id"))
    )
    .transform(async (t) => CF(t))
    .refine((t) => !!t && ud(t), {
      message: "Provided value was not a valid ENS name",
    }),
  AF = ne.custom(
    (t) => typeof t == "string" && ud(t),
    (t) => ({
      message: `${t} is not a valid address`,
    })
  ),
  wr = ne.union([AF, lue], {
    invalid_type_error: "Provided value was not a valid address or ENS name",
  });
let Ve = (function (t) {
    return (
      (t[(t.Mainnet = 1)] = "Mainnet"),
      (t[(t.Goerli = 5)] = "Goerli"),
      (t[(t.Polygon = 137)] = "Polygon"),
      (t[(t.Mumbai = 80001)] = "Mumbai"),
      (t[(t.Localhost = 1337)] = "Localhost"),
      (t[(t.Hardhat = 31337)] = "Hardhat"),
      (t[(t.Fantom = 250)] = "Fantom"),
      (t[(t.FantomTestnet = 4002)] = "FantomTestnet"),
      (t[(t.Avalanche = 43114)] = "Avalanche"),
      (t[(t.AvalancheFujiTestnet = 43113)] = "AvalancheFujiTestnet"),
      (t[(t.Optimism = 10)] = "Optimism"),
      (t[(t.OptimismGoerli = 420)] = "OptimismGoerli"),
      (t[(t.Arbitrum = 42161)] = "Arbitrum"),
      (t[(t.ArbitrumGoerli = 421613)] = "ArbitrumGoerli"),
      (t[(t.BinanceSmartChainMainnet = 56)] = "BinanceSmartChainMainnet"),
      (t[(t.BinanceSmartChainTestnet = 97)] = "BinanceSmartChainTestnet"),
      t
    );
  })({}),
  R_ = wv;
function uue(t) {
  t && t.length > 0 ? (R_ = t) : (R_ = wv);
}
function kF() {
  return R_;
}
const qi = "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
  d2 = {
    [Ve.Mainnet]: {
      name: "Ether",
      symbol: "ETH",
      decimals: 18,
      wrapped: {
        address: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
        name: "Wrapped Ether",
        symbol: "WETH",
      },
    },
    [Ve.Goerli]: {
      name: "Görli Ether",
      symbol: "GOR",
      decimals: 18,
      wrapped: {
        address: "0xb4fbf271143f4fbf7b91a5ded31805e42b2208d6",
        name: "Wrapped Ether",
        symbol: "WETH",
      },
    },
    11155111: {
      name: "Sepolia Ether",
      symbol: "SEP",
      decimals: 18,
      wrapped: {
        address: "0x7b79995e5f793A07Bc00c21412e50Ecae098E7f9",
        name: "Wrapped Ether",
        symbol: "WETH",
      },
    },
    [Ve.Polygon]: {
      name: "Matic",
      symbol: "MATIC",
      decimals: 18,
      wrapped: {
        address: "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270",
        name: "Wrapped Matic",
        symbol: "WMATIC",
      },
    },
    [Ve.Mumbai]: {
      name: "Matic",
      symbol: "MATIC",
      decimals: 18,
      wrapped: {
        address: "0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889",
        name: "Wrapped Matic",
        symbol: "WMATIC",
      },
    },
    [Ve.Avalanche]: {
      name: "Avalanche",
      symbol: "AVAX",
      decimals: 18,
      wrapped: {
        address: "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7",
        name: "Wrapped AVAX",
        symbol: "WAVAX",
      },
    },
    [Ve.AvalancheFujiTestnet]: {
      name: "Avalanche",
      symbol: "AVAX",
      decimals: 18,
      wrapped: {
        address: "0xd00ae08403B9bbb9124bB305C09058E32C39A48c",
        name: "Wrapped AVAX",
        symbol: "WAVAX",
      },
    },
    [Ve.Fantom]: {
      name: "Fantom",
      symbol: "FTM",
      decimals: 18,
      wrapped: {
        address: "0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83",
        name: "Wrapped Fantom",
        symbol: "WFTM",
      },
    },
    [Ve.FantomTestnet]: {
      name: "Fantom",
      symbol: "FTM",
      decimals: 18,
      wrapped: {
        address: "0xf1277d1Ed8AD466beddF92ef448A132661956621",
        name: "Wrapped Fantom",
        symbol: "WFTM",
      },
    },
    [Ve.Arbitrum]: {
      name: "Ether",
      symbol: "ETH",
      decimals: 18,
      wrapped: {
        address: "0x82af49447d8a07e3bd95bd0d56f35241523fbab1",
        name: "Wrapped Ether",
        symbol: "WETH",
      },
    },
    [Ve.ArbitrumGoerli]: {
      name: "Arbitrum Goerli Ether",
      symbol: "AGOR",
      decimals: 18,
      wrapped: {
        address: "0xe39Ab88f8A4777030A534146A9Ca3B52bd5D43A3",
        name: "Wrapped Ether",
        symbol: "WETH",
      },
    },
    [Ve.Optimism]: {
      name: "Ether",
      symbol: "ETH",
      decimals: 18,
      wrapped: {
        address: "0x4200000000000000000000000000000000000006",
        name: "Wrapped Ether",
        symbol: "WETH",
      },
    },
    [Ve.OptimismGoerli]: {
      name: "Goerli Ether",
      symbol: "ETH",
      decimals: 18,
      wrapped: {
        address: "0x4200000000000000000000000000000000000006",
        name: "Wrapped Ether",
        symbol: "WETH",
      },
    },
    [Ve.BinanceSmartChainMainnet]: {
      name: "Binance Chain Native Token",
      symbol: "BNB",
      decimals: 18,
      wrapped: {
        address: "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
        name: "Wrapped Binance Chain Token",
        symbol: "WBNB",
      },
    },
    [Ve.BinanceSmartChainTestnet]: {
      name: "Binance Chain Native Token",
      symbol: "TBNB",
      decimals: 18,
      wrapped: {
        address: "0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd",
        name: "Wrapped Binance Chain Testnet Token",
        symbol: "WBNB",
      },
    },
    [Ve.Hardhat]: {
      name: "Ether",
      symbol: "ETH",
      decimals: 18,
      wrapped: {
        address: "0x5FbDB2315678afecb367f032d93F642f64180aa3",
        name: "Wrapped Ether",
        symbol: "WETH",
      },
    },
    [Ve.Localhost]: {
      name: "Ether",
      symbol: "ETH",
      decimals: 18,
      wrapped: {
        address: "0x5FbDB2315678afecb367f032d93F642f64180aa3",
        name: "Wrapped Ether",
        symbol: "WETH",
      },
    },
    84531: {
      name: "Base Goerli Testnet",
      symbol: "ETH",
      decimals: 18,
      wrapped: {
        address: "0x4200000000000000000000000000000000000006",
        name: "Wrapped Ether",
        symbol: "WETH",
      },
    },
    280: {
      name: "zkSync Era Testnet",
      symbol: "ETH",
      decimals: 18,
      wrapped: {
        address: "0x5AEa5775959fBC2557Cc8789bC1bf90A239D9a91",
        name: "Wrapped Ether",
        symbol: "WETH",
      },
    },
  };
function SF(t) {
  const e = kF().find((r) => r.chainId === t);
  return e && e.nativeCurrency
    ? {
        name: e.nativeCurrency.name,
        symbol: e.nativeCurrency.symbol,
        decimals: 18,
        wrapped: {
          address: Ft,
          name: `Wrapped ${e.nativeCurrency.name}`,
          symbol: `W${e.nativeCurrency.symbol}`,
        },
      }
    : d2[t] || {
        name: "Ether",
        symbol: "ETH",
        decimals: 18,
        wrapped: {
          address: Ft,
          name: "Wrapped Ether",
          symbol: "WETH",
        },
      };
}
const mke = {
    [Ve.Mainnet]: "0x514910771AF9Ca656af840dff83E8264EcF986CA",
    [Ve.Goerli]: "0x326C977E6efc84E512bB9C30f76E30c160eD06FB",
    [Ve.BinanceSmartChainMainnet]: "0x404460C6A5EdE2D891e8297795264fDe62ADBB75",
    [Ve.Polygon]: "0xb0897686c545045aFc77CF20eC7A532E3120E0F1",
    [Ve.Mumbai]: "0x326C977E6efc84E512bB9C30f76E30c160eD06FB",
    [Ve.Avalanche]: "0x5947BB275c521040051D82396192181b413227A3",
    [Ve.AvalancheFujiTestnet]: "0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846",
    [Ve.Fantom]: "0x6F43FF82CCA38001B6699a8AC47A2d0E66939407",
    [Ve.FantomTestnet]: "0xfaFedb041c0DD4fA2Dc0d87a6B0979Ee6FA7af5F",
  },
  Ev = ne.union([
    ne.date().transform((t) => ae.from(Math.floor(t.getTime() / 1e3))),
    ne.number().transform((t) => ae.from(t)),
  ]),
  SE = Ev.default(new Date(0)),
  Hm = Ev.default(new Date(Date.now() + 1e3 * 60 * 60 * 24 * 365 * 10)),
  fue = ne.object({
    name: ne.string(),
    symbol: ne.string(),
    decimals: ne.number(),
  }),
  due = fue.extend({
    value: hi,
    displayValue: ne.string(),
  }),
  bl = ne.object({
    merkle: ne.record(ne.string()).default({}),
  }),
  P_ = ne.object({
    address: wr,
    maxClaimable: Sf.default(0),
    price: Sf.optional(),
    currencyAddress: wr.default(Ft).optional(),
  }),
  ME = ne.union([
    ne.array(ne.string()).transform(
      async (t) =>
        await Promise.all(
          t.map((e) =>
            P_.parseAsync({
              address: e,
            })
          )
        )
    ),
    ne.array(P_),
  ]),
  MF = P_.extend({
    proof: ne.array(ne.string()),
  }),
  IF = ne.object({
    merkleRoot: ne.string(),
    claims: ne.array(MF),
  }),
  hue = ne
    .object({
      name: ne.string().optional(),
    })
    .catchall(ne.unknown()),
  IE = ne.object({
    startTime: SE,
    currencyAddress: ne.string().default(qi),
    price: Gi.default(0),
    maxClaimableSupply: Sf,
    maxClaimablePerWallet: Sf,
    waitInSeconds: Tn.default(0),
    merkleRootHash: nne.default(Rt([0], 32)),
    snapshot: ne.optional(ME).nullable(),
    metadata: hue.optional(),
  }),
  pue = ne.array(IE),
  RF = IE.extend({
    availableSupply: Sf,
    currentMintSupply: Sf,
    currencyMetadata: due.default({
      value: ae.from("0"),
      displayValue: "0",
      symbol: "",
      decimals: 18,
      name: "",
    }),
    price: hi,
    waitInSeconds: hi,
    startTime: hi.transform((t) => new Date(t.toNumber() * 1e3)),
    snapshot: ME.optional().nullable(),
  });
function PF(t) {
  if (t === void 0) {
    const e = Buffer.alloc(16);
    return oB({}, e), Ke(Lt(e.toString("hex")));
  } else return Ke(t);
}
const RE = ne.object({
    to: wr.refine((t) => t.toLowerCase() !== Ft, {
      message: "Cannot create payload to mint to zero address",
    }),
    price: Gi.default(0),
    currencyAddress: AF.default(qi),
    mintStartTime: SE,
    mintEndTime: Hm,
    uid: ne
      .string()
      .optional()
      .transform((t) => PF(t)),
    primarySaleRecipient: wr.default(Ft),
  }),
  NF = RE.extend({
    quantity: Gi,
  }),
  mue = NF.extend({
    mintStartTime: hi,
    mintEndTime: hi,
  }),
  PE = RE.extend({
    metadata: uv,
    royaltyRecipient: ne.string().default(Ft),
    royaltyBps: yd.default(0),
  }),
  BF = PE.extend({
    metadata: uv.default(""),
    uri: ne.string(),
    royaltyBps: hi,
    mintStartTime: hi,
    mintEndTime: hi,
  }),
  yue = PE.extend({
    metadata: uv.default(""),
    quantity: Tn,
  }),
  gue = yue.extend({
    tokenId: Tn,
  }),
  bue = BF.extend({
    tokenId: hi,
    quantity: hi,
  }),
  vue = PE.extend({
    metadata: uv.default(""),
    quantity: hi.default(1),
  }),
  xue = BF.extend({
    quantity: hi.default(1),
  }),
  wue = [
    {
      name: "to",
      type: "address",
    },
    {
      name: "primarySaleRecipient",
      type: "address",
    },
    {
      name: "quantity",
      type: "uint256",
    },
    {
      name: "price",
      type: "uint256",
    },
    {
      name: "currency",
      type: "address",
    },
    {
      name: "validityStartTimestamp",
      type: "uint128",
    },
    {
      name: "validityEndTimestamp",
      type: "uint128",
    },
    {
      name: "uid",
      type: "bytes32",
    },
  ],
  _ue = [
    {
      name: "to",
      type: "address",
    },
    {
      name: "royaltyRecipient",
      type: "address",
    },
    {
      name: "royaltyBps",
      type: "uint256",
    },
    {
      name: "primarySaleRecipient",
      type: "address",
    },
    {
      name: "uri",
      type: "string",
    },
    {
      name: "price",
      type: "uint256",
    },
    {
      name: "currency",
      type: "address",
    },
    {
      name: "validityStartTimestamp",
      type: "uint128",
    },
    {
      name: "validityEndTimestamp",
      type: "uint128",
    },
    {
      name: "uid",
      type: "bytes32",
    },
  ],
  Eue = [
    {
      name: "to",
      type: "address",
    },
    {
      name: "royaltyRecipient",
      type: "address",
    },
    {
      name: "royaltyBps",
      type: "uint256",
    },
    {
      name: "primarySaleRecipient",
      type: "address",
    },
    {
      name: "tokenId",
      type: "uint256",
    },
    {
      name: "uri",
      type: "string",
    },
    {
      name: "quantity",
      type: "uint256",
    },
    {
      name: "pricePerToken",
      type: "uint256",
    },
    {
      name: "currency",
      type: "address",
    },
    {
      name: "validityStartTimestamp",
      type: "uint128",
    },
    {
      name: "validityEndTimestamp",
      type: "uint128",
    },
    {
      name: "uid",
      type: "bytes32",
    },
  ],
  Tue = [
    {
      name: "to",
      type: "address",
    },
    {
      name: "royaltyRecipient",
      type: "address",
    },
    {
      name: "royaltyBps",
      type: "uint256",
    },
    {
      name: "primarySaleRecipient",
      type: "address",
    },
    {
      name: "uri",
      type: "string",
    },
    {
      name: "quantity",
      type: "uint256",
    },
    {
      name: "pricePerToken",
      type: "uint256",
    },
    {
      name: "currency",
      type: "address",
    },
    {
      name: "validityStartTimestamp",
      type: "uint128",
    },
    {
      name: "validityEndTimestamp",
      type: "uint128",
    },
    {
      name: "uid",
      type: "bytes32",
    },
  ],
  Cue = [
    {
      name: "validityStartTimestamp",
      type: "uint128",
    },
    {
      name: "validityEndTimestamp",
      type: "uint128",
    },
    {
      name: "uid",
      type: "bytes32",
    },
    {
      name: "data",
      type: "bytes",
    },
  ],
  Qn = ne
    .object({
      name: ne.string(),
      description: ne.string().optional(),
      image: gu.optional(),
      external_link: ne.string().optional(),
      app_uri: ne.string().optional(),
      social_urls: ne.record(ne.string()).optional(),
    })
    .catchall(ne.unknown()),
  Ja = Qn.extend({
    image: ne.string().optional(),
  }).catchall(ne.unknown()),
  Bn = ne.object({
    seller_fee_basis_points: yd.default(0),
    fee_recipient: wr.default(Ft),
  }),
  vl = ne.object({
    primary_sale_recipient: wr,
  }),
  Va = ne.object({
    platform_fee_basis_points: yd.default(0),
    platform_fee_recipient: wr.default(Ft),
  }),
  Ji = ne.object({
    trusted_forwarders: ne.array(wr).default([]),
  }),
  gn = ne.object({
    symbol: ne.string().default(""),
  }),
  Aue = Qn.catchall(ne.union([tue, ne.unknown()])),
  DF = Aue.merge(Bn.merge(bl).merge(gn).partial()).catchall(ne.any()),
  kue = Ja.merge(Bn.merge(bl).merge(gn).partial()).catchall(ne.any()),
  Sue = DF.merge(Va.merge(vl).merge(Ji).partial()),
  Z0 = {
    deploy: Sue,
    output: kue,
    input: DF,
  },
  T7 = ne
    .object({
      type: ne.string(),
      name: ne.string().default(""),
    })
    .catchall(ne.any()),
  C7 = T7.extend({
    stateMutability: ne.string().optional(),
    components: ne.array(T7).optional(),
  }).catchall(ne.any()),
  Mue = ne
    .object({
      type: ne.string(),
      name: ne.string().default(""),
      inputs: ne.array(C7).default([]),
      outputs: ne.array(C7).default([]),
    })
    .catchall(ne.any()),
  Gt = ne.array(Mue),
  Tv = ne
    .object({
      name: ne.string(),
      metadataUri: ne.string(),
      bytecodeUri: ne.string(),
      analytics: ne.any().optional(),
    })
    .catchall(ne.any()),
  N_ = ne.record(ne.string(), ne.string()),
  Iue = ne.object({
    factoryFunction: ne.string(),
    params: ne
      .array(
        ne.object({
          name: ne.string(),
          type: ne.string(),
        })
      )
      .default([]),
    customFactoryAddresses: N_,
  }),
  Rue = ne.object({
    implementationAddresses: N_,
    implementationInitializerFunction: ne.string().default("initialize"),
    customFactoryInput: Iue.optional(),
    factoryAddresses: N_.optional(),
  }),
  Pue = ne.union([
    ne.literal("standard"),
    ne.literal("autoFactory"),
    ne.literal("customFactory"),
  ]),
  Nue = ne.union([
    ne.literal("none"),
    ne.literal("plugin"),
    ne.literal("dynamic"),
  ]),
  Bue = ne.object({
    allNetworks: ne.boolean().optional(),
    networksEnabled: ne.array(ne.number()).default([]),
  }),
  OF = ne
    .object({
      version: ne.string().refine(
        (t) => {
          try {
            return S_(t), !0;
          } catch {
            return !1;
          }
        },
        (t) => ({
          message: `'${t}' is not a valid semantic version. Should be in the format of major.minor.patch. Ex: 0.4.1`,
        })
      ),
      displayName: ne.string().optional(),
      description: ne.string().optional(),
      readme: ne.string().optional(),
      license: ne.string().optional(),
      changelog: ne.string().optional(),
      tags: ne.array(ne.string()).optional(),
      audit: gu.nullable().optional(),
      logo: gu.nullable().optional(),
      isDeployableViaFactory: ne.boolean().optional(),
      isDeployableViaProxy: ne.boolean().optional(),
      factoryDeploymentData: Rue.optional(),
      deployType: Pue.optional(),
      routerType: Nue.optional(),
      defaultExtensions: ne
        .array(
          ne.object({
            extensionName: ne.string(),
            extensionVersion: ne.string().default("latest"),
            publisherAddress: wr,
          })
        )
        .optional(),
      networksForDeployment: Bue.optional(),
      constructorParams: ne
        .record(
          ne.string(),
          ne
            .object({
              displayName: ne.string().optional(),
              description: ne.string().optional(),
              defaultValue: ne.string().optional(),
              hidden: ne.boolean().optional(),
            })
            .catchall(ne.any())
        )
        .optional(),
      compositeAbi: Gt.optional(),
    })
    .catchall(ne.any()),
  Due = OF.extend({
    audit: ne.string().nullable().optional(),
    logo: ne.string().nullable().optional(),
  }),
  Oue = Tv.merge(OF).extend({
    publisher: wr.optional(),
  }),
  Fue = Tv.merge(Due).extend({
    publisher: wr.optional(),
  }),
  Lue = ne.object({
    name: ne.string().optional(),
    bio: ne.string().optional(),
    avatar: gu.nullable().optional(),
    website: ne.string().optional(),
    twitter: ne.string().optional(),
    telegram: ne.string().optional(),
    facebook: ne.string().optional(),
    github: ne.string().optional(),
    medium: ne.string().optional(),
    linkedin: ne.string().optional(),
    reddit: ne.string().optional(),
    discord: ne.string().optional(),
  }),
  $ue = Lue.extend({
    avatar: ne.string().nullable().optional(),
  }),
  B_ = ne.object({
    id: ne.string(),
    timestamp: Tn,
    metadataUri: ne.string(),
  }),
  FF = ne.object({
    title: ne.string().optional(),
    author: ne.string().optional(),
    details: ne.string().optional(),
    notice: ne.string().optional(),
  }),
  Uue = ne.object({
    name: ne.string(),
    abi: Gt,
    metadata: ne.record(ne.string(), ne.any()),
    info: FF,
    licenses: ne
      .array(ne.string().optional())
      .default([])
      .transform((t) => t.filter((e) => e !== void 0)),
    isPartialAbi: ne.boolean().optional(),
  }),
  Wue = Tv.merge(Uue).extend({
    bytecode: ne.string(),
  }),
  jue = ne
    .object({
      gasLimit: Tn.optional(),
      gasPrice: Tn.optional(),
      maxFeePerGas: Tn.optional(),
      maxPriorityFeePerGas: Tn.optional(),
      nonce: Tn.optional(),
      value: Tn.optional(),
      blockTag: ne.union([ne.string(), ne.number()]).optional(),
      from: wr.optional(),
      type: ne.number().optional(),
    })
    .strict();
class Sr {
  constructor(e) {
    this.contractWrapper = e;
  }
  encode(e, r) {
    return this.contractWrapper.readContract.interface.encodeFunctionData(e, r);
  }
  decode(e, r) {
    return this.contractWrapper.readContract.interface.decodeFunctionData(e, r);
  }
}
class LF extends Error {
  constructor(e) {
    super(e ? `Object with id ${e} NOT FOUND` : "NOT_FOUND");
  }
}
class Hue extends Error {
  constructor(e, r) {
    super(`MISSING ROLE: ${e} does not have the '${r}' role`);
  }
}
class zue extends Error {
  constructor(e) {
    super(`DUPLICATE_LEAFS${e ? ` : ${e}` : ""}`);
  }
}
class yke extends Error {
  constructor(e) {
    super(`Auction already started with existing bid${e ? `, id: ${e}` : ""}`);
  }
}
class gke extends Error {
  constructor(e, r) {
    super(
      `Could not find listing.${e ? ` marketplace address: ${e}` : ""}${
        r ? ` listing id: ${r}` : ""
      }`
    );
  }
}
class bke extends Error {
  constructor(e, r, n, i) {
    super(
      `Incorrect listing type. Are you sure you're using the right method?.${
        e ? ` marketplace address: ${e}` : ""
      }${r ? ` listing id: ${r}` : ""}${i ? ` expected type: ${i}` : ""}${
        n ? ` actual type: ${n}` : ""
      }`
    );
  }
}
class G3 extends Error {
  constructor(e, r) {
    super(
      `Auction has not ended yet${e ? `, id: ${e}` : ""}${
        r ? `, end time: ${r.toString()}` : ""
      }`
    );
  }
}
class nu extends Error {
  constructor(e) {
    super(
      `This functionality is not available because the contract does not implement the '${e.name}' Extension. Learn how to unlock this functionality at https://portal.thirdweb.com/extensions `
    );
  }
}
var wm, _m, Em;
class NE extends Error {
  constructor(r, n) {
    var a;
    let i = `


╔═══════════════════╗
║ TRANSACTION ERROR ║
╚═══════════════════╝

`;
    if (
      ((i += `Reason: ${r.reason}`),
      (i += `


╔═════════════════════════╗
║ TRANSACTION INFORMATION ║
╚═════════════════════════╝
`),
      (i += ac("from", r.from)),
      r.to &&
        (i += ac("to", r.contractName ? `${r.to} (${r.contractName})` : r.to)),
      (i += ac("chain", `${r.network.name} (${r.network.chainId})`)),
      r.rpcUrl)
    )
      try {
        const s = new URL(r.rpcUrl);
        i += ac("rpc", s.hostname);
      } catch {}
    if (
      (r.hash && (i += ac("tx hash", r.hash)),
      r.value &&
        r.value.gt(0) &&
        (i += ac(
          "value",
          `${Wr(r.value)} ${
            ((a = d2[r.network.chainId]) == null ? void 0 : a.symbol) || ""
          }`
        )),
      (i += ac("data", `${r.data}`)),
      r.method && (i += ac("method", r.method)),
      r.sources)
    ) {
      const s = r.sources.find((o) => o.source.includes(r.reason));
      if (s) {
        const o = s.source
            .split(
              `
`
            )
            .map((d, m) => `${m + 1}  ${d}`),
          c = o.findIndex((d) => d.includes(r.reason));
        o[c] += "   <-- REVERT";
        const u = o.slice(c - 8, c + 4);
        (i += `


╔══════════════════════╗
║ SOLIDITY STACK TRACE ║
╚══════════════════════╝

`),
          (i += `File: ${s.filename.replace("node_modules/", "")}

`),
          (i += u.join(`
`));
      }
    }
    (i += `


╔═════════════════════╗
║ DEBUGGING RESOURCES ║
╚═════════════════════╝

`),
      (i +=
        "Need helping debugging? Join our Discord: https://discord.gg/thirdweb"),
      (i += `

`);
    super(i);
    k1(this, wm);
    k1(this, _m);
    k1(this, Em);
    S1(this, wm, r.reason), S1(this, _m, r), S1(this, Em, n);
  }
  get reason() {
    return A1(this, wm);
  }
  get raw() {
    return A1(this, Em);
  }
  get info() {
    return A1(this, _m);
  }
}
(wm = new WeakMap()), (_m = new WeakMap()), (Em = new WeakMap());
function BE(t) {
  if (t.reason && !t.reason.includes("cannot estimate gas")) return t.reason;
  if (t.error) return t.error;
  let e = t;
  return (
    typeof t == "object"
      ? (e = JSON.stringify(t))
      : typeof t != "string" && (e = t.toString()),
    A7(/.*?"message":"([^"\\]*).*?/, e) ||
      A7(/.*?"reason":"([^"\\]*).*?/, e) ||
      t.message ||
      ""
  );
}
function ac(t, e) {
  if (e === "") return e;
  const r = Array(10 - t.length)
    .fill(" ")
    .join("");
  return (
    e.includes(`
`)
      ? (e =
          `

  ` +
          e.split(`
`).join(`
  `))
      : (e = `${r}${e}`),
    `
${t}:${e}`
  );
}
function A7(t, e) {
  const r = e.match(t) || [];
  let n = "";
  return (r == null ? void 0 : r.length) > 0 && (n += r[1]), n;
}
function h2(t, e) {
  return t
    ? (t && t.toString().includes(e)) ||
        (t && t.message && t.message.toString().includes(e)) ||
        (t && t.error && t.error.toString().includes(e))
    : !1;
}
const k7 = {
    name: "ERC20ClaimConditionsV1",
    namespace: "token.drop.claim",
    docLinks: {
      sdk: "sdk.erc20dclaimable",
      contracts: "erc20claimconditions",
    },
    abis: [Ri, hF],
    features: {},
  },
  Zp = {
    name: "ERC20ClaimConditionsV2",
    namespace: "token.drop.claim",
    docLinks: {
      sdk: "sdk.erc20dclaimable",
      contracts: "erc20claimconditions",
    },
    abis: [Ri, dF],
    features: {},
  },
  S7 = {
    name: "ERC20ClaimPhasesV2",
    namespace: "token.drop.claim",
    docLinks: {
      sdk: "sdk.erc20dclaimable",
      contracts: "erc20claimphases",
    },
    abis: [Ri, fF],
    features: {},
  },
  M7 = {
    name: "ERC20ClaimPhasesV1",
    namespace: "token.drop.claim",
    docLinks: {
      sdk: "sdk.erc20dclaimable",
      contracts: "erc20claimphases",
    },
    abis: [Hce],
    features: {},
  },
  Jp = {
    name: "ERC20Burnable",
    namespace: "token.burn",
    docLinks: {
      sdk: "sdk.erc20burnable",
      contracts: "erc20burnable",
    },
    abis: [Ri, jce],
    features: {},
  },
  p2 = {
    name: "ERC20SignatureMintable",
    namespace: "token.signature",
    docLinks: {
      sdk: "sdk.erc20signaturemintable",
      contracts: "erc20signaturemint",
    },
    abis: [Ri, qce],
    features: {},
  },
  m2 = {
    name: "ERC20BatchMintable",
    namespace: "token.mint.batch",
    docLinks: {
      sdk: "sdk.erc20batchmintable",
      contracts: "erc20batchmintable",
    },
    abis: [Ri, pF, CE],
    features: {},
  },
  Qp = {
    name: "ERC20Mintable",
    namespace: "token.mint",
    docLinks: {
      sdk: "sdk.erc20mintable",
      contracts: "erc20mintable",
    },
    abis: [Ri, pF],
    features: {
      [m2.name]: m2,
    },
  },
  I7 = {
    name: "ERC20Permit",
    namespace: "token.permit",
    docLinks: {
      sdk: "sdk.erc20permit",
      contracts: "erc20permit",
    },
    abis: [Ri, zce],
    features: {},
  },
  y2 = {
    name: "ERC20",
    namespace: "token",
    docLinks: {
      sdk: "sdk.erc20",
      contracts: "erc20",
    },
    abis: [Ri, eF],
    features: {
      [Jp.name]: Jp,
      [Qp.name]: Qp,
      [k7.name]: k7,
      [Zp.name]: Zp,
      [M7.name]: M7,
      [S7.name]: S7,
      [p2.name]: p2,
      [I7.name]: I7,
    },
  },
  g2 = {
    name: "ERC721Burnable",
    namespace: "nft.burn",
    docLinks: {
      sdk: "sdk.erc721burnable",
      contracts: "erc721burnable",
    },
    abis: [yn, Vce],
    features: {},
  },
  b2 = {
    name: "ERC721Revealable",
    namespace: "nft.drop.revealer",
    docLinks: {
      sdk: "sdk.delayedreveal",
      contracts: "erc721revealable",
    },
    abis: [yn, _v, mF],
    features: {},
  },
  v2 = {
    name: "ERC721TieredDrop",
    namespace: "nft.tieredDrop",
    docLinks: {
      sdk: "sdk.erc721tiereddrop",
      contracts: "",
    },
    abis: [yn, ele],
    features: {},
  },
  R7 = {
    name: "ERC721ClaimConditionsV1",
    namespace: "nft.drop.claim",
    docLinks: {
      sdk: "sdk.erc721claimable",
      contracts: "erc721claimconditions",
    },
    abis: [yn, hF],
    features: {},
  },
  x2 = {
    name: "ERC721ClaimConditionsV2",
    namespace: "nft.drop.claim",
    docLinks: {
      sdk: "sdk.erc721claimable",
      contracts: "erc721claimconditions",
    },
    abis: [yn, dF],
    features: {},
  },
  P7 = {
    name: "ERC721ClaimPhasesV1",
    namespace: "nft.drop.claim",
    docLinks: {
      sdk: "sdk.erc721claimable",
      contracts: "erc721claimphases",
    },
    abis: [Gce],
    features: {},
  },
  N7 = {
    name: "ERC721ClaimPhasesV2",
    namespace: "nft.drop.claim",
    docLinks: {
      sdk: "sdk.erc721claimable",
      contracts: "erc721claimphases",
    },
    abis: [yn, fF],
    features: {},
  },
  Yp = {
    name: "ERC721ClaimCustom",
    namespace: "nft.drop.claim",
    docLinks: {
      sdk: "sdk.erc721claimable",
      contracts: "erc721claimcustom",
    },
    abis: [yn, Kce],
    features: {},
  },
  D_ = {
    name: "ERC721ClaimZora",
    namespace: "nft.drop.claim",
    docLinks: {
      sdk: "sdk.erc721claimable",
      contracts: "erc721claimzora",
    },
    abis: [yn, rle],
    features: {},
  },
  w2 = {
    name: "ERC721LazyMintable",
    namespace: "nft.drop",
    docLinks: {
      sdk: "sdk.erc721lazymintable",
      contracts: "lazymint",
    },
    abis: [yn, _v],
    features: {
      [b2.name]: b2,
    },
  },
  _2 = {
    name: "ERC721BatchMintable",
    namespace: "nft.mint.batch",
    docLinks: {
      sdk: "sdk.erc721batchmintable",
      contracts: "erc721batchmintable",
    },
    abis: [yn, yF, CE],
    features: {},
  },
  E2 = {
    name: "ERC721Mintable",
    namespace: "nft.mint",
    docLinks: {
      sdk: "sdk.erc721mintable",
      contracts: "erc721mintable",
    },
    abis: [yn, yF],
    features: {
      [_2.name]: _2,
    },
  },
  T2 = {
    name: "ERC721SignatureMintV2",
    namespace: "nft.signature",
    docLinks: {
      sdk: "sdk.erc721signaturemint",
      contracts: "erc721signaturemint",
    },
    abis: [yn, Yce],
    features: {},
  },
  B7 = {
    name: "ERC721SignatureMintV1",
    namespace: "nft.signature",
    docLinks: {
      sdk: "sdk.erc721signaturemint",
      contracts: "erc721signaturemint",
    },
    abis: [Xce],
    features: {},
  },
  O_ = {
    name: "ERC721Enumerable",
    namespace: "nft.query.owned",
    docLinks: {
      sdk: "sdk.erc721enumerable",
      contracts: "erc721enumerable",
    },
    abis: [yn, Zce],
    features: {},
  },
  F_ = {
    name: "ERC721AQueryable",
    namespace: "nft.query.owned",
    docLinks: {
      sdk: "",
      contracts: "",
    },
    abis: [Jce],
    features: {},
  },
  J0 = {
    name: "ERC721Supply",
    namespace: "nft.query",
    docLinks: {
      sdk: "sdk.erc721supply",
      contracts: "erc721supply",
    },
    abis: [yn, Qce],
    features: {
      [O_.name]: O_,
      [F_.name]: F_,
    },
  },
  C2 = {
    name: "ERC721SharedMetadata",
    namespace: "nft.sharedmetadata",
    docLinks: {
      sdk: "sdk.sharedmetadata",
      contracts: "SharedMetadata",
    },
    abis: [yn, tle],
    features: {},
  },
  vu = {
    name: "ERC721LoyaltyCard",
    namespace: "nft.loyaltyCard",
    docLinks: {
      sdk: "",
      contracts: "",
    },
    abis: [nle],
    features: {},
  },
  If = {
    name: "ERC721UpdatableMetadata",
    namespace: "nft.metadata",
    docLinks: {
      sdk: "",
      contracts: "",
    },
    abis: [yn, gF],
    features: {},
  },
  A2 = {
    name: "ERC721",
    namespace: "nft",
    docLinks: {
      sdk: "sdk.erc721",
      contracts: "erc721",
    },
    abis: [yn, YO],
    features: {
      [g2.name]: g2,
      [J0.name]: J0,
      [E2.name]: E2,
      [w2.name]: w2,
      [B7.name]: B7,
      [T2.name]: T2,
      [v2.name]: v2,
      [Yp.name]: Yp,
      [D_.name]: D_,
      [R7.name]: R7,
      [x2.name]: x2,
      [P7.name]: P7,
      [N7.name]: N7,
      [C2.name]: C2,
      [vu.name]: vu,
      [If.name]: If,
    },
  },
  que = [
    {
      inputs: [],
      name: "name",
      outputs: [
        {
          internalType: "string",
          name: "",
          type: "string",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "symbol",
      outputs: [
        {
          internalType: "string",
          name: "",
          type: "string",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  Vl = {
    name: "ERC1155Burnable",
    namespace: "edition.burn",
    docLinks: {
      sdk: "sdk.erc1155burnable",
      contracts: "erc1155burnable",
    },
    abis: [ti, ile],
    features: {},
  },
  D7 = {
    name: "ERC1155ClaimConditionsV1",
    namespace: "edition.drop.claim",
    docLinks: {
      sdk: "sdk.erc1155claimable",
      contracts: "erc1155dropsinglephase",
    },
    abis: [ti, cle],
    features: {},
  },
  k2 = {
    name: "ERC1155ClaimConditionsV2",
    namespace: "edition.drop.claim",
    docLinks: {
      sdk: "sdk.erc1155claimable",
      contracts: "erc1155claimconditions",
    },
    abis: [ti, ole],
    features: {},
  },
  O7 = {
    name: "ERC1155ClaimPhasesV2",
    namespace: "edition.drop.claim",
    docLinks: {
      sdk: "sdk.erc1155claimable",
      contracts: "erc1155claimphases",
    },
    abis: [ti, sle],
    features: {},
  },
  F7 = {
    name: "ERC1155ClaimPhasesV1",
    namespace: "edition.drop.claim",
    docLinks: {
      sdk: "sdk.erc1155claimable",
      contracts: "erc1155claimphases",
    },
    abis: [bF],
    features: {},
  },
  Xp = {
    name: "ERC1155ClaimCustom",
    namespace: "edition.drop.claim",
    docLinks: {
      sdk: "sdk.erc1155claimable",
      contracts: "erc1155claimcustom",
    },
    abis: [ti, ale],
    features: {},
  },
  Rf = {
    name: "ERC1155Revealable",
    namespace: "edition.drop.revealer",
    docLinks: {
      sdk: "sdk.drop.delayedreveal",
      contracts: "erc1155revealable",
    },
    abis: [ti, _v, mF],
    features: {},
  },
  S2 = {
    name: "ERC1155LazyMintableV2",
    namespace: "edition.drop",
    docLinks: {
      sdk: "sdk.erc1155droppable",
      contracts: "lazymint",
    },
    abis: [ti, _v],
    features: {
      [Rf.name]: Rf,
    },
  },
  L7 = {
    name: "ERC1155LazyMintableV1",
    namespace: "edition.drop",
    docLinks: {
      sdk: "sdk.erc1155droppable",
      contracts: "lazymint",
    },
    abis: [bF],
    features: {
      [F7.name]: F7,
    },
  },
  M2 = {
    name: "ERC1155SignatureMintable",
    namespace: "edition.signature",
    docLinks: {
      sdk: "sdk.erc1155signaturemintable",
      contracts: "erc1155signaturemint",
    },
    abis: [ti, fle],
    features: {},
  },
  I2 = {
    name: "ERC1155BatchMintable",
    namespace: "edition.mint.batch",
    docLinks: {
      sdk: "sdk.erc1155batchmintable",
      contracts: "erc1155batchmintable",
    },
    abis: [ti, vF, CE],
    features: {},
  },
  Kl = {
    name: "ERC1155Mintable",
    namespace: "edition.mint",
    docLinks: {
      sdk: "sdk.erc1155mintable",
      contracts: "erc1155mintable",
    },
    abis: [ti, vF],
    features: {
      [I2.name]: I2,
    },
  },
  Gl = {
    name: "ERC1155Enumerable",
    namespace: "edition.query",
    docLinks: {
      sdk: "sdk.erc1155",
      contracts: "erc1155enumerable",
    },
    abis: [ti, ule],
    features: {},
  },
  $7 = {
    name: "ERC1155UpdatableMetadata",
    namespace: "edition.metadata",
    docLinks: {
      sdk: "",
      contracts: "",
    },
    abis: [ti, gF],
    features: {},
  },
  L_ = {
    name: "ERC1155Supply",
    namespace: "edition.supply",
    docLinks: {
      sdk: "",
      contracts: "",
    },
    abis: [ti, lle],
    features: {},
  },
  R2 = {
    name: "ERC1155",
    namespace: "edition",
    docLinks: {
      sdk: "sdk.erc1155enumerable",
      contracts: "erc1155",
    },
    abis: [ti, XO, que],
    features: {
      [L_.name]: L_,
      [Vl.name]: Vl,
      [Gl.name]: Gl,
      [Kl.name]: Kl,
      [L7.name]: L7,
      [S2.name]: S2,
      [Rf.name]: Rf,
      [M2.name]: M2,
      [Xp.name]: Xp,
      [D7.name]: D7,
      [k2.name]: k2,
      [O7.name]: O7,
      [$7.name]: $7,
    },
  },
  $F = [
    {
      inputs: [],
      name: "getAllPlugins",
      outputs: [
        {
          components: [
            {
              internalType: "bytes4",
              name: "functionSelector",
              type: "bytes4",
            },
            {
              internalType: "string",
              name: "functionSignature",
              type: "string",
            },
            {
              internalType: "address",
              name: "pluginAddress",
              type: "address",
            },
          ],
          internalType: "struct IPluginMap.Plugin[]",
          name: "registered",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  UF = [
    {
      inputs: [],
      name: "getAllExtensions",
      outputs: [
        {
          components: [
            {
              components: [
                {
                  internalType: "string",
                  name: "name",
                  type: "string",
                },
                {
                  internalType: "string",
                  name: "metadataURI",
                  type: "string",
                },
                {
                  internalType: "address",
                  name: "implementation",
                  type: "address",
                },
              ],
              internalType: "struct IExtension.ExtensionMetadata",
              name: "metadata",
              type: "tuple",
            },
            {
              components: [
                {
                  internalType: "bytes4",
                  name: "functionSelector",
                  type: "bytes4",
                },
                {
                  internalType: "string",
                  name: "functionSignature",
                  type: "string",
                },
              ],
              internalType: "struct IExtension.ExtensionFunction[]",
              name: "functions",
              type: "tuple[]",
            },
          ],
          internalType: "struct IExtension.Extension[]",
          name: "allExtensions",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  P2 = {
    name: "Royalty",
    namespace: "royalty",
    docLinks: {
      sdk: "sdk.contractroyalty",
      contracts: "royalty",
    },
    abis: [Ele],
    features: {},
  },
  N2 = {
    name: "PrimarySale",
    namespace: "sales",
    docLinks: {
      sdk: "sdk.contractprimarysale",
      contracts: "primarysale",
    },
    abis: [_le],
    features: {},
  },
  B2 = {
    name: "PlatformFee",
    namespace: "platformFees",
    docLinks: {
      sdk: "sdk.platformfee",
      contracts: "platformfee",
    },
    abis: [wle],
    features: {},
  },
  U7 = {
    name: "PermissionsEnumerable",
    namespace: "roles",
    docLinks: {
      sdk: "sdk.contractroles",
      contracts: "permissionsenumerable",
    },
    abis: [xle],
    features: {},
  },
  D2 = {
    name: "Permissions",
    namespace: "roles",
    docLinks: {
      sdk: "sdk.contractroles",
      contracts: "permissions",
    },
    abis: [vle],
    features: {
      [U7.name]: U7,
    },
  },
  O2 = {
    name: "ContractMetadata",
    namespace: "metadata",
    docLinks: {
      sdk: "sdk.contractmetadata",
      contracts: "contractmetadata",
    },
    abis: [ple],
    features: {},
  },
  F2 = {
    name: "AppURI",
    namespace: "appURI",
    docLinks: {
      sdk: "sdk.appURI",
      contracts: "",
    },
    abis: [hle],
    features: {},
  },
  L2 = {
    name: "Ownable",
    namespace: "owner",
    docLinks: {
      sdk: "sdk.owner",
      contracts: "ownable",
    },
    abis: [Tle],
    features: {},
  },
  W7 = {
    name: "Gasless",
    namespace: "gasless",
    docLinks: {
      sdk: "sdk.gaslesstransaction",
      contracts: "IERC2771Context",
    },
    abis: [dle],
    features: {},
  },
  j7 = {
    name: "PackVRF",
    namespace: "pack.vrf",
    docLinks: {
      sdk: "sdk.packvrf",
      contracts: "IPackVRF",
    },
    abis: [ble],
    features: {},
  },
  H7 = {
    name: "PluginRouter",
    namespace: "plugin.router",
    docLinks: {
      sdk: "sdk.pluginrouter",
      contracts: "PluginRouter",
    },
    abis: [$F],
    features: {},
  },
  em = {
    name: "DynamicContract",
    namespace: "dynamic.contract",
    docLinks: {
      sdk: "",
      contracts: "IExtensionsManager",
    },
    abis: [UF],
    features: {},
  },
  $2 = {
    name: "DirectListings",
    namespace: "direct.listings",
    docLinks: {
      sdk: "",
      contracts: "IDirectListings",
    },
    abis: [mle],
    features: {},
  },
  U2 = {
    name: "EnglishAuctions",
    namespace: "english.auctions",
    docLinks: {
      sdk: "",
      contracts: "IEnglishAuctions",
    },
    abis: [yle],
    features: {},
  },
  W2 = {
    name: "Offers",
    namespace: "offers",
    docLinks: {
      sdk: "",
      contracts: "IOffers",
    },
    abis: [gle],
    features: {},
  },
  tm = {
    name: "AccountFactory",
    namespace: "accountFactory",
    docLinks: {
      sdk: "sdk.accountFactory",
      contracts: "IAccountFactory",
    },
    abis: [Sle],
    features: {},
  },
  si = {
    name: "AccountPermissions",
    namespace: "accountPermissions",
    docLinks: {
      sdk: "sdk.account",
      contracts: "IAccountPermissions",
    },
    abis: [Mle],
    features: {},
  },
  rm = {
    name: "Account",
    namespace: "account",
    docLinks: {
      sdk: "sdk.account",
      contracts: "IAccount",
    },
    abis: [Ile],
    features: {
      [si.name]: si,
    },
  },
  j2 = {
    name: "AirdropERC20",
    namespace: "airdrop20",
    docLinks: {
      sdk: "",
      contracts: "IAirdropERC20",
    },
    abis: [Cle],
    features: {},
  },
  H2 = {
    name: "AirdropERC721",
    namespace: "airdrop721",
    docLinks: {
      sdk: "",
      contracts: "IAirdropERC721",
    },
    abis: [Ale],
    features: {},
  },
  z2 = {
    name: "AirdropERC1155",
    namespace: "airdrop1155",
    docLinks: {
      sdk: "",
      contracts: "IAirdropERC1155",
    },
    abis: [kle],
    features: {},
  },
  WF = {
    [y2.name]: y2,
    [A2.name]: A2,
    [R2.name]: R2,
    [P2.name]: P2,
    [B2.name]: B2,
    [N2.name]: N2,
    [D2.name]: D2,
    [O2.name]: O2,
    [F2.name]: F2,
    [L2.name]: L2,
    [W7.name]: W7,
    [j7.name]: j7,
    [H7.name]: H7,
    [em.name]: em,
    [$2.name]: $2,
    [U2.name]: U2,
    [W2.name]: W2,
    [j2.name]: j2,
    [H2.name]: H2,
    [z2.name]: z2,
    [tm.name]: tm,
    [rm.name]: rm,
    [vu.name]: vu,
    [If.name]: If,
  };
function $_(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
    r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1,
    n = t.type,
    i = !1;
  return (
    n.endsWith("[]") && ((i = !0), (n = n.slice(0, -2))),
    n.startsWith("bytes") && (n = "BytesLike"),
    (n.startsWith("uint") || n.startsWith("int")) &&
      (n = e ? "BigNumber" : "BigNumberish"),
    n.startsWith("bool") && (n = "boolean"),
    n === "address" && (n = "string"),
    n === "tuple" &&
      t.components &&
      (n = `{ ${t.components.map((a) => $_(a, !1, !0)).join(", ")} }`),
    i && (n += "[]"),
    r && (n = `${t.name}: ${n}`),
    n
  );
}
function jF(t, e, r) {
  var n, i, a, s, o, c, u, d, m, v;
  return (
    ((o =
      (s =
        (i =
          (n = e == null ? void 0 : e.output) == null ? void 0 : n.userdoc) ==
        null
          ? void 0
          : i[r]) == null
        ? void 0
        : s[
            Object.keys(
              ((a = e == null ? void 0 : e.output) == null
                ? void 0
                : a.userdoc[r]) || {}
            ).find((E) => E.includes(t || "unknown")) || ""
          ]) == null
      ? void 0
      : o.notice) ||
    ((v =
      (m =
        (u = (c = e == null ? void 0 : e.output) == null ? void 0 : c.devdoc) ==
        null
          ? void 0
          : u[r]) == null
        ? void 0
        : m[
            Object.keys(
              ((d = e == null ? void 0 : e.output) == null
                ? void 0
                : d.devdoc[r]) || {}
            ).find((E) => E.includes(t || "unknown")) || ""
          ]) == null
      ? void 0
      : v.details)
  );
}
function Pf(t, e) {
  var i, a, s, o;
  const r = (t || []).filter((c) => c.type === "function"),
    n = [];
  for (const c of r) {
    const u = jF(c.name, e, "methods"),
      d =
        ((a =
          (i = c.inputs) == null
            ? void 0
            : i.map((I) => `${I.name || "key"}: ${$_(I)}`)) == null
          ? void 0
          : a.join(", ")) || "",
      m = d ? `, [${d}]` : "",
      v =
        (o = (s = c.outputs) == null ? void 0 : s.map((I) => $_(I, !0))) == null
          ? void 0
          : o.join(", "),
      E = v ? `: Promise<${v}>` : ": Promise<TransactionResult>",
      A = `contract.call("${c.name}"${m})${E}`;
    n.push({
      inputs: c.inputs || [],
      outputs: c.outputs || [],
      name: c.name || "unknown",
      signature: A,
      stateMutability: c.stateMutability || "",
      comment: u,
    });
  }
  return n;
}
function Vue(t, e) {
  const r = Pf(t),
    n = e.flatMap((a) => Pf(a));
  return (
    r.filter(
      (a) =>
        n.find(
          (o) =>
            o.name === a.name &&
            o.inputs.length === a.inputs.length &&
            o.inputs.every((c, u) => {
              var d;
              return c.type === "tuple" || c.type === "tuple[]"
                ? c.type === a.inputs[u].type &&
                    ((d = c.components) == null
                      ? void 0
                      : d.every((m, v) => {
                          var E, A;
                          return (
                            m.type ===
                            ((A =
                              (E = a.inputs[u].components) == null
                                ? void 0
                                : E[v]) == null
                              ? void 0
                              : A.type)
                          );
                        }))
                : c.type === a.inputs[u].type;
            })
        ) !== void 0
    ).length === n.length
  );
}
function Kue(t, e) {
  const n = e
    .map((a) => new oa.Interface(a))
    .flatMap((a) =>
      Object.values(a.functions).map((s) =>
        Number(a.getSighash(s)).toString(16)
      )
    );
  return [...new Set(n)].every((a) => t.includes(a));
}
function DE(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : WF;
  const r = {};
  for (const n in e) {
    const i = e[n],
      a = Gue(t, i),
      s = DE(t, i.features);
    r[n] = {
      ...i,
      features: s,
      enabled: a,
    };
  }
  return r;
}
function HF(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : WF;
  const r = {};
  for (const n in e) {
    const i = e[n],
      a = Kue(t, i.abis),
      s = HF(t, i.features);
    r[n] = {
      ...i,
      features: s,
      enabled: a,
    };
  }
  return r;
}
function Gue(t, e) {
  return Vue(t, e.abis);
}
function xu(t, e) {
  const r = DE(t);
  return zF(r, e);
}
function Zue(t, e) {
  return xu(t, e);
}
function zF(t, e) {
  const r = Object.keys(t);
  if (!r.includes(e)) {
    let i = !1;
    for (const a of r) {
      const s = t[a];
      if (((i = zF(s.features, e)), i)) break;
    }
    return i;
  }
  return t[e].enabled;
}
function Qe(t, e) {
  return Zue(Gt.parse(t.abi), e);
}
function Kr(t, e) {
  return t in e.readContract.functions;
}
let U_;
try {
  U_ = new TextDecoder();
} catch {}
let st,
  iu,
  He = 0;
const Jue = 105,
  Que = 57342,
  Yue = 57343,
  z7 = 57337,
  q7 = 6,
  Xu = {};
let Bt = {},
  nn,
  q2,
  V2 = 0,
  nm = 0,
  An,
  us,
  Qr = [],
  W_ = [],
  Li,
  wi,
  Eh,
  V7 = {
    useRecords: !1,
    mapsAsObjects: !0,
  },
  j_ = !1;
class K2 {
  constructor(e) {
    if (
      e &&
      ((e.keyMap || e._keyMap) &&
        !e.useRecords &&
        ((e.useRecords = !1), (e.mapsAsObjects = !0)),
      e.useRecords === !1 &&
        e.mapsAsObjects === void 0 &&
        (e.mapsAsObjects = !0),
      e.getStructures && (e.getShared = e.getStructures),
      e.getShared && !e.structures && ((e.structures = []).uninitialized = !0),
      e.keyMap)
    ) {
      this.mapKey = new Map();
      for (let [r, n] of Object.entries(e.keyMap)) this.mapKey.set(n, r);
    }
    Object.assign(this, e);
  }
  decodeKey(e) {
    return (this.keyMap && this.mapKey.get(e)) || e;
  }
  decode(e, r) {
    if (st)
      return GF(
        () => (
          ZF(), this ? this.decode(e, r) : K2.prototype.decode.call(V7, e, r)
        )
      );
    (iu = r > -1 ? r : e.length),
      (He = 0),
      (nm = 0),
      (q2 = null),
      (An = null),
      (st = e);
    try {
      wi =
        e.dataView ||
        (e.dataView = new DataView(e.buffer, e.byteOffset, e.byteLength));
    } catch (n) {
      throw (
        ((st = null),
        e instanceof Uint8Array
          ? n
          : new Error(
              "Source must be a Uint8Array or Buffer but was a " +
                (e && typeof e == "object" ? e.constructor.name : typeof e)
            ))
      );
    }
    if (this instanceof K2) {
      if (
        ((Bt = this),
        (Li =
          this.sharedValues &&
          (this.pack
            ? new Array(this.maxPrivatePackedValues || 16).concat(
                this.sharedValues
              )
            : this.sharedValues)),
        this.structures)
      )
        return (nn = this.structures), K7();
      (!nn || nn.length > 0) && (nn = []);
    } else (Bt = V7), (!nn || nn.length > 0) && (nn = []), (Li = null);
    return K7();
  }
}
function K7() {
  try {
    let t = Kt();
    if (An) {
      if (He >= An.postBundlePosition) {
        let e = new Error("Unexpected bundle position");
        throw ((e.incomplete = !0), e);
      }
      (He = An.postBundlePosition), (An = null);
    }
    if (He == iu) (nn = null), (st = null), us && (us = null);
    else if (He > iu) {
      let e = new Error("Unexpected end of CBOR data");
      throw ((e.incomplete = !0), e);
    } else if (!j_) throw new Error("Data read, but end of buffer not reached");
    return t;
  } catch (t) {
    throw (
      (ZF(),
      (t instanceof RangeError ||
        t.message.startsWith("Unexpected end of buffer")) &&
        (t.incomplete = !0),
      t)
    );
  }
}
function Kt() {
  let t = st[He++],
    e = t >> 5;
  if (((t = t & 31), t > 23))
    switch (t) {
      case 24:
        t = st[He++];
        break;
      case 25:
        if (e == 7) return r0e();
        (t = wi.getUint16(He)), (He += 2);
        break;
      case 26:
        if (e == 7) {
          let r = wi.getFloat32(He);
          if (Bt.useFloat32 > 2) {
            let n = JF[((st[He] & 127) << 1) | (st[He + 1] >> 7)];
            return (He += 4), ((n * r + (r > 0 ? 0.5 : -0.5)) >> 0) / n;
          }
          return (He += 4), r;
        }
        (t = wi.getUint32(He)), (He += 4);
        break;
      case 27:
        if (e == 7) {
          let r = wi.getFloat64(He);
          return (He += 8), r;
        }
        if (e > 1) {
          if (wi.getUint32(He) > 0)
            throw new Error(
              "JavaScript does not support arrays, maps, or strings with length over 4294967295"
            );
          t = wi.getUint32(He + 4);
        } else
          Bt.int64AsNumber
            ? ((t = wi.getUint32(He) * 4294967296), (t += wi.getUint32(He + 4)))
            : (t = wi.getBigUint64(He));
        He += 8;
        break;
      case 31:
        switch (e) {
          case 2:
          case 3:
            throw new Error(
              "Indefinite length not supported for byte or text strings"
            );
          case 4:
            let r = [],
              n,
              i = 0;
            for (; (n = Kt()) != Xu; ) r[i++] = n;
            return e == 4 ? r : e == 3 ? r.join("") : Buffer.concat(r);
          case 5:
            let a;
            if (Bt.mapsAsObjects) {
              let s = {};
              if (Bt.keyMap)
                for (; (a = Kt()) != Xu; ) s[Ks(Bt.decodeKey(a))] = Kt();
              else for (; (a = Kt()) != Xu; ) s[Ks(a)] = Kt();
              return s;
            } else {
              Eh && ((Bt.mapsAsObjects = !0), (Eh = !1));
              let s = new Map();
              if (Bt.keyMap)
                for (; (a = Kt()) != Xu; ) s.set(Bt.decodeKey(a), Kt());
              else for (; (a = Kt()) != Xu; ) s.set(a, Kt());
              return s;
            }
          case 7:
            return Xu;
          default:
            throw new Error("Invalid major type for indefinite length " + e);
        }
      default:
        throw new Error("Unknown token " + t);
    }
  switch (e) {
    case 0:
      return t;
    case 1:
      return ~t;
    case 2:
      return t0e(t);
    case 3:
      if (nm >= He) return q2.slice(He - V2, (He += t) - V2);
      if (nm == 0 && iu < 140 && t < 32) {
        let i = t < 16 ? qF(t) : e0e(t);
        if (i != null) return i;
      }
      return Xue(t);
    case 4:
      let r = new Array(t);
      for (let i = 0; i < t; i++) r[i] = Kt();
      return r;
    case 5:
      if (Bt.mapsAsObjects) {
        let i = {};
        if (Bt.keyMap)
          for (let a = 0; a < t; a++) i[Ks(Bt.decodeKey(Kt()))] = Kt();
        else for (let a = 0; a < t; a++) i[Ks(Kt())] = Kt();
        return i;
      } else {
        Eh && ((Bt.mapsAsObjects = !0), (Eh = !1));
        let i = new Map();
        if (Bt.keyMap)
          for (let a = 0; a < t; a++) i.set(Bt.decodeKey(Kt()), Kt());
        else for (let a = 0; a < t; a++) i.set(Kt(), Kt());
        return i;
      }
    case 6:
      if (t >= z7) {
        let i = nn[t & 8191];
        if (i) return i.read || (i.read = H_(i)), i.read();
        if (t < 65536) {
          if (t == Yue) return q_(Kt());
          if (t == Que) {
            let a = Th(),
              s = Kt();
            for (let o = 2; o < a; o++) q_([s++, Kt()]);
            return Kt();
          } else if (t == z7) return c0e();
          if (Bt.getShared && (OE(), (i = nn[t & 8191]), i))
            return i.read || (i.read = H_(i)), i.read();
        }
      }
      let n = Qr[t];
      if (n) return n.handlesRead ? n(Kt) : n(Kt());
      {
        let i = Kt();
        for (let a = 0; a < W_.length; a++) {
          let s = W_[a](t, i);
          if (s !== void 0) return s;
        }
        return new Cv(i, t);
      }
    case 7:
      switch (t) {
        case 20:
          return !1;
        case 21:
          return !0;
        case 22:
          return null;
        case 23:
          return;
        case 31:
        default:
          let i = (Li || Dl())[t];
          if (i !== void 0) return i;
          throw new Error("Unknown token " + t);
      }
    default:
      if (isNaN(t)) {
        let i = new Error("Unexpected end of CBOR data");
        throw ((i.incomplete = !0), i);
      }
      throw new Error("Unknown CBOR token " + t);
  }
}
const G7 = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;
function H_(t) {
  function e() {
    let r = st[He++];
    if (((r = r & 31), r > 23))
      switch (r) {
        case 24:
          r = st[He++];
          break;
        case 25:
          (r = wi.getUint16(He)), (He += 2);
          break;
        case 26:
          (r = wi.getUint32(He)), (He += 4);
          break;
        default:
          throw new Error("Expected array header, but got " + st[He - 1]);
      }
    let n = this.compiledReader;
    for (; n; ) {
      if (n.propertyCount === r) return n(Kt);
      n = n.next;
    }
    if (this.slowReads++ >= 3) {
      let a = this.length == r ? this : this.slice(0, r);
      return (
        (n = Bt.keyMap
          ? new Function(
              "r",
              "return {" +
                a
                  .map((s) => Bt.decodeKey(s))
                  .map((s) =>
                    G7.test(s)
                      ? Ks(s) + ":r()"
                      : "[" + JSON.stringify(s) + "]:r()"
                  )
                  .join(",") +
                "}"
            )
          : new Function(
              "r",
              "return {" +
                a
                  .map((s) =>
                    G7.test(s)
                      ? Ks(s) + ":r()"
                      : "[" + JSON.stringify(s) + "]:r()"
                  )
                  .join(",") +
                "}"
            )),
        this.compiledReader && (n.next = this.compiledReader),
        (n.propertyCount = r),
        (this.compiledReader = n),
        n(Kt)
      );
    }
    let i = {};
    if (Bt.keyMap)
      for (let a = 0; a < r; a++) i[Ks(Bt.decodeKey(this[a]))] = Kt();
    else for (let a = 0; a < r; a++) i[Ks(this[a])] = Kt();
    return i;
  }
  return (t.slowReads = 0), e;
}
function Ks(t) {
  return t === "__proto__" ? "__proto_" : t;
}
let Xue = z_;
function z_(t) {
  let e;
  if (t < 16 && (e = qF(t))) return e;
  if (t > 64 && U_) return U_.decode(st.subarray(He, (He += t)));
  const r = He + t,
    n = [];
  for (e = ""; He < r; ) {
    const i = st[He++];
    if (!(i & 128)) n.push(i);
    else if ((i & 224) === 192) {
      const a = st[He++] & 63;
      n.push(((i & 31) << 6) | a);
    } else if ((i & 240) === 224) {
      const a = st[He++] & 63,
        s = st[He++] & 63;
      n.push(((i & 31) << 12) | (a << 6) | s);
    } else if ((i & 248) === 240) {
      const a = st[He++] & 63,
        s = st[He++] & 63,
        o = st[He++] & 63;
      let c = ((i & 7) << 18) | (a << 12) | (s << 6) | o;
      c > 65535 &&
        ((c -= 65536),
        n.push(((c >>> 10) & 1023) | 55296),
        (c = 56320 | (c & 1023))),
        n.push(c);
    } else n.push(i);
    n.length >= 4096 && ((e += Mn.apply(String, n)), (n.length = 0));
  }
  return n.length > 0 && (e += Mn.apply(String, n)), e;
}
let Mn = String.fromCharCode;
function e0e(t) {
  let e = He,
    r = new Array(t);
  for (let n = 0; n < t; n++) {
    const i = st[He++];
    if ((i & 128) > 0) {
      He = e;
      return;
    }
    r[n] = i;
  }
  return Mn.apply(String, r);
}
function qF(t) {
  if (t < 4)
    if (t < 2) {
      if (t === 0) return "";
      {
        let e = st[He++];
        if ((e & 128) > 1) {
          He -= 1;
          return;
        }
        return Mn(e);
      }
    } else {
      let e = st[He++],
        r = st[He++];
      if ((e & 128) > 0 || (r & 128) > 0) {
        He -= 2;
        return;
      }
      if (t < 3) return Mn(e, r);
      let n = st[He++];
      if ((n & 128) > 0) {
        He -= 3;
        return;
      }
      return Mn(e, r, n);
    }
  else {
    let e = st[He++],
      r = st[He++],
      n = st[He++],
      i = st[He++];
    if ((e & 128) > 0 || (r & 128) > 0 || (n & 128) > 0 || (i & 128) > 0) {
      He -= 4;
      return;
    }
    if (t < 6) {
      if (t === 4) return Mn(e, r, n, i);
      {
        let a = st[He++];
        if ((a & 128) > 0) {
          He -= 5;
          return;
        }
        return Mn(e, r, n, i, a);
      }
    } else if (t < 8) {
      let a = st[He++],
        s = st[He++];
      if ((a & 128) > 0 || (s & 128) > 0) {
        He -= 6;
        return;
      }
      if (t < 7) return Mn(e, r, n, i, a, s);
      let o = st[He++];
      if ((o & 128) > 0) {
        He -= 7;
        return;
      }
      return Mn(e, r, n, i, a, s, o);
    } else {
      let a = st[He++],
        s = st[He++],
        o = st[He++],
        c = st[He++];
      if ((a & 128) > 0 || (s & 128) > 0 || (o & 128) > 0 || (c & 128) > 0) {
        He -= 8;
        return;
      }
      if (t < 10) {
        if (t === 8) return Mn(e, r, n, i, a, s, o, c);
        {
          let u = st[He++];
          if ((u & 128) > 0) {
            He -= 9;
            return;
          }
          return Mn(e, r, n, i, a, s, o, c, u);
        }
      } else if (t < 12) {
        let u = st[He++],
          d = st[He++];
        if ((u & 128) > 0 || (d & 128) > 0) {
          He -= 10;
          return;
        }
        if (t < 11) return Mn(e, r, n, i, a, s, o, c, u, d);
        let m = st[He++];
        if ((m & 128) > 0) {
          He -= 11;
          return;
        }
        return Mn(e, r, n, i, a, s, o, c, u, d, m);
      } else {
        let u = st[He++],
          d = st[He++],
          m = st[He++],
          v = st[He++];
        if ((u & 128) > 0 || (d & 128) > 0 || (m & 128) > 0 || (v & 128) > 0) {
          He -= 12;
          return;
        }
        if (t < 14) {
          if (t === 12) return Mn(e, r, n, i, a, s, o, c, u, d, m, v);
          {
            let E = st[He++];
            if ((E & 128) > 0) {
              He -= 13;
              return;
            }
            return Mn(e, r, n, i, a, s, o, c, u, d, m, v, E);
          }
        } else {
          let E = st[He++],
            A = st[He++];
          if ((E & 128) > 0 || (A & 128) > 0) {
            He -= 14;
            return;
          }
          if (t < 15) return Mn(e, r, n, i, a, s, o, c, u, d, m, v, E, A);
          let I = st[He++];
          if ((I & 128) > 0) {
            He -= 15;
            return;
          }
          return Mn(e, r, n, i, a, s, o, c, u, d, m, v, E, A, I);
        }
      }
    }
  }
}
function t0e(t) {
  return Bt.copyBuffers
    ? Uint8Array.prototype.slice.call(st, He, (He += t))
    : st.subarray(He, (He += t));
}
let VF = new Float32Array(1),
  cy = new Uint8Array(VF.buffer, 0, 4);
function r0e() {
  let t = st[He++],
    e = st[He++],
    r = (t & 127) >> 2;
  if (r === 31) return e || t & 3 ? NaN : t & 128 ? -1 / 0 : 1 / 0;
  if (r === 0) {
    let n = (((t & 3) << 8) | e) / 16777216;
    return t & 128 ? -n : n;
  }
  return (
    (cy[3] = (t & 128) | ((r >> 1) + 56)),
    (cy[2] = ((t & 7) << 5) | (e >> 3)),
    (cy[1] = e << 5),
    (cy[0] = 0),
    VF[0]
  );
}
class Cv {
  constructor(e, r) {
    (this.value = e), (this.tag = r);
  }
}
Qr[0] = (t) => new Date(t);
Qr[1] = (t) => new Date(Math.round(t * 1e3));
Qr[2] = (t) => {
  let e = BigInt(0);
  for (let r = 0, n = t.byteLength; r < n; r++)
    e = (BigInt(t[r]) + e) << BigInt(8);
  return e;
};
Qr[3] = (t) => BigInt(-1) - Qr[2](t);
Qr[4] = (t) => +(t[1] + "e" + t[0]);
Qr[5] = (t) => t[1] * Math.exp(t[0] * Math.log(2));
const q_ = (t) => {
  let e = t[0] - 57344,
    r = t[1],
    n = nn[e];
  n &&
    n.isShared &&
    ((nn.restoreStructures || (nn.restoreStructures = []))[e] = n),
    (nn[e] = r),
    (r.read = H_(r));
  let i = {};
  if (Bt.keyMap)
    for (let a = 2, s = t.length; a < s; a++) {
      let o = Bt.decodeKey(r[a - 2]);
      i[Ks(o)] = t[a];
    }
  else
    for (let a = 2, s = t.length; a < s; a++) {
      let o = r[a - 2];
      i[Ks(o)] = t[a];
    }
  return i;
};
Qr[Jue] = q_;
Qr[14] = (t) =>
  An ? An[0].slice(An.position0, (An.position0 += t)) : new Cv(t, 14);
Qr[15] = (t) =>
  An ? An[1].slice(An.position1, (An.position1 += t)) : new Cv(t, 15);
let n0e = {
  Error,
  RegExp,
};
Qr[27] = (t) => (n0e[t[0]] || Error)(t[1], t[2]);
const KF = (t) => {
  if (st[He++] != 132)
    throw new Error(
      "Packed values structure must be followed by a 4 element array"
    );
  let e = t();
  return (
    (Li = Li ? e.concat(Li.slice(e.length)) : e),
    (Li.prefixes = t()),
    (Li.suffixes = t()),
    t()
  );
};
KF.handlesRead = !0;
Qr[51] = KF;
Qr[q7] = (t) => {
  if (!Li)
    if (Bt.getShared) OE();
    else return new Cv(t, q7);
  if (typeof t == "number") return Li[16 + (t >= 0 ? 2 * t : -2 * t - 1)];
  throw new Error("No support for non-integer packed references yet");
};
Qr[25] = (t) => stringRefs[t];
Qr[256] = (t) => {
  stringRefs = [];
  try {
    return t();
  } finally {
    stringRefs = null;
  }
};
Qr[256].handlesRead = !0;
Qr[28] = (t) => {
  us || ((us = new Map()), (us.id = 0));
  let e = us.id++,
    r = st[He],
    n;
  r >> 5 == 4 ? (n = []) : (n = {});
  let i = {
    target: n,
  };
  us.set(e, i);
  let a = t();
  return i.used ? Object.assign(n, a) : ((i.target = a), a);
};
Qr[28].handlesRead = !0;
Qr[29] = (t) => {
  let e = us.get(t);
  return (e.used = !0), e.target;
};
Qr[258] = (t) => new Set(t);
(Qr[259] = (t) => (
  Bt.mapsAsObjects && ((Bt.mapsAsObjects = !1), (Eh = !0)), t()
)).handlesRead = !0;
function e0(t, e) {
  return typeof t == "string"
    ? t + e
    : t instanceof Array
    ? t.concat(e)
    : Object.assign({}, t, e);
}
function Dl() {
  if (!Li)
    if (Bt.getShared) OE();
    else throw new Error("No packed values available");
  return Li;
}
const i0e = 1399353956;
W_.push((t, e) => {
  if (t >= 225 && t <= 255) return e0(Dl().prefixes[t - 224], e);
  if (t >= 28704 && t <= 32767) return e0(Dl().prefixes[t - 28672], e);
  if (t >= 1879052288 && t <= 2147483647)
    return e0(Dl().prefixes[t - 1879048192], e);
  if (t >= 216 && t <= 223) return e0(e, Dl().suffixes[t - 216]);
  if (t >= 27647 && t <= 28671) return e0(e, Dl().suffixes[t - 27639]);
  if (t >= 1811940352 && t <= 1879048191)
    return e0(e, Dl().suffixes[t - 1811939328]);
  if (t == i0e)
    return {
      packedValues: Li,
      structures: nn.slice(0),
      version: e,
    };
  if (t == 55799) return e;
});
const a0e = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1,
  Z7 = [Uint8Array],
  s0e = [64];
for (let t = 0; t < Z7.length; t++) o0e(Z7[t], s0e[t]);
function o0e(t, e) {
  let r = "get" + t.name.slice(0, -5);
  typeof t != "function" && (t = null);
  let n = t.BYTES_PER_ELEMENT;
  for (let i = 0; i < 2; i++) {
    if (!i && n == 1) continue;
    let a = n == 2 ? 1 : n == 4 ? 2 : 3;
    Qr[i ? e : e - 4] =
      n == 1 || i == a0e
        ? (s) => {
            if (!t) throw new Error("Could not find typed array for code " + e);
            return new t(Uint8Array.prototype.slice.call(s, 0).buffer);
          }
        : (s) => {
            if (!t) throw new Error("Could not find typed array for code " + e);
            let o = new DataView(s.buffer, s.byteOffset, s.byteLength),
              c = s.length >> a,
              u = new t(c),
              d = o[r];
            for (let m = 0; m < c; m++) u[m] = d.call(o, m << a, i);
            return u;
          };
  }
}
function c0e() {
  let t = Th(),
    e = He + Kt();
  for (let n = 2; n < t; n++) {
    let i = Th();
    He += i;
  }
  let r = He;
  return (
    (He = e),
    (An = [z_(Th()), z_(Th())]),
    (An.position0 = 0),
    (An.position1 = 0),
    (An.postBundlePosition = He),
    (He = r),
    Kt()
  );
}
function Th() {
  let t = st[He++] & 31;
  if (t > 23)
    switch (t) {
      case 24:
        t = st[He++];
        break;
      case 25:
        (t = wi.getUint16(He)), (He += 2);
        break;
      case 26:
        (t = wi.getUint32(He)), (He += 4);
        break;
    }
  return t;
}
function OE() {
  if (Bt.getShared) {
    let t = GF(() => ((st = null), Bt.getShared())) || {},
      e = t.structures || [];
    (Bt.sharedVersion = t.version),
      (Li = Bt.sharedValues = t.packedValues),
      nn === !0
        ? (Bt.structures = nn = e)
        : nn.splice.apply(nn, [0, e.length].concat(e));
  }
}
function GF(t) {
  let e = iu,
    r = He,
    n = V2,
    i = nm,
    a = q2,
    s = us,
    o = An,
    c = new Uint8Array(st.slice(0, iu)),
    u = nn,
    d = Bt,
    m = j_,
    v = t();
  return (
    (iu = e),
    (He = r),
    (V2 = n),
    (nm = i),
    (q2 = a),
    (us = s),
    (An = o),
    (st = c),
    (j_ = m),
    (nn = u),
    (Bt = d),
    (wi = new DataView(st.buffer, st.byteOffset, st.byteLength)),
    v
  );
}
function ZF() {
  (st = null), (us = null), (nn = null);
}
const JF = new Array(147);
for (let t = 0; t < 256; t++) JF[t] = +("1e" + Math.floor(45.15 - t * 0.30103));
const l0e = new K2({
    useRecords: !1,
  }),
  u0e = l0e.decode;
function f0e(t) {
  if (((t = t.toString(16)), t.startsWith("0x") || (t = `0x${t}`), !d0e(t)))
    throw new Error(`Given value "${t}" is not a valid hex string.`);
  t = t.replace(/^0x/i, "");
  const e = [];
  for (let r = 0; r < t.length; r += 2) e.push(parseInt(t.slice(r, r + 2), 16));
  return e;
}
function d0e(t) {
  return (
    (typeof t == "string" || typeof t == "number") &&
    /^(-)?0x[0-9a-f]*$/i.test(t.toString())
  );
}
function QF(t) {
  const e = f0e(t),
    r = e[e.length - 2] * 256 + e[e.length - 1],
    n = Uint8Array.from(e.slice(e.length - 2 - r, -2)),
    i = u0e(n);
  if ("ipfs" in i && i.ipfs)
    try {
      return `ipfs://${Wce.encode(i.ipfs)}`;
    } catch (a) {
      console.warn("feature-detection ipfs cbor failed", a);
    }
}
function h0e(t) {
  if (t.startsWith("0x363d3d373d3d3d363d73")) return `0x${t.slice(22, 62)}`;
  if (t.startsWith("0x36603057343d5230")) return `0x${t.slice(122, 162)}`;
  if (t.startsWith("0x3d3d3d3d363d3d37363d73")) return `0x${t.slice(24, 64)}`;
  if (t.startsWith("0x366000600037611000600036600073"))
    return `0x${t.slice(32, 72)}`;
}
async function YF(t, e) {
  const { bytecode: r } = await G2(t, e);
  return QF(r);
}
async function p0e(t, e) {
  const { bytecode: r } = await G2(t, e);
  return {
    uri: QF(r),
    bytecode: r,
  };
}
async function G2(t, e) {
  let r;
  try {
    r = await e.getCode(t);
  } catch (n) {
    throw new Error(`Failed to get bytecode for address ${t}: ${n}`);
  }
  if (r === "0x") {
    const n = await e.getNetwork();
    throw new Error(
      `Contract at ${t} does not exist on chain '${n.name}' (chainId: ${n.chainId})`
    );
  }
  try {
    const n = h0e(r);
    if (n) return await G2(n, e);
  } catch {}
  try {
    const i = `0x${(
      await e.getStorageAt(
        t,
        ae.from(
          "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc"
        )
      )
    ).slice(-40)}`;
    if (ud(i) && i !== Ft) return await G2(i, e);
  } catch {}
  if (!r) throw new Error(`Error fetching bytecode for ${t}`);
  return {
    address: t,
    bytecode: r,
  };
}
const m0e = 2;
async function FE(t, e) {
  const r = await e.downloadJSON(t, {
    timeoutInSeconds: m0e,
  });
  if (!r || !r.output)
    throw new Error(`Could not resolve metadata for contract at ${t}`);
  const n = Gt.parse(r.output.abi),
    i = r.settings.compilationTarget,
    a = Object.keys(i),
    s = i[a[0]],
    o = FF.parse({
      title: r.output.devdoc.title,
      author: r.output.devdoc.author,
      details: r.output.devdoc.detail,
      notice: r.output.userdoc.notice,
    }),
    c = [
      ...new Set(
        Object.entries(r.sources).map((u) => {
          let [, d] = u;
          return d.license;
        })
      ),
    ];
  return {
    name: s,
    abi: n,
    metadata: r,
    info: o,
    licenses: c,
  };
}
function im(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  return typeof process < "u" && x7[t] ? x7[t] : e;
}
const y0e = "0xcdAD8FA86e18538aC207872E8ff3536501431B73";
function V_() {
  return im("multiChainRegistryAddress", y0e);
}
const g0e = () => !0,
  XF = () => !g0e();
function b0e(t, e) {
  if (t.length === 0 || t.length === 1 || !e) return t;
  for (let r = 0; r < t.length; r++)
    for (let n = r + 1; n < t.length; n++) e(t[r], t[n]) && t.splice(n, 1);
  return t;
}
function Nf(t) {
  const e = t.map((i) => Gt.parse(i)).flat(),
    n = b0e(
      e,
      (i, a) =>
        i.name === a.name &&
        i.type === a.type &&
        i.inputs.length === a.inputs.length
    ).filter((i) => i.type !== "constructor");
  return Gt.parse(n);
}
function LE(t, e) {
  if (t)
    for (const r in t) {
      const n = t[r];
      n.enabled && e.push(n), LE(n.features, e);
    }
}
function v0e(t) {
  const e = [];
  return LE(HF(t), e), e;
}
function x0e(t) {
  let e = v0e(t);
  return (
    e.find((n) => n.name === "ERC721") &&
      (e = e.filter((n) => n.name !== "ERC20")),
    Nf(e.map((n) => Nf(n.abis)))
  );
}
const eL = {};
let Z3;
function tL(t, e) {
  return `${t}-${e}`;
}
function w0e(t, e, r) {
  eL[tL(t, e)] = r;
}
function _0e(t, e) {
  return eL[tL(t, e)];
}
async function Ai(t, e, r) {
  let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  const i = (await e.getNetwork()).chainId,
    a = _0e(t, i);
  if (a) return a;
  let s;
  const [o, c] = await Promise.all([
      p0e(t, e).catch(() => {}),
      E0e(t, i, n)
        .then((m) => {
          if (m)
            return {
              uri: m,
              bytecode: "",
            };
        })
        .catch(() => {}),
    ]),
    u = o == null ? void 0 : o.bytecode,
    d = (c == null ? void 0 : c.uri) || (o == null ? void 0 : o.uri);
  if (!d && !u)
    throw new Error(
      `Could not fetch bytecode for contract at ${t} on chain ${i}, double check that the address and chainId are correct.`
    );
  try {
    s = await FE(d, r);
  } catch {}
  if (!s && u) {
    const m = x0e(u);
    if (m && m.length > 0)
      return (
        console.warn(
          `Contract metadata could only be partially resolved, some contract functions might be unavailable. Try importing the contract by visiting: https://thirdweb.com/${i}/${t}`
        ),
        (s = {
          name: "Unimported Contract",
          abi: m,
          metadata: {},
          info: {},
          licenses: [],
          isPartialAbi: !0,
        }),
        s
      );
  }
  if (!s)
    throw new Error(
      `Could not resolve contract. Try importing it by visiting: https://thirdweb.com/${i}/${t}`
    );
  return w0e(t, i, s), s;
}
async function E0e(t, e, r) {
  var i;
  if (!Z3) {
    const s =
      ((i = r == null ? void 0 : r.supportedChains) == null
        ? void 0
        : i.find((o) => o.chainId === 137)) || TE;
    Z3 = new Yt(V_(), uF, Es(s, r));
  }
  return await Z3.getMetadataUri(e, t);
}
async function xa(t, e, r) {
  try {
    const n = await Ai(t, e, r);
    if (n && n.abi) return n.abi;
  } catch {}
}
function Tr(t) {
  async function e() {
    return (await t(...arguments)).execute();
  }
  return (e.prepare = t), e;
}
function be(t) {
  async function e() {
    return (await t(...arguments)).execute();
  }
  return (e.prepare = t), e;
}
async function $E(t) {
  return {};
}
async function T0e(t) {
  const e = await t.getGasPrice(),
    r = ya("300", "gwei"),
    n = e.div(100).mul(10),
    i = e.add(n);
  return i.gt(r) ? r : i;
}
async function Av(t, e) {
  return await Promise.all(
    Object.entries(t.metadata.sources).map(async (r) => {
      let [n, i] = r;
      const a = i.urls,
        s = a ? a.find((o) => o.includes("ipfs")) : void 0;
      if (s) {
        const o = s.split("ipfs/")[1],
          c = new Promise((d, m) => setTimeout(() => m("timeout"), 3e3)),
          u = await Promise.race([(await e.download(`ipfs://${o}`)).text(), c]);
        return {
          filename: n,
          source: u,
        };
      } else
        return {
          filename: n,
          source: i.content || "Could not find source for this contract",
        };
    })
  );
}
function C0e(t) {
  const e = xu(Gt.parse(t), "PluginRouter");
  return xu(Gt.parse(t), "DynamicContract") || e;
}
const A0e = [
    "eip-155",
    "eip155",
    "protected",
    "invalid chain id for signer",
    "chain id none",
    "chain_id mismatch",
    "recovered sender mismatch",
    "transaction hash mismatch",
    "chainid no support",
    "chainid (0)",
    "chainid(0)",
  ],
  k0e = [
    ["account", "not found"],
    ["wrong", "chainid"],
  ],
  O0 = {
    5001: {
      name: "Mantle Testnet",
      gasPrice: 1,
    },
    71402: {
      name: "Godwoken Mainnet",
      gasPrice: 4e4 * 10 ** 9,
    },
    1351057110: {
      name: "Chaos (SKALE Testnet)",
      gasPrice: 1e5,
    },
    361: {
      name: "Theta Mainnet",
      gasPrice: 4e3 * 10 ** 9,
    },
    365: {
      name: "Theta Testnet",
      gasPrice: 4e3 * 10 ** 9,
    },
    7700: {
      name: "Canto",
      gasPrice: 1e3 * 10 ** 9,
    },
    7701: {
      name: "Canto Testnet",
      gasPrice: 1e3 * 10 ** 9,
    },
    338: {
      name: "Cronos Testnet",
      gasPrice: 2e3 * 10 ** 9,
    },
    199: {
      name: "BitTorrent Chain",
      gasPrice: 3e5 * 10 ** 9,
    },
  };
function J7(t) {
  const e = A0e.findIndex((n) => t.includes(n)),
    r = k0e.findIndex((n) => {
      let i = !0;
      return (
        n.forEach((a) => {
          i && (i = t.includes(a));
        }),
        i
      );
    });
  return e !== -1 || r !== -1;
}
const S0e =
    "0x604580600e600039806000f350fe7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf3",
  M0e = {
    v: 27,
    r: "0x2222222222222222222222222222222222222222222222222222222222222222",
    s: "0x2222222222222222222222222222222222222222222222222222222222222222",
  },
  Z2 = "0x4e59b44847b379578588920cA78FbF26c0B4956C",
  I0e = 5e6,
  R0e =
    "0x60806040526040516107f33803806107f383398101604081905261002291610359565b805160005b818110156100c157828181518110610041576100416104c9565b6020026020010151600001516001600160a01b03163b600014156100af576100ad838281518110610074576100746104c9565b602002602001015160200151848381518110610092576100926104c9565b6020026020010151604001516100c960201b6100091760201c565b505b806100b9816104df565b915050610027565b505050610557565b606061011183836040518060400160405280601e81526020017f416464726573733a206c6f772d6c6576656c2063616c6c206661696c6564000081525061011860201b60201c565b9392505050565b6060610127848460008561012f565b949350505050565b6060824710156101955760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b60648201526084015b60405180910390fd5b6001600160a01b0385163b6101ec5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000604482015260640161018c565b600080866001600160a01b031685876040516102089190610508565b60006040518083038185875af1925050503d8060008114610245576040519150601f19603f3d011682016040523d82523d6000602084013e61024a565b606091505b50909250905061025b828286610266565b979650505050505050565b60608315610275575081610111565b8251156102855782518084602001fd5b8160405162461bcd60e51b815260040161018c9190610524565b634e487b7160e01b600052604160045260246000fd5b604051606081016001600160401b03811182821017156102d7576102d761029f565b60405290565b604051601f8201601f191681016001600160401b03811182821017156103055761030561029f565b604052919050565b80516001600160a01b038116811461032457600080fd5b919050565b60005b8381101561034457818101518382015260200161032c565b83811115610353576000848401525b50505050565b6000602080838503121561036c57600080fd5b82516001600160401b038082111561038357600080fd5b818501915085601f83011261039757600080fd5b8151818111156103a9576103a961029f565b8060051b6103b88582016102dd565b91825283810185019185810190898411156103d257600080fd5b86860192505b838310156104bc578251858111156103f05760008081fd5b86016060601f19828d0381018213156104095760008081fd5b6104116102b5565b61041c8b850161030d565b8152604061042b81860161030d565b828d01529284015192898411156104425760008081fd5b83850194508e603f86011261045957600093508384fd5b8b85015193508984111561046f5761046f61029f565b61047f8c84601f870116016102dd565b92508383528e818587010111156104965760008081fd5b6104a5848d8501838801610329565b8101919091528452505091860191908601906103d8565b9998505050505050505050565b634e487b7160e01b600052603260045260246000fd5b600060001982141561050157634e487b7160e01b600052601160045260246000fd5b5060010190565b6000825161051a818460208701610329565b9190910192915050565b6020815260008251806020840152610543816040850160208701610329565b601f01601f19169190910160400192915050565b61028d806105666000396000f3fe6080604052600080fd5b606061004b83836040518060400160405280601e81526020017f416464726573733a206c6f772d6c6576656c2063616c6c206661696c65640000815250610052565b9392505050565b60606100618484600085610069565b949350505050565b6060824710156100cf5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b60648201526084015b60405180910390fd5b6001600160a01b0385163b6101265760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016100c6565b600080866001600160a01b031685876040516101429190610208565b60006040518083038185875af1925050503d806000811461017f576040519150601f19603f3d011682016040523d82523d6000602084013e610184565b606091505b509150915061019482828661019f565b979650505050505050565b606083156101ae57508161004b565b8251156101be5782518084602001fd5b8160405162461bcd60e51b81526004016100c69190610224565b60005b838110156101f35781810151838201526020016101db565b83811115610202576000848401525b50505050565b6000825161021a8184602087016101d8565b9190910192915050565b60208152600082518060208401526102438160408501602087016101d8565b601f01601f1916919091016040019291505056fea26469706673582212200b524eb8ceaafe6c603273ee859fddbc2d6f1b7860c3d853dcf6f129f9d9371364736f6c634300080c0033",
  P0e = [
    {
      inputs: [
        {
          components: [
            {
              internalType: "address",
              name: "predictedAddress",
              type: "address",
            },
            {
              internalType: "address",
              name: "to",
              type: "address",
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes",
            },
          ],
          internalType: "struct IDeployer.Transaction[]",
          name: "transactions",
          type: "tuple[]",
        },
      ],
      stateMutability: "payable",
      type: "constructor",
    },
  ];
async function ho(t, e) {
  const r = await e.getCode(t);
  return r !== "0x" && r !== "0x0";
}
async function rL(t) {
  try {
    await t.sendTransaction(
      "0xf8a58085174876e800830186a08080b853604580600e600039806000f350fe7fffffffffffffffafffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf31ba02222222222222222222222222222222222222222222222222222222222222222a02222222222222222222222222222222222222222222222222222222222222222"
    );
  } catch (e) {
    const r = e.toString().toLowerCase(),
      n = JSON.stringify(e).toLowerCase();
    return !!(J7(r) || J7(n));
  }
  return !1;
}
function N0e(t, e) {
  const r = qe(Ut(Up(t))),
    n = Du(r, e),
    i = Up(t, e);
  return {
    signer: n,
    transaction: i,
  };
}
function J2(t, e) {
  const r = Bp(M0e),
    n = N0e(
      {
        gasPrice: e || 100 * 10 ** 9,
        gasLimit: 1e5,
        nonce: 0,
        data: S0e,
        chainId: t,
      },
      r
    ),
    i = fd({
      from: n.signer,
      nonce: 0,
    });
  return {
    ...n,
    deployment: i,
  };
}
async function xl(t) {
  if (await ho(Z2, t)) return Z2;
  const r = await rL(t),
    n = (await t.getNetwork()).chainId,
    i = r ? n : 0;
  return (O0[n] ? J2(i, O0[n].gasPrice) : J2(i)).deployment;
}
const Q7 =
    "0x60606040526040805190810160405280600d81526020017f57726170706564204574686572000000000000000000000000000000000000008152506000908051906020019061004f9291906100c8565b506040805190810160405280600481526020017f57455448000000000000000000000000000000000000000000000000000000008152506001908051906020019061009b9291906100c8565b506012600260006101000a81548160ff021916908360ff16021790555034156100c357600080fd5b61016d565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061010957805160ff1916838001178555610137565b82800160010185558215610137579182015b8281111561013657825182559160200191906001019061011b565b5b5090506101449190610148565b5090565b61016a91905b8082111561016657600081600090555060010161014e565b5090565b90565b610c348061017c6000396000f3006060604052600436106100af576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806306fdde03146100b9578063095ea7b31461014757806318160ddd146101a157806323b872dd146101ca5780632e1a7d4d14610243578063313ce5671461026657806370a082311461029557806395d89b41146102e2578063a9059cbb14610370578063d0e30db0146103ca578063dd62ed3e146103d4575b6100b7610440565b005b34156100c457600080fd5b6100cc6104dd565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561010c5780820151818401526020810190506100f1565b50505050905090810190601f1680156101395780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561015257600080fd5b610187600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803590602001909190505061057b565b604051808215151515815260200191505060405180910390f35b34156101ac57600080fd5b6101b461066d565b6040518082815260200191505060405180910390f35b34156101d557600080fd5b610229600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803590602001909190505061068c565b604051808215151515815260200191505060405180910390f35b341561024e57600080fd5b61026460048080359060200190919050506109d9565b005b341561027157600080fd5b610279610b05565b604051808260ff1660ff16815260200191505060405180910390f35b34156102a057600080fd5b6102cc600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610b18565b6040518082815260200191505060405180910390f35b34156102ed57600080fd5b6102f5610b30565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561033557808201518184015260208101905061031a565b50505050905090810190601f1680156103625780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561037b57600080fd5b6103b0600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091908035906020019091905050610bce565b604051808215151515815260200191505060405180910390f35b6103d2610440565b005b34156103df57600080fd5b61042a600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610be3565b6040518082815260200191505060405180910390f35b34600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055503373ffffffffffffffffffffffffffffffffffffffff167fe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c346040518082815260200191505060405180910390a2565b60008054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156105735780601f1061054857610100808354040283529160200191610573565b820191906000526020600020905b81548152906001019060200180831161055657829003601f168201915b505050505081565b600081600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925846040518082815260200191505060405180910390a36001905092915050565b60003073ffffffffffffffffffffffffffffffffffffffff1631905090565b600081600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054101515156106dc57600080fd5b3373ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff16141580156107b457507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205414155b156108cf5781600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541015151561084457600080fd5b81600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825403925050819055505b81600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254039250508190555081600360008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a3600190509392505050565b80600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205410151515610a2757600080fd5b80600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825403925050819055503373ffffffffffffffffffffffffffffffffffffffff166108fc829081150290604051600060405180830381858888f193505050501515610ab457600080fd5b3373ffffffffffffffffffffffffffffffffffffffff167f7fcf532c15f0a6db0bd6d0e038bea71d30d808c7d98cb3bf7268a95bf5081b65826040518082815260200191505060405180910390a250565b600260009054906101000a900460ff1681565b60036020528060005260406000206000915090505481565b60018054600181600116156101000203166002900480601f016020809104026020016040519081016040528092919081815260200182805460018160011615610100020316600290048015610bc65780601f10610b9b57610100808354040283529160200191610bc6565b820191906000526020600020905b815481529060010190602001808311610ba957829003601f168201915b505050505081565b6000610bdb33848461068c565b905092915050565b60046020528160005260406000206020528060005260406000206000915091505054815600a165627a7a72305820deb4c2ccab3c2fdca32ab3f46728389c2fe2c165d5fafa07661e4e004f6c344a0029",
  B0e = "0x664244560eBa21Bf82d7150C791bE1AbcD5B4cd7";
function UE() {
  return im("contractPublisherAddress", B0e);
}
const nL = Qn.merge(Bn).merge(bl).merge(gn),
  D0e = Ja.merge(Bn).merge(bl).merge(gn),
  O0e = nL.merge(Va).merge(vl).merge(Ji),
  WE = {
    deploy: O0e,
    output: D0e,
    input: nL,
  },
  iL = Qn.merge(Bn).merge(bl).merge(gn),
  F0e = Ja.merge(Bn).merge(bl).merge(gn),
  L0e = iL.merge(Va).merge(vl).merge(Ji),
  $0e = {
    deploy: L0e,
    output: F0e,
    input: iL,
  },
  aL = Qn,
  U0e = Ja,
  W0e = aL.merge(Va).merge(Ji),
  sL = {
    deploy: W0e,
    output: U0e,
    input: aL,
  },
  oL = Qn.merge(Bn).merge(gn),
  j0e = Ja.merge(Bn).merge(gn),
  H0e = oL.merge(Va).merge(Ji),
  z0e = {
    deploy: H0e,
    output: j0e,
    input: oL,
  },
  cL = ne.object({
    address: wr,
    sharesBps: yd.gt(0, "Shares must be greater than 0"),
  }),
  q0e = cL.extend({
    address: wr,
    sharesBps: yd,
  }),
  K_ = Qn.extend({
    recipients: ne
      .array(cL)
      .default([])
      .superRefine((t, e) => {
        const r = {};
        let n = 0;
        for (let i = 0; i < t.length; i++) {
          const a = t[i];
          r[a.address] &&
            e.addIssue({
              code: ne.ZodIssueCode.custom,
              message: "Duplicate address.",
              path: [i, "address"],
            }),
            (r[a.address] = !0),
            (n += a.sharesBps),
            n > 1e4 &&
              e.addIssue({
                code: ne.ZodIssueCode.custom,
                message: "Total shares cannot go over 100%.",
                path: [i, "sharesBps"],
              });
        }
        n !== 1e4 &&
          e.addIssue({
            code: ne.ZodIssueCode.custom,
            message: `Total shares need to add up to 100%. Total shares are currently ${
              n / 100
            }%`,
            path: [],
          });
      }),
  }),
  V0e = Ja.extend({
    recipients: ne.array(q0e),
  }),
  K0e = K_.merge(K_).merge(Ji),
  G0e = {
    deploy: K0e,
    output: V0e,
    input: K_,
  },
  lL = Qn.merge(gn),
  Z0e = Ja.merge(gn),
  J0e = lL.merge(Va).merge(vl).merge(Ji),
  Q0e = {
    deploy: J0e,
    output: Z0e,
    input: lL,
  },
  uL = Qn.merge(Bn).merge(gn),
  Y0e = Ja.merge(Bn).merge(gn),
  X0e = uL.merge(Va).merge(vl).merge(Ji),
  efe = {
    deploy: X0e,
    output: Y0e,
    input: uL,
  },
  fL = Qn.merge(Bn).merge(gn),
  tfe = Ja.merge(Bn).merge(gn),
  rfe = fL.merge(Va).merge(vl).merge(Ji),
  nfe = {
    deploy: rfe,
    output: tfe,
    input: fL,
  },
  dL = ne.object({
    voting_delay_in_blocks: ne.number().min(0).default(0),
    voting_period_in_blocks: ne.number().min(1).default(1),
    voting_token_address: wr,
    voting_quorum_fraction: ine.default(0),
    proposal_token_threshold: Tn.default(1),
  }),
  ife = dL.extend({
    proposal_token_threshold: hi,
  }),
  hL = Qn.merge(dL),
  afe = Ja.merge(ife),
  sfe = hL.merge(Ji),
  ofe = {
    deploy: sfe,
    output: afe,
    input: hL,
  };
async function Se(t) {
  return wr.parseAsync(t);
}
async function jE(t, e) {
  const r = await (await e.download(t)).text();
  return Fue.parse(JSON.parse(r));
}
async function pL(t, e) {
  return Tv.parse(JSON.parse(await (await e.download(t)).text()));
}
async function am(t, e) {
  const r = await pL(t, e),
    n = await (await e.download(r.bytecodeUri)).text(),
    i = await FE(r.metadataUri, e);
  return Wue.parse({
    ...r,
    ...i,
    bytecode: n,
  });
}
const J3 = {};
async function Vi(t, e) {
  if (J3[t]) return J3[t];
  const r = await am(t, e);
  let n;
  try {
    n = await jE(t, e);
  } catch {}
  const i = {
    compilerMetadata: r,
    extendedMetadata: n,
  };
  return (J3[t] = i), i;
}
const fr = "0x0000000000000000000000000000000000000000",
  Bi = "0x7c487845f98938Bb955B1D5AD069d9a30e4131fd",
  Tl = "0x5DBC7B840baa9daBcBe9D2492E45D7244B54A2A0",
  Cl = "0xc82BbE41f2cF04e3a8efA18F7032BDD7f6d98a81",
  wu = {
    [Ve.Mainnet]: {
      openzeppelinForwarder: Cl,
      openzeppelinForwarderEOA: "0x76ce2CB1Ae48Fa067f4fb8c5f803111AE0B24BEA",
      biconomyForwarder: "0x84a0856b038eaAd1cC7E297cF34A7e72685A8693",
      twFactory: Tl,
      twRegistry: Bi,
      twBYOCRegistry: fr,
    },
    [Ve.Goerli]: {
      openzeppelinForwarder: "0x5001A14CA6163143316a7C614e30e6041033Ac20",
      openzeppelinForwarderEOA: "0xe73c50cB9c5B378627ff625BB6e6725A4A5D65d2",
      biconomyForwarder: "0xE041608922d06a4F26C0d4c27d8bCD01daf1f792",
      twFactory: Tl,
      twRegistry: Bi,
      twBYOCRegistry: "0xB1Bd9d7942A250BA2Dce27DD601F2ED4211A60C4",
    },
    [Ve.Polygon]: {
      openzeppelinForwarder: Cl,
      openzeppelinForwarderEOA: "0x4f247c69184ad61036EC2Bb3213b69F10FbEDe1F",
      biconomyForwarder: "0x86C80a8aa58e0A4fa09A69624c31Ab2a6CAD56b8",
      twFactory: Tl,
      twRegistry: Bi,
      twBYOCRegistry: "0x308473Be900F4185A56587dE54bDFF5E8f7a6AE7",
    },
    [Ve.Mumbai]: {
      openzeppelinForwarder: Cl,
      openzeppelinForwarderEOA: "0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",
      biconomyForwarder: "0x9399BB24DBB5C4b782C70c2969F58716Ebbd6a3b",
      twFactory: Tl,
      twRegistry: Bi,
      twBYOCRegistry: "0x3F17972CB27506eb4a6a3D59659e0B57a43fd16C",
    },
    [Ve.Avalanche]: {
      openzeppelinForwarder: Cl,
      openzeppelinForwarderEOA: "0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",
      biconomyForwarder: "0x64CD353384109423a966dCd3Aa30D884C9b2E057",
      twFactory: Tl,
      twRegistry: Bi,
      twBYOCRegistry: fr,
    },
    [Ve.AvalancheFujiTestnet]: {
      openzeppelinForwarder: Cl,
      openzeppelinForwarderEOA: "0xe73c50cB9c5B378627ff625BB6e6725A4A5D65d2",
      biconomyForwarder: "0x6271Ca63D30507f2Dcbf99B52787032506D75BBF",
      twFactory: Tl,
      twRegistry: Bi,
      twBYOCRegistry: "0x3E6eE864f850F5e5A98bc950B68E181Cf4010F23",
    },
    [Ve.Fantom]: {
      openzeppelinForwarder: Cl,
      openzeppelinForwarderEOA: "0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",
      biconomyForwarder: "0x64CD353384109423a966dCd3Aa30D884C9b2E057",
      twFactory: "0x97EA0Fcc552D5A8Fb5e9101316AAd0D62Ea0876B",
      twRegistry: Bi,
      twBYOCRegistry: fr,
    },
    [Ve.FantomTestnet]: {
      openzeppelinForwarder: Cl,
      openzeppelinForwarderEOA: "0x42D3048b595B6e1c28a588d70366CcC2AA4dB47b",
      biconomyForwarder: "0x69FB8Dca8067A5D38703b9e8b39cf2D51473E4b4",
      twFactory: Tl,
      twRegistry: Bi,
      twBYOCRegistry: "0x3E6eE864f850F5e5A98bc950B68E181Cf4010F23",
    },
    [Ve.Arbitrum]: {
      openzeppelinForwarder: "0x4a8AC7f22DeD2CF923A51e4A1c67490bd8868add",
      openzeppelinForwarderEOA: "0x4f247c69184ad61036EC2Bb3213b69F10FbEDe1F",
      biconomyForwarder: "0xfe0fa3C06d03bDC7fb49c892BbB39113B534fB57",
      twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
      twRegistry: Bi,
      twBYOCRegistry: fr,
    },
    [Ve.ArbitrumGoerli]: {
      openzeppelinForwarder: "0x8cbc8B5d71702032904750A66AEfE8B603eBC538",
      openzeppelinForwarderEOA: "0x119704314Ef304EaAAE4b3c7C9ABd59272A28310",
      biconomyForwarder: fr,
      twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
      twRegistry: Bi,
      twBYOCRegistry: fr,
    },
    [Ve.Optimism]: {
      openzeppelinForwarder: "0xd85da690EF288A6976DE0E85Fb2Aad512eBAfbf7",
      openzeppelinForwarderEOA: "0x7e80648EB2071E26937F9D42A513ccf4815fc702",
      biconomyForwarder: "0xefba8a2a82ec1fb1273806174f5e28fbb917cf95",
      twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
      twRegistry: Bi,
      twBYOCRegistry: fr,
    },
    [Ve.OptimismGoerli]: {
      openzeppelinForwarder: "0x8cbc8B5d71702032904750A66AEfE8B603eBC538",
      openzeppelinForwarderEOA: "0x119704314Ef304EaAAE4b3c7C9ABd59272A28310",
      biconomyForwarder: fr,
      twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
      twRegistry: Bi,
      twBYOCRegistry: fr,
    },
    [Ve.BinanceSmartChainMainnet]: {
      openzeppelinForwarder: "0x7C4717039B89d5859c4Fbb85EDB19A6E2ce61171",
      openzeppelinForwarderEOA: "0xE8dd2Ff0212F86d3197b4AfDC6dAC6ac47eb10aC",
      biconomyForwarder: "0x86C80a8aa58e0A4fa09A69624c31Ab2a6CAD56b8",
      twBYOCRegistry: fr,
      twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
      twRegistry: Bi,
    },
    [Ve.BinanceSmartChainTestnet]: {
      openzeppelinForwarder: "0x44bE9D54B9C8b5e57a3325E8Ec9154640e7c6955",
      openzeppelinForwarderEOA: "0x7e80648EB2071E26937F9D42A513ccf4815fc702",
      biconomyForwarder: "0x61456BF1715C1415730076BB79ae118E806E74d2",
      twBYOCRegistry: fr,
      twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
      twRegistry: Bi,
    },
    [Ve.Hardhat]: {
      openzeppelinForwarder: fr,
      openzeppelinForwarderEOA: fr,
      biconomyForwarder: fr,
      twFactory: fr,
      twRegistry: fr,
      twBYOCRegistry: fr,
    },
    [Ve.Localhost]: {
      openzeppelinForwarder: fr,
      openzeppelinForwarderEOA: fr,
      biconomyForwarder: fr,
      twFactory: fr,
      twRegistry: fr,
      twBYOCRegistry: fr,
    },
  };
function Q2(t, e) {
  var r;
  return t === Ve.Hardhat || t === Ve.Localhost
    ? e === "twFactory"
      ? im("factoryAddress")
      : e === "twRegistry"
      ? im("registryAddress")
      : fr
    : (r = wu[t]) == null
    ? void 0
    : r[e];
}
const kv = qe("0x80ac58cd"),
  Sv = qe("0xd9b67a26");
let ia = (function (t) {
  return (t.Transaction = "transaction"), (t.Signature = "signature"), t;
})({});
const _u = "0xdd99b75f095d0c4d5112aCe938e4e6ed962fb024";
async function po(t, e) {
  let r =
      arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "latest",
    n = arguments.length > 3 ? arguments[3] : void 0,
    i = arguments.length > 4 ? arguments[4] : void 0,
    a = arguments.length > 5 ? arguments[5] : void 0;
  const o = kF().find((m) => m.chainId === 137) || TE,
    c = await Se(t),
    u = new Yt(
      UE(),
      EE,
      Es(o, {
        clientId: i,
        secretKey: a,
      })
    );
  let d;
  if (!r || r === "latest") {
    const m = await u.getPublishedContract(c, e);
    d = B_.parse({
      id: m.contractId,
      timestamp: m.publishTimestamp,
      metadataUri: m.publishMetadataUri,
    });
  } else {
    const m = (await u.getPublishedContractVersions(c, e)).map((A) =>
        B_.parse({
          id: A.contractId,
          timestamp: A.publishTimestamp,
          metadataUri: A.publishMetadataUri,
        })
      ),
      E = (
        await Promise.all(
          m.map(async (A) => ({
            name: A.id,
            publishedTimestamp: A.timestamp,
            publishedMetadata: await Vi(A.metadataUri, n),
          }))
        )
      ).find((A) => {
        var I;
        return (
          ((I = A.publishedMetadata.extendedMetadata) == null
            ? void 0
            : I.version) === r
        );
      });
    Je(E), (d = m.find((A) => A.timestamp === E.publishedTimestamp));
  }
  if (!d)
    throw new Error(
      `No published contract found for ${e} at version by '${_u}'`
    );
  return d;
}
function mL(t) {
  const e = t.startsWith("0x") ? t : `0x${t}`,
    n = `tw.${ui(e)}`;
  return ui(n);
}
function G_(t, e, r) {
  const n = t.startsWith("0x") ? t : `0x${t}`,
    i = r ? ui(r) : mL(n);
  return rl(["bytes32", "bytes", "bytes"], [i, n, e]);
}
function Y2(t, e, r, n) {
  const i = t.startsWith("0x") ? t : `0x${t}`,
    a = n ? ui(n) : mL(i),
    s = rl(["bytes", "bytes"], [i, e]),
    o = rl(
      ["bytes1", "address", "bytes32", "bytes32"],
      ["0xff", r, a, ha(["bytes"], [s])]
    );
  return `0x${ha(["bytes"], [o]).slice(26)}`;
}
function _d(t) {
  const e = Gt.parse(t || []);
  for (const r of e) if (r.type === "constructor") return r.inputs || [];
  return [];
}
const Ls = {
  deploymentPresets: {},
};
function cfe(t) {
  return lfe[t] || Ft;
}
const lfe = {
  [Ve.Mainnet]: "0x0385603ab55642cb4dd5de3ae9e306809991804f",
  [Ve.Goerli]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
  [Ve.BinanceSmartChainMainnet]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
  [Ve.Polygon]: "0x28EdFcF0Be7E86b07493466e7631a213bDe8eEF2",
  [Ve.Mumbai]: "0x0a01E11887f727D1b1Cd81251eeEE9BEE4262D07",
  [Ve.Avalanche]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
  [Ve.Optimism]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
  [Ve.Arbitrum]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
};
async function Oa(t, e, r, n, i, a, s) {
  const o = i && i.contractName,
    c = i && i.version;
  let u = i && i.publisherAddress,
    d = i && i.metadata;
  if ((Je(o || d), o && Ls.deploymentPresets[o]))
    return Ls.deploymentPresets[o];
  if (o === "WETH9") {
    const I = Y2(Q7, [], n),
      b = await ho(I, e);
    let w = "";
    return (
      b || (w = G_(Q7, [])),
      {
        name: o,
        type: t,
        transaction: {
          predictedAddress: I,
          to: n,
          data: w,
        },
      }
    );
  }
  if (!d) {
    Je(o), u || (u = _u);
    const I = await po(u, o, c, r, a, s);
    d = (await Vi(I.metadataUri, r)).compilerMetadata;
  }
  const m = await yL(
      d,
      e,
      r,
      n,
      i == null ? void 0 : i.constructorParams,
      a,
      s
    ),
    v = Y2(d.bytecode, m, n),
    E = await ho(v, e);
  let A = "";
  return (
    E || (A = G_(d.bytecode, m)),
    {
      name: o,
      type: t,
      transaction: {
        predictedAddress: v,
        to: n,
        data: A,
      },
      encodedArgs: m,
    }
  );
}
async function yL(t, e, r, n, i, a, s) {
  const o = _d(t.abi),
    c = o.map((m) => (m.type === "tuple[]" ? rn.from(m) : m.type)),
    u = await Promise.all(
      o.map(async (m) => {
        if (i && i[m.name])
          return (
            i[m.name].type &&
              Je(
                i[m.name].type === m.type,
                `Provided type ${
                  i[m.name].type
                } doesn't match the actual type ${m.type} from Abi`
              ),
            i[m.name].value
          );
        if (m.name && m.name.includes("nativeTokenWrapper")) {
          const v = (await e.getNetwork()).chainId;
          let E = SF(v).wrapped.address;
          if (E === Ft) {
            const A = await Oa(
              "infra",
              e,
              r,
              n,
              {
                contractName: "WETH9",
              },
              a,
              s
            );
            Ls.deploymentPresets.WETH9 || (Ls.deploymentPresets.WETH9 = A),
              (E = A.transaction.predictedAddress);
          }
          return E;
        } else if (m.name && m.name.includes("trustedForwarder")) {
          if (t.name === "Pack") {
            const E = await Oa(
              "infra",
              e,
              r,
              n,
              {
                contractName: "ForwarderEOAOnly",
              },
              a,
              s
            );
            return (
              Ls.deploymentPresets.ForwarderEOAOnly ||
                (Ls.deploymentPresets.ForwarderEOAOnly = E),
              E.transaction.predictedAddress
            );
          }
          const v = await Oa(
            "infra",
            e,
            r,
            n,
            {
              contractName: "Forwarder",
            },
            a,
            s
          );
          return (
            Ls.deploymentPresets.Forwarder ||
              (Ls.deploymentPresets.Forwarder = v),
            v.transaction.predictedAddress
          );
        } else if (m.name && m.name.includes("royaltyEngineAddress")) {
          const v = (await e.getNetwork()).chainId;
          return cfe(v);
        } else throw new Error("Can't resolve constructor arguments");
      })
    );
  return xs.encode(c, u);
}
async function gL(t, e, r, n, i) {
  return (
    (!r || r === "") && (r = await xl(t)),
    (
      await Oa(
        "infra",
        t,
        e,
        r,
        {
          contractName: "ForwarderEOAOnly",
        },
        n,
        i
      )
    ).transaction.predictedAddress
  );
}
async function HE(t, e, r, n, i) {
  return (
    (!r || r === "") && (r = await xl(t)),
    (
      await Oa(
        "infra",
        t,
        e,
        r,
        {
          contractName: "Forwarder",
        },
        n,
        i
      )
    ).transaction.predictedAddress
  );
}
const bL = [
    {
      name: "from",
      type: "address",
    },
    {
      name: "to",
      type: "address",
    },
    {
      name: "value",
      type: "uint256",
    },
    {
      name: "gas",
      type: "uint256",
    },
    {
      name: "nonce",
      type: "uint256",
    },
    {
      name: "data",
      type: "bytes",
    },
  ],
  vL = [
    {
      name: "from",
      type: "address",
    },
    {
      name: "to",
      type: "address",
    },
    {
      name: "value",
      type: "uint256",
    },
    {
      name: "gas",
      type: "uint256",
    },
    {
      name: "nonce",
      type: "uint256",
    },
    {
      name: "data",
      type: "bytes",
    },
    {
      name: "chainid",
      type: "uint256",
    },
  ],
  xL = [
    {
      inputs: [
        {
          internalType: "address",
          name: "from",
          type: "address",
        },
        {
          internalType: "uint256",
          name: "batchId",
          type: "uint256",
        },
      ],
      name: "getNonce",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  t0 = {},
  Y7 = {};
async function X2(t, e, r) {
  const n = r.join("|"),
    i = Y7[n],
    a = Date.now() - i >= 2e3;
  if (!(n in t0) || a) {
    const o = await t.functions[e](...r);
    Array.isArray(o) && o.length > 0
      ? (t0[n] = ae.from(o[0]))
      : (t0[n] = ae.from(o)),
      (Y7[n] = Date.now());
  }
  const s = t0[n];
  return (t0[n] = ae.from(t0[n]).add(1)), s;
}
async function sm(t, e, r, n) {
  var u, d;
  let i = t;
  t.originalSigner && (i = t.originalSigner);
  const a = i == null ? void 0 : i.provider;
  if (!a) throw new Error("missing provider");
  const s = wn.getPayload(e, r, n);
  let o = "";
  const c = (await i.getAddress()).toLowerCase();
  if ((u = a == null ? void 0 : a.provider) != null && u.isWalletConnect)
    o = await a.send("eth_signTypedData", [
      (await i.getAddress()).toLowerCase(),
      JSON.stringify(s),
    ]);
  else
    try {
      o = await i._signTypedData(e, r, n);
    } catch (m) {
      if (
        (d = m == null ? void 0 : m.message) != null &&
        d.includes("eth_signTypedData_v4")
      )
        o = await a.send("eth_signTypedData", [c, JSON.stringify(s)]);
      else
        try {
          await a.send("eth_signTypedData_v4", [c, JSON.stringify(s)]);
        } catch (v) {
          throw v;
        }
    }
  return {
    payload: s,
    signature: Bp(yo(o)),
  };
}
const ufe = [
    {
      inputs: [],
      name: "name",
      outputs: [
        {
          internalType: "string",
          name: "",
          type: "string",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  ffe = [
    {
      constant: !0,
      inputs: [],
      name: "DOMAIN_SEPARATOR",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32",
        },
      ],
      payable: !1,
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "getDomainSeperator",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  dfe = [
    {
      inputs: [
        {
          internalType: "address",
          name: "owner",
          type: "address",
        },
      ],
      name: "nonces",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "user",
          type: "address",
        },
      ],
      name: "getNonce",
      outputs: [
        {
          internalType: "uint256",
          name: "nonce",
          type: "uint256",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
  ];
async function hfe(t, e) {
  const r = new Yt(e, dfe, t);
  try {
    return await r.nonces(await t.getAddress());
  } catch {
    return await r.getNonce(await t.getAddress());
  }
}
async function pfe(t, e) {
  const r = new Yt(e, ffe, t);
  try {
    return await r.DOMAIN_SEPARATOR();
  } catch {
    try {
      return await r.getDomainSeperator();
    } catch (i) {
      console.error("Error getting domain separator", i);
    }
  }
}
async function mfe(t, e) {
  return new Yt(e, ufe, t).name();
}
async function yfe(t, e) {
  const r = await pfe(t, e.verifyingContract),
    n = {
      name: e.name,
      version: e.version,
      verifyingContract: e.verifyingContract,
      salt: Rt(ae.from(e.chainId).toHexString(), 32),
    };
  return wn.hashDomain(n) === r ? n : e;
}
async function wL(t, e, r, n, i, a, s) {
  const o = await yfe(t, {
    name: await mfe(t, e),
    version: "1",
    chainId: await t.getChainId(),
    verifyingContract: e,
  });
  (s = s || (await hfe(t, e)).toString()), (a = a || da);
  const c = {
      owner: r,
      spender: n,
      value: i,
      nonce: s,
      deadline: a,
    },
    u = {
      Permit: [
        {
          name: "owner",
          type: "address",
        },
        {
          name: "spender",
          type: "address",
        },
        {
          name: "value",
          type: "uint256",
        },
        {
          name: "nonce",
          type: "uint256",
        },
        {
          name: "deadline",
          type: "uint256",
        },
      ],
    },
    { signature: d } = await sm(t, o, u, c);
  return {
    message: c,
    signature: d,
  };
}
class _L {
  constructor(e) {
    (this.args = e.args),
      (this.overrides = e.overrides || {}),
      (this.provider = e.provider),
      (this.signer = e.signer),
      (this.storage = e.storage),
      this.signer.provider ||
        (this.signer = this.signer.connect(this.provider));
  }
  get getSigner() {
    return this.signer;
  }
  get getProvider() {
    return this.provider;
  }
  get getStorage() {
    return this.storage;
  }
  getArgs() {
    return this.args;
  }
  getOverrides() {
    return this.overrides;
  }
  getValue() {
    return this.overrides.value || 0;
  }
  setArgs(e) {
    return (this.args = e), this;
  }
  setOverrides(e) {
    return (this.overrides = e), this;
  }
  updateOverrides(e) {
    return (
      (this.overrides = {
        ...this.overrides,
        ...e,
      }),
      this
    );
  }
  setValue(e) {
    return (
      this.updateOverrides({
        value: e,
      }),
      this
    );
  }
  setGasLimit(e) {
    return (
      this.updateOverrides({
        gasLimit: e,
      }),
      this
    );
  }
  setGasPrice(e) {
    return (
      this.updateOverrides({
        gasPrice: e,
      }),
      this
    );
  }
  setNonce(e) {
    return (
      this.updateOverrides({
        nonce: e,
      }),
      this
    );
  }
  setMaxFeePerGas(e) {
    return (
      this.updateOverrides({
        maxFeePerGas: e,
      }),
      this
    );
  }
  setMaxPriorityFeePerGas(e) {
    return (
      this.updateOverrides({
        maxPriorityFeePerGas: e,
      }),
      this
    );
  }
  setType(e) {
    return (
      this.updateOverrides({
        type: e,
      }),
      this
    );
  }
  setAccessList(e) {
    return (
      this.updateOverrides({
        accessList: e,
      }),
      this
    );
  }
  setCustomData(e) {
    return (
      this.updateOverrides({
        customData: e,
      }),
      this
    );
  }
  setCcipReadEnabled(e) {
    return (
      this.updateOverrides({
        ccipReadEnabled: e,
      }),
      this
    );
  }
  setGasLimitMultiple(e) {
    ae.isBigNumber(this.overrides.gasLimit)
      ? (this.overrides.gasLimit = ae.from(
          Math.floor(ae.from(this.overrides.gasLimit).toNumber() * e)
        ))
      : (this.gasMultiple = e);
  }
  async estimateGasCost() {
    const [e, r] = await Promise.all([
        this.estimateGasLimit(),
        this.getGasPrice(),
      ]),
      n = e.mul(r);
    return {
      ether: Wr(n),
      wei: n,
    };
  }
  async getGasPrice() {
    return T0e(this.provider);
  }
  async getSignerAddress() {
    return this.signer.getAddress();
  }
  async getGasOverrides() {
    return $E(this.provider);
  }
  getPreferredPriorityFee(e) {
    const r = e.div(100).mul(10);
    return e.add(r);
  }
}
class ze extends _L {
  static fromContractWrapper(e) {
    const r = e.contractWrapper.getSigner();
    if (!r)
      throw new Error(
        "Cannot create a transaction without a signer. Please ensure that you have a connected signer."
      );
    const n = {
      ...e,
      contract: e.contractWrapper.writeContract,
      provider: e.contractWrapper.getProvider(),
      signer: r,
      gasless: e.contractWrapper.options.gasless,
      storage: e.contractWrapper.storage,
    };
    return new ze(n);
  }
  static async fromContractInfo(e) {
    const r = e.storage;
    let n = e.contractAbi;
    if (!n)
      try {
        n = (await Ai(e.contractAddress, e.provider, r)).abi;
      } catch {
        throw new Error(
          `Could resolve contract metadata for address ${e.contractAddress}. Please pass the contract ABI manually with the 'contractAbi' option.`
        );
      }
    const i = new Yt(e.contractAddress, n, e.provider),
      a = {
        ...e,
        storage: r,
        contract: i,
      };
    return new ze(a);
  }
  constructor(e) {
    super({
      args: e.args,
      overrides: e.overrides,
      provider: e.provider,
      signer: e.signer,
      storage: e.storage,
    }),
      (this.method = e.method),
      (this.gaslessOptions = e.gasless),
      (this.parse = e.parse),
      (this.contract = e.contract.connect(this.signer)),
      (this.storage = e.storage);
  }
  getTarget() {
    return this.contract.address;
  }
  getMethod() {
    return this.method;
  }
  getGaslessOptions() {
    return this.gaslessOptions;
  }
  setGaslessOptions(e) {
    return (this.gaslessOptions = e), this;
  }
  setParse(e) {
    return (this.parse = e), this;
  }
  encode() {
    return this.contract.interface.encodeFunctionData(this.method, this.args);
  }
  async sign() {
    const e = await this.populateTransaction();
    return await this.contract.signer.signTransaction(e);
  }
  async populateTransaction() {
    const r = {
      ...(await this.getGasOverrides()),
      ...this.overrides,
    };
    r.gasLimit || (r.gasLimit = await this.estimateGasLimit());
    const n = await this.contract.populateTransaction[this.method](
      ...this.args,
      r
    );
    return await this.contract.signer.populateTransaction(n);
  }
  async simulate() {
    if (!this.contract.callStatic[this.method]) throw this.functionError();
    try {
      return await this.contract.callStatic[this.method](
        ...this.args,
        ...(this.overrides.value
          ? [
              {
                value: this.overrides.value,
              },
            ]
          : [])
      );
    } catch (e) {
      throw await this.transactionError(e);
    }
  }
  async estimateGasLimit() {
    if (!this.contract.estimateGas[this.method]) throw this.functionError();
    try {
      const e = await this.contract.estimateGas[this.method](
        ...this.args,
        this.overrides
      );
      return this.gasMultiple
        ? ae.from(Math.floor(ae.from(e).toNumber() * this.gasMultiple))
        : e;
    } catch (e) {
      throw (await this.simulate(), await this.transactionError(e));
    }
  }
  async send() {
    if (!this.contract.functions[this.method]) throw this.functionError();
    if (
      this.gaslessOptions &&
      ("openzeppelin" in this.gaslessOptions ||
        "biconomy" in this.gaslessOptions)
    )
      return this.sendGasless();
    const r = {
      ...(await this.getGasOverrides()),
      ...this.overrides,
    };
    if (!r.gasLimit) {
      r.gasLimit = await this.estimateGasLimit();
      try {
        const n = JSON.parse(this.contract.interface.format("json"));
        C0e(n) && (r.gasLimit = r.gasLimit.mul(110).div(100));
      } catch (n) {
        console.warn("Error raising gas limit", n);
      }
    }
    try {
      return await this.contract.functions[this.method](...this.args, r);
    } catch (n) {
      throw await this.transactionError(n);
    }
  }
  async execute() {
    const e = await this.send();
    let r;
    try {
      r = await e.wait();
    } catch (n) {
      throw (await this.simulate(), await this.transactionError(n));
    }
    return this.parse
      ? this.parse(r)
      : {
          receipt: r,
        };
  }
  async sendGasless() {
    const e = await this.prepareGasless(),
      r = await bfe(
        e,
        this.signer,
        this.provider,
        this.storage,
        this.gaslessOptions
      );
    let n,
      i = 1;
    for (; !n; ) {
      try {
        n = await this.provider.getTransaction(r);
      } catch {}
      if (
        (n ||
          (await new Promise((a) => setTimeout(a, Math.min(i * 1e3, 1e4))),
          i++),
        i > 20)
      )
        throw new Error(`Unable to retrieve transaction with hash ${r}`);
    }
    return n;
  }
  async prepareGasless() {
    var u;
    Je(
      this.gaslessOptions &&
        ("openzeppelin" in this.gaslessOptions ||
          "biconomy" in this.gaslessOptions)
    );
    const e = await this.getSignerAddress(),
      r = [...this.args];
    this.method === "multicall" &&
      Array.isArray(this.args[0]) &&
      r[0].length > 0 &&
      (r[0] = r[0].map((d) => rl(["bytes", "address"], [d, e]))),
      Je(this.signer);
    const [{ chainId: n }, i] = await Promise.all([
        this.provider.getNetwork(),
        this.overrides.from || e,
      ]),
      a = this.contract.address,
      s = ((u = this.overrides) == null ? void 0 : u.value) || 0;
    if (ae.from(s).gt(0))
      throw new Error(
        "Cannot send native token value with gasless transaction"
      );
    const o = this.contract.interface.encodeFunctionData(this.method, r);
    let c = ae.from(0);
    try {
      c = (await this.contract.estimateGas[this.method](...r)).mul(2);
    } catch {}
    return (
      c.lt(1e5) && (c = ae.from(5e5)),
      this.overrides.gasLimit &&
        ae.from(this.overrides.gasLimit).gt(c) &&
        (c = ae.from(this.overrides.gasLimit)),
      {
        from: i,
        to: a,
        data: o,
        chainId: n,
        gasLimit: c,
        functionName: this.method,
        functionArgs: r,
        callOverrides: this.overrides,
      }
    );
  }
  functionError() {
    return new Error(
      `Contract "${this.contract.address}" does not have function "${this.method}"`
    );
  }
  async transactionError(e) {
    var w, S, k;
    const r = this.provider,
      [n, i] = await Promise.all([
        r.getNetwork(),
        this.overrides.from || this.getSignerAddress(),
      ]),
      a = this.contract.address,
      s = this.encode(),
      o = ae.from(this.overrides.value || 0),
      c = (w = r.connection) == null ? void 0 : w.url,
      u = this.contract.interface.getFunction(this.method),
      d = this.args.map((N) =>
        JSON.stringify(N).length <= 80
          ? JSON.stringify(N)
          : JSON.stringify(N, void 0, 2)
      ),
      m =
        d.join(", ").length <= 80
          ? d.join(", ")
          : `
` +
            d.map(
              (N) =>
                "  " +
                N.split(`
`).join(`
  `)
            ).join(`,
`) +
            `
`,
      v = `${u.name}(${m})`,
      E =
        e.transactionHash ||
        ((S = e.transaction) == null ? void 0 : S.hash) ||
        ((k = e.receipt) == null ? void 0 : k.transactionHash),
      A = BE(e);
    let I, b;
    try {
      const N = await Ai(this.contract.address, this.provider, this.storage);
      N.name && (b = N.name),
        N.metadata.sources && (I = await Av(N, this.storage));
    } catch {}
    return new NE(
      {
        reason: A,
        from: i,
        to: a,
        method: v,
        data: s,
        network: n,
        rpcUrl: c,
        value: o,
        hash: E,
        contractName: b,
        sources: I,
      },
      e
    );
  }
}
class gfe extends _L {
  constructor(e) {
    super(e), (this.factory = e.factory), (this.events = e.events);
  }
  encode() {
    return Ke(
      cr([
        this.factory.bytecode,
        this.factory.interface.encodeDeploy(this.args),
      ])
    );
  }
  getTarget() {
    return Ft;
  }
  getMethod() {
    return "deploy";
  }
  async sign() {
    const e = await this.populateTransaction();
    return this.signer.signTransaction(e);
  }
  async simulate() {
    const e = await this.populateTransaction();
    return this.signer.call(e);
  }
  async estimateGasLimit() {
    try {
      const r = {
          ...(await this.getGasOverrides()),
          ...this.overrides,
        },
        n = this.factory.getDeployTransaction(...this.args, r);
      return this.signer.estimateGas(n);
    } catch (e) {
      throw await this.deployError(e);
    }
  }
  async send() {
    try {
      const e = await this.populateTransaction();
      return await this.signer.sendTransaction(e);
    } catch (e) {
      throw await this.deployError(e);
    }
  }
  async execute() {
    const e = await this.send();
    try {
      await e.wait();
    } catch (n) {
      throw (await this.simulate(), await this.deployError(n));
    }
    const r = fd({
      from: e.from,
      nonce: e.nonce,
    });
    return (
      this.events &&
        this.events.emit("contractDeployed", {
          status: "completed",
          contractAddress: r,
          transactionHash: e.hash,
        }),
      r
    );
  }
  async populateTransaction() {
    const r = {
      ...(await this.getGasOverrides()),
      ...this.overrides,
    };
    return (
      r.gasLimit || (r.gasLimit = await this.estimateGasLimit()),
      this.factory.getDeployTransaction(...this.args, r)
    );
  }
  async deployError(e) {
    var E, A, I;
    const r = this.provider,
      [n, i] = await Promise.all([
        r.getNetwork(),
        this.overrides.from || this.getSignerAddress(),
      ]),
      a = this.encode(),
      s = ae.from(this.overrides.value || 0),
      o = (E = r.connection) == null ? void 0 : E.url,
      c = this.args.map((b) =>
        JSON.stringify(b).length <= 80
          ? JSON.stringify(b)
          : JSON.stringify(b, void 0, 2)
      ),
      d = `deployContract(${
        c.join(", ").length <= 80
          ? c.join(", ")
          : `
` +
            c.map(
              (b) =>
                "  " +
                b.split(`
`).join(`
  `)
            ).join(`,
`) +
            `
`
      })`,
      m =
        e.transactionHash ||
        ((A = e.transaction) == null ? void 0 : A.hash) ||
        ((I = e.receipt) == null ? void 0 : I.transactionHash),
      v = BE(e);
    return new NE(
      {
        reason: v,
        from: i,
        method: d,
        data: a,
        network: n,
        rpcUrl: o,
        value: s,
        hash: m,
      },
      e
    );
  }
}
async function bfe(t, e, r, n, i) {
  return i && "biconomy" in i ? vfe(t, e, r, i) : xfe(t, e, r, n, i);
}
async function vfe(t, e, r, n) {
  const i = await _fe(t, e, r, n),
    a = await _s("https://api.biconomy.io/api/v2/meta-tx/native", i);
  if (a.ok) {
    const s = await a.json();
    if (!s.txHash) throw new Error(`relay transaction failed: ${s.log}`);
    return s.txHash;
  }
  throw new Error(
    `relay transaction failed with status: ${a.status} (${a.statusText})`
  );
}
async function xfe(t, e, r, n, i) {
  Je(i && "openzeppelin" in i);
  const a = await wfe(t, e, r, n, i),
    s = await _s(i.openzeppelin.relayerUrl, a);
  if (s.ok) {
    const o = await s.json();
    if (!o.result) throw new Error(`Relay transaction failed: ${o.message}`);
    return JSON.parse(o.result).txHash;
  }
  throw new Error(
    `relay transaction failed with status: ${s.status} (${s.statusText})`
  );
}
async function wfe(t, e, r, n, i) {
  Je(i && "openzeppelin" in i), Je(e), Je(r);
  const a =
      i.openzeppelin.relayerForwarderAddress ||
      (i.openzeppelin.useEOAForwarder
        ? wu[t.chainId].openzeppelinForwarderEOA || (await gL(r, n))
        : wu[t.chainId].openzeppelinForwarder || (await HE(r, n))),
    s = new Yt(a, xF, r),
    o = await X2(s, "getNonce", [t.from]);
  let c, u, d;
  i.experimentalChainlessSupport
    ? ((c = {
        name: "GSNv2 Forwarder",
        version: "0.0.1",
        verifyingContract: a,
      }),
      (u = {
        ForwardRequest: vL,
      }),
      (d = {
        from: t.from,
        to: t.to,
        value: ae.from(0).toString(),
        gas: ae.from(t.gasLimit).toString(),
        nonce: ae.from(o).toString(),
        data: t.data,
        chainid: ae.from(t.chainId).toString(),
      }))
    : ((c = {
        name: i.openzeppelin.domainName,
        version: i.openzeppelin.domainVersion,
        chainId: t.chainId,
        verifyingContract: a,
      }),
      (u = {
        ForwardRequest: bL,
      }),
      (d = {
        from: t.from,
        to: t.to,
        value: ae.from(0).toString(),
        gas: ae.from(t.gasLimit).toString(),
        nonce: ae.from(o).toString(),
        data: t.data,
      }));
  let m;
  if (t.functionName === "approve" && t.functionArgs.length === 2) {
    const E = t.functionArgs[0],
      A = t.functionArgs[1],
      { message: I, signature: b } = await wL(e, t.to, t.from, E, A),
      { r: w, s: S, v: k } = yo(b);
    (d = {
      to: t.to,
      owner: I.owner,
      spender: I.spender,
      value: ae.from(I.value).toString(),
      nonce: ae.from(I.nonce).toString(),
      deadline: ae.from(I.deadline).toString(),
      r: w,
      s: S,
      v: k,
    }),
      (m = b);
  } else {
    const { signature: E } = await sm(e, c, u, d);
    m = E;
  }
  let v = "forward";
  return (
    d != null && d.owner && (v = "permit"),
    {
      method: "POST",
      body: JSON.stringify({
        request: d,
        signature: m,
        forwarderAddress: a,
        type: v,
      }),
    }
  );
}
async function _fe(t, e, r, n) {
  var d;
  Je(n && "biconomy" in n), Je(e && r);
  const i = new Yt(Q2(t.chainId, "biconomyForwarder"), xL, r),
    a = 0,
    s = await X2(i, "getNonce", [t.from, a]),
    o = {
      from: t.from,
      to: t.to,
      token: Ft,
      txGas: t.gasLimit.toNumber(),
      tokenGasPrice: "0",
      batchId: a,
      batchNonce: s.toNumber(),
      deadline: Math.floor(
        Date.now() / 1e3 +
          ((n &&
            "biconomy" in n &&
            ((d = n.biconomy) == null ? void 0 : d.deadlineSeconds)) ||
            3600)
      ),
      data: t.data,
    },
    c = qe(
      ha(
        [
          "address",
          "address",
          "address",
          "uint256",
          "uint256",
          "uint256",
          "uint256",
          "uint256",
          "bytes32",
        ],
        [
          o.from,
          o.to,
          o.token,
          o.txGas,
          o.tokenGasPrice,
          o.batchId,
          o.batchNonce,
          o.deadline,
          Ut(o.data),
        ]
      )
    ),
    u = await e.signMessage(c);
  return {
    method: "POST",
    body: JSON.stringify({
      from: t.from,
      apiId: n.biconomy.apiId,
      params: [o, u],
      to: t.to,
      gasLimit: t.gasLimit.toHexString(),
    }),
    headers: {
      "x-api-key": n.biconomy.apiKey,
      "Content-Type": "application/json;charset=utf-8",
    },
  };
}
class Q0 {
  constructor(e, r, n) {
    oe(this, "featureName", O2.name);
    oe(
      this,
      "set",
      be(async (e) => {
        const r = await this._parseAndUploadMetadata(e),
          n = this.contractWrapper;
        if (this.supportsContractMetadata(n))
          return ze.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "setContractURI",
            args: [r],
            parse: (i) => ({
              receipt: i,
              data: this.get,
            }),
          });
        throw new nu(O2);
      })
    );
    oe(
      this,
      "update",
      be(
        async (e) =>
          await this.set.prepare({
            ...(await this.get()),
            ...e,
          })
      )
    );
    (this.contractWrapper = e), (this.schema = r), (this.storage = n);
  }
  parseOutputMetadata(e) {
    return this.schema.output.parseAsync(e);
  }
  parseInputMetadata(e) {
    return this.schema.input.parseAsync(e);
  }
  async get() {
    let e;
    if (this.supportsContractMetadata(this.contractWrapper)) {
      const r = await this.contractWrapper.read("contractURI", []);
      r && r.includes("://") && (e = await this.storage.downloadJSON(r));
    }
    if (!e)
      try {
        let r;
        try {
          Kr("name", this.contractWrapper) &&
            (r = await this.contractWrapper.read("name", []));
        } catch {}
        let n;
        try {
          Kr("symbol", this.contractWrapper) &&
            (n = await this.contractWrapper.read("symbol", []));
        } catch {}
        let i;
        try {
          i = await Ai(
            this.contractWrapper.address,
            this.contractWrapper.getProvider(),
            this.storage,
            this.contractWrapper.options
          );
        } catch {}
        e = {
          name: r || (i == null ? void 0 : i.name),
          symbol: n,
          description: i == null ? void 0 : i.info.title,
        };
      } catch {
        throw new Error("Could not fetch contract metadata");
      }
    return this.parseOutputMetadata(e);
  }
  async _parseAndUploadMetadata(e) {
    const r = await this.parseInputMetadata(e);
    return this.storage.upload(r);
  }
  supportsContractMetadata(e) {
    return Qe(e, "ContractMetadata");
  }
}
const EL = {
    admin: "",
    transfer: "TRANSFER_ROLE",
    minter: "MINTER_ROLE",
    pauser: "PAUSER_ROLE",
    lister: "LISTER_ROLE",
    asset: "ASSET_ROLE",
    unwrap: "UNWRAP_ROLE",
    factory: "FACTORY_ROLE",
    signer: "SIGNER_ROLE",
  },
  TL = Object.keys(EL);
function ah(t) {
  return t === "admin" ? Rt([0], 32) : ui(EL[t]);
}
class Efe {
  constructor(e, r) {
    oe(this, "featureName", D2.name);
    oe(
      this,
      "setAll",
      be(async (e) => {
        var o, c;
        const r = new Sr(this.contractWrapper),
          n = Object.keys(e);
        Je(n.length), Je(n.every((u) => this.roles.includes(u)));
        const i = await this.getAll(),
          a = [],
          s = n.sort((u) => (u === "admin" ? 1 : -1));
        for (let u = 0; u < s.length; u++) {
          const d = s[u],
            m = await Promise.all(
              ((o = e[d]) == null ? void 0 : o.map(async (I) => await Se(I))) ||
                []
            ),
            v = await Promise.all(
              ((c = i[d]) == null ? void 0 : c.map(async (I) => await Se(I))) ||
                []
            ),
            E = m.filter((I) => !v.includes(I)),
            A = v.filter((I) => !m.includes(I));
          if (
            (E.length &&
              E.forEach((I) => {
                a.push(r.encode("grantRole", [ah(d), I]));
              }),
            A.length)
          )
            for (let I = 0; I < A.length; I++) {
              const b = A[I],
                w = await this.getRevokeRoleFunctionName(b);
              a.push(r.encode(w, [ah(d), b]));
            }
        }
        return ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "multicall",
          args: [a],
        });
      })
    );
    oe(
      this,
      "grant",
      be(async (e, r) => {
        Je(this.roles.includes(e));
        const n = await Se(r);
        return ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "grantRole",
          args: [ah(e), n],
        });
      })
    );
    oe(
      this,
      "revoke",
      be(async (e, r) => {
        Je(this.roles.includes(e));
        const n = await Se(r),
          i = await this.getRevokeRoleFunctionName(n);
        return ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: i,
          args: [ah(e), n],
        });
      })
    );
    (this.contractWrapper = e), (this.roles = r);
  }
  async getAll() {
    Je(this.roles.length);
    const e = {};
    for (const r of this.roles) e[r] = await this.get(r);
    return e;
  }
  async get(e) {
    Je(this.roles.includes(e));
    const r = this.contractWrapper;
    if (Kr("getRoleMemberCount", r) && Kr("getRoleMember", r)) {
      const n = ah(e),
        i = (await r.read("getRoleMemberCount", [n])).toNumber();
      return await Promise.all(
        Array.from(Array(i).keys()).map((a) => r.read("getRoleMember", [n, a]))
      );
    }
    throw new Error(
      "Contract does not support enumerating roles. Please implement IPermissionsEnumerable to unlock this functionality."
    );
  }
  async verify(e, r) {
    await Promise.all(
      e.map(async (n) => {
        const i = await this.get(n),
          a = await Se(r);
        if (!i.map((s) => s.toLowerCase()).includes(a.toLowerCase()))
          throw new Hue(a, n);
      })
    );
  }
  async getRevokeRoleFunctionName(e) {
    const r = await Se(e);
    return (await this.contractWrapper.getSignerAddress()).toLowerCase() ===
      r.toLowerCase()
      ? "renounceRole"
      : "revokeRole";
  }
}
class Tfe {
  constructor(e, r) {
    oe(this, "featureName", P2.name);
    oe(
      this,
      "setDefaultRoyaltyInfo",
      be(async (e) => {
        const r = await this.metadata.get(),
          n = await this.metadata.parseInputMetadata({
            ...r,
            ...e,
          }),
          i = await this.metadata._parseAndUploadMetadata(n);
        if (Kr("setContractURI", this.contractWrapper)) {
          const a = new Sr(this.contractWrapper),
            s = [
              a.encode("setDefaultRoyaltyInfo", [
                n.fee_recipient,
                n.seller_fee_basis_points,
              ]),
              a.encode("setContractURI", [i]),
            ];
          return ze.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "multicall",
            args: [s],
            parse: (o) => ({
              receipt: o,
              data: () => this.getDefaultRoyaltyInfo(),
            }),
          });
        } else
          throw new Error(
            "Updating royalties requires implementing ContractMetadata in your contract to support marketplaces like OpenSea."
          );
      })
    );
    oe(
      this,
      "setTokenRoyaltyInfo",
      be(async (e, r) => {
        const n = Bn.parse(r);
        return ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "setRoyaltyInfoForToken",
          args: [e, n.fee_recipient, n.seller_fee_basis_points],
          parse: (i) => ({
            receipt: i,
            data: () => this.getDefaultRoyaltyInfo(),
          }),
        });
      })
    );
    (this.contractWrapper = e), (this.metadata = r);
  }
  async getDefaultRoyaltyInfo() {
    const [e, r] = await this.contractWrapper.read("getDefaultRoyaltyInfo", []);
    return Bn.parseAsync({
      fee_recipient: e,
      seller_fee_basis_points: r,
    });
  }
  async getTokenRoyaltyInfo(e) {
    const [r, n] = await this.contractWrapper.read("getRoyaltyInfoForToken", [
      e,
    ]);
    return Bn.parseAsync({
      fee_recipient: r,
      seller_fee_basis_points: n,
    });
  }
}
class Cfe {
  constructor(e) {
    oe(this, "featureName", N2.name);
    oe(
      this,
      "setRecipient",
      be(async (e) =>
        ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "setPrimarySaleRecipient",
          args: [e],
        })
      )
    );
    this.contractWrapper = e;
  }
  async getRecipient() {
    return await this.contractWrapper.read("primarySaleRecipient", []);
  }
}
const Mv = {
  name: "Failed to load NFT metadata",
};
async function zE(t, e, r) {
  if (e.startsWith("data:application/json;base64") && typeof Buffer < "u") {
    const a = e.split(",")[1],
      s = JSON.parse(Buffer.from(a, "base64").toString("utf-8"));
    return h_.parse({
      ...s,
      id: ae.from(t).toString(),
      uri: e,
    });
  }
  const n = e.replace("{id}", Rt(ae.from(t).toHexString(), 32).slice(2));
  let i;
  try {
    i = await r.downloadJSON(n);
  } catch {
    const s = e.replace("{id}", ae.from(t).toString());
    try {
      i = await r.downloadJSON(s);
    } catch {
      console.warn(
        `failed to get token metadata: ${JSON.stringify({
          tokenId: t.toString(),
          tokenUri: e,
        })} -- falling back to default metadata`
      ),
        (i = Mv);
    }
  }
  return h_.parse({
    ...i,
    id: ae.from(t).toString(),
    uri: e,
  });
}
async function Iv(t, e, r, n) {
  let i;
  const a = new Yt(t, yv, e),
    [s, o] = await Promise.all([
      a.supportsInterface(kv),
      a.supportsInterface(Sv),
    ]);
  if (s) i = await new Yt(t, YO, e).tokenURI(r);
  else if (o) i = await new Yt(t, XO, e).uri(r);
  else throw Error("Contract must implement ERC 1155 or ERC 721.");
  return i
    ? zE(r, i, n)
    : h_.parse({
        ...Mv,
        id: ae.from(r).toString(),
        uri: "",
      });
}
async function qE(t, e) {
  return typeof t == "string" ? t : await e.upload(il.parse(t));
}
async function $u(t, e, r, n) {
  if (Afe(t)) return t;
  if (kfe(t))
    return await e.uploadBatch(
      t.map((a) => il.parse(a)),
      {
        rewriteFileNames: {
          fileStartNumber: r || 0,
        },
        onProgress: n == null ? void 0 : n.onProgress,
      }
    );
  throw new Error(
    "NFT metadatas must all be of the same type (all URI or all NFTMetadataInput)"
  );
}
function Y0(t) {
  const e = t[0].substring(0, t[0].lastIndexOf("/"));
  for (let r = 0; r < t.length; r++) {
    const n = t[r].substring(0, t[r].lastIndexOf("/"));
    if (e !== n)
      throw new Error(
        `Can only create batches with the same base URI for every entry in the batch. Expected '${e}' but got '${n}'`
      );
  }
  return e.replace(/\/$/, "") + "/";
}
function Afe(t) {
  return t.find((e) => typeof e != "string") === void 0;
}
function kfe(t) {
  return t.find((e) => typeof e != "object") === void 0;
}
class CL {
  constructor(e, r, n, i) {
    oe(
      this,
      "createDelayedRevealBatch",
      be(async (e, r, n, i) => {
        if (!n) throw new Error("Password is required");
        const a = await this.storage.uploadBatch([il.parse(e)], {
            rewriteFileNames: {
              fileStartNumber: 0,
            },
          }),
          s = Y0(a),
          o = await this.nextTokenIdToMintFn(),
          c = await this.storage.uploadBatch(
            r.map((I) => il.parse(I)),
            {
              onProgress: i == null ? void 0 : i.onProgress,
              rewriteFileNames: {
                fileStartNumber: o.toNumber(),
              },
            }
          ),
          u = Y0(c),
          d = await this.contractWrapper.read("getBaseURICount", []),
          m = await this.hashDelayRevealPassword(d, n),
          v = await this.contractWrapper.read("encryptDecrypt", [Lt(u), m]);
        let E;
        if (await this.isLegacyContract()) E = v;
        else {
          const I = await this.contractWrapper.getChainID(),
            b = ha(["bytes", "bytes", "uint256"], [Lt(u), m, I]);
          E = xs.encode(["bytes", "bytes32"], [v, b]);
        }
        return ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "lazyMint",
          args: [c.length, s.endsWith("/") ? s : `${s}/`, E],
          parse: (I) => {
            const b = this.contractWrapper.parseLogs(
                "TokensLazyMinted",
                I == null ? void 0 : I.logs
              ),
              w = b[0].args.startTokenId,
              S = b[0].args.endTokenId,
              k = [];
            for (let N = w; N.lte(S); N = N.add(1))
              k.push({
                id: N,
                receipt: I,
              });
            return k;
          },
        });
      })
    );
    oe(
      this,
      "reveal",
      be(async (e, r) => {
        if (!r) throw new Error("Password is required");
        const n = await this.hashDelayRevealPassword(e, r);
        try {
          const i = await this.contractWrapper.callStatic().reveal(e, n);
          if (!i.includes("://") || !i.endsWith("/"))
            throw new Error("invalid password");
        } catch {
          throw new Error("invalid password");
        }
        return ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "reveal",
          args: [e, n],
        });
      })
    );
    (this.featureName = n),
      (this.nextTokenIdToMintFn = i),
      (this.contractWrapper = e),
      (this.storage = r);
  }
  async getBatchesToReveal() {
    const e = await this.contractWrapper.read("getBaseURICount", []);
    if (e.isZero()) return [];
    const r = Array.from(Array(e.toNumber()).keys()),
      n = await Promise.all(
        r.map((u) => {
          if (Kr("getBatchIdAtIndex", this.contractWrapper))
            return this.contractWrapper.read("getBatchIdAtIndex", [u]);
          if (Kr("baseURIIndices", this.contractWrapper))
            return this.contractWrapper.read("baseURIIndices", [u]);
          throw new Error(
            "Contract does not have getBatchIdAtIndex or baseURIIndices."
          );
        })
      ),
      i = n.slice(0, n.length - 1),
      a = await Promise.all(
        Array.from([0, ...i]).map((u) => this.getNftMetadata(u.toString()))
      ),
      s = await this.isLegacyContract(),
      c = (
        await Promise.all(
          Array.from([...n]).map((u) =>
            s
              ? this.getLegacyEncryptedData(u)
              : this.contractWrapper.read("encryptedData", [u])
          )
        )
      ).map((u) =>
        za(u) > 0 ? (s ? u : xs.decode(["bytes", "bytes32"], u)[0]) : u
      );
    return a
      .map((u, d) => ({
        batchId: ae.from(d),
        batchUri: u.uri,
        placeholderMetadata: u,
      }))
      .filter((u, d) => za(c[d]) > 0);
  }
  async hashDelayRevealPassword(e, r) {
    const n = await this.contractWrapper.getChainID(),
      i = this.contractWrapper.address;
    return ha(["string", "uint256", "uint256", "address"], [r, n, e, i]);
  }
  async getNftMetadata(e) {
    return Iv(
      this.contractWrapper.address,
      this.contractWrapper.getProvider(),
      e,
      this.storage
    );
  }
  async isLegacyContract() {
    if (Kr("contractVersion", this.contractWrapper))
      try {
        return (await this.contractWrapper.read("contractVersion", [])) <= 2;
      } catch {
        return !1;
      }
    return !1;
  }
  async getLegacyEncryptedData(e) {
    const n = await new Yt(
      this.contractWrapper.address,
      bce,
      this.contractWrapper.getProvider()
    ).functions.encryptedBaseURI(e);
    return n.length > 0 ? n[0] : "0x";
  }
}
function eb(t) {
  return {
    startTimestamp: t.startTimestamp,
    maxClaimableSupply: t.maxClaimableSupply,
    supplyClaimed: t.supplyClaimed,
    merkleRoot: t.merkleRoot,
    pricePerToken: t.pricePerToken,
    currency: t.currency,
    quantityLimitPerTransaction: t.maxClaimablePerWallet,
    waitTimeInSecondsBetweenClaims: t.waitTimeInSecondsBetweenClaims || 0,
  };
}
function tb(t) {
  return {
    startTimestamp: t.startTimestamp,
    maxClaimableSupply: t.maxClaimableSupply,
    supplyClaimed: t.supplyClaimed,
    merkleRoot: t.merkleRoot,
    pricePerToken: t.pricePerToken,
    currency: t.currency,
    quantityLimitPerWallet: t.maxClaimablePerWallet,
    metadata: t.metadata || "",
  };
}
function io(t, e) {
  return t === "unlimited" ? da : ya(t, e);
}
function mo(t) {
  return t.toLowerCase() === qi || t.toLowerCase() === Ft;
}
async function zm(t, e) {
  if (mo(e)) {
    const r = await t.getNetwork(),
      n = SF(r.chainId);
    return {
      name: n.name,
      symbol: n.symbol,
      decimals: n.decimals,
    };
  } else {
    const r = new Yt(e, eF, t),
      [n, i, a] = await Promise.all([r.name(), r.symbol(), r.decimals()]);
    return {
      name: n,
      symbol: i,
      decimals: a,
    };
  }
}
async function AL(t) {
  const r = Array.from(
      {
        length: Math.ceil(t.length / 25e3),
      },
      (i, a) => t.slice(a * 25e3, a * 25e3 + 25e3)
    ),
    n = [];
  for (const i of r) n.push(...(await ME.parseAsync(i)));
  return n;
}
const Sfe = 2;
let Eu = (function (t) {
  return (t[(t.V1 = 1)] = "V1"), (t[(t.V2 = 2)] = "V2"), t;
})({});
class Na {
  constructor(e, r, n, i, a) {
    (this.storage = e),
      (this.shardNybbles = i),
      (this.baseUri = r),
      (this.originalEntriesUri = n),
      (this.tokenDecimals = a),
      (this.shards = {}),
      (this.trees = {});
  }
  static async fromUri(e, r) {
    try {
      const n = await r.downloadJSON(e);
      if (n.isShardedMerkleTree) return Na.fromShardedMerkleTreeInfo(n, r);
    } catch {
      return;
    }
  }
  static async fromShardedMerkleTreeInfo(e, r) {
    return new Na(
      r,
      e.baseUri,
      e.originalEntriesUri,
      e.shardNybbles,
      e.tokenDecimals
    );
  }
  static hashEntry(e, r, n, i) {
    switch (i) {
      case Eu.V1:
        return ha(["address", "uint256"], [e.address, io(e.maxClaimable, r)]);
      case Eu.V2:
        return ha(
          ["address", "uint256", "uint256", "address"],
          [
            e.address,
            io(e.maxClaimable, r),
            io(e.price || "unlimited", n),
            e.currencyAddress || Ft,
          ]
        );
    }
  }
  static async fetchAndCacheDecimals(e, r, n) {
    if (!n) return 18;
    let i = e[n];
    return i === void 0 && ((i = (await zm(r, n)).decimals), (e[n] = i)), i;
  }
  static async buildAndUpload(e, r, n, i, a) {
    let s =
      arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : Sfe;
    const o = await AL(e),
      c = {};
    for (const k of o) {
      const N = k.address.slice(2, 2 + s).toLowerCase();
      c[N] === void 0 && (c[N] = []), c[N].push(k);
    }
    const u = {},
      d = await Promise.all(
        Object.entries(c).map(async (k) => {
          let [N, O] = k;
          return [
            N,
            new Xy.MerkleTree(
              await Promise.all(
                O.map(async (F) => {
                  const V = await Na.fetchAndCacheDecimals(
                    u,
                    n,
                    F.currencyAddress
                  );
                  return Na.hashEntry(F, r, V, a);
                })
              ),
              Ut,
              {
                sort: !0,
              }
            ).getHexRoot(),
          ];
        })
      ),
      m = Object.fromEntries(d),
      v = new Xy.MerkleTree(Object.values(m), Ut, {
        sort: !0,
      }),
      E = [];
    for (const [k, N] of Object.entries(c)) {
      const O = {
        proofs: v.getProof(m[k]).map((F) => "0x" + F.data.toString("hex")),
        entries: N,
      };
      E.push({
        data: JSON.stringify(O),
        name: `${k}.json`,
      });
    }
    const A = await i.uploadBatch(E),
      I = A[0].slice(0, A[0].lastIndexOf("/")),
      b = await i.upload(o),
      w = {
        merkleRoot: v.getHexRoot(),
        baseUri: I,
        originalEntriesUri: b,
        shardNybbles: s,
        tokenDecimals: r,
        isShardedMerkleTree: !0,
      },
      S = await i.upload(w);
    return {
      shardedMerkleInfo: w,
      uri: S,
    };
  }
  async getProof(e, r, n) {
    const i = e.slice(2, 2 + this.shardNybbles).toLowerCase();
    let a = this.shards[i];
    const s = {};
    if (a === void 0)
      try {
        a = this.shards[i] = await this.storage.downloadJSON(
          `${this.baseUri}/${i}.json`
        );
        const m = await Promise.all(
          a.entries.map(async (v) => {
            const E = await Na.fetchAndCacheDecimals(s, r, v.currencyAddress);
            return Na.hashEntry(v, this.tokenDecimals, E, n);
          })
        );
        this.trees[i] = new Xy.MerkleTree(m, Ut, {
          sort: !0,
        });
      } catch {
        return null;
      }
    const o = a.entries.find(
      (m) => m.address.toLowerCase() === e.toLowerCase()
    );
    if (!o) return null;
    const c = await Na.fetchAndCacheDecimals(s, r, o.currencyAddress),
      u = Na.hashEntry(o, this.tokenDecimals, c, n),
      d = this.trees[i].getProof(u).map((m) => "0x" + m.data.toString("hex"));
    return MF.parseAsync({
      ...o,
      proof: d.concat(a.proofs),
    });
  }
  async getAllEntries() {
    try {
      return await this.storage.downloadJSON(this.originalEntriesUri);
    } catch (e) {
      return console.warn("Could not fetch original snapshot entries", e), [];
    }
  }
}
async function VE(t, e, r, n, i, a) {
  if (!r) return null;
  const s = r[e];
  if (s) {
    const o = await i.downloadJSON(s);
    if (o.isShardedMerkleTree && o.merkleRoot === e)
      return await (await Na.fromShardedMerkleTreeInfo(o, i)).getProof(t, n, a);
    const c = await IF.parseAsync(o);
    if (e === c.merkleRoot)
      return (
        c.claims.find((u) => u.address.toLowerCase() === t.toLowerCase()) ||
        null
      );
  }
  return null;
}
function rb(t) {
  return {
    startTimestamp: t.startTimestamp,
    maxClaimableSupply: t.maxClaimableSupply,
    supplyClaimed: t.supplyClaimed,
    merkleRoot: t.merkleRoot.toString(),
    pricePerToken: t.pricePerToken,
    currency: t.currency,
    maxClaimablePerWallet: t.quantityLimitPerTransaction,
    waitTimeInSecondsBetweenClaims: t.waitTimeInSecondsBetweenClaims,
  };
}
function nb(t) {
  return {
    startTimestamp: t.startTimestamp,
    maxClaimableSupply: t.maxClaimableSupply,
    supplyClaimed: t.supplyClaimed,
    merkleRoot: t.merkleRoot.toString(),
    pricePerToken: t.pricePerToken,
    currency: t.currency,
    maxClaimablePerWallet: t.quantityLimitPerWallet,
    waitTimeInSecondsBetweenClaims: 0,
    metadata: t.metadata,
  };
}
class Ed extends Mf {
  constructor(e, r) {
    super();
    try {
      this.options = M_.parse(r);
    } catch (a) {
      console.error(
        "invalid sdk options object passed, falling back to default options",
        a
      ),
        (this.options = M_.parse({}));
    }
    const [n, i] = Jn(e, this.options);
    (this.network = e), (this.signer = n), (this.provider = i);
  }
  updateSignerOrProvider(e) {
    const [r, n] = Jn(e, this.options);
    (this.network = e), (this.signer = r), (this.provider = n);
  }
  isReadOnly() {
    return !AE(this.signer);
  }
  getSigner() {
    return this.signer;
  }
  getProvider() {
    return this.provider;
  }
  getSignerOrProvider() {
    return this.getSigner() || this.getProvider();
  }
}
class Gn extends Ed {
  constructor(r, n, i, a, s) {
    super(r, a);
    oe(this, "isValidContract", !1);
    oe(this, "customOverrides", () => ({}));
    (this.abi = i),
      (this.address = n),
      (this.writeContract = new Yt(n, i, this.getSignerOrProvider())),
      (this.readContract = this.writeContract.connect(this.getProvider())),
      (this.storage = s);
  }
  updateSignerOrProvider(r) {
    super.updateSignerOrProvider(r),
      (this.writeContract = this.writeContract.connect(
        this.getSignerOrProvider()
      )),
      (this.readContract = this.writeContract.connect(this.getProvider()));
  }
  updateAbi(r) {
    (this.writeContract = new Yt(this.address, r, this.getSignerOrProvider())),
      (this.readContract = this.writeContract.connect(this.getProvider())),
      (this.abi = Gt.parse(r));
  }
  async getChainID() {
    const r = this.getProvider(),
      { chainId: n } = await r.getNetwork();
    return n;
  }
  async getSignerAddress() {
    const r = this.getSigner();
    if (!r)
      throw new Error(
        "This action requires a connected wallet to sign the transaction. Please pass a valid signer to the SDK."
      );
    return await r.getAddress();
  }
  callStatic() {
    return this.writeContract.callStatic;
  }
  async getCallOverrides() {
    return $E(this.getProvider());
  }
  emitTransactionEvent(r, n) {
    this.emit(ia.Transaction, {
      status: r,
      transactionHash: n,
    });
  }
  async multiCall(r) {
    return this.sendTransaction("multicall", [r]);
  }
  async estimateGas(r, n) {
    return this.writeContract.estimateGas[r](...n);
  }
  withTransactionOverride(r) {
    this.customOverrides = r;
  }
  async read(r, n) {
    const i = Pf(Gt.parse(this.abi)).filter((c) => c.name === r);
    if (!i.length)
      throw new Error(
        `Function "${r.toString()}" not found in contract. Check your dashboard for the list of functions available`
      );
    const a = i.find((c) => c.name === r && c.inputs.length === n.length);
    if (!a)
      throw new Error(`Function "${r.toString()}" requires ${
        i[0].inputs.length
      } arguments, but ${n.length} were provided.
Expected function signature: ${i[0].signature}`);
    const s = `${r.toString()}(${a.inputs.map((c) => c.type).join()})`,
      o = s in this.readContract.functions ? s : r;
    if (a.stateMutability === "view" || a.stateMutability === "pure")
      return await this.readContract[o.toString()](...n);
    throw new Error("Cannot call a write function with read()");
  }
  async call(r) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [],
      i = arguments.length > 2 ? arguments[2] : void 0;
    const a = i ? await jue.parseAsync(i) : void 0,
      s = Pf(Gt.parse(this.abi)).filter((d) => d.name === r);
    if (!s.length)
      throw new Error(
        `Function "${r}" not found in contract. Check your dashboard for the list of functions available`
      );
    const o = s.find((d) => d.name === r && d.inputs.length === n.length);
    if (!o)
      throw new Error(`Function "${r}" requires ${s[0].inputs.length} arguments, but ${n.length} were provided.
Expected function signature: ${s[0].signature}`);
    const c = `${r}(${o.inputs.map((d) => d.type).join()})`,
      u = c in this.readContract.functions ? c : r;
    return o.stateMutability === "view" || o.stateMutability === "pure"
      ? a
        ? this.readContract[u](...n, a)
        : this.readContract[u](...n)
      : {
          receipt: await this.sendTransaction(u, n, a),
        };
  }
  async sendTransaction(r, n, i) {
    var a;
    if (
      (i || (i = await this.getCallOverrides()),
      (i = {
        ...i,
        ...this.customOverrides(),
      }),
      (this.customOverrides = () => ({})),
      (a = this.options) != null &&
        a.gasless &&
        ("openzeppelin" in this.options.gasless ||
          "biconomy" in this.options.gasless))
    ) {
      if (r === "multicall" && Array.isArray(n[0]) && n[0].length > 0) {
        const u = await this.getSignerAddress();
        n[0] = n[0].map((d) => rl(["bytes", "address"], [d, u]));
      }
      const s = this.getProvider(),
        o = await this.sendGaslessTransaction(r, n, i);
      this.emitTransactionEvent("submitted", o);
      const c = await s.waitForTransaction(o);
      return this.emitTransactionEvent("completed", o), c;
    } else {
      if (!this.isValidContract) {
        const c = await this.getProvider().getCode(this.address);
        if (((this.isValidContract = c !== "0x"), !this.isValidContract))
          throw new Error(
            "The address you're trying to send a transaction to is not a smart contract. Make sure you are on the correct network and the contract address is correct"
          );
      }
      const s = await this.sendTransactionByFunction(r, n, i);
      this.emitTransactionEvent("submitted", s.hash);
      let o;
      try {
        o = await s.wait();
      } catch (c) {
        try {
          await this.writeContract.callStatic[r](
            ...n,
            ...(i.value
              ? [
                  {
                    value: i.value,
                  },
                ]
              : [])
          );
        } catch (u) {
          throw await this.formatError(u, r, n, i);
        }
        throw await this.formatError(c, r, n, i);
      }
      return this.emitTransactionEvent("completed", s.hash), o;
    }
  }
  async sendTransactionByFunction(r, n, i) {
    const a = this.writeContract.functions[r];
    if (!a) throw new Error(`invalid function: "${r.toString()}"`);
    if (!i.gasLimit)
      try {
        i.gasLimit = await this.writeContract.estimateGas[r](...n, i);
      } catch {
        try {
          await this.writeContract.callStatic[r](
            ...n,
            ...(i.value
              ? [
                  {
                    value: i.value,
                  },
                ]
              : [])
          );
        } catch (o) {
          throw await this.formatError(o, r, n, i);
        }
      }
    try {
      return await a(...n, i);
    } catch (s) {
      throw await this.formatError(s, r, n, i);
    }
  }
  async formatError(r, n, i, a) {
    var O, F, V;
    const s = this.getProvider(),
      o = await s.getNetwork(),
      c = await (a.from || this.getSignerAddress()),
      u = this.address,
      d = this.readContract.interface.encodeFunctionData(n, i),
      m = ae.from(a.value || 0),
      v = (O = s.connection) == null ? void 0 : O.url,
      E = this.readContract.interface.getFunction(n),
      A = i.map((j) =>
        JSON.stringify(j).length <= 80
          ? JSON.stringify(j)
          : JSON.stringify(j, void 0, 2)
      ),
      I =
        A.join(", ").length <= 80
          ? A.join(", ")
          : `
` +
            A.map(
              (j) =>
                "  " +
                j.split(`
`).join(`
  `)
            ).join(`,
`) +
            `
`,
      b = `${E.name}(${I})`,
      w =
        r.transactionHash ||
        ((F = r.transaction) == null ? void 0 : F.hash) ||
        ((V = r.receipt) == null ? void 0 : V.transactionHash),
      S = BE(r);
    let k, N;
    try {
      const j = await Ai(
        this.address,
        this.getProvider(),
        this.storage,
        this.options
      );
      j.name && (N = j.name),
        j.metadata.sources && (k = await Av(j, this.storage));
    } catch {}
    return new NE(
      {
        reason: S,
        from: c,
        to: u,
        method: b,
        data: d,
        network: o,
        rpcUrl: v,
        value: m,
        hash: w,
        contractName: N,
        sources: k,
      },
      r
    );
  }
  async sendGaslessTransaction(r) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [],
      i = arguments.length > 2 ? arguments[2] : void 0;
    const a = this.getSigner();
    Je(a);
    const s = await this.getChainID(),
      o = await this.getSignerAddress(),
      c = this.writeContract.address,
      u = (i == null ? void 0 : i.value) || 0;
    if (ae.from(u).gt(0))
      throw new Error(
        "Cannot send native token value with gasless transaction"
      );
    const d = this.writeContract.interface.encodeFunctionData(r, n);
    let m = ae.from(0);
    try {
      m = (await this.readContract.estimateGas[r](...n)).mul(2);
    } catch {}
    m.lt(1e5) && (m = ae.from(5e5)),
      i.gasLimit && ae.from(i.gasLimit).gt(m) && (m = ae.from(i.gasLimit));
    const v = {
      from: o,
      to: c,
      data: d,
      chainId: s,
      gasLimit: m,
      functionName: r.toString(),
      functionArgs: n,
      callOverrides: i,
    };
    return await this.defaultGaslessSendFunction(v);
  }
  async signTypedData(r, n, i, a) {
    this.emit(ia.Signature, {
      status: "submitted",
      message: a,
      signature: "",
    });
    const { signature: s } = await sm(r, n, i, a);
    return (
      this.emit(ia.Signature, {
        status: "completed",
        message: a,
        signature: s,
      }),
      s
    );
  }
  parseLogs(r, n) {
    if (!n || n.length === 0) return [];
    const i = this.writeContract.interface.getEventTopic(r);
    return n
      .filter((s) => s.topics.indexOf(i) >= 0)
      .map((s) => this.writeContract.interface.parseLog(s));
  }
  async defaultGaslessSendFunction(r) {
    return this.options.gasless && "biconomy" in this.options.gasless
      ? this.biconomySendFunction(r)
      : this.defenderSendFunction(r);
  }
  async biconomySendFunction(r) {
    var v, E;
    Je(this.options.gasless && "biconomy" in this.options.gasless);
    const n = this.getSigner(),
      i = this.getProvider();
    Je(n && i);
    const a = new Yt(Q2(r.chainId, "biconomyForwarder"), xL, i),
      s = 0,
      o = await X2(a, "getNonce", [r.from, s]),
      c = {
        from: r.from,
        to: r.to,
        token: Ft,
        txGas: r.gasLimit.toNumber(),
        tokenGasPrice: "0",
        batchId: s,
        batchNonce: o.toNumber(),
        deadline: Math.floor(
          Date.now() / 1e3 +
            ((((v = this.options) == null ? void 0 : v.gasless) &&
              "biconomy" in this.options.gasless &&
              ((E = this.options.gasless.biconomy) == null
                ? void 0
                : E.deadlineSeconds)) ||
              3600)
        ),
        data: r.data,
      },
      u = qe(
        ha(
          [
            "address",
            "address",
            "address",
            "uint256",
            "uint256",
            "uint256",
            "uint256",
            "uint256",
            "bytes32",
          ],
          [
            c.from,
            c.to,
            c.token,
            c.txGas,
            c.tokenGasPrice,
            c.batchId,
            c.batchNonce,
            c.deadline,
            Ut(c.data),
          ]
        )
      );
    this.emit(ia.Signature, {
      status: "submitted",
      message: u,
      signature: "",
    });
    const d = await n.signMessage(u);
    this.emit(ia.Signature, {
      status: "completed",
      message: u,
      signature: d,
    });
    const m = await _s("https://api.biconomy.io/api/v2/meta-tx/native", {
      method: "POST",
      body: JSON.stringify({
        from: r.from,
        apiId: this.options.gasless.biconomy.apiId,
        params: [c, d],
        to: r.to,
        gasLimit: r.gasLimit.toHexString(),
      }),
      headers: {
        "x-api-key": this.options.gasless.biconomy.apiKey,
        "Content-Type": "application/json;charset=utf-8",
      },
    });
    if (m.ok) {
      const A = await m.json();
      if (!A.txHash) throw new Error(`relay transaction failed: ${A.log}`);
      return A.txHash;
    }
    throw new Error(
      `relay transaction failed with status: ${m.status} (${m.statusText})`
    );
  }
  async defenderSendFunction(r) {
    Je(this.options.gasless && "openzeppelin" in this.options.gasless);
    const n = this.getSigner(),
      i = this.getProvider();
    Je(n), Je(i);
    const a =
        this.options.gasless.openzeppelin.relayerForwarderAddress ||
        (this.options.gasless.openzeppelin.useEOAForwarder
          ? wu[r.chainId].openzeppelinForwarderEOA ||
            (await gL(
              this.getProvider(),
              this.storage,
              "",
              this.options.clientId,
              this.options.secretKey
            ))
          : wu[r.chainId].openzeppelinForwarder ||
            (await HE(
              this.getProvider(),
              this.storage,
              "",
              this.options.clientId,
              this.options.secretKey
            ))),
      s = new Yt(a, xF, i),
      o = await X2(s, "getNonce", [r.from]);
    let c, u, d;
    this.options.gasless.experimentalChainlessSupport
      ? ((c = {
          name: "GSNv2 Forwarder",
          version: "0.0.1",
          verifyingContract: a,
        }),
        (u = {
          ForwardRequest: vL,
        }),
        (d = {
          from: r.from,
          to: r.to,
          value: ae.from(0).toString(),
          gas: ae.from(r.gasLimit).toString(),
          nonce: ae.from(o).toString(),
          data: r.data,
          chainid: ae.from(r.chainId).toString(),
        }))
      : ((c = {
          name: this.options.gasless.openzeppelin.domainName,
          version: this.options.gasless.openzeppelin.domainVersion,
          chainId: r.chainId,
          verifyingContract: a,
        }),
        (u = {
          ForwardRequest: bL,
        }),
        (d = {
          from: r.from,
          to: r.to,
          value: ae.from(0).toString(),
          gas: ae.from(r.gasLimit).toString(),
          nonce: ae.from(o).toString(),
          data: r.data,
        }));
    let m;
    if (
      (this.emit(ia.Signature, {
        status: "submitted",
        message: d,
        signature: "",
      }),
      r.functionName === "approve" && r.functionArgs.length === 2)
    ) {
      const I = r.functionArgs[0],
        b = r.functionArgs[1],
        { message: w, signature: S } = await wL(
          n,
          this.writeContract.address,
          r.from,
          I,
          b
        ),
        { r: k, s: N, v: O } = yo(S);
      (d = {
        to: this.address,
        owner: w.owner,
        spender: w.spender,
        value: ae.from(w.value).toString(),
        nonce: ae.from(w.nonce).toString(),
        deadline: ae.from(w.deadline).toString(),
        r: k,
        s: N,
        v: O,
      }),
        (m = S);
    } else {
      const { signature: I } = await sm(n, c, u, d);
      m = I;
    }
    let v = "forward";
    d != null && d.owner && (v = "permit");
    const E = JSON.stringify({
      request: d,
      signature: m,
      forwarderAddress: a,
      type: v,
    });
    this.emit(ia.Signature, {
      status: "completed",
      message: d,
      signature: m,
    });
    const A = await _s(this.options.gasless.openzeppelin.relayerUrl, {
      method: "POST",
      body: E,
    });
    if (A.ok) {
      const I = await A.json();
      if (!I.result) throw new Error(`Relay transaction failed: ${I.message}`);
      return JSON.parse(I.result).txHash;
    }
    throw new Error(
      `relay transaction failed with status: ${A.status} (${A.statusText})`
    );
  }
}
async function kL(t, e, r, n, i) {
  const a = t.getSigner(),
    s = t.getProvider(),
    o = new Gn(a || s, e, Ri, t.options, t.storage),
    c = await t.getSignerAddress(),
    u = t.address,
    d = await o.read("allowance", [c, u]),
    m = ae.from(r).mul(ae.from(n)).div(ya("1", i));
  d.lt(m) && (await o.sendTransaction("approve", [u, d.add(m)]));
}
async function pi(t, e, r) {
  const n = await zm(t, r);
  return ya(Gi.parse(e), n.decimals);
}
async function SL(t, e, r, n, i, a, s, o, c) {
  let u = io(r.maxClaimablePerWallet, i),
    d = [Rt([0], 32)],
    m = r.price,
    v = r.currencyAddress;
  try {
    if (!r.merkleRootHash.toString().startsWith(Ft)) {
      const b = await VE(
        t,
        r.merkleRootHash.toString(),
        await n(),
        a.getProvider(),
        s,
        c
      );
      if (b)
        (d = b.proof),
          (u = b.maxClaimable === "unlimited" ? da : ya(b.maxClaimable, i)),
          (m =
            b.price === void 0 || b.price === "unlimited"
              ? da
              : await pi(a.getProvider(), b.price, b.currencyAddress || Ft)),
          (v = b.currencyAddress || Ft);
      else if (c === Eu.V1) throw new Error("No claim found for this address");
    }
  } catch (b) {
    if ((b == null ? void 0 : b.message) === "No claim found for this address")
      throw b;
    console.warn(
      "failed to check claim condition merkle root hash, continuing anyways",
      b
    );
  }
  const E = (await a.getCallOverrides()) || {},
    A = m.toString() !== da.toString() ? m : r.price,
    I = v !== Ft ? v : r.currencyAddress;
  return (
    A.gt(0) &&
      (mo(I)
        ? (E.value = ae.from(A).mul(e).div(ya("1", i)))
        : o && (await kL(a, I, A, e, i))),
    {
      overrides: E,
      proofs: d,
      maxClaimable: u,
      price: A,
      currencyAddress: I,
      priceInProof: m,
      currencyAddressInProof: v,
    }
  );
}
async function Mfe(t, e, r, n, i) {
  const a = await AL(t),
    s = a.map((u) => u.address);
  if (new Set(s).size < s.length) throw new zue();
  const c = await Na.buildAndUpload(a, e, r, n, i);
  return {
    merkleRoot: c.shardedMerkleInfo.merkleRoot,
    snapshotUri: c.uri,
  };
}
function Ife(t, e) {
  const r = ae.from(t),
    n = ae.from(e);
  return r.eq(n) ? 0 : r.gt(n) ? 1 : -1;
}
async function Rfe(t, e, r, n, i) {
  const a = [];
  return {
    inputsWithSnapshots: await Promise.all(
      t.map(async (o) => {
        if (o.snapshot && o.snapshot.length > 0) {
          const c = await Mfe(o.snapshot, e, r, n, i);
          a.push(c), (o.merkleRootHash = c.merkleRoot);
        } else o.merkleRootHash = Rt([0], 32);
        return o;
      })
    ),
    snapshotInfos: a,
  };
}
async function Pfe(t, e, r, n) {
  const i = t.currencyAddress === Ft ? qi : t.currencyAddress,
    a = io(t.maxClaimableSupply, e),
    s = io(t.maxClaimablePerWallet, e);
  let o;
  return (
    t.metadata &&
      (typeof t.metadata == "string"
        ? (o = t.metadata)
        : (o = await n.upload(t.metadata))),
    {
      startTimestamp: t.startTime,
      maxClaimableSupply: a,
      supplyClaimed: 0,
      maxClaimablePerWallet: s,
      pricePerToken: await pi(r, t.price, i),
      currency: i,
      merkleRoot: t.merkleRootHash.toString(),
      waitTimeInSecondsBetweenClaims: t.waitInSeconds || 0,
      metadata: o,
    }
  );
}
async function ML(t, e, r, n, i) {
  const { inputsWithSnapshots: a, snapshotInfos: s } = await Rfe(t, e, r, n, i),
    o = await pue.parseAsync(a),
    c = (await Promise.all(o.map((u) => Pfe(u, e, r, n)))).sort((u, d) =>
      Ife(u.startTimestamp, d.startTimestamp)
    );
  return {
    snapshotInfos: s,
    sortedConditions: c,
  };
}
async function hs(t, e, r) {
  const n = await zm(t, e);
  return {
    ...n,
    value: ae.from(r),
    displayValue: nl(r, n.decimals),
  };
}
async function Nfe(t, e, r) {
  if (!e) return null;
  const n = e[t];
  if (n) {
    const i = await r.downloadJSON(n);
    if (i.isShardedMerkleTree && i.merkleRoot === t) {
      const a = await Na.fromUri(n, r);
      return (a == null ? void 0 : a.getAllEntries()) || null;
    } else {
      const a = await IF.parseAsync(i);
      if (t === a.merkleRoot)
        return a.claims.map((s) => ({
          address: s.address,
          maxClaimable: s.maxClaimable,
          price: s.price,
          currencyAddress: s.currencyAddress,
        }));
    }
  }
  return null;
}
function ly(t, e) {
  return t.toString() === da.toString() ? "unlimited" : nl(t, e);
}
async function ib(t, e, r, n, i, a) {
  var v;
  const s = await hs(r, t.currency, t.pricePerToken),
    o = ly(t.maxClaimableSupply, e),
    c = ly(t.maxClaimablePerWallet, e),
    u = ly(ae.from(t.maxClaimableSupply).sub(t.supplyClaimed), e),
    d = ly(t.supplyClaimed, e);
  let m;
  return (
    t.metadata && (m = await i.downloadJSON(t.metadata)),
    RF.parseAsync({
      startTime: t.startTimestamp,
      maxClaimableSupply: o,
      maxClaimablePerWallet: c,
      currentMintSupply: d,
      availableSupply: u,
      waitInSeconds:
        (v = t.waitTimeInSecondsBetweenClaims) == null ? void 0 : v.toString(),
      price: ae.from(t.pricePerToken),
      currency: t.currency,
      currencyAddress: t.currency,
      currencyMetadata: s,
      merkleRootHash: t.merkleRoot,
      snapshot: a ? await Nfe(t.merkleRoot, n, i) : void 0,
      metadata: m,
    })
  );
}
async function IL(t, e, r) {
  if (t >= r.length)
    throw Error(
      `Index out of bounds - got index: ${t} with ${r.length} conditions`
    );
  const n = r[t].currencyMetadata.decimals,
    i = r[t].price,
    a = nl(i, n),
    s = await IE.parseAsync({
      ...r[t],
      price: a,
      ...e,
    }),
    o = await RF.parseAsync({
      ...s,
      price: i,
    });
  return r.map((c, u) => {
    let d;
    u === t ? (d = o) : (d = c);
    const m = nl(d.price, n);
    return {
      ...d,
      price: m,
    };
  });
}
let zn = (function (t) {
    return (
      (t[(t.UNSET = 0)] = "UNSET"),
      (t[(t.Created = 1)] = "Created"),
      (t[(t.Completed = 2)] = "Completed"),
      (t[(t.Cancelled = 3)] = "Cancelled"),
      (t[(t.Active = 4)] = "Active"),
      (t[(t.Expired = 5)] = "Expired"),
      t
    );
  })({}),
  Mt = (function (t) {
    return (
      (t.NotEnoughSupply = "There is not enough supply to claim."),
      (t.AddressNotAllowed = "This address is not on the allowlist."),
      (t.WaitBeforeNextClaimTransaction =
        "Not enough time since last claim transaction. Please wait."),
      (t.ClaimPhaseNotStarted = "Claim phase has not started yet."),
      (t.AlreadyClaimed = "You have already claimed the token."),
      (t.WrongPriceOrCurrency = "Incorrect price or currency."),
      (t.OverMaxClaimablePerWallet =
        "Cannot claim more than maximum allowed quantity."),
      (t.NotEnoughTokens =
        "There are not enough tokens in the wallet to pay for the claim."),
      (t.NoActiveClaimPhase =
        "There is no active claim phase at the moment. Please check back in later."),
      (t.NoClaimConditionSet = "There is no claim condition set."),
      (t.NoWallet = "No wallet connected."),
      (t.Unknown = "No claim conditions found."),
      t
    );
  })({});
class RL {
  constructor(e, r, n) {
    oe(
      this,
      "set",
      be(
        (() => {
          var e = this;
          return async function (r) {
            let n =
                arguments.length > 1 && arguments[1] !== void 0
                  ? arguments[1]
                  : !1,
              i = r;
            if (
              e.isLegacySinglePhaseDrop(e.contractWrapper) ||
              e.isNewSinglePhaseDrop(e.contractWrapper)
            ) {
              if (((n = !0), r.length === 0))
                i = [
                  {
                    startTime: new Date(0),
                    currencyAddress: Ft,
                    price: 0,
                    maxClaimableSupply: 0,
                    maxClaimablePerWallet: 0,
                    waitInSeconds: 0,
                    merkleRootHash: Rt([0], 32),
                    snapshot: [],
                  },
                ];
              else if (r.length > 1)
                throw new Error(
                  "Single phase drop contract cannot have multiple claim conditions, only one is allowed"
                );
            }
            (e.isNewSinglePhaseDrop(e.contractWrapper) ||
              e.isNewMultiphaseDrop(e.contractWrapper)) &&
              i.forEach((v) => {
                var E;
                if (
                  v.snapshot &&
                  v.snapshot.length > 0 &&
                  (v.maxClaimablePerWallet === void 0 ||
                    v.maxClaimablePerWallet === "unlimited")
                )
                  throw new Error(`maxClaimablePerWallet must be set to a specific value when an allowlist is set.
Example: Set it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.
contract.claimConditions.set([{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])`);
                if (
                  v.snapshot &&
                  v.snapshot.length > 0 &&
                  ((E = v.maxClaimablePerWallet) == null
                    ? void 0
                    : E.toString()) === "0" &&
                  v.snapshot
                    .map((A) => {
                      var I;
                      return typeof A == "string"
                        ? 0
                        : Number(
                            ((I = A.maxClaimable) == null
                              ? void 0
                              : I.toString()) || 0
                          );
                    })
                    .reduce((A, I) => A + I, 0) === 0
                )
                  throw new Error(
                    "maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim."
                  );
              });
            const { snapshotInfos: a, sortedConditions: s } = await ML(
                i,
                await e.getTokenDecimals(),
                e.contractWrapper.getProvider(),
                e.storage,
                e.getSnapshotFormatVersion()
              ),
              o = {};
            a.forEach((v) => {
              o[v.merkleRoot] = v.snapshotUri;
            });
            const c = await e.metadata.get(),
              u = [];
            if (!tF(c.merkle, o)) {
              const v = await e.metadata.parseInputMetadata({
                  ...c,
                  merkle: o,
                }),
                E = await e.metadata._parseAndUploadMetadata(v);
              if (Kr("setContractURI", e.contractWrapper)) {
                const A = new Sr(e.contractWrapper);
                u.push(A.encode("setContractURI", [E]));
              } else
                throw new Error(
                  "Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root."
                );
            }
            const d = e.contractWrapper,
              m = new Sr(d);
            if (e.isLegacySinglePhaseDrop(d)) {
              const v = new Sr(d);
              u.push(v.encode("setClaimConditions", [eb(s[0]), n]));
            } else if (e.isLegacyMultiPhaseDrop(d))
              u.push(m.encode("setClaimConditions", [s.map(eb), n]));
            else if (e.isNewSinglePhaseDrop(d))
              u.push(m.encode("setClaimConditions", [tb(s[0]), n]));
            else if (e.isNewMultiphaseDrop(d))
              u.push(m.encode("setClaimConditions", [s.map(tb), n]));
            else throw new Error("Contract does not support claim conditions");
            if (Kr("multicall", e.contractWrapper))
              return ze.fromContractWrapper({
                contractWrapper: e.contractWrapper,
                method: "multicall",
                args: [u],
              });
            throw new Error("Contract does not support multicall");
          };
        })()
      )
    );
    oe(
      this,
      "update",
      be(async (e, r) => {
        const n = await this.getAll(),
          i = await IL(e, r, n);
        return await this.set.prepare(i);
      })
    );
    (this.storage = n), (this.contractWrapper = e), (this.metadata = r);
  }
  async getActive(e) {
    const r = await this.get(),
      n = await this.metadata.get();
    return await ib(
      r,
      await this.getTokenDecimals(),
      this.contractWrapper.getProvider(),
      n.merkle || {},
      this.storage,
      (e == null ? void 0 : e.withAllowList) || !1
    );
  }
  async get(e) {
    if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
      const r = await this.contractWrapper.read("claimCondition", []);
      return rb(r);
    } else if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
      const r =
          e !== void 0
            ? e
            : await this.contractWrapper.read("getActiveClaimConditionId", []),
        n = await this.contractWrapper.read("getClaimConditionById", [r]);
      return rb(n);
    } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {
      const r = await this.contractWrapper.read("claimCondition", []);
      return nb(r);
    } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {
      const r =
          e !== void 0
            ? e
            : await this.contractWrapper.read("getActiveClaimConditionId", []),
        n = await this.contractWrapper.read("getClaimConditionById", [r]);
      return nb(n);
    } else throw new Error("Contract does not support claim conditions");
  }
  async getAll(e) {
    if (
      this.isLegacyMultiPhaseDrop(this.contractWrapper) ||
      this.isNewMultiphaseDrop(this.contractWrapper)
    ) {
      const [r, n] = await this.contractWrapper.read("claimCondition", []),
        i = r.toNumber(),
        a = n.toNumber(),
        s = [];
      for (let d = i; d < i + a; d++) s.push(this.get(d));
      const [o, c, ...u] = await Promise.all([
        this.metadata.get(),
        this.getTokenDecimals(),
        ...s,
      ]);
      return Promise.all(
        u.map((d) =>
          ib(
            d,
            c,
            this.contractWrapper.getProvider(),
            o.merkle,
            this.storage,
            (e == null ? void 0 : e.withAllowList) || !1
          )
        )
      );
    } else return [await this.getActive(e)];
  }
  async canClaim(e, r) {
    return (
      r && (r = await Se(r)),
      (await this.getClaimIneligibilityReasons(e, r)).length === 0
    );
  }
  async getClaimIneligibilityReasons(e, r) {
    const n = [];
    let i, a;
    const s = await this.getTokenDecimals(),
      o = ya(Gi.parse(e), s);
    if (r === void 0)
      try {
        r = await this.contractWrapper.getSignerAddress();
      } catch (v) {
        console.warn("failed to get signer address", v);
      }
    if (!r) return [Mt.NoWallet];
    const c = await Se(r);
    try {
      a = await this.getActive();
    } catch (v) {
      return h2(v, "!CONDITION") || h2(v, "no active mint condition")
        ? (n.push(Mt.NoClaimConditionSet), n)
        : (console.warn("failed to get active claim condition", v),
          n.push(Mt.Unknown),
          n);
    }
    if (a.availableSupply !== "unlimited" && ya(a.availableSupply, s).lt(o))
      return n.push(Mt.NotEnoughSupply), n;
    const d = zi(a.merkleRootHash).length > 0;
    let m = null;
    if (d) {
      if (
        ((m = await this.getClaimerProofs(c)),
        !m &&
          (this.isLegacySinglePhaseDrop(this.contractWrapper) ||
            this.isLegacyMultiPhaseDrop(this.contractWrapper)))
      )
        return n.push(Mt.AddressNotAllowed), n;
      if (m)
        try {
          const v = await this.prepareClaim(e, !1, s, c);
          let E;
          if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
            if (
              ((i = await this.contractWrapper.read(
                "getActiveClaimConditionId",
                []
              )),
              ([E] = await this.contractWrapper.read("verifyClaimMerkleProof", [
                i,
                c,
                e,
                v.proofs,
                v.maxClaimable,
              ])),
              !E)
            )
              return n.push(Mt.AddressNotAllowed), n;
          } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
            if (
              (([E] = await this.contractWrapper.read(
                "verifyClaimMerkleProof",
                [
                  c,
                  e,
                  {
                    proof: v.proofs,
                    maxQuantityInAllowlist: v.maxClaimable,
                  },
                ]
              )),
              !E)
            )
              return n.push(Mt.AddressNotAllowed), n;
          } else
            this.isNewSinglePhaseDrop(this.contractWrapper)
              ? await this.contractWrapper.read("verifyClaim", [
                  c,
                  e,
                  v.currencyAddress,
                  v.price,
                  {
                    proof: v.proofs,
                    quantityLimitPerWallet: v.maxClaimable,
                    currency: v.currencyAddressInProof,
                    pricePerToken: v.priceInProof,
                  },
                ])
              : this.isNewMultiphaseDrop(this.contractWrapper) &&
                ((i = await this.contractWrapper.read(
                  "getActiveClaimConditionId",
                  []
                )),
                await this.contractWrapper.read("verifyClaim", [
                  i,
                  c,
                  e,
                  v.currencyAddress,
                  v.price,
                  {
                    proof: v.proofs,
                    quantityLimitPerWallet: v.maxClaimable,
                    currency: v.currencyAddressInProof,
                    pricePerToken: v.priceInProof,
                  },
                ]));
        } catch (v) {
          switch (
            (console.warn(
              "Merkle proof verification failed:",
              "reason" in v ? v.reason : v
            ),
            v.reason)
          ) {
            case "!Qty":
              n.push(Mt.OverMaxClaimablePerWallet);
              break;
            case "!PriceOrCurrency":
              n.push(Mt.WrongPriceOrCurrency);
              break;
            case "!MaxSupply":
              n.push(Mt.NotEnoughSupply);
              break;
            case "cant claim yet":
              n.push(Mt.ClaimPhaseNotStarted);
              break;
            default: {
              n.push(Mt.AddressNotAllowed);
              break;
            }
          }
          return n;
        }
    }
    if (
      this.isNewSinglePhaseDrop(this.contractWrapper) ||
      this.isNewMultiphaseDrop(this.contractWrapper)
    ) {
      let v = ae.from(0),
        E = io(a.maxClaimablePerWallet, s);
      try {
        v = await this.getSupplyClaimedByWallet(c);
      } catch {}
      if ((m && (E = io(m.maxClaimable, s)), E.gt(0) && E.lt(v.add(o))))
        return n.push(Mt.OverMaxClaimablePerWallet), n;
      if ((!d || (d && !m)) && (E.lte(v) || E.eq(0)))
        return n.push(Mt.AddressNotAllowed), n;
    }
    if (
      this.isLegacySinglePhaseDrop(this.contractWrapper) ||
      this.isLegacyMultiPhaseDrop(this.contractWrapper)
    ) {
      let [v, E] = [ae.from(0), ae.from(0)];
      this.isLegacyMultiPhaseDrop(this.contractWrapper)
        ? ((i = await this.contractWrapper.read(
            "getActiveClaimConditionId",
            []
          )),
          ([v, E] = await this.contractWrapper.read("getClaimTimestamp", [
            i,
            c,
          ])))
        : this.isLegacySinglePhaseDrop(this.contractWrapper) &&
          ([v, E] = await this.contractWrapper.read("getClaimTimestamp", [c]));
      const A = ae.from(Date.now()).div(1e3);
      if (v.gt(0) && A.lt(E))
        return (
          E.eq(da)
            ? n.push(Mt.AlreadyClaimed)
            : n.push(Mt.WaitBeforeNextClaimTransaction),
          n
        );
    }
    if (a.price.gt(0) && XF()) {
      const v = a.price.mul(ae.from(e)),
        E = this.contractWrapper.getProvider();
      mo(a.currencyAddress)
        ? (await E.getBalance(c)).lt(v) && n.push(Mt.NotEnoughTokens)
        : (
            await new Gn(E, a.currencyAddress, Ri, {}, this.storage).read(
              "balanceOf",
              [c]
            )
          ).lt(v) && n.push(Mt.NotEnoughTokens);
    }
    return n;
  }
  async getClaimerProofs(e, r) {
    const i = (await this.get(r)).merkleRoot;
    if (zi(i).length > 0) {
      const s = await this.metadata.get(),
        o = await Se(e);
      return await VE(
        o,
        i.toString(),
        s.merkle,
        this.contractWrapper.getProvider(),
        this.storage,
        this.getSnapshotFormatVersion()
      );
    } else return null;
  }
  async getSupplyClaimedByWallet(e) {
    const r = await Se(e);
    if (this.isNewSinglePhaseDrop(this.contractWrapper))
      return await this.contractWrapper.read("getSupplyClaimedByWallet", [r]);
    if (this.isNewMultiphaseDrop(this.contractWrapper)) {
      const n = await this.contractWrapper.read(
        "getActiveClaimConditionId",
        []
      );
      return await this.contractWrapper.read("getSupplyClaimedByWallet", [
        n,
        r,
      ]);
    }
    throw new Error(
      "This contract does not support the getSupplyClaimedByWallet function"
    );
  }
  async getTokenDecimals() {
    return Qe(this.contractWrapper, "ERC20")
      ? this.contractWrapper.read("decimals", [])
      : Promise.resolve(0);
  }
  async prepareClaim(e, r) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0,
      i = arguments.length > 3 ? arguments[3] : void 0;
    const a = i || (await this.contractWrapper.getSignerAddress());
    return SL(
      a,
      e,
      await this.getActive(),
      async () => (await this.metadata.get()).merkle,
      n,
      this.contractWrapper,
      this.storage,
      r,
      this.getSnapshotFormatVersion()
    );
  }
  async getClaimArguments(e, r, n) {
    const i = await Se(e);
    return this.isLegacyMultiPhaseDrop(this.contractWrapper)
      ? [i, r, n.currencyAddress, n.price, n.proofs, n.maxClaimable]
      : this.isLegacySinglePhaseDrop(this.contractWrapper)
      ? [
          i,
          r,
          n.currencyAddress,
          n.price,
          {
            proof: n.proofs,
            maxQuantityInAllowlist: n.maxClaimable,
          },
          Lt(""),
        ]
      : [
          i,
          r,
          n.currencyAddress,
          n.price,
          {
            proof: n.proofs,
            quantityLimitPerWallet: n.maxClaimable,
            pricePerToken: n.priceInProof,
            currency: n.currencyAddressInProof,
          },
          Lt(""),
        ];
  }
  async getClaimTransaction(e, r, n) {
    if (n != null && n.pricePerToken)
      throw new Error(
        "Price per token is be set via claim conditions by calling `contract.erc721.claimConditions.set()`"
      );
    const i = await this.prepareClaim(
      r,
      (n == null ? void 0 : n.checkERC20Allowance) === void 0
        ? !0
        : n.checkERC20Allowance,
      await this.getTokenDecimals()
    );
    return ze.fromContractWrapper({
      contractWrapper: this.contractWrapper,
      method: "claim",
      args: await this.getClaimArguments(e, r, i),
      overrides: i.overrides,
    });
  }
  isNewSinglePhaseDrop(e) {
    return Qe(e, "ERC721ClaimConditionsV2") || Qe(e, "ERC20ClaimConditionsV2");
  }
  isNewMultiphaseDrop(e) {
    return Qe(e, "ERC721ClaimPhasesV2") || Qe(e, "ERC20ClaimPhasesV2");
  }
  isLegacySinglePhaseDrop(e) {
    return Qe(e, "ERC721ClaimConditionsV1") || Qe(e, "ERC20ClaimConditionsV1");
  }
  isLegacyMultiPhaseDrop(e) {
    return Qe(e, "ERC721ClaimPhasesV1") || Qe(e, "ERC20ClaimPhasesV1");
  }
  getSnapshotFormatVersion() {
    return this.isLegacyMultiPhaseDrop(this.contractWrapper) ||
      this.isLegacySinglePhaseDrop(this.contractWrapper)
      ? Eu.V1
      : Eu.V2;
  }
}
class Bfe {
  constructor(e, r, n) {
    oe(
      this,
      "set",
      be(
        (() => {
          var e = this;
          return async function (r, n) {
            let i =
              arguments.length > 2 && arguments[2] !== void 0
                ? arguments[2]
                : !1;
            return e.setBatch.prepare(
              [
                {
                  tokenId: r,
                  claimConditions: n,
                },
              ],
              i
            );
          };
        })()
      )
    );
    oe(
      this,
      "setBatch",
      be(
        (() => {
          var e = this;
          return async function (r) {
            let n =
              arguments.length > 1 && arguments[1] !== void 0
                ? arguments[1]
                : !1;
            const i = {},
              a = await Promise.all(
                r.map(async (c) => {
                  let { tokenId: u, claimConditions: d } = c,
                    m = d;
                  if (e.isLegacySinglePhaseDrop(e.contractWrapper)) {
                    if (((n = !0), d.length === 0))
                      m = [
                        {
                          startTime: new Date(0),
                          currencyAddress: Ft,
                          price: 0,
                          maxClaimableSupply: 0,
                          maxClaimablePerWallet: 0,
                          waitInSeconds: 0,
                          merkleRootHash: Rt([0], 32),
                          snapshot: [],
                        },
                      ];
                    else if (d.length > 1)
                      throw new Error(
                        "Single phase drop contract cannot have multiple claim conditions, only one is allowed"
                      );
                  }
                  (e.isNewSinglePhaseDrop(e.contractWrapper) ||
                    e.isNewMultiphaseDrop(e.contractWrapper)) &&
                    m.forEach((A) => {
                      var I;
                      if (
                        A.snapshot &&
                        A.snapshot.length > 0 &&
                        (A.maxClaimablePerWallet === void 0 ||
                          A.maxClaimablePerWallet === "unlimited")
                      )
                        throw new Error(`maxClaimablePerWallet must be set to a specific value when an allowlist is set.
Set it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.

ex:
contract.claimConditions.set(tokenId, [{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])`);
                      if (
                        A.snapshot &&
                        A.snapshot.length > 0 &&
                        ((I = A.maxClaimablePerWallet) == null
                          ? void 0
                          : I.toString()) === "0" &&
                        A.snapshot
                          .map((b) => {
                            var w;
                            return typeof b == "string"
                              ? 0
                              : Number(
                                  ((w = b.maxClaimable) == null
                                    ? void 0
                                    : w.toString()) || 0
                                );
                          })
                          .reduce((b, w) => b + w, 0) === 0
                      )
                        throw new Error(
                          "maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim."
                        );
                    });
                  const { snapshotInfos: v, sortedConditions: E } = await ML(
                    m,
                    0,
                    e.contractWrapper.getProvider(),
                    e.storage,
                    e.getSnapshotFormatVersion()
                  );
                  return (
                    v.forEach((A) => {
                      i[A.merkleRoot] = A.snapshotUri;
                    }),
                    {
                      tokenId: u,
                      sortedConditions: E,
                    }
                  );
                })
              ),
              s = await e.metadata.get(),
              o = [];
            for (const c of Object.keys(s.merkle || {})) i[c] = s.merkle[c];
            if (!tF(s.merkle, i)) {
              const c = await e.metadata.parseInputMetadata({
                  ...s,
                  merkle: i,
                }),
                u = await e.metadata._parseAndUploadMetadata(c);
              if (Kr("setContractURI", e.contractWrapper)) {
                const d = new Sr(e.contractWrapper);
                o.push(d.encode("setContractURI", [u]));
              } else
                throw new Error(
                  "Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root."
                );
            }
            if (
              (a.forEach((c) => {
                let { tokenId: u, sortedConditions: d } = c;
                const m = new Sr(e.contractWrapper);
                if (e.isLegacySinglePhaseDrop(e.contractWrapper)) {
                  const v = new Sr(e.contractWrapper);
                  o.push(v.encode("setClaimConditions", [u, eb(d[0]), n]));
                } else if (e.isLegacyMultiPhaseDrop(e.contractWrapper))
                  o.push(m.encode("setClaimConditions", [u, d.map(eb), n]));
                else if (e.isNewSinglePhaseDrop(e.contractWrapper))
                  o.push(m.encode("setClaimConditions", [u, tb(d[0]), n]));
                else if (e.isNewMultiphaseDrop(e.contractWrapper))
                  o.push(m.encode("setClaimConditions", [u, d.map(tb), n]));
                else
                  throw new Error("Contract does not support claim conditions");
              }),
              Kr("multicall", e.contractWrapper))
            )
              return ze.fromContractWrapper({
                contractWrapper: e.contractWrapper,
                method: "multicall",
                args: [o],
              });
            throw new Error("Contract does not support multicall");
          };
        })()
      )
    );
    oe(
      this,
      "update",
      be(async (e, r, n) => {
        const i = await this.getAll(e),
          a = await IL(r, n, i);
        return await this.set.prepare(e, a);
      })
    );
    (this.storage = n), (this.contractWrapper = e), (this.metadata = r);
  }
  async getActive(e, r) {
    const n = await this.get(e),
      i = await this.metadata.get();
    return await ib(
      n,
      0,
      this.contractWrapper.getProvider(),
      i.merkle,
      this.storage,
      (r == null ? void 0 : r.withAllowList) || !1
    );
  }
  async get(e, r) {
    if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
      const n = await this.contractWrapper.read("claimCondition", [e]);
      return rb(n);
    } else if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
      const n =
          r !== void 0
            ? r
            : await this.contractWrapper.read("getActiveClaimConditionId", [e]),
        i = await this.contractWrapper.read("getClaimConditionById", [e, n]);
      return rb(i);
    } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {
      const n = await this.contractWrapper.read("claimCondition", [e]);
      return nb(n);
    } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {
      const n =
          r !== void 0
            ? r
            : await this.contractWrapper.read("getActiveClaimConditionId", [e]),
        i = await this.contractWrapper.read("getClaimConditionById", [e, n]);
      return nb(i);
    } else throw new Error("Contract does not support claim conditions");
  }
  async getAll(e, r) {
    if (
      this.isLegacyMultiPhaseDrop(this.contractWrapper) ||
      this.isNewMultiphaseDrop(this.contractWrapper)
    ) {
      const n = await this.contractWrapper.read("claimCondition", [e]),
        i = n.currentStartId.toNumber(),
        a = n.count.toNumber(),
        s = [];
      for (let c = i; c < i + a; c++) s.push(await this.get(e, c));
      const o = await this.metadata.get();
      return Promise.all(
        s.map((c) =>
          ib(
            c,
            0,
            this.contractWrapper.getProvider(),
            o.merkle,
            this.storage,
            (r == null ? void 0 : r.withAllowList) || !1
          )
        )
      );
    } else return [await this.getActive(e, r)];
  }
  async canClaim(e, r, n) {
    return (
      n && (n = await Se(n)),
      (await this.getClaimIneligibilityReasons(e, r, n)).length === 0
    );
  }
  async getClaimIneligibilityReasons(e, r, n) {
    const i = [];
    let a, s;
    if (n === void 0)
      try {
        n = await this.contractWrapper.getSignerAddress();
      } catch (A) {
        console.warn("failed to get signer address", A);
      }
    if (!n) return [Mt.NoWallet];
    const o = await Se(n);
    try {
      s = await this.getActive(e);
    } catch (A) {
      return h2(A, "!CONDITION") || h2(A, "no active mint condition")
        ? (i.push(Mt.NoClaimConditionSet), i)
        : (i.push(Mt.Unknown), i);
    }
    if (s.availableSupply !== "unlimited" && ae.from(s.availableSupply).lt(r))
      return i.push(Mt.NotEnoughSupply), i;
    const u = zi(s.merkleRootHash).length > 0;
    let d = null;
    if (u) {
      if (
        ((d = await this.getClaimerProofs(e, o)),
        !d &&
          (this.isLegacySinglePhaseDrop(this.contractWrapper) ||
            this.isLegacyMultiPhaseDrop(this.contractWrapper)))
      )
        return i.push(Mt.AddressNotAllowed), i;
      if (d)
        try {
          const A = await this.prepareClaim(e, r, !1, o);
          let I;
          if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
            if (
              ((a = await this.contractWrapper.read(
                "getActiveClaimConditionId",
                [e]
              )),
              ([I] = await this.contractWrapper.read("verifyClaimMerkleProof", [
                a,
                o,
                e,
                r,
                A.proofs,
                A.maxClaimable,
              ])),
              !I)
            )
              return i.push(Mt.AddressNotAllowed), i;
          } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
            if (
              (([I] = await this.contractWrapper.read(
                "verifyClaimMerkleProof",
                [
                  e,
                  o,
                  r,
                  {
                    proof: A.proofs,
                    maxQuantityInAllowlist: A.maxClaimable,
                  },
                ]
              )),
              !I)
            )
              return i.push(Mt.AddressNotAllowed), i;
          } else
            this.isNewSinglePhaseDrop(this.contractWrapper)
              ? await this.contractWrapper.read("verifyClaim", [
                  e,
                  o,
                  r,
                  A.currencyAddress,
                  A.price,
                  {
                    proof: A.proofs,
                    quantityLimitPerWallet: A.maxClaimable,
                    currency: A.currencyAddressInProof,
                    pricePerToken: A.priceInProof,
                  },
                ])
              : this.isNewMultiphaseDrop(this.contractWrapper) &&
                ((a = await this.contractWrapper.read(
                  "getActiveClaimConditionId",
                  [e]
                )),
                await this.contractWrapper.read("verifyClaim", [
                  a,
                  o,
                  e,
                  r,
                  A.currencyAddress,
                  A.price,
                  {
                    proof: A.proofs,
                    quantityLimitPerWallet: A.maxClaimable,
                    currency: A.currencyAddressInProof,
                    pricePerToken: A.priceInProof,
                  },
                ]));
        } catch (A) {
          switch (
            (console.warn(
              "Merkle proof verification failed:",
              "reason" in A ? A.reason : A
            ),
            A.reason)
          ) {
            case "!Qty":
              i.push(Mt.OverMaxClaimablePerWallet);
              break;
            case "!PriceOrCurrency":
              i.push(Mt.WrongPriceOrCurrency);
              break;
            case "!MaxSupply":
              i.push(Mt.NotEnoughSupply);
              break;
            case "cant claim yet":
              i.push(Mt.ClaimPhaseNotStarted);
              break;
            default: {
              i.push(Mt.AddressNotAllowed);
              break;
            }
          }
          return i;
        }
    }
    if (
      this.isNewSinglePhaseDrop(this.contractWrapper) ||
      this.isNewMultiphaseDrop(this.contractWrapper)
    ) {
      let A = ae.from(0),
        I = io(s.maxClaimablePerWallet, 0);
      try {
        A = await this.getSupplyClaimedByWallet(e, o);
      } catch {}
      if ((d && (I = io(d.maxClaimable, 0)), I.gt(0) && I.lt(A.add(r))))
        return i.push(Mt.OverMaxClaimablePerWallet), i;
      if ((!u || (u && !d)) && (I.lte(A) || I.eq(0)))
        return i.push(Mt.AddressNotAllowed), i;
    }
    let [m, v] = [ae.from(0), ae.from(0)];
    this.isLegacyMultiPhaseDrop(this.contractWrapper)
      ? ((a = await this.contractWrapper.read("getActiveClaimConditionId", [
          e,
        ])),
        ([m, v] = await this.contractWrapper.read("getClaimTimestamp", [
          e,
          a,
          o,
        ])))
      : this.isLegacySinglePhaseDrop(this.contractWrapper) &&
        ([m, v] = await this.contractWrapper.read("getClaimTimestamp", [e, o]));
    const E = ae.from(Date.now()).div(1e3);
    if (m.gt(0) && E.lt(v))
      return (
        v.eq(da)
          ? i.push(Mt.AlreadyClaimed)
          : i.push(Mt.WaitBeforeNextClaimTransaction),
        i
      );
    if (s.price.gt(0) && XF()) {
      const A = s.price.mul(r),
        I = this.contractWrapper.getProvider();
      mo(s.currencyAddress)
        ? (await I.getBalance(o)).lt(A) && i.push(Mt.NotEnoughTokens)
        : (
            await new Gn(I, s.currencyAddress, Ri, {}, this.storage).read(
              "balanceOf",
              [o]
            )
          ).lt(A) && i.push(Mt.NotEnoughTokens);
    }
    return i;
  }
  async getClaimerProofs(e, r, n) {
    const a = (await this.get(e, n)).merkleRoot;
    if (zi(a).length > 0) {
      const o = await this.metadata.get(),
        c = await Se(r);
      return await VE(
        c,
        a.toString(),
        o.merkle,
        this.contractWrapper.getProvider(),
        this.storage,
        this.getSnapshotFormatVersion()
      );
    } else return null;
  }
  async getSupplyClaimedByWallet(e, r) {
    const n = await Se(r);
    if (this.isNewSinglePhaseDrop(this.contractWrapper))
      return await this.contractWrapper.read("getSupplyClaimedByWallet", [
        e,
        n,
      ]);
    if (this.isNewMultiphaseDrop(this.contractWrapper)) {
      const i = await this.contractWrapper.read("getActiveClaimConditionId", [
        e,
      ]);
      return await this.contractWrapper.read("getSupplyClaimedByWallet", [
        e,
        i,
        n,
      ]);
    }
    throw new Error(
      "This contract does not support the getSupplyClaimedByWallet function"
    );
  }
  async prepareClaim(e, r, n, i) {
    const a = await Se(i || (await this.contractWrapper.getSignerAddress()));
    return SL(
      a,
      r,
      await this.getActive(e),
      async () => (await this.metadata.get()).merkle,
      0,
      this.contractWrapper,
      this.storage,
      n,
      this.getSnapshotFormatVersion()
    );
  }
  async getClaimArguments(e, r, n, i) {
    const a = await Se(r);
    return this.isLegacyMultiPhaseDrop(this.contractWrapper)
      ? [a, e, n, i.currencyAddress, i.price, i.proofs, i.maxClaimable]
      : this.isLegacySinglePhaseDrop(this.contractWrapper)
      ? [
          a,
          e,
          n,
          i.currencyAddress,
          i.price,
          {
            proof: i.proofs,
            maxQuantityInAllowlist: i.maxClaimable,
          },
          Lt(""),
        ]
      : [
          a,
          e,
          n,
          i.currencyAddress,
          i.price,
          {
            proof: i.proofs,
            quantityLimitPerWallet: i.maxClaimable,
            pricePerToken: i.priceInProof,
            currency: i.currencyAddressInProof,
          },
          Lt(""),
        ];
  }
  async getClaimTransaction(e, r, n, i) {
    if (i != null && i.pricePerToken)
      throw new Error(
        "Price per token should be set via claim conditions by calling `contract.erc1155.claimConditions.set()`"
      );
    const a = await this.prepareClaim(
      r,
      n,
      (i == null ? void 0 : i.checkERC20Allowance) || !0
    );
    return ze.fromContractWrapper({
      contractWrapper: this.contractWrapper,
      method: "claim",
      args: await this.getClaimArguments(r, e, n, a),
      overrides: a.overrides,
    });
  }
  isNewSinglePhaseDrop(e) {
    return Qe(e, "ERC1155ClaimConditionsV2");
  }
  isNewMultiphaseDrop(e) {
    return Qe(e, "ERC1155ClaimPhasesV2");
  }
  isLegacySinglePhaseDrop(e) {
    return Qe(e, "ERC1155ClaimConditionsV1");
  }
  isLegacyMultiPhaseDrop(e) {
    return Qe(e, "ERC1155ClaimPhasesV1");
  }
  getSnapshotFormatVersion() {
    return this.isLegacyMultiPhaseDrop(this.contractWrapper) ||
      this.isLegacySinglePhaseDrop(this.contractWrapper)
      ? Eu.V1
      : Eu.V2;
  }
}
class Dfe {
  constructor(e, r) {
    oe(this, "featureName", m2.name);
    oe(
      this,
      "to",
      be(async (e) => {
        const r = [],
          n = new Sr(this.contractWrapper);
        for (const i of e)
          r.push(
            n.encode("mintTo", [
              await Se(i.toAddress),
              await this.erc20.normalizeAmount(i.amount),
            ])
          );
        return ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "multicall",
          args: [r],
        });
      })
    );
    (this.erc20 = e), (this.contractWrapper = r);
  }
}
class Ofe {
  constructor(e, r) {
    oe(this, "featureName", Jp.name);
    oe(
      this,
      "tokens",
      be(async (e) =>
        ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "burn",
          args: [await this.erc20.normalizeAmount(e)],
        })
      )
    );
    oe(
      this,
      "from",
      be(async (e, r) =>
        ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "burnFrom",
          args: [await Se(e), await this.erc20.normalizeAmount(r)],
        })
      )
    );
    (this.erc20 = e), (this.contractWrapper = r);
  }
}
class Ffe {
  constructor(e, r, n) {
    oe(this, "featureName", Zp.name);
    oe(
      this,
      "to",
      be(async (e, r, n) => {
        const i = await this.erc20.normalizeAmount(r);
        return await this.conditions.getClaimTransaction(e, i, n);
      })
    );
    (this.erc20 = e), (this.contractWrapper = r), (this.storage = n);
    const i = new Q0(this.contractWrapper, Z0, this.storage);
    this.conditions = new RL(this.contractWrapper, i, this.storage);
  }
}
class Lfe {
  constructor(e, r, n) {
    (this.erc20 = e),
      (this.contractWrapper = r),
      (this.storage = n),
      (this.claim = new Ffe(this.erc20, this.contractWrapper, this.storage));
  }
}
class $fe {
  constructor(e, r) {
    oe(this, "featureName", Qp.name);
    oe(
      this,
      "to",
      be(async (e, r) => await this.getMintTransaction(e, r))
    );
    (this.erc20 = e),
      (this.contractWrapper = r),
      (this.batch = this.detectErc20BatchMintable());
  }
  async getMintTransaction(e, r) {
    return ze.fromContractWrapper({
      contractWrapper: this.contractWrapper,
      method: "mintTo",
      args: [await Se(e), await this.erc20.normalizeAmount(r)],
    });
  }
  detectErc20BatchMintable() {
    if (Qe(this.contractWrapper, "ERC20BatchMintable"))
      return new Dfe(this.erc20, this.contractWrapper);
  }
}
async function al(t, e, r, n) {
  if (mo(r)) n.value = e;
  else {
    const i = t.getSigner(),
      a = t.getProvider(),
      s = new Gn(i || a, r, Ri, t.options, t.storage),
      o = await t.getSignerAddress(),
      c = t.address;
    return (
      (await s.read("allowance", [o, c])).lt(e) &&
        (await s.sendTransaction("approve", [c, e])),
      n
    );
  }
}
class Ufe {
  constructor(e, r) {
    oe(this, "featureName", p2.name);
    oe(
      this,
      "mint",
      be(async (e) => {
        const r = e.payload,
          n = e.signature,
          i = await this.mapPayloadToContractStruct(r),
          a = await this.contractWrapper.getCallOverrides();
        return (
          await al(
            this.contractWrapper,
            ae.from(i.price),
            r.currencyAddress,
            a
          ),
          ze.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "mintWithSignature",
            args: [i, n],
            overrides: a,
          })
        );
      })
    );
    oe(
      this,
      "mintBatch",
      be(async (e) => {
        const r = await Promise.all(
            e.map(async (a) => {
              const s = await this.mapPayloadToContractStruct(a.payload),
                o = a.signature,
                c = a.payload.price;
              if (ae.from(c).gt(0))
                throw new Error(
                  "Can only batch free mints. For mints with a price, use regular mint()"
                );
              return {
                message: s,
                signature: o,
              };
            })
          ),
          n = new Sr(this.contractWrapper),
          i = r.map((a) =>
            n.encode("mintWithSignature", [a.message, a.signature])
          );
        return ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "multicall",
          args: [i],
        });
      })
    );
    (this.contractWrapper = e), (this.roles = r);
  }
  async verify(e) {
    const r = e.payload,
      n = e.signature,
      i = await this.mapPayloadToContractStruct(r);
    return (await this.contractWrapper.read("verify", [i, n]))[0];
  }
  async generate(e) {
    return (await this.generateBatch([e]))[0];
  }
  async generateBatch(e) {
    var s;
    await ((s = this.roles) == null
      ? void 0
      : s.verify(["minter"], await this.contractWrapper.getSignerAddress()));
    const r = await Promise.all(e.map((o) => NF.parseAsync(o))),
      n = await this.contractWrapper.getChainID(),
      i = this.contractWrapper.getSigner();
    Je(i);
    const a = await this.contractWrapper.read("name", []);
    return await Promise.all(
      r.map(async (o) => {
        const c = await mue.parseAsync(o),
          u = await this.contractWrapper.signTypedData(
            i,
            {
              name: a,
              version: "1",
              chainId: n,
              verifyingContract: this.contractWrapper.address,
            },
            {
              MintRequest: wue,
            },
            await this.mapPayloadToContractStruct(c)
          );
        return {
          payload: c,
          signature: u.toString(),
        };
      })
    );
  }
  async mapPayloadToContractStruct(e) {
    const r = await pi(
        this.contractWrapper.getProvider(),
        e.price,
        e.currencyAddress
      ),
      n = ya(e.quantity, await this.contractWrapper.read("decimals", []));
    return {
      to: e.to,
      primarySaleRecipient: e.primarySaleRecipient,
      quantity: n,
      price: r,
      currency: e.currencyAddress,
      validityEndTimestamp: e.mintEndTime,
      validityStartTimestamp: e.mintStartTime,
      uid: e.uid,
    };
  }
}
function et(t, e) {
  if (!t) throw new nu(e);
  return t;
}
async function Wfe(t, e) {
  const r = await t.read("decimals", []);
  return ya(Gi.parse(e), r);
}
class jfe {
  constructor(e, r, n) {
    oe(this, "featureName", y2.name);
    oe(
      this,
      "transfer",
      be(async (e, r) =>
        ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "transfer",
          args: await Promise.all([Se(e), this.normalizeAmount(r)]),
        })
      )
    );
    oe(
      this,
      "transferFrom",
      be(async (e, r, n) =>
        ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "transferFrom",
          args: await Promise.all([Se(e), Se(r), this.normalizeAmount(n)]),
        })
      )
    );
    oe(
      this,
      "setAllowance",
      be(async (e, r) =>
        ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "approve",
          args: await Promise.all([Se(e), this.normalizeAmount(r)]),
        })
      )
    );
    oe(
      this,
      "transferBatch",
      be(async (e) => {
        const r = new Sr(this.contractWrapper),
          n = (
            await Promise.all(
              e.map((i) =>
                Promise.all([this.normalizeAmount(i.amount), Se(i.toAddress)])
              )
            )
          ).map((i) => {
            let [a, s] = i;
            return r.encode("transfer", [s, a]);
          });
        return ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "multicall",
          args: [n],
        });
      })
    );
    oe(
      this,
      "mint",
      be(async (e) =>
        this.mintTo.prepare(await this.contractWrapper.getSignerAddress(), e)
      )
    );
    oe(
      this,
      "mintTo",
      be(async (e, r) => et(this.mintable, Qp).to.prepare(e, r))
    );
    oe(
      this,
      "mintBatchTo",
      be(async (e) => {
        var r;
        return et(
          (r = this.mintable) == null ? void 0 : r.batch,
          m2
        ).to.prepare(e);
      })
    );
    oe(
      this,
      "burn",
      be(async (e) => et(this.burnable, Jp).tokens.prepare(e))
    );
    oe(
      this,
      "burnFrom",
      be(async (e, r) => et(this.burnable, Jp).from.prepare(e, r))
    );
    oe(
      this,
      "claim",
      be(async (e, r) =>
        this.claimTo.prepare(
          await this.contractWrapper.getSignerAddress(),
          e,
          r
        )
      )
    );
    oe(
      this,
      "claimTo",
      be(async (e, r, n) => {
        var i;
        return et(
          (i = this.droppable) == null ? void 0 : i.claim,
          Zp
        ).to.prepare(e, r, n);
      })
    );
    (this.contractWrapper = e),
      (this.storage = r),
      (this.mintable = this.detectErc20Mintable()),
      (this.burnable = this.detectErc20Burnable()),
      (this.droppable = this.detectErc20Droppable()),
      (this.signatureMintable = this.detectErc20SignatureMintable()),
      (this._chainId = n);
  }
  get chainId() {
    return this._chainId;
  }
  onNetworkUpdated(e) {
    this.contractWrapper.updateSignerOrProvider(e);
  }
  getAddress() {
    return this.contractWrapper.address;
  }
  async get() {
    return await zm(this.contractWrapper.getProvider(), this.getAddress());
  }
  async balance() {
    return await this.balanceOf(await this.contractWrapper.getSignerAddress());
  }
  async balanceOf(e) {
    return this.getValue(
      await this.contractWrapper.read("balanceOf", [await Se(e)])
    );
  }
  async totalSupply() {
    return await this.getValue(
      await this.contractWrapper.read("totalSupply", [])
    );
  }
  async allowance(e) {
    const [r, n] = await Promise.all([
      this.contractWrapper.getSignerAddress(),
      Se(e),
    ]);
    return await this.allowanceOf(r, n);
  }
  async allowanceOf(e, r) {
    const n = await Promise.all([Se(e), Se(r)]);
    return await this.getValue(await this.contractWrapper.read("allowance", n));
  }
  async getMintTransaction(e, r) {
    return et(this.mintable, Qp).getMintTransaction(e, r);
  }
  get claimConditions() {
    var e;
    return et((e = this.droppable) == null ? void 0 : e.claim, Zp).conditions;
  }
  get signature() {
    return et(this.signatureMintable, p2);
  }
  async normalizeAmount(e) {
    return Wfe(this.contractWrapper, e);
  }
  async getValue(e) {
    return await hs(
      this.contractWrapper.getProvider(),
      this.getAddress(),
      ae.from(e)
    );
  }
  detectErc20Mintable() {
    if (Qe(this.contractWrapper, "ERC20"))
      return new $fe(this, this.contractWrapper);
  }
  detectErc20Burnable() {
    if (Qe(this.contractWrapper, "ERC20Burnable"))
      return new Ofe(this, this.contractWrapper);
  }
  detectErc20Droppable() {
    if (
      Qe(this.contractWrapper, "ERC20ClaimConditionsV1") ||
      Qe(this.contractWrapper, "ERC20ClaimConditionsV2") ||
      Qe(this.contractWrapper, "ERC20ClaimPhasesV1") ||
      Qe(this.contractWrapper, "ERC20ClaimPhasesV2")
    )
      return new Lfe(this, this.contractWrapper, this.storage);
  }
  detectErc20SignatureMintable() {
    if (Qe(this.contractWrapper, "ERC20SignatureMintable"))
      return new Ufe(this.contractWrapper);
  }
}
class Hfe {
  constructor(e, r, n) {
    oe(this, "featureName", _2.name);
    oe(
      this,
      "to",
      be(async (e, r) => {
        const [n, i] = await Promise.all([$u(r, this.storage), Se(e)]),
          a = new Sr(this.contractWrapper),
          s = n.map((o) => a.encode("mintTo", [i, o]));
        return ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "multicall",
          args: [s],
          parse: (o) => {
            const c = this.contractWrapper.parseLogs("TokensMinted", o.logs);
            if (c.length === 0 || c.length < r.length)
              throw new Error("TokenMinted event not found, minting failed");
            return c.map((u) => {
              const d = u.args.tokenIdMinted;
              return {
                id: d,
                receipt: o,
                data: () => this.erc721.get(d),
              };
            });
          },
        });
      })
    );
    (this.erc721 = e), (this.contractWrapper = r), (this.storage = n);
  }
}
class zfe {
  constructor(e, r, n) {
    oe(this, "featureName", x2.name);
    oe(
      this,
      "to",
      be(async (e, r, n) => {
        const i = await this.conditions.getClaimTransaction(e, r, n);
        return (
          i.setParse((a) => {
            const o = this.contractWrapper.parseLogs(
                "TokensClaimed",
                a == null ? void 0 : a.logs
              )[0].args.startTokenId,
              c = o.add(r),
              u = [];
            for (let d = o; d.lt(c); d = d.add(1))
              u.push({
                id: d,
                receipt: a,
                data: () => this.erc721.get(d),
              });
            return u;
          }),
          i
        );
      })
    );
    (this.erc721 = e), (this.contractWrapper = r), (this.storage = n);
    const i = new Q0(this.contractWrapper, Z0, this.storage);
    this.conditions = new RL(this.contractWrapper, i, this.storage);
  }
}
async function PL(t, e, r, n, i) {
  let a = {};
  const s = n || qi,
    c = (await pi(t.getProvider(), e, s)).mul(r);
  return (
    c.gt(0) &&
      (s === qi
        ? (a = {
            value: c,
          })
        : s !== qi && i && (await kL(t, s, c, r, 0))),
    a
  );
}
class qfe {
  constructor(e, r) {
    oe(this, "featureName", Yp.name);
    oe(
      this,
      "to",
      be(async (e, r, n) => {
        const i = await this.getClaimTransaction(e, r, n);
        return (
          i.setParse((a) => {
            const o = this.contractWrapper.parseLogs(
                "TokensClaimed",
                a == null ? void 0 : a.logs
              )[0].args.startTokenId,
              c = o.add(r),
              u = [];
            for (let d = o; d.lt(c); d = d.add(1))
              u.push({
                id: d,
                receipt: a,
                data: () => this.erc721.get(d),
              });
            return u;
          }),
          i
        );
      })
    );
    (this.erc721 = e), (this.contractWrapper = r);
  }
  async getClaimTransaction(e, r, n) {
    let i = {};
    return (
      n &&
        n.pricePerToken &&
        (i = await PL(
          this.contractWrapper,
          n.pricePerToken,
          r,
          n.currencyAddress,
          n.checkERC20Allowance
        )),
      ze.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "claim",
        args: [e, r],
        overrides: i,
      })
    );
  }
}
class Vfe {
  constructor(e, r, n) {
    oe(this, "featureName", w2.name);
    oe(
      this,
      "lazyMint",
      be(async (e, r) => {
        const n = await this.erc721.nextTokenIdToMint(),
          i = await $u(e, this.storage, n.toNumber(), r),
          a = Y0(i);
        return ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "lazyMint",
          args: [i.length, a.endsWith("/") ? a : `${a}/`, Lt("")],
          parse: (s) => {
            const o = this.contractWrapper.parseLogs(
                "TokensLazyMinted",
                s == null ? void 0 : s.logs
              ),
              c = o[0].args.startTokenId,
              u = o[0].args.endTokenId,
              d = [];
            for (let m = c; m.lte(u); m = m.add(1))
              d.push({
                id: m,
                receipt: s,
                data: () => this.erc721.getTokenMetadata(m),
              });
            return d;
          },
        });
      })
    );
    (this.erc721 = e),
      (this.contractWrapper = r),
      (this.storage = n),
      (this.revealer = this.detectErc721Revealable());
  }
  detectErc721Revealable() {
    if (Qe(this.contractWrapper, "ERC721Revealable"))
      return new CL(this.contractWrapper, this.storage, b2.name, () =>
        this.erc721.nextTokenIdToMint()
      );
  }
}
class Kfe {
  constructor(e, r, n) {
    oe(this, "featureName", E2.name);
    oe(
      this,
      "to",
      be(async (e, r) => {
        const [n, i] = await Promise.all([qE(r, this.storage), Se(e)]);
        return ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "mintTo",
          args: [i, n],
          parse: (a) => {
            const s = this.contractWrapper.parseLogs(
              "Transfer",
              a == null ? void 0 : a.logs
            );
            if (s.length === 0)
              throw new Error("TransferEvent event not found");
            const o = s[0].args.tokenId;
            return {
              id: o,
              receipt: a,
              data: () => this.erc721.get(o),
            };
          },
        });
      })
    );
    (this.erc721 = e),
      (this.contractWrapper = r),
      (this.storage = n),
      (this.batch = this.detectErc721BatchMintable());
  }
  async getMintTransaction(e, r) {
    return this.to.prepare(await Se(e), r);
  }
  detectErc721BatchMintable() {
    if (Qe(this.contractWrapper, "ERC721BatchMintable"))
      return new Hfe(this.erc721, this.contractWrapper, this.storage);
  }
}
class Gfe {
  constructor(e, r) {
    oe(this, "featureName", O_.name);
    (this.erc721 = e), (this.contractWrapper = r);
  }
  async all(e) {
    const r = await this.tokenIds(e);
    return await Promise.all(r.map((n) => this.erc721.get(n.toString())));
  }
  async tokenIds(e) {
    const r = await Se(e || (await this.contractWrapper.getSignerAddress())),
      n = await this.contractWrapper.read("balanceOf", [r]),
      i = Array.from(Array(n.toNumber()).keys());
    return await Promise.all(
      i.map((a) => this.contractWrapper.read("tokenOfOwnerByIndex", [r, a]))
    );
  }
}
class Zfe {
  constructor(e, r) {
    oe(this, "featureName", F_.name);
    (this.erc721 = e), (this.contractWrapper = r);
  }
  async all(e) {
    const r = await this.tokenIds(e);
    return await Promise.all(r.map((n) => this.erc721.get(n.toString())));
  }
  async tokenIds(e) {
    const r = await Se(e || (await this.contractWrapper.getSignerAddress()));
    return await this.contractWrapper.read("tokensOfOwner", [r]);
  }
}
class Jfe {
  constructor(e, r) {
    oe(this, "featureName", J0.name);
    (this.erc721 = e),
      (this.contractWrapper = r),
      (this.owned = this.detectErc721Owned());
  }
  async all(e) {
    let r = ae.from(0);
    Kr("startTokenId", this.contractWrapper) &&
      (r = await this.contractWrapper.read("startTokenId", []));
    const n = ae
        .from((e == null ? void 0 : e.start) || 0)
        .add(r)
        .toNumber(),
      i = ae.from((e == null ? void 0 : e.count) || Hh).toNumber(),
      a = await this.erc721.nextTokenIdToMint(),
      s = Math.min(a.add(r).toNumber(), n + i);
    return await Promise.all(
      [...Array(s - n).keys()].map((o) => this.erc721.get((n + o).toString()))
    );
  }
  async allOwners() {
    let e,
      r = ae.from(0);
    Kr("startTokenId", this.contractWrapper) &&
      (r = await this.contractWrapper.read("startTokenId", []));
    try {
      e = await this.erc721.totalClaimedSupply();
    } catch {
      e = await this.totalCount();
    }
    e = e.add(r);
    const n = [...new Array(e.toNumber()).keys()],
      i = await Promise.all(
        n.map((a) => this.erc721.ownerOf(a).catch(() => Ft))
      );
    return n
      .map((a) => ({
        tokenId: a,
        owner: i[a],
      }))
      .filter((a) => a.owner !== Ft);
  }
  async totalCount() {
    return await this.erc721.nextTokenIdToMint();
  }
  async totalCirculatingSupply() {
    return await this.contractWrapper.read("totalSupply", []);
  }
  detectErc721Owned() {
    if (Qe(this.contractWrapper, "ERC721Enumerable"))
      return new Gfe(this.erc721, this.contractWrapper);
    if (Qe(this.contractWrapper, "ERC721AQueryable"))
      return new Zfe(this.erc721, this.contractWrapper);
  }
}
const Qfe = RE.extend({
  tierPriority: ne.array(ne.string()),
  royaltyRecipient: wr.default(Ft),
  royaltyBps: yd.default(0),
  quantity: hi.default(1),
});
class Yfe {
  constructor(e, r, n) {
    oe(this, "featureName", v2.name);
    oe(
      this,
      "createBatchWithTier",
      be(async (e, r, n) => {
        const i = await this.erc721.nextTokenIdToMint(),
          a = await $u(e, this.storage, i.toNumber(), n),
          s = Y0(a);
        return ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "lazyMint",
          args: [a.length, s.endsWith("/") ? s : `${s}/`, r, Lt("")],
          parse: (o) => {
            const c = this.contractWrapper.parseLogs(
                "TokensLazyMinted",
                o == null ? void 0 : o.logs
              ),
              u = c[0].args[1],
              d = c[0].args[2],
              m = [];
            for (let v = u; v.lte(d); v = v.add(1))
              m.push({
                id: v,
                receipt: o,
                data: () => this.erc721.getTokenMetadata(v),
              });
            return m;
          },
        });
      })
    );
    oe(
      this,
      "createDelayedRevealBatchWithTier",
      be(async (e, r, n, i, a) => {
        if (!n) throw new Error("Password is required");
        const s = await this.storage.uploadBatch([il.parse(e)], {
            rewriteFileNames: {
              fileStartNumber: 0,
            },
          }),
          o = Y0(s),
          c = await this.erc721.nextTokenIdToMint(),
          u = await this.storage.uploadBatch(
            r.map((w) => il.parse(w)),
            {
              onProgress: a == null ? void 0 : a.onProgress,
              rewriteFileNames: {
                fileStartNumber: c.toNumber(),
              },
            }
          ),
          d = Y0(u),
          m = await this.contractWrapper.read("getBaseURICount", []),
          v = await this.contractWrapper.getChainID(),
          E = ha(
            ["string", "uint256", "uint256", "address"],
            [n, v, m, this.contractWrapper.address]
          ),
          A = await this.contractWrapper.read("encryptDecrypt", [Lt(d), E]),
          I = ha(["bytes", "bytes", "uint256"], [Lt(d), E, v]),
          b = xs.encode(["bytes", "bytes32"], [A, I]);
        return ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "lazyMint",
          args: [u.length, o.endsWith("/") ? o : `${o}/`, i, b],
          parse: (w) => {
            const S = this.contractWrapper.parseLogs(
                "TokensLazyMinted",
                w == null ? void 0 : w.logs
              ),
              k = S[0].args[1],
              N = S[0].args[2],
              O = [];
            for (let F = k; F.lte(N); F = F.add(1))
              O.push({
                id: F,
                receipt: w,
                data: () => this.erc721.getTokenMetadata(F),
              });
            return O;
          },
        });
      })
    );
    oe(
      this,
      "reveal",
      be(async (e, r) => {
        if (!r) throw new Error("Password is required");
        const n = await this.contractWrapper.getChainID(),
          i = ha(
            ["string", "uint256", "uint256", "address"],
            [r, n, e, this.contractWrapper.address]
          );
        try {
          const a = await this.contractWrapper.callStatic().reveal(e, i);
          if (!a.includes("://") || !a.endsWith("/"))
            throw new Error("invalid password");
        } catch {
          throw new Error("invalid password");
        }
        return ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "reveal",
          args: [e, i],
        });
      })
    );
    (this.erc721 = e), (this.contractWrapper = r), (this.storage = n);
  }
  async getMetadataInTier(e) {
    const n = (
      await this.contractWrapper.read("getMetadataForAllTiers", [])
    ).find((a) => a.tier === e);
    if (!n) throw new Error("Tier not found in contract.");
    return await Promise.all(
      n.ranges
        .map((a, s) => {
          const o = [],
            c = n.baseURIs[s];
          for (
            let u = a.startIdInclusive.toNumber();
            u < a.endIdNonInclusive.toNumber();
            u++
          ) {
            const d = c.endsWith("/") ? `${c}${u}` : `${c}/${u}`,
              m = this.storage.downloadJSON(d);
            o.push(m);
          }
          return o;
        })
        .flat()
    );
  }
  async getTokensInTier(e) {
    const r = await this.contractWrapper.read("getTokensInTierLen", []);
    if (r.eq(0)) return [];
    const n = await this.contractWrapper.read("getTokensInTier", [e, 0, r]);
    return await Promise.all(
      n
        .map((a) => {
          const s = [];
          for (
            let o = a.startIdInclusive.toNumber();
            o < a.endIdNonInclusive.toNumber();
            o++
          )
            s.push(this.erc721.get(o));
          return s;
        })
        .flat()
    );
  }
  async generate(e) {
    const [r] = await this.generateBatch([e]);
    return r;
  }
  async generateBatch(e) {
    const r = await Promise.all(e.map((a) => Qfe.parseAsync(a))),
      n = await this.contractWrapper.getChainID(),
      i = this.contractWrapper.getSigner();
    return (
      Je(i),
      await Promise.all(
        r.map(async (a) => {
          const s = await this.contractWrapper.signTypedData(
            i,
            {
              name: "SignatureAction",
              version: "1",
              chainId: n,
              verifyingContract: this.contractWrapper.address,
            },
            {
              GenericRequest: Cue,
            },
            await this.mapPayloadToContractStruct(a)
          );
          return {
            payload: a,
            signature: s.toString(),
          };
        })
      )
    );
  }
  async verify(e) {
    const r = await this.mapPayloadToContractStruct(e.payload);
    return (await this.contractWrapper.read("verify", [r, e.signature]))[0];
  }
  async claimWithSignature(e) {
    const r = await this.mapPayloadToContractStruct(e.payload),
      n = await pi(
        this.contractWrapper.getProvider(),
        e.payload.price,
        e.payload.currencyAddress
      ),
      i = await this.contractWrapper.getCallOverrides();
    await al(this.contractWrapper, n, e.payload.currencyAddress, i);
    const a = await this.contractWrapper.sendTransaction(
        "claimWithSignature",
        [r, e.signature],
        i
      ),
      s = this.contractWrapper.parseLogs(
        "TokensClaimed",
        a == null ? void 0 : a.logs
      ),
      o = s[0].args.startTokenId,
      c = o.add(s[0].args.quantityClaimed),
      u = [];
    for (let d = o; d.lt(c); d = d.add(1))
      u.push({
        id: d,
        receipt: a,
        data: () => this.erc721.get(d),
      });
    return u;
  }
  async mapPayloadToContractStruct(e) {
    const r = await pi(
        this.contractWrapper.getProvider(),
        e.price,
        e.currencyAddress
      ),
      n = xs.encode(
        [
          "string[]",
          "address",
          "address",
          "uint256",
          "address",
          "uint256",
          "uint256",
          "address",
        ],
        [
          e.tierPriority,
          e.to,
          e.royaltyRecipient,
          e.royaltyBps,
          e.primarySaleRecipient,
          e.quantity,
          r,
          e.currencyAddress,
        ]
      );
    return {
      uid: e.uid,
      validityStartTimestamp: e.mintStartTime,
      validityEndTimestamp: e.mintEndTime,
      data: n,
    };
  }
}
class Xfe {
  constructor(e) {
    oe(this, "featureName", g2.name);
    oe(
      this,
      "token",
      be(async (e) =>
        ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "burn",
          args: [e],
        })
      )
    );
    this.contractWrapper = e;
  }
}
function NL(t) {
  return lv(Gi.parse(t));
}
class ede {
  constructor(e, r) {
    oe(this, "featureName", D_.name);
    oe(
      this,
      "to",
      be(async (e, r, n) => {
        var d;
        const i = await ((d = this.contractWrapper.getSigner()) == null
          ? void 0
          : d.getAddress());
        if (e !== i)
          throw new Error(
            "Zora Drop: Destination address must match connected wallet address"
          );
        if (n != null && n.pricePerToken)
          throw new Error(
            "Zora Drop: Custom pricePerToken is not supported. Price is automatically calculated"
          );
        const s = (await this.getSaleDetails()).publicSalePrice,
          o = NL("0.000777"),
          c = ae.from(s).add(o).mul(r),
          u = ze.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "purchase",
            args: [r],
            overrides: {
              value: c,
            },
          });
        return (
          u.setParse((m) => {
            const E = this.contractWrapper.parseLogs(
                "Sale",
                m == null ? void 0 : m.logs
              )[0].args.firstPurchasedTokenId,
              A = E.add(r),
              I = [];
            for (let b = E; b.lt(A); b = b.add(1))
              I.push({
                id: b,
                receipt: m,
                data: () => this.erc721.get(b),
              });
            return I;
          }),
          u
        );
      })
    );
    (this.erc721 = e), (this.contractWrapper = r);
  }
  async getSaleDetails() {
    return this.contractWrapper.read("saleDetails", []);
  }
}
class tde {
  constructor(e) {
    oe(this, "featureName", vu.name);
    oe(
      this,
      "cancel",
      be(async (e) =>
        ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "cancel",
          args: [e],
        })
      )
    );
    oe(
      this,
      "revoke",
      be(async (e) =>
        ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "revoke",
          args: [e],
        })
      )
    );
    this.contractWrapper = e;
  }
}
class rde {
  constructor(e, r) {
    oe(this, "featureName", If.name);
    oe(
      this,
      "update",
      be(async (e, r) => {
        const n = await qE(r, this.storage);
        return ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "setTokenURI",
          args: [e, n],
        });
      })
    );
    (this.contractWrapper = e), (this.storage = r);
  }
}
class nde {
  constructor(e, r) {
    oe(this, "featureName", C2.name);
    oe(
      this,
      "set",
      be(async (e) => {
        const r = aO.parse(e);
        r.description = this.sanitizeJSONString(r.description);
        const n = [];
        bu(r.image)
          ? n.push(this.storage.upload(r.image))
          : typeof r.image == "string"
          ? n.push(Promise.resolve(r.image))
          : n.push(Promise.resolve(void 0)),
          bu(r.animation_url)
            ? n.push(this.storage.upload(r.animation_url))
            : typeof r.animation_url == "string"
            ? n.push(Promise.resolve(r.animation_url))
            : n.push(Promise.resolve(void 0));
        const [i, a] = await Promise.all(n);
        return ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "setSharedMetadata",
          args: [
            {
              name: `${r.name || ""}`,
              description: r.description || "",
              imageURI: i || "",
              animationURI: a || "",
            },
          ],
        });
      })
    );
    (this.contractWrapper = e), (this.storage = r);
  }
  async get() {
    const e = await this.contractWrapper.read("sharedMetadata", []);
    if (!e.every((r) => r === ""))
      return {
        name: e.name,
        description: e.description,
        image: e.imageURI,
        animation_url: e.animationURI,
      };
  }
  sanitizeJSONString(e) {
    if (!e) return e;
    const r = JSON.stringify(e);
    return r.slice(1, r.length - 1);
  }
}
class ide {
  constructor(e, r) {
    oe(this, "featureName", T2.name);
    oe(
      this,
      "mint",
      be(async (e) => {
        const r = e.payload,
          n = e.signature,
          i = await this.contractWrapper.getCallOverrides(),
          a = (s) => {
            const o = this.contractWrapper.parseLogs(
              "TokensMintedWithSignature",
              s.logs
            );
            if (o.length === 0)
              throw new Error("No MintWithSignature event found");
            return {
              id: o[0].args.tokenIdMinted,
              receipt: s,
            };
          };
        if (await this.isLegacyNFTContract()) {
          const s = await this.mapLegacyPayloadToContractStruct(r),
            o = s.price;
          return (
            await al(this.contractWrapper, o, r.currencyAddress, i),
            ze.fromContractWrapper({
              contractWrapper: this.contractWrapper,
              method: "mintWithSignature",
              args: [s, n],
              overrides: i,
              parse: a,
            })
          );
        } else {
          const s = await this.mapPayloadToContractStruct(r),
            o = s.pricePerToken.mul(s.quantity);
          return (
            await al(this.contractWrapper, o, r.currencyAddress, i),
            ze.fromContractWrapper({
              contractWrapper: this.contractWrapper,
              method: "mintWithSignature",
              args: [s, n],
              overrides: i,
              parse: a,
            })
          );
        }
      })
    );
    oe(
      this,
      "mintBatch",
      be(async (e) => {
        const r = await this.isLegacyNFTContract(),
          n = (
            await Promise.all(
              e.map((s) =>
                r
                  ? this.mapLegacyPayloadToContractStruct(s.payload)
                  : this.mapPayloadToContractStruct(s.payload)
              )
            )
          ).map((s, o) => {
            const c = e[o],
              u = c.signature,
              d = c.payload.price;
            if (ae.from(d).gt(0))
              throw new Error(
                "Can only batch free mints. For mints with a price, use regular mint()"
              );
            return {
              message: s,
              signature: u,
            };
          }),
          i = new Sr(this.contractWrapper),
          a = n.map((s) =>
            r
              ? i.encode("mintWithSignature", [s.message, s.signature])
              : i.encode("mintWithSignature", [s.message, s.signature])
          );
        if (Kr("multicall", this.contractWrapper))
          return ze.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "multicall",
            args: [a],
            parse: (s) => {
              const o = this.contractWrapper.parseLogs(
                "TokensMintedWithSignature",
                s.logs
              );
              if (o.length === 0)
                throw new Error("No MintWithSignature event found");
              return o.map((c) => ({
                id: c.args.tokenIdMinted,
                receipt: s,
              }));
            },
          });
        throw new Error("Multicall not available on this contract!");
      })
    );
    (this.contractWrapper = e), (this.storage = r);
  }
  async verify(e) {
    const r = await this.isLegacyNFTContract(),
      n = e.payload,
      i = e.signature;
    let a, s;
    return (
      r
        ? ((a = await this.mapLegacyPayloadToContractStruct(n)),
          (s = await this.contractWrapper.read("verify", [a, i])))
        : ((a = await this.mapPayloadToContractStruct(n)),
          (s = await this.contractWrapper.read("verify", [a, i]))),
      s[0]
    );
  }
  async generate(e) {
    return (await this.generateBatch([e]))[0];
  }
  async generateBatch(e) {
    const r = await this.isLegacyNFTContract(),
      n = await Promise.all(e.map((c) => vue.parseAsync(c))),
      i = n.map((c) => c.metadata),
      a = await $u(i, this.storage),
      s = await this.contractWrapper.getChainID(),
      o = this.contractWrapper.getSigner();
    return (
      Je(o),
      await Promise.all(
        n.map(async (c, u) => {
          const d = a[u],
            m = await xue.parseAsync({
              ...c,
              uri: d,
            });
          let v;
          return (
            r
              ? (v = await this.contractWrapper.signTypedData(
                  o,
                  {
                    name: "TokenERC721",
                    version: "1",
                    chainId: s,
                    verifyingContract: this.contractWrapper.address,
                  },
                  {
                    MintRequest: _ue,
                  },
                  await this.mapLegacyPayloadToContractStruct(m)
                ))
              : (v = await this.contractWrapper.signTypedData(
                  o,
                  {
                    name: "SignatureMintERC721",
                    version: "1",
                    chainId: s,
                    verifyingContract: await this.contractWrapper.address,
                  },
                  {
                    MintRequest: Tue,
                  },
                  await this.mapPayloadToContractStruct(m)
                )),
            {
              payload: m,
              signature: v.toString(),
            }
          );
        })
      )
    );
  }
  async mapPayloadToContractStruct(e) {
    const r = await pi(
      this.contractWrapper.getProvider(),
      e.price,
      e.currencyAddress
    );
    return {
      to: e.to,
      royaltyRecipient: e.royaltyRecipient,
      royaltyBps: e.royaltyBps,
      primarySaleRecipient: e.primarySaleRecipient,
      uri: e.uri,
      quantity: e.quantity,
      pricePerToken: r,
      currency: e.currencyAddress,
      validityStartTimestamp: e.mintStartTime,
      validityEndTimestamp: e.mintEndTime,
      uid: e.uid,
    };
  }
  async mapLegacyPayloadToContractStruct(e) {
    const r = await pi(
      this.contractWrapper.getProvider(),
      e.price,
      e.currencyAddress
    );
    return {
      to: e.to,
      price: r,
      uri: e.uri,
      currency: e.currencyAddress,
      validityEndTimestamp: e.mintEndTime,
      validityStartTimestamp: e.mintStartTime,
      uid: e.uid,
      royaltyRecipient: e.royaltyRecipient,
      royaltyBps: e.royaltyBps,
      primarySaleRecipient: e.primarySaleRecipient,
    };
  }
  async isLegacyNFTContract() {
    return Qe(this.contractWrapper, "ERC721SignatureMintV1");
  }
}
class ade {
  constructor(e, r, n) {
    oe(this, "featureName", A2.name);
    oe(
      this,
      "transfer",
      be(async (e, r) => {
        const [n, i] = await Promise.all([
          this.contractWrapper.getSignerAddress(),
          Se(e),
        ]);
        return ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "transferFrom(address,address,uint256)",
          args: [n, i, r],
        });
      })
    );
    oe(
      this,
      "transferFrom",
      be(async (e, r, n) => {
        const [i, a] = await Promise.all([Se(e), Se(r)]);
        return ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "transferFrom(address,address,uint256)",
          args: [i, a, n],
        });
      })
    );
    oe(
      this,
      "setApprovalForAll",
      be(async (e, r) =>
        ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "setApprovalForAll",
          args: [await Se(e), r],
        })
      )
    );
    oe(
      this,
      "setApprovalForToken",
      be(async (e, r) =>
        ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "approve",
          args: [await Se(e), r],
        })
      )
    );
    oe(
      this,
      "mint",
      be(async (e) =>
        this.mintTo.prepare(await this.contractWrapper.getSignerAddress(), e)
      )
    );
    oe(
      this,
      "mintTo",
      be(async (e, r) => et(this.mintable, E2).to.prepare(e, r))
    );
    oe(
      this,
      "mintBatch",
      be(async (e) =>
        this.mintBatchTo.prepare(
          await this.contractWrapper.getSignerAddress(),
          e
        )
      )
    );
    oe(
      this,
      "mintBatchTo",
      be(async (e, r) => {
        var n;
        return et(
          (n = this.mintable) == null ? void 0 : n.batch,
          _2
        ).to.prepare(e, r);
      })
    );
    oe(
      this,
      "burn",
      be(async (e) => et(this.burnable, g2).token.prepare(e))
    );
    oe(
      this,
      "cancel",
      be(async (e) => et(this.loyaltyCard, vu).cancel.prepare(e))
    );
    oe(
      this,
      "revoke",
      be(async (e) => et(this.loyaltyCard, vu).revoke.prepare(e))
    );
    oe(
      this,
      "lazyMint",
      be(async (e, r) => et(this.lazyMintable, w2).lazyMint.prepare(e, r))
    );
    oe(
      this,
      "update",
      be(async (e, r) => et(this.updatableMetadata, If).update.prepare(e, r))
    );
    oe(
      this,
      "claim",
      be(async (e, r) =>
        this.claimTo.prepare(
          await this.contractWrapper.getSignerAddress(),
          e,
          r
        )
      )
    );
    oe(
      this,
      "claimTo",
      be(async (e, r, n) => {
        const i = this.claimWithConditions,
          a = this.claimCustom,
          s = this.claimZora;
        if (i) return i.to.prepare(e, r, n);
        if (a) return a.to.prepare(e, r, n);
        if (s) return s.to.prepare(e, r, n);
        throw new nu(Yp);
      })
    );
    (this.contractWrapper = e),
      (this.storage = r),
      (this.query = this.detectErc721Enumerable()),
      (this.mintable = this.detectErc721Mintable()),
      (this.burnable = this.detectErc721Burnable()),
      (this.lazyMintable = this.detectErc721LazyMintable()),
      (this.tieredDropable = this.detectErc721TieredDrop()),
      (this.signatureMintable = this.detectErc721SignatureMintable()),
      (this.claimWithConditions = this.detectErc721ClaimableWithConditions()),
      (this.claimCustom = this.detectErc721Claimable()),
      (this.claimZora = this.detectErc721ClaimableZora()),
      (this.erc721SharedMetadata = this.detectErc721SharedMetadata()),
      (this.loyaltyCard = this.detectErc721LoyaltyCard()),
      (this.updatableMetadata = this.detectErc721UpdatableMetadata()),
      (this._chainId = n);
  }
  get chainId() {
    return this._chainId;
  }
  onNetworkUpdated(e) {
    this.contractWrapper.updateSignerOrProvider(e);
  }
  getAddress() {
    return this.contractWrapper.address;
  }
  async get(e) {
    const [r, n] = await Promise.all([
      this.ownerOf(e).catch(() => Ft),
      this.getTokenMetadata(e).catch(() => ({
        id: e.toString(),
        uri: "",
        ...Mv,
      })),
    ]);
    return {
      owner: r,
      metadata: n,
      type: "ERC721",
      supply: "1",
    };
  }
  async ownerOf(e) {
    return await this.contractWrapper.read("ownerOf", [e]);
  }
  async balanceOf(e) {
    return await this.contractWrapper.read("balanceOf", [await Se(e)]);
  }
  async balance() {
    return await this.balanceOf(await this.contractWrapper.getSignerAddress());
  }
  async isApproved(e, r) {
    const [n, i] = await Promise.all([Se(e), Se(r)]);
    return await this.contractWrapper.read("isApprovedForAll", [n, i]);
  }
  async getAll(e) {
    return et(this.query, J0).all(e);
  }
  async getAllOwners() {
    return et(this.query, J0).allOwners();
  }
  async totalCount() {
    return this.nextTokenIdToMint();
  }
  async totalCirculatingSupply() {
    return et(this.query, J0).totalCirculatingSupply();
  }
  async getOwned(e) {
    var r;
    if ((e && (e = await Se(e)), (r = this.query) != null && r.owned))
      return this.query.owned.all(e);
    {
      const [n, i] = await Promise.all([
        e || this.contractWrapper.getSignerAddress(),
        this.getAllOwners(),
      ]);
      return await Promise.all(
        (i || [])
          .filter((a) => {
            var s;
            return (
              (n == null ? void 0 : n.toLowerCase()) ===
              ((s = a.owner) == null ? void 0 : s.toLowerCase())
            );
          })
          .map((a) => this.get(a.tokenId))
      );
    }
  }
  async getOwnedTokenIds(e) {
    var r;
    if ((e && (e = await Se(e)), (r = this.query) != null && r.owned))
      return this.query.owned.tokenIds(e);
    {
      const [n, i] = await Promise.all([
        e || this.contractWrapper.getSignerAddress(),
        this.getAllOwners(),
      ]);
      return (i || [])
        .filter((a) => {
          var s;
          return (
            (n == null ? void 0 : n.toLowerCase()) ===
            ((s = a.owner) == null ? void 0 : s.toLowerCase())
          );
        })
        .map((a) => ae.from(a.tokenId));
    }
  }
  async getMintTransaction(e, r) {
    return this.mintTo.prepare(e, r);
  }
  async getClaimTransaction(e, r, n) {
    const i = this.claimWithConditions,
      a = this.claimCustom;
    if (i) return i.conditions.getClaimTransaction(e, r, n);
    if (a) return a.getClaimTransaction(e, r, n);
    throw new nu(Yp);
  }
  async totalClaimedSupply() {
    const e = this.contractWrapper;
    if (Kr("totalMinted", e))
      return this.contractWrapper.read("totalMinted", []);
    if (Kr("nextTokenIdToClaim", e))
      return this.contractWrapper.read("nextTokenIdToClaim", []);
    throw new Error(
      "No function found on contract to get total claimed supply"
    );
  }
  async totalUnclaimedSupply() {
    const [e, r] = await Promise.all([
      this.nextTokenIdToMint(),
      this.totalClaimedSupply(),
    ]);
    return e.sub(r);
  }
  get claimConditions() {
    return et(this.claimWithConditions, x2).conditions;
  }
  get tieredDrop() {
    return et(this.tieredDropable, v2);
  }
  get signature() {
    return et(this.signatureMintable, T2);
  }
  get revealer() {
    var e;
    return et((e = this.lazyMintable) == null ? void 0 : e.revealer, b2);
  }
  get sharedMetadata() {
    return et(this.erc721SharedMetadata, C2);
  }
  async getTokenMetadata(e) {
    const r = await this.contractWrapper.read("tokenURI", [e]);
    if (!r) throw new LF();
    return zE(e, r, this.storage);
  }
  async nextTokenIdToMint() {
    if (Kr("nextTokenIdToMint", this.contractWrapper)) {
      let e = await this.contractWrapper.read("nextTokenIdToMint", []);
      return (
        Kr("startTokenId", this.contractWrapper) &&
          (e = e.sub(await this.contractWrapper.read("startTokenId", []))),
        e
      );
    } else {
      if (Kr("totalSupply", this.contractWrapper))
        return await this.contractWrapper.read("totalSupply", []);
      throw new Error(
        "Contract requires either `nextTokenIdToMint` or `totalSupply` function available to determine the next token ID to mint"
      );
    }
  }
  detectErc721Enumerable() {
    if (
      Qe(this.contractWrapper, "ERC721Supply") ||
      Kr("nextTokenIdToMint", this.contractWrapper)
    )
      return new Jfe(this, this.contractWrapper);
  }
  detectErc721Mintable() {
    if (Qe(this.contractWrapper, "ERC721Mintable"))
      return new Kfe(this, this.contractWrapper, this.storage);
  }
  detectErc721Burnable() {
    if (Qe(this.contractWrapper, "ERC721Burnable"))
      return new Xfe(this.contractWrapper);
  }
  detectErc721LazyMintable() {
    if (Qe(this.contractWrapper, "ERC721LazyMintable"))
      return new Vfe(this, this.contractWrapper, this.storage);
  }
  detectErc721TieredDrop() {
    if (Qe(this.contractWrapper, "ERC721TieredDrop"))
      return new Yfe(this, this.contractWrapper, this.storage);
  }
  detectErc721SignatureMintable() {
    if (
      Qe(this.contractWrapper, "ERC721SignatureMintV1") ||
      Qe(this.contractWrapper, "ERC721SignatureMintV2")
    )
      return new ide(this.contractWrapper, this.storage);
  }
  detectErc721ClaimableWithConditions() {
    if (
      Qe(this.contractWrapper, "ERC721ClaimConditionsV1") ||
      Qe(this.contractWrapper, "ERC721ClaimConditionsV2") ||
      Qe(this.contractWrapper, "ERC721ClaimPhasesV1") ||
      Qe(this.contractWrapper, "ERC721ClaimPhasesV2")
    )
      return new zfe(this, this.contractWrapper, this.storage);
  }
  detectErc721Claimable() {
    if (Qe(this.contractWrapper, "ERC721ClaimCustom"))
      return new qfe(this, this.contractWrapper);
  }
  detectErc721ClaimableZora() {
    if (Qe(this.contractWrapper, "ERC721ClaimZora"))
      return new ede(this, this.contractWrapper);
  }
  detectErc721SharedMetadata() {
    if (Qe(this.contractWrapper, "ERC721SharedMetadata"))
      return new nde(this.contractWrapper, this.storage);
  }
  detectErc721LoyaltyCard() {
    if (Qe(this.contractWrapper, "ERC721LoyaltyCard"))
      return new tde(this.contractWrapper);
  }
  detectErc721UpdatableMetadata() {
    if (Qe(this.contractWrapper, "ERC721UpdatableMetadata"))
      return new rde(this.contractWrapper, this.storage);
  }
}
class sde {
  constructor(e, r, n) {
    oe(this, "featureName", I2.name);
    oe(
      this,
      "to",
      be(async (e, r) => {
        const n = r.map((u) => u.metadata),
          i = r.map((u) => u.supply),
          a = await $u(n, this.storage),
          s = await Se(e),
          o = new Sr(this.contractWrapper),
          c = await Promise.all(
            a.map(async (u, d) => o.encode("mintTo", [s, da, u, i[d]]))
          );
        return ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "multicall",
          args: [c],
          parse: (u) => {
            const d = this.contractWrapper.parseLogs("TokensMinted", u.logs);
            if (d.length === 0 || d.length < n.length)
              throw new Error("TokenMinted event not found, minting failed");
            return d.map((m) => {
              const v = m.args.tokenIdMinted;
              return {
                id: v,
                receipt: u,
                data: () => this.erc1155.get(v),
              };
            });
          },
        });
      })
    );
    (this.erc1155 = e), (this.contractWrapper = r), (this.storage = n);
  }
}
class ode {
  constructor(e) {
    oe(this, "featureName", Vl.name);
    oe(
      this,
      "tokens",
      be(async (e, r) => {
        const n = await this.contractWrapper.getSignerAddress();
        return this.from.prepare(n, e, r);
      })
    );
    oe(
      this,
      "from",
      be(async (e, r, n) =>
        ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "burn",
          args: [await Se(e), r, n],
        })
      )
    );
    oe(
      this,
      "batch",
      be(async (e, r) => {
        const n = await this.contractWrapper.getSignerAddress();
        return this.batchFrom.prepare(n, e, r);
      })
    );
    oe(
      this,
      "batchFrom",
      be(async (e, r, n) =>
        ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "burnBatch",
          args: [await Se(e), r, n],
        })
      )
    );
    this.contractWrapper = e;
  }
}
class cde {
  constructor(e, r) {
    oe(this, "featureName", Gl.name);
    (this.erc1155 = e), (this.contractWrapper = r);
  }
  async all(e) {
    const r = ae.from((e == null ? void 0 : e.start) || 0).toNumber(),
      n = ae.from((e == null ? void 0 : e.count) || Hh).toNumber(),
      i = Math.min((await this.totalCount()).toNumber(), r + n);
    return await Promise.all(
      [...Array(i - r).keys()].map((a) => this.erc1155.get((r + a).toString()))
    );
  }
  async totalCount() {
    return await this.contractWrapper.read("nextTokenIdToMint", []);
  }
  async totalCirculatingSupply(e) {
    return await this.contractWrapper.read("totalSupply", [e]);
  }
  async owned(e) {
    const [r, n] = await Promise.all([
        Se(e || (await this.contractWrapper.getSignerAddress())),
        this.contractWrapper.read("nextTokenIdToMint", []),
      ]),
      a = (
        await this.contractWrapper.read("balanceOfBatch", [
          Array(n.toNumber()).fill(r),
          Array.from(Array(n.toNumber()).keys()),
        ])
      )
        .map((o, c) => ({
          tokenId: c,
          balance: o,
        }))
        .filter((o) => o.balance.gt(0));
    return (
      await Promise.all(a.map((o) => this.erc1155.get(o.tokenId.toString())))
    ).map((o, c) => ({
      ...o,
      owner: r,
      quantityOwned: a[c].balance.toString(),
    }));
  }
}
async function KE(t, e) {
  try {
    const r = new Yt(t, lF, e),
      [n, i] = await Promise.all([
        go(await r.contractType()).replace(/\x00/g, ""),
        await r.contractVersion(),
      ]);
    return {
      type: n,
      version: i,
    };
  } catch {
    return;
  }
}
class lde {
  constructor(e, r, n) {
    oe(this, "featureName", S2.name);
    oe(
      this,
      "lazyMint",
      be(async (e, r) => {
        const n = await this.erc1155.nextTokenIdToMint(),
          i = await $u(e, this.storage, n.toNumber(), r),
          a = i[0].substring(0, i[0].lastIndexOf("/"));
        for (let c = 0; c < i.length; c++) {
          const u = i[c].substring(0, i[c].lastIndexOf("/"));
          if (a !== u)
            throw new Error(
              `Can only create batches with the same base URI for every entry in the batch. Expected '${a}' but got '${u}'`
            );
        }
        const s = (c) => {
            const u = this.contractWrapper.parseLogs(
                "TokensLazyMinted",
                c == null ? void 0 : c.logs
              ),
              d = u[0].args.startTokenId,
              m = u[0].args.endTokenId,
              v = [];
            for (let E = d; E.lte(m); E = E.add(1))
              v.push({
                id: E,
                receipt: c,
                data: () => this.erc1155.getTokenMetadata(E),
              });
            return v;
          },
          o = await KE(
            this.contractWrapper.address,
            this.contractWrapper.getProvider()
          );
        return this.isLegacyEditionDropContract(this.contractWrapper, o)
          ? ze.fromContractWrapper({
              contractWrapper: this.contractWrapper,
              method: "lazyMint",
              args: [i.length, `${a.endsWith("/") ? a : `${a}/`}`],
              parse: s,
            })
          : ze.fromContractWrapper({
              contractWrapper: this.contractWrapper,
              method: "lazyMint",
              args: [i.length, `${a.endsWith("/") ? a : `${a}/`}`, Lt("")],
              parse: s,
            });
      })
    );
    (this.erc1155 = e),
      (this.contractWrapper = r),
      (this.storage = n),
      (this.revealer = this.detectErc1155Revealable());
  }
  detectErc1155Revealable() {
    if (Qe(this.contractWrapper, "ERC1155Revealable"))
      return new CL(this.contractWrapper, this.storage, Rf.name, () =>
        this.erc1155.nextTokenIdToMint()
      );
  }
  isLegacyEditionDropContract(e, r) {
    return (r && r.type === "DropERC1155" && r.version < 3) || !1;
  }
}
class ude {
  constructor(e, r, n) {
    oe(this, "featureName", Kl.name);
    oe(
      this,
      "to",
      be(async (e, r) => {
        const n = await this.getMintTransaction(e, r);
        return (
          n.setParse((i) => {
            const a = this.contractWrapper.parseLogs(
              "TransferSingle",
              i == null ? void 0 : i.logs
            );
            if (a.length === 0)
              throw new Error("TransferSingleEvent event not found");
            const s = a[0].args.id;
            return {
              id: s,
              receipt: i,
              data: () => this.erc1155.get(s.toString()),
            };
          }),
          n
        );
      })
    );
    oe(
      this,
      "additionalSupplyTo",
      be(async (e, r, n) => {
        const i = await this.erc1155.getTokenMetadata(r);
        return ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "mintTo",
          args: [await Se(e), r, i.uri, n],
          parse: (a) => ({
            id: ae.from(r),
            receipt: a,
            data: () => this.erc1155.get(r),
          }),
        });
      })
    );
    (this.erc1155 = e),
      (this.contractWrapper = r),
      (this.storage = n),
      (this.batch = this.detectErc1155BatchMintable());
  }
  async getMintTransaction(e, r) {
    const n = await qE(r.metadata, this.storage);
    return ze.fromContractWrapper({
      contractWrapper: this.contractWrapper,
      method: "mintTo",
      args: [await Se(e), da, n, r.supply],
    });
  }
  detectErc1155BatchMintable() {
    if (Qe(this.contractWrapper, "ERC1155BatchMintable"))
      return new sde(this.erc1155, this.contractWrapper, this.storage);
  }
}
const X7 = ne.object({
    address: wr,
    quantity: Gi.default(1),
  }),
  fde = ne.union([
    ne.array(ne.string()).transform(
      async (t) =>
        await Promise.all(
          t.map((e) =>
            X7.parseAsync({
              address: e,
            })
          )
        )
    ),
    ne.array(X7),
  ]);
class dde {
  constructor(e) {
    oe(this, "featureName", Xp.name);
    oe(
      this,
      "to",
      be(async (e, r, n, i) => await this.getClaimTransaction(e, r, n, i))
    );
    this.contractWrapper = e;
  }
  async getClaimTransaction(e, r, n, i) {
    let a = {};
    return (
      i &&
        i.pricePerToken &&
        (a = await PL(
          this.contractWrapper,
          i.pricePerToken,
          n,
          i.currencyAddress,
          i.checkERC20Allowance
        )),
      ze.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "claim",
        args: [await Se(e), r, n],
        overrides: a,
      })
    );
  }
}
class hde {
  constructor(e, r) {
    oe(this, "featureName", k2.name);
    oe(
      this,
      "to",
      be(
        async (e, r, n, i) =>
          await this.conditions.getClaimTransaction(e, r, n, i)
      )
    );
    (this.contractWrapper = e), (this.storage = r);
    const n = new Q0(this.contractWrapper, Z0, this.storage);
    this.conditions = new Bfe(e, n, this.storage);
  }
}
class pde {
  constructor(e, r, n) {
    oe(this, "featureName", M2.name);
    oe(
      this,
      "mint",
      be(async (e) => {
        const r = e.payload,
          n = e.signature,
          i = await this.mapPayloadToContractStruct(r),
          a = await this.contractWrapper.getCallOverrides();
        return (
          await al(
            this.contractWrapper,
            i.pricePerToken.mul(i.quantity),
            r.currencyAddress,
            a
          ),
          ze.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "mintWithSignature",
            args: [i, n],
            overrides: a,
            parse: (s) => {
              const o = this.contractWrapper.parseLogs(
                "TokensMintedWithSignature",
                s.logs
              );
              if (o.length === 0)
                throw new Error("No MintWithSignature event found");
              return {
                id: o[0].args.tokenIdMinted,
                receipt: s,
              };
            },
          })
        );
      })
    );
    oe(
      this,
      "mintBatch",
      be(async (e) => {
        const r = await Promise.all(
            e.map(async (a) => {
              const s = await this.mapPayloadToContractStruct(a.payload),
                o = a.signature,
                c = a.payload.price;
              if (ae.from(c).gt(0))
                throw new Error(
                  "Can only batch free mints. For mints with a price, use regular mint()"
                );
              return {
                message: s,
                signature: o,
              };
            })
          ),
          n = new Sr(this.contractWrapper),
          i = r.map((a) =>
            n.encode("mintWithSignature", [a.message, a.signature])
          );
        if (Kr("multicall", this.contractWrapper))
          return ze.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "multicall",
            args: [i],
            parse: (a) => {
              const s = this.contractWrapper.parseLogs(
                "TokensMintedWithSignature",
                a.logs
              );
              if (s.length === 0)
                throw new Error("No MintWithSignature event found");
              return s.map((o) => ({
                id: o.args.tokenIdMinted,
                receipt: a,
              }));
            },
          });
        throw new Error("Multicall not supported on this contract!");
      })
    );
    (this.contractWrapper = e), (this.storage = r), (this.roles = n);
  }
  async verify(e) {
    const r = e.payload,
      n = e.signature,
      i = await this.mapPayloadToContractStruct(r);
    return (await this.contractWrapper.read("verify", [i, n]))[0];
  }
  async generate(e) {
    const r = {
      ...e,
      tokenId: da,
    };
    return this.generateFromTokenId(r);
  }
  async generateFromTokenId(e) {
    return (await this.generateBatchFromTokenIds([e]))[0];
  }
  async generateBatch(e) {
    const r = e.map((n) => ({
      ...n,
      tokenId: da,
    }));
    return this.generateBatchFromTokenIds(r);
  }
  async generateBatchFromTokenIds(e) {
    var u;
    await ((u = this.roles) == null
      ? void 0
      : u.verify(["minter"], await this.contractWrapper.getSignerAddress()));
    const r = await Promise.all(e.map((d) => gue.parseAsync(d))),
      n = r.map((d) => d.metadata),
      i = await $u(n, this.storage),
      a = await this.contractWrapper.getChainID(),
      s = this.contractWrapper.getSigner();
    Je(s);
    const o = await KE(
        this.contractWrapper.address,
        this.contractWrapper.getProvider()
      ),
      c = (o == null ? void 0 : o.type) === "TokenERC1155";
    return await Promise.all(
      r.map(async (d, m) => {
        const v = i[m],
          E = await bue.parseAsync({
            ...d,
            uri: v,
          }),
          A = await this.contractWrapper.signTypedData(
            s,
            {
              name: c ? "TokenERC1155" : "SignatureMintERC1155",
              version: "1",
              chainId: a,
              verifyingContract: this.contractWrapper.address,
            },
            {
              MintRequest: Eue,
            },
            await this.mapPayloadToContractStruct(E)
          );
        return {
          payload: E,
          signature: A.toString(),
        };
      })
    );
  }
  async mapPayloadToContractStruct(e) {
    const r = await pi(
      this.contractWrapper.getProvider(),
      e.price,
      e.currencyAddress
    );
    return {
      to: e.to,
      tokenId: e.tokenId,
      uri: e.uri,
      quantity: e.quantity,
      pricePerToken: r,
      currency: e.currencyAddress,
      validityStartTimestamp: e.mintStartTime,
      validityEndTimestamp: e.mintEndTime,
      uid: e.uid,
      royaltyRecipient: e.royaltyRecipient,
      royaltyBps: e.royaltyBps,
      primarySaleRecipient: e.primarySaleRecipient,
    };
  }
}
class mde {
  constructor(e, r, n) {
    oe(this, "featureName", R2.name);
    oe(
      this,
      "transfer",
      be(
        (() => {
          var e = this;
          return async function (r, n, i) {
            let a =
              arguments.length > 3 && arguments[3] !== void 0
                ? arguments[3]
                : [0];
            const s = await e.contractWrapper.getSignerAddress();
            return ze.fromContractWrapper({
              contractWrapper: e.contractWrapper,
              method: "safeTransferFrom",
              args: [s, await Se(r), n, i, a],
            });
          };
        })()
      )
    );
    oe(
      this,
      "transferFrom",
      be(
        (() => {
          var e = this;
          return async function (r, n, i, a) {
            let s =
              arguments.length > 4 && arguments[4] !== void 0
                ? arguments[4]
                : [0];
            return ze.fromContractWrapper({
              contractWrapper: e.contractWrapper,
              method: "safeTransferFrom",
              args: [await Se(r), await Se(n), i, a, s],
            });
          };
        })()
      )
    );
    oe(
      this,
      "setApprovalForAll",
      be(async (e, r) =>
        ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "setApprovalForAll",
          args: [e, r],
        })
      )
    );
    oe(
      this,
      "airdrop",
      be(
        (() => {
          var e = this;
          return async function (r, n, i) {
            let a =
              arguments.length > 3 && arguments[3] !== void 0
                ? arguments[3]
                : [0];
            const s = i
                ? await Se(i)
                : await e.contractWrapper.getSignerAddress(),
              o = await e.balanceOf(s, r),
              c = await fde.parseAsync(n),
              u = c.reduce(
                (v, E) =>
                  ae
                    .from(v)
                    .add(ae.from((E == null ? void 0 : E.quantity) || 1)),
                ae.from(0)
              );
            if (o.lt(ae.from(u)))
              throw new Error(
                `The caller owns ${o.toString()} NFTs, but wants to airdrop ${u.toString()} NFTs.`
              );
            const d = new Sr(e.contractWrapper),
              m = c.map((v) => {
                let { address: E, quantity: A } = v;
                return d.encode("safeTransferFrom", [s, E, r, A, a]);
              });
            return ze.fromContractWrapper({
              contractWrapper: e.contractWrapper,
              method: "multicall",
              args: [m],
            });
          };
        })()
      )
    );
    oe(
      this,
      "mint",
      be(async (e) =>
        this.mintTo.prepare(await this.contractWrapper.getSignerAddress(), e)
      )
    );
    oe(
      this,
      "mintTo",
      be(async (e, r) => et(this.mintable, Kl).to.prepare(e, r))
    );
    oe(
      this,
      "mintAdditionalSupply",
      be(async (e, r) =>
        et(this.mintable, Kl).additionalSupplyTo.prepare(
          await this.contractWrapper.getSignerAddress(),
          e,
          r
        )
      )
    );
    oe(
      this,
      "mintAdditionalSupplyTo",
      be(async (e, r, n) =>
        et(this.mintable, Kl).additionalSupplyTo.prepare(e, r, n)
      )
    );
    oe(
      this,
      "mintBatch",
      be(async (e) =>
        this.mintBatchTo.prepare(
          await this.contractWrapper.getSignerAddress(),
          e
        )
      )
    );
    oe(
      this,
      "mintBatchTo",
      be(async (e, r) => {
        var n;
        return et(
          (n = this.mintable) == null ? void 0 : n.batch,
          I2
        ).to.prepare(e, r);
      })
    );
    oe(
      this,
      "burn",
      be(async (e, r) => et(this.burnable, Vl).tokens.prepare(e, r))
    );
    oe(
      this,
      "burnFrom",
      be(async (e, r, n) => et(this.burnable, Vl).from.prepare(e, r, n))
    );
    oe(
      this,
      "burnBatch",
      be(async (e, r) => et(this.burnable, Vl).batch.prepare(e, r))
    );
    oe(
      this,
      "burnBatchFrom",
      be(async (e, r, n) => et(this.burnable, Vl).batchFrom.prepare(e, r, n))
    );
    oe(
      this,
      "lazyMint",
      be(async (e, r) => et(this.lazyMintable, S2).lazyMint.prepare(e, r))
    );
    oe(
      this,
      "claim",
      be(async (e, r, n) =>
        this.claimTo.prepare(
          await this.contractWrapper.getSignerAddress(),
          e,
          r,
          n
        )
      )
    );
    oe(
      this,
      "claimTo",
      be(async (e, r, n, i) => {
        const a = this.claimWithConditions,
          s = this.claimCustom;
        if (a) return a.to.prepare(e, r, n, i);
        if (s) return s.to.prepare(e, r, n, i);
        throw new nu(Xp);
      })
    );
    (this.contractWrapper = e),
      (this.storage = r),
      (this.query = this.detectErc1155Enumerable()),
      (this.mintable = this.detectErc1155Mintable()),
      (this.burnable = this.detectErc1155Burnable()),
      (this.lazyMintable = this.detectErc1155LazyMintable()),
      (this.signatureMintable = this.detectErc1155SignatureMintable()),
      (this.claimCustom = this.detectErc1155Claimable()),
      (this.claimWithConditions = this.detectErc1155ClaimableWithConditions()),
      (this._chainId = n);
  }
  get chainId() {
    return this._chainId;
  }
  onNetworkUpdated(e) {
    this.contractWrapper.updateSignerOrProvider(e);
  }
  getAddress() {
    return this.contractWrapper.address;
  }
  async get(e) {
    const [r, n] = await Promise.all([
      this.contractWrapper.read("totalSupply", [e]).catch(() => ae.from(0)),
      this.getTokenMetadata(e).catch(() => ({
        id: e.toString(),
        uri: "",
        ...Mv,
      })),
    ]);
    return {
      owner: Ft,
      metadata: n,
      type: "ERC1155",
      supply: r.toString(),
    };
  }
  async totalSupply(e) {
    if (Qe(this.contractWrapper, "ERC1155Supply"))
      return await this.contractWrapper.read("totalSupply", [e]);
    throw new nu(L_);
  }
  async balanceOf(e, r) {
    return await this.contractWrapper.read("balanceOf", [await Se(e), r]);
  }
  async balance(e) {
    return await this.balanceOf(
      await this.contractWrapper.getSignerAddress(),
      e
    );
  }
  async isApproved(e, r) {
    return await this.contractWrapper.read("isApprovedForAll", [
      await Se(e),
      await Se(r),
    ]);
  }
  async nextTokenIdToMint() {
    if (Kr("nextTokenIdToMint", this.contractWrapper))
      return await this.contractWrapper.read("nextTokenIdToMint", []);
    throw new Error(
      "Contract requires the `nextTokenIdToMint` function available to determine the next token ID to mint"
    );
  }
  async getAll(e) {
    return et(this.query, Gl).all(e);
  }
  async totalCount() {
    return et(this.query, Gl).totalCount();
  }
  async totalCirculatingSupply(e) {
    return et(this.query, Gl).totalCirculatingSupply(e);
  }
  async getOwned(e) {
    return e && (e = await Se(e)), et(this.query, Gl).owned(e);
  }
  async getMintTransaction(e, r) {
    return et(this.mintable, Kl).getMintTransaction(e, r);
  }
  async getClaimTransaction(e, r, n, i) {
    const a = this.claimWithConditions,
      s = this.claimCustom;
    if (a) return a.conditions.getClaimTransaction(e, r, n, i);
    if (s) return s.getClaimTransaction(e, r, n, i);
    throw new nu(Xp);
  }
  get claimConditions() {
    return et(this.claimWithConditions, k2).conditions;
  }
  get signature() {
    return et(this.signatureMintable, M2);
  }
  get revealer() {
    var e;
    return et((e = this.lazyMintable) == null ? void 0 : e.revealer, Rf);
  }
  async getTokenMetadata(e) {
    const r = await this.contractWrapper.read("uri", [e]);
    if (!r) throw new LF();
    return zE(e, r, this.storage);
  }
  detectErc1155Enumerable() {
    if (Qe(this.contractWrapper, "ERC1155Enumerable"))
      return new cde(this, this.contractWrapper);
  }
  detectErc1155Mintable() {
    if (Qe(this.contractWrapper, "ERC1155Mintable"))
      return new ude(this, this.contractWrapper, this.storage);
  }
  detectErc1155Burnable() {
    if (Qe(this.contractWrapper, "ERC1155Burnable"))
      return new ode(this.contractWrapper);
  }
  detectErc1155LazyMintable() {
    if (
      Qe(this.contractWrapper, "ERC1155LazyMintableV1") ||
      Qe(this.contractWrapper, "ERC1155LazyMintableV2")
    )
      return new lde(this, this.contractWrapper, this.storage);
  }
  detectErc1155SignatureMintable() {
    if (Qe(this.contractWrapper, "ERC1155SignatureMintable"))
      return new pde(this.contractWrapper, this.storage);
  }
  detectErc1155Claimable() {
    if (Qe(this.contractWrapper, "ERC1155ClaimCustom"))
      return new dde(this.contractWrapper);
  }
  detectErc1155ClaimableWithConditions() {
    if (
      Qe(this.contractWrapper, "ERC1155ClaimConditionsV1") ||
      Qe(this.contractWrapper, "ERC1155ClaimConditionsV2") ||
      Qe(this.contractWrapper, "ERC1155ClaimPhasesV1") ||
      Qe(this.contractWrapper, "ERC1155ClaimPhasesV2")
    )
      return new hde(this.contractWrapper, this.storage);
  }
}
function Z_(t) {
  return mo(t) ? qi : t;
}
async function yde(t, e, r, n, i) {
  try {
    const a = new Yt(r, yv, t),
      s = await a.supportsInterface(kv),
      o = await a.supportsInterface(Sv);
    if (s) {
      const c = new Yt(r, yn, t);
      if (await c.isApprovedForAll(i, e)) return !0;
      let d;
      try {
        d = await c.getApproved(n);
      } catch {}
      return (d == null ? void 0 : d.toLowerCase()) === e.toLowerCase();
    } else
      return o
        ? await new Yt(r, ti, t).isApprovedForAll(i, e)
        : (console.error("Contract does not implement ERC 1155 or ERC 721."),
          !1);
  } catch (a) {
    return console.error("Failed to check if token is approved", a), !1;
  }
}
async function ab(t, e, r, n, i) {
  const a = new Gn(t.getSignerOrProvider(), r, yv, t.options, t.storage),
    s = await a.read("supportsInterface", [kv]),
    o = await a.read("supportsInterface", [Sv]);
  if (s) {
    const c = new Gn(t.getSignerOrProvider(), r, yn, t.options, t.storage);
    (await c.read("isApprovedForAll", [i, e])) ||
      (await c.read("getApproved", [n])).toLowerCase() === e.toLowerCase() ||
      (await c.sendTransaction("setApprovalForAll", [e, !0]));
  } else if (o) {
    const c = new Gn(t.getSignerOrProvider(), r, ti, t.options, t.storage);
    (await c.read("isApprovedForAll", [i, e])) ||
      (await c.sendTransaction("setApprovalForAll", [e, !0]));
  } else throw Error("Contract must implement ERC 1155 or ERC 721.");
}
function vke(t) {
  switch (
    (Je(t.assetContractAddress !== void 0 && t.assetContractAddress !== null),
    Je(t.buyoutPricePerToken !== void 0 && t.buyoutPricePerToken !== null),
    Je(
      t.listingDurationInSeconds !== void 0 &&
        t.listingDurationInSeconds !== null
    ),
    Je(t.startTimestamp !== void 0 && t.startTimestamp !== null),
    Je(t.tokenId !== void 0 && t.tokenId !== null),
    Je(t.quantity !== void 0 && t.quantity !== null),
    t.type)
  ) {
    case "NewAuctionListing":
      Je(t.reservePricePerToken !== void 0 && t.reservePricePerToken !== null);
  }
}
async function xke(t, e, r) {
  return {
    quantity: r.quantityDesired,
    pricePerToken: r.pricePerToken,
    currencyContractAddress: r.currency,
    buyerAddress: r.offeror,
    quantityDesired: r.quantityWanted,
    currencyValue: await hs(
      t,
      r.currency,
      r.quantityWanted.mul(r.pricePerToken)
    ),
    listingId: e,
  };
}
function wke(t, e, r) {
  return (
    (r = ae.from(r)),
    (t = ae.from(t)),
    (e = ae.from(e)),
    t.eq(ae.from(0)) ? !1 : e.sub(t).mul(nO).div(t).gte(r)
  );
}
async function Bf(t, e, r) {
  const n = [];
  for (; e - t > Hh; ) n.push(r(t, t + Hh - 1)), (t += Hh);
  return n.push(r(t, e - 1)), await Promise.all(n);
}
class Df {
  constructor(e) {
    this.contractWrapper = e;
  }
  addTransactionListener(e) {
    this.contractWrapper.addListener(ia.Transaction, e);
  }
  removeTransactionListener(e) {
    this.contractWrapper.off(ia.Transaction, e);
  }
  addEventListener(e, r) {
    const n = this.contractWrapper.readContract.interface.getEvent(e),
      a = {
        address: this.contractWrapper.address,
        topics: [this.contractWrapper.readContract.interface.getEventTopic(n)],
      },
      s = (o) => {
        const c = this.contractWrapper.readContract.interface.parseLog(o);
        r(this.toContractEvent(c.eventFragment, c.args, o));
      };
    return (
      this.contractWrapper.getProvider().on(a, s),
      () => {
        this.contractWrapper.getProvider().off(a, s);
      }
    );
  }
  listenToAllEvents(e) {
    const n = {
        address: this.contractWrapper.address,
      },
      i = (a) => {
        try {
          const s = this.contractWrapper.readContract.interface.parseLog(a);
          e(this.toContractEvent(s.eventFragment, s.args, a));
        } catch (s) {
          console.error("Could not parse event:", a, s);
        }
      };
    return (
      this.contractWrapper.getProvider().on(n, i),
      () => {
        this.contractWrapper.getProvider().off(n, i);
      }
    );
  }
  removeEventListener(e, r) {
    const n = this.contractWrapper.readContract.interface.getEvent(e);
    this.contractWrapper.readContract.off(n.name, r);
  }
  removeAllListeners() {
    this.contractWrapper.readContract.removeAllListeners();
    const r = {
      address: this.contractWrapper.address,
    };
    this.contractWrapper.getProvider().removeAllListeners(r);
  }
  async getAllEvents() {
    let e =
      arguments.length > 0 && arguments[0] !== void 0
        ? arguments[0]
        : {
            fromBlock: 0,
            toBlock: "latest",
            order: "desc",
          };
    const n = (
      await this.contractWrapper.readContract.queryFilter(
        {},
        e.fromBlock,
        e.toBlock
      )
    ).sort((i, a) =>
      e.order === "desc"
        ? a.blockNumber - i.blockNumber
        : i.blockNumber - a.blockNumber
    );
    return this.parseEvents(n);
  }
  async getEvents(e) {
    let r =
      arguments.length > 1 && arguments[1] !== void 0
        ? arguments[1]
        : {
            fromBlock: 0,
            toBlock: "latest",
            order: "desc",
          };
    const n = this.contractWrapper.readContract.interface.getEvent(e),
      i = r.filters ? n.inputs.map((c) => r.filters[c.name]) : [],
      a = this.contractWrapper.readContract.filters[n.name](...i),
      o = (
        await this.contractWrapper.readContract.queryFilter(
          a,
          r.fromBlock,
          r.toBlock
        )
      ).sort((c, u) =>
        r.order === "desc"
          ? u.blockNumber - c.blockNumber
          : c.blockNumber - u.blockNumber
      );
    return this.parseEvents(o);
  }
  parseEvents(e) {
    return e.map((r) => {
      const n = Object.fromEntries(
        Object.entries(r).filter(
          (i) => typeof i[1] != "function" && i[0] !== "args"
        )
      );
      if (r.args) {
        const i = Object.entries(r.args),
          a = i.slice(i.length / 2, i.length),
          s = {};
        for (const [o, c] of a) s[o] = c;
        return {
          eventName: r.event || "",
          data: s,
          transaction: n,
        };
      }
      return {
        eventName: r.event || "",
        data: {},
        transaction: n,
      };
    });
  }
  toContractEvent(e, r, n) {
    const i = Object.fromEntries(
        Object.entries(n).filter(
          (s) => typeof s[1] != "function" && s[0] !== "args"
        )
      ),
      a = {};
    return (
      e.inputs.forEach((s, o) => {
        if (Array.isArray(r[o])) {
          const c = s.components;
          if (c) {
            const u = r[o];
            if (s.type === "tuple[]") {
              const d = [];
              for (let m = 0; m < u.length; m++) {
                const v = u[m],
                  E = {};
                for (let A = 0; A < c.length; A++) {
                  const I = c[A].name;
                  E[I] = v[A];
                }
                d.push(E);
              }
              a[s.name] = d;
            } else {
              const d = {};
              for (let m = 0; m < c.length; m++) {
                const v = c[m].name;
                d[v] = u[m];
              }
              a[s.name] = d;
            }
          }
        } else a[s.name] = r[o];
      }),
      {
        eventName: e.name,
        data: a,
        transaction: i,
      }
    );
  }
}
const e9 = ne.object({
  assetContractAddress: wr,
  tokenId: Tn,
  quantity: Tn.default(1),
  currencyContractAddress: wr.default(qi),
  pricePerToken: Gi,
  startTimestamp: Ev.default(new Date()),
  endTimestamp: Hm,
  isReservedListing: ne.boolean().default(!1),
});
class Rv {
  constructor(e) {
    this.contractWrapper = e;
  }
  overrideNextTransaction(e) {
    this.contractWrapper.withTransactionOverride(e);
  }
}
class Pv {
  constructor(e) {
    this.contractWrapper = e;
  }
  async gasCostOf(e, r) {
    const [n, i] = await Promise.all([
      this.contractWrapper.getProvider().getGasPrice(),
      this.contractWrapper.estimateGas(e, r),
    ]);
    return Wr(i.mul(n));
  }
  async gasLimitOf(e, r) {
    return this.contractWrapper.estimateGas(e, r);
  }
  async currentGasPriceInGwei() {
    const e = await this.contractWrapper.getProvider().getGasPrice();
    return nl(e, "gwei");
  }
}
class gde {
  constructor(e, r) {
    oe(this, "featureName", $2.name);
    oe(
      this,
      "createListing",
      be(async (e) => {
        const r = await e9.parseAsync(e);
        await ab(
          this.contractWrapper,
          this.getAddress(),
          r.assetContractAddress,
          r.tokenId,
          await this.contractWrapper.getSignerAddress()
        );
        const n = await pi(
            this.contractWrapper.getProvider(),
            r.pricePerToken,
            r.currencyContractAddress
          ),
          a = (await this.contractWrapper.getProvider().getBlock("latest"))
            .timestamp;
        return (
          r.startTimestamp.lt(a) && (r.startTimestamp = ae.from(a)),
          ze.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "createListing",
            args: [
              {
                assetContract: r.assetContractAddress,
                tokenId: r.tokenId,
                quantity: r.quantity,
                currency: Z_(r.currencyContractAddress),
                pricePerToken: n,
                startTimestamp: r.startTimestamp,
                endTimestamp: r.endTimestamp,
                reserved: r.isReservedListing,
              },
            ],
            parse: (s) => ({
              id: this.contractWrapper.parseLogs(
                "NewListing",
                s == null ? void 0 : s.logs
              )[0].args.listingId,
              receipt: s,
            }),
          })
        );
      })
    );
    oe(
      this,
      "createListingsBatch",
      be(async (e) => {
        const r = await Promise.all(
          e.map(async (n) => (await this.createListing.prepare(n)).encode())
        );
        return ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "multicall",
          args: [r],
          parse: (n) =>
            this.contractWrapper
              .parseLogs("NewListing", n == null ? void 0 : n.logs)
              .map((a) => ({
                id: a.args.listingId,
                receipt: n,
              })),
        });
      })
    );
    oe(
      this,
      "updateListing",
      be(async (e, r) => {
        const n = await e9.parseAsync(r);
        await ab(
          this.contractWrapper,
          this.getAddress(),
          n.assetContractAddress,
          n.tokenId,
          await this.contractWrapper.getSignerAddress()
        );
        const i = await pi(
          this.contractWrapper.getProvider(),
          n.pricePerToken,
          n.currencyContractAddress
        );
        return ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "updateListing",
          args: [
            e,
            {
              assetContract: n.assetContractAddress,
              tokenId: n.tokenId,
              quantity: n.quantity,
              currency: Z_(n.currencyContractAddress),
              pricePerToken: i,
              startTimestamp: n.startTimestamp,
              endTimestamp: n.endTimestamp,
              reserved: n.isReservedListing,
            },
          ],
          parse: (a) => ({
            id: this.contractWrapper.parseLogs(
              "UpdatedListing",
              a == null ? void 0 : a.logs
            )[0].args.listingId,
            receipt: a,
          }),
        });
      })
    );
    oe(
      this,
      "cancelListing",
      be(async (e) =>
        ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "cancelListing",
          args: [e],
        })
      )
    );
    oe(
      this,
      "buyFromListing",
      be(async (e, r, n) => {
        n && (n = await Se(n));
        const i = await this.validateListing(ae.from(e)),
          { valid: a, error: s } = await this.isStillValidListing(i, r);
        if (!a) throw new Error(`Listing ${e} is no longer valid. ${s}`);
        const o = n || (await this.contractWrapper.getSignerAddress()),
          c = ae.from(r),
          u = ae.from(i.pricePerToken).mul(c),
          d = (await this.contractWrapper.getCallOverrides()) || {};
        return (
          await al(this.contractWrapper, u, i.currencyContractAddress, d),
          ze.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "buyFromListing",
            args: [e, o, c, i.currencyContractAddress, u],
            overrides: d,
          })
        );
      })
    );
    oe(
      this,
      "approveBuyerForReservedListing",
      be(async (e, r) => {
        if (await this.isBuyerApprovedForListing(e, r))
          throw new Error(`Buyer ${r} already approved for listing ${e}.`);
        return ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "approveBuyerForListing",
          args: [e, r, !0],
        });
      })
    );
    oe(
      this,
      "revokeBuyerApprovalForReservedListing",
      be(async (e, r) => {
        if (await this.isBuyerApprovedForListing(e, r))
          return ze.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "approveBuyerForListing",
            args: [e, r, !1],
          });
        throw new Error(`Buyer ${r} not approved for listing ${e}.`);
      })
    );
    oe(
      this,
      "approveCurrencyForListing",
      be(async (e, r, n) => {
        const i = await this.validateListing(ae.from(e)),
          a = await Se(r);
        a === i.currencyContractAddress && Je(n === i.pricePerToken);
        const s = await this.contractWrapper.read("currencyPriceForListing", [
          e,
          a,
        ]);
        return (
          Je(n === s),
          ze.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "approveCurrencyForListing",
            args: [e, a, n],
          })
        );
      })
    );
    oe(
      this,
      "revokeCurrencyApprovalForListing",
      be(async (e, r) => {
        const n = await this.validateListing(ae.from(e)),
          i = await Se(r);
        if (i === n.currencyContractAddress)
          throw new Error("Can't revoke approval for main listing currency.");
        const a = await this.contractWrapper.read("currencyPriceForListing", [
          e,
          i,
        ]);
        return (
          Je(!a.isZero()),
          ze.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "approveCurrencyForListing",
            args: [e, i, ae.from(0)],
          })
        );
      })
    );
    (this.contractWrapper = e),
      (this.storage = r),
      (this.events = new Df(this.contractWrapper)),
      (this.encoder = new Sr(this.contractWrapper)),
      (this.interceptor = new Rv(this.contractWrapper)),
      (this.estimator = new Pv(this.contractWrapper));
  }
  getAddress() {
    return this.contractWrapper.address;
  }
  async getTotalCount() {
    return await this.contractWrapper.read("totalListings", []);
  }
  async getAll(e) {
    const r = await this.getTotalCount(),
      n = ae.from((e == null ? void 0 : e.start) || 0).toNumber(),
      i = r.toNumber();
    if (i === 0) throw new Error("No listings exist on the contract.");
    let a = [];
    a = (
      await Bf(n, i, (c, u) =>
        this.contractWrapper.read("getAllListings", [c, u])
      )
    ).flat();
    const o = await this.applyFilter(a, e);
    return await Promise.all(o.map((c) => this.mapListing(c)));
  }
  async getAllValid(e) {
    const r = await this.getTotalCount(),
      n = ae.from((e == null ? void 0 : e.start) || 0).toNumber(),
      i = r.toNumber();
    if (i === 0) throw new Error("No listings exist on the contract.");
    let a = [];
    a = (
      await Bf(n, i, (c, u) =>
        this.contractWrapper.read("getAllValidListings", [c, u])
      )
    ).flat();
    const o = await this.applyFilter(a, e);
    return await Promise.all(o.map((c) => this.mapListing(c)));
  }
  async getListing(e) {
    const r = await this.contractWrapper.read("getListing", [e]);
    return await this.mapListing(r);
  }
  async isBuyerApprovedForListing(e, r) {
    if (!(await this.validateListing(ae.from(e))).isReservedListing)
      throw new Error(`Listing ${e} is not a reserved listing.`);
    return await this.contractWrapper.read("isBuyerApprovedForListing", [
      e,
      await Se(r),
    ]);
  }
  async isCurrencyApprovedForListing(e, r) {
    return (
      await this.validateListing(ae.from(e)),
      await this.contractWrapper.read("isCurrencyApprovedForListing", [
        e,
        await Se(r),
      ])
    );
  }
  async currencyPriceForListing(e, r) {
    const n = await this.validateListing(ae.from(e)),
      i = await Se(r);
    if (i === n.currencyContractAddress) return n.pricePerToken;
    if (!(await this.isCurrencyApprovedForListing(e, i)))
      throw new Error(`Currency ${i} is not approved for Listing ${e}.`);
    return await this.contractWrapper.read("currencyPriceForListing", [e, i]);
  }
  async validateListing(e) {
    try {
      return await this.getListing(e);
    } catch (r) {
      throw (console.error(`Error getting the listing with id ${e}`), r);
    }
  }
  async mapListing(e) {
    let r = zn.UNSET;
    const i = (await this.contractWrapper.getProvider().getBlock("latest"))
      .timestamp;
    switch (e.status) {
      case 1:
        r = ae.from(e.startTimestamp).gt(i)
          ? zn.Created
          : ae.from(e.endTimestamp).lt(i)
          ? zn.Expired
          : zn.Active;
        break;
      case 2:
        r = zn.Completed;
        break;
      case 3:
        r = zn.Cancelled;
        break;
    }
    return {
      assetContractAddress: e.assetContract,
      currencyContractAddress: e.currency,
      pricePerToken: e.pricePerToken.toString(),
      currencyValuePerToken: await hs(
        this.contractWrapper.getProvider(),
        e.currency,
        e.pricePerToken
      ),
      id: e.listingId.toString(),
      tokenId: e.tokenId.toString(),
      quantity: e.quantity.toString(),
      startTimeInSeconds: ae.from(e.startTimestamp).toNumber(),
      asset: await Iv(
        e.assetContract,
        this.contractWrapper.getProvider(),
        e.tokenId,
        this.storage
      ),
      endTimeInSeconds: ae.from(e.endTimestamp).toNumber(),
      creatorAddress: e.listingCreator,
      isReservedListing: e.reserved,
      status: r,
    };
  }
  async isStillValidListing(e, r) {
    if (
      !(await yde(
        this.contractWrapper.getProvider(),
        this.getAddress(),
        e.assetContractAddress,
        e.tokenId,
        e.creatorAddress
      ))
    )
      return {
        valid: !1,
        error: `Token '${e.tokenId}' from contract '${e.assetContractAddress}' is not approved for transfer`,
      };
    const i = this.contractWrapper.getProvider(),
      a = new Yt(e.assetContractAddress, yv, i),
      s = await a.supportsInterface(kv),
      o = await a.supportsInterface(Sv);
    if (s) {
      const c = new Yt(e.assetContractAddress, yn, i);
      let u;
      try {
        u = await c.ownerOf(e.tokenId);
      } catch {}
      const d =
        (u == null ? void 0 : u.toLowerCase()) ===
        e.creatorAddress.toLowerCase();
      return {
        valid: d,
        error: d
          ? void 0
          : `Seller is not the owner of Token '${e.tokenId}' from contract '${e.assetContractAddress} anymore'`,
      };
    } else if (o) {
      const d = (
        await new Yt(e.assetContractAddress, ti, i).balanceOf(
          e.creatorAddress,
          e.tokenId
        )
      ).gte(r || e.quantity);
      return {
        valid: d,
        error: d
          ? void 0
          : `Seller does not have enough balance of Token '${e.tokenId}' from contract '${e.assetContractAddress} to fulfill the listing`,
      };
    } else
      return {
        valid: !1,
        error: "Contract does not implement ERC 1155 or ERC 721.",
      };
  }
  async applyFilter(e, r) {
    let n = [...e];
    if (r) {
      if (r.seller) {
        const i = await Se(r.seller);
        n = n.filter(
          (a) =>
            a.listingCreator.toString().toLowerCase() ===
            (i == null ? void 0 : i.toString().toLowerCase())
        );
      }
      if (r.tokenContract) {
        const i = await Se(r.tokenContract);
        n = n.filter(
          (a) =>
            a.assetContract.toString().toLowerCase() ===
            (i == null ? void 0 : i.toString().toLowerCase())
        );
      }
      r.tokenId !== void 0 &&
        (n = n.filter((i) => {
          var a;
          return (
            i.tokenId.toString() ===
            ((a = r == null ? void 0 : r.tokenId) == null
              ? void 0
              : a.toString())
          );
        }));
    }
    return r != null && r.count && r.count < n.length ? n.slice(0, r.count) : n;
  }
}
const bde = ne.object({
  assetContractAddress: wr,
  tokenId: Tn,
  quantity: Tn.default(1),
  currencyContractAddress: wr.default(qi),
  minimumBidAmount: Gi,
  buyoutBidAmount: Gi,
  timeBufferInSeconds: Tn.default(900),
  bidBufferBps: Tn.default(500),
  startTimestamp: Ev.default(new Date()),
  endTimestamp: Hm,
});
class vde {
  constructor(e, r) {
    oe(this, "featureName", U2.name);
    oe(
      this,
      "createAuction",
      be(async (e) => {
        const r = bde.parse(e);
        await ab(
          this.contractWrapper,
          this.getAddress(),
          r.assetContractAddress,
          r.tokenId,
          await this.contractWrapper.getSignerAddress()
        );
        const n = await pi(
            this.contractWrapper.getProvider(),
            r.buyoutBidAmount,
            r.currencyContractAddress
          ),
          i = await pi(
            this.contractWrapper.getProvider(),
            r.minimumBidAmount,
            r.currencyContractAddress
          ),
          s = (await this.contractWrapper.getProvider().getBlock("latest"))
            .timestamp;
        return (
          r.startTimestamp.lt(s) && (r.startTimestamp = ae.from(s)),
          ze.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "createAuction",
            args: [
              {
                assetContract: r.assetContractAddress,
                tokenId: r.tokenId,
                quantity: r.quantity,
                currency: Z_(r.currencyContractAddress),
                minimumBidAmount: i,
                buyoutBidAmount: n,
                timeBufferInSeconds: r.timeBufferInSeconds,
                bidBufferBps: r.bidBufferBps,
                startTimestamp: r.startTimestamp,
                endTimestamp: r.endTimestamp,
              },
            ],
            parse: (o) => ({
              id: this.contractWrapper.parseLogs("NewAuction", o.logs)[0].args
                .auctionId,
              receipt: o,
            }),
          })
        );
      })
    );
    oe(
      this,
      "createAuctionsBatch",
      be(async (e) => {
        const r = await Promise.all(
          e.map(async (n) => (await this.createAuction.prepare(n)).encode())
        );
        return ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "multicall",
          args: [r],
          parse: (n) =>
            this.contractWrapper
              .parseLogs("NewAuction", n == null ? void 0 : n.logs)
              .map((a) => ({
                id: a.args.auctionId,
                receipt: n,
              })),
        });
      })
    );
    oe(
      this,
      "buyoutAuction",
      be(async (e) => {
        const r = await this.validateAuction(ae.from(e)),
          n = await zm(
            this.contractWrapper.getProvider(),
            r.currencyContractAddress
          );
        return this.makeBid.prepare(e, nl(r.buyoutBidAmount, n.decimals));
      })
    );
    oe(
      this,
      "makeBid",
      be(async (e, r) => {
        const n = await this.validateAuction(ae.from(e)),
          i = await pi(
            this.contractWrapper.getProvider(),
            r,
            n.currencyContractAddress
          );
        if (i.eq(ae.from(0))) throw new Error("Cannot make a bid with 0 value");
        if (ae.from(n.buyoutBidAmount).gt(0) && i.gt(n.buyoutBidAmount))
          throw new Error(
            "Bid amount must be less than or equal to buyoutBidAmount"
          );
        if (await this.getWinningBid(e)) {
          const o = await this.isWinningBid(e, i);
          Je(o);
        } else {
          const o = i,
            c = ae.from(n.minimumBidAmount);
          Je(o.gte(c));
        }
        const s = (await this.contractWrapper.getCallOverrides()) || {};
        return (
          await al(this.contractWrapper, i, n.currencyContractAddress, s),
          ze.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "bidInAuction",
            args: [e, i],
            overrides: s,
          })
        );
      })
    );
    oe(
      this,
      "cancelAuction",
      be(async (e) => {
        if (await this.getWinningBid(e)) throw new Error("Bids already made.");
        return ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "cancelAuction",
          args: [e],
        });
      })
    );
    oe(
      this,
      "closeAuctionForBidder",
      be(async (e, r) => {
        r || (r = await this.contractWrapper.getSignerAddress());
        const n = await this.validateAuction(ae.from(e));
        try {
          return ze.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "collectAuctionTokens",
            args: [ae.from(e)],
          });
        } catch (i) {
          throw i.message.includes("Marketplace: auction still active.")
            ? new G3(e.toString(), n.endTimeInSeconds.toString())
            : i;
        }
      })
    );
    oe(
      this,
      "closeAuctionForSeller",
      be(async (e) => {
        const r = await this.validateAuction(ae.from(e));
        try {
          return ze.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "collectAuctionPayout",
            args: [ae.from(e)],
          });
        } catch (n) {
          throw n.message.includes("Marketplace: auction still active.")
            ? new G3(e.toString(), r.endTimeInSeconds.toString())
            : n;
        }
      })
    );
    oe(
      this,
      "executeSale",
      be(async (e) => {
        const r = await this.validateAuction(ae.from(e));
        try {
          const n = await this.getWinningBid(e);
          Je(n, "No winning bid found");
          const i = this.encoder.encode("collectAuctionPayout", [e]),
            a = this.encoder.encode("collectAuctionTokens", [e]);
          return ze.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "multicall",
            args: [[i, a]],
          });
        } catch (n) {
          throw n.message.includes("Marketplace: auction still active.")
            ? new G3(e.toString(), r.endTimeInSeconds.toString())
            : n;
        }
      })
    );
    (this.contractWrapper = e),
      (this.storage = r),
      (this.events = new Df(this.contractWrapper)),
      (this.encoder = new Sr(this.contractWrapper)),
      (this.interceptor = new Rv(this.contractWrapper)),
      (this.estimator = new Pv(this.contractWrapper));
  }
  getAddress() {
    return this.contractWrapper.address;
  }
  async getTotalCount() {
    return await this.contractWrapper.read("totalAuctions", []);
  }
  async getAll(e) {
    const r = await this.getTotalCount(),
      n = ae.from((e == null ? void 0 : e.start) || 0).toNumber(),
      i = r.toNumber();
    if (i === 0) throw new Error("No auctions exist on the contract.");
    let a = [];
    a = (
      await Bf(n, i, (c, u) =>
        this.contractWrapper.read("getAllAuctions", [c, u])
      )
    ).flat();
    const o = await this.applyFilter(a, e);
    return await Promise.all(o.map((c) => this.mapAuction(c)));
  }
  async getAllValid(e) {
    const r = await this.getTotalCount(),
      n = ae.from((e == null ? void 0 : e.start) || 0).toNumber(),
      i = r.toNumber();
    if (i === 0) throw new Error("No auctions exist on the contract.");
    let a = [];
    a = (
      await Bf(n, i, (c, u) =>
        this.contractWrapper.read("getAllValidAuctions", [c, u])
      )
    ).flat();
    const o = await this.applyFilter(a, e);
    return await Promise.all(o.map((c) => this.mapAuction(c)));
  }
  async getAuction(e) {
    const r = await this.contractWrapper.read("getAuction", [e]);
    return await this.mapAuction(r);
  }
  async getWinningBid(e) {
    await this.validateAuction(ae.from(e));
    const r = await this.contractWrapper.read("getWinningBid", [e]);
    if (r._bidder !== Ft)
      return await this.mapBid(
        e.toString(),
        r._bidder,
        r._currency,
        r._bidAmount.toString()
      );
  }
  async isWinningBid(e, r) {
    return await this.contractWrapper.read("isNewWinningBid", [e, r]);
  }
  async getWinner(e) {
    const r = await this.validateAuction(ae.from(e)),
      n = await this.contractWrapper.read("getWinningBid", [e]),
      i = ae.from(Math.floor(Date.now() / 1e3)),
      a = ae.from(r.endTimeInSeconds);
    if (i.gt(a) && n._bidder !== Ft) return n._bidder;
    const c = (
      await new Df(this.contractWrapper).getEvents("AuctionClosed")
    ).find((u) => u.data.auctionId.eq(ae.from(e)));
    if (!c)
      throw new Error(`Could not find auction with ID ${e} in closed auctions`);
    return c.data.winningBidder;
  }
  async getBidBufferBps(e) {
    return (await this.getAuction(e)).bidBufferBps;
  }
  async getMinimumNextBid(e) {
    const [r, n, i] = await Promise.all([
        this.getBidBufferBps(e),
        this.getWinningBid(e),
        this.validateAuction(ae.from(e)),
      ]),
      a = n ? ae.from(n.bidAmount) : ae.from(i.minimumBidAmount),
      s = a.add(a.mul(r).div(1e4));
    return hs(this.contractWrapper.getProvider(), i.currencyContractAddress, s);
  }
  async validateAuction(e) {
    try {
      return await this.getAuction(e);
    } catch (r) {
      throw (console.error(`Error getting the auction with id ${e}`), r);
    }
  }
  async mapAuction(e) {
    let r = zn.UNSET;
    const i = (await this.contractWrapper.getProvider().getBlock("latest"))
      .timestamp;
    switch (e.status) {
      case 1:
        r = ae.from(e.startTimestamp).gt(i)
          ? zn.Created
          : ae.from(e.endTimestamp).lt(i)
          ? zn.Expired
          : zn.Active;
        break;
      case 2:
        r = zn.Completed;
        break;
      case 3:
        r = zn.Cancelled;
        break;
    }
    return {
      id: e.auctionId.toString(),
      creatorAddress: e.auctionCreator,
      assetContractAddress: e.assetContract,
      tokenId: e.tokenId.toString(),
      quantity: e.quantity.toString(),
      currencyContractAddress: e.currency,
      minimumBidAmount: e.minimumBidAmount.toString(),
      minimumBidCurrencyValue: await hs(
        this.contractWrapper.getProvider(),
        e.currency,
        e.minimumBidAmount
      ),
      buyoutBidAmount: e.buyoutBidAmount.toString(),
      buyoutCurrencyValue: await hs(
        this.contractWrapper.getProvider(),
        e.currency,
        e.buyoutBidAmount
      ),
      timeBufferInSeconds: ae.from(e.timeBufferInSeconds).toNumber(),
      bidBufferBps: ae.from(e.bidBufferBps).toNumber(),
      startTimeInSeconds: ae.from(e.startTimestamp).toNumber(),
      endTimeInSeconds: ae.from(e.endTimestamp).toNumber(),
      asset: await Iv(
        e.assetContract,
        this.contractWrapper.getProvider(),
        e.tokenId,
        this.storage
      ),
      status: r,
    };
  }
  async mapBid(e, r, n, i) {
    const a = await Se(r),
      s = await Se(n);
    return {
      auctionId: e,
      bidderAddress: a,
      currencyContractAddress: s,
      bidAmount: i,
      bidAmountCurrencyValue: await hs(
        this.contractWrapper.getProvider(),
        s,
        i
      ),
    };
  }
  async applyFilter(e, r) {
    let n = [...e];
    if (r) {
      if (r.seller) {
        const i = await Se(r.seller);
        n = n.filter(
          (a) =>
            a.auctionCreator.toString().toLowerCase() ===
            (i == null ? void 0 : i.toString().toLowerCase())
        );
      }
      if (r.tokenContract) {
        const i = await Se(r.tokenContract);
        n = n.filter(
          (a) =>
            a.assetContract.toString().toLowerCase() ===
            (i == null ? void 0 : i.toString().toLowerCase())
        );
      }
      r.tokenId !== void 0 &&
        (n = n.filter((i) => {
          var a;
          return (
            i.tokenId.toString() ===
            ((a = r == null ? void 0 : r.tokenId) == null
              ? void 0
              : a.toString())
          );
        }));
    }
    return r != null && r.count && r.count < n.length ? n.slice(0, r.count) : n;
  }
}
const xde = ne.object({
  assetContractAddress: wr,
  tokenId: Tn,
  quantity: Tn.default(1),
  currencyContractAddress: wr.default(qi),
  totalPrice: Gi,
  endTimestamp: Hm,
});
class wde {
  constructor(e, r) {
    oe(this, "featureName", W2.name);
    oe(
      this,
      "makeOffer",
      be(async (e) => {
        const r = await xde.parseAsync(e),
          n = await this.contractWrapper.getChainID(),
          i = mo(r.currencyContractAddress)
            ? d2[n].wrapped.address
            : r.currencyContractAddress,
          a = await pi(this.contractWrapper.getProvider(), r.totalPrice, i),
          s = await this.contractWrapper.getCallOverrides();
        return (
          await al(this.contractWrapper, a, i, s),
          ze.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "makeOffer",
            args: [
              {
                assetContract: r.assetContractAddress,
                tokenId: r.tokenId,
                quantity: r.quantity,
                currency: i,
                totalPrice: a,
                expirationTimestamp: r.endTimestamp,
              },
            ],
            parse: (o) => ({
              id: this.contractWrapper.parseLogs(
                "NewOffer",
                o == null ? void 0 : o.logs
              )[0].args.offerId,
              receipt: o,
            }),
          })
        );
      })
    );
    oe(
      this,
      "cancelOffer",
      be(async (e) =>
        ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "cancelOffer",
          args: [e],
        })
      )
    );
    oe(
      this,
      "acceptOffer",
      be(async (e) => {
        const r = await this.validateOffer(ae.from(e)),
          { valid: n, error: i } = await this.isStillValidOffer(r);
        if (!n) throw new Error(`Offer ${e} is no longer valid. ${i}`);
        const a = (await this.contractWrapper.getCallOverrides()) || {};
        return (
          await ab(
            this.contractWrapper,
            this.getAddress(),
            r.assetContractAddress,
            r.tokenId,
            await this.contractWrapper.getSignerAddress()
          ),
          ze.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "acceptOffer",
            args: [e],
            overrides: a,
          })
        );
      })
    );
    (this.contractWrapper = e),
      (this.storage = r),
      (this.events = new Df(this.contractWrapper)),
      (this.encoder = new Sr(this.contractWrapper)),
      (this.interceptor = new Rv(this.contractWrapper)),
      (this.estimator = new Pv(this.contractWrapper));
  }
  getAddress() {
    return this.contractWrapper.address;
  }
  async getTotalCount() {
    return await this.contractWrapper.read("totalOffers", []);
  }
  async getAll(e) {
    const r = await this.getTotalCount(),
      n = ae.from((e == null ? void 0 : e.start) || 0).toNumber(),
      i = r.toNumber();
    if (i === 0) throw new Error("No offers exist on the contract.");
    let a = [];
    a = (
      await Bf(n, i, (c, u) =>
        this.contractWrapper.read("getAllOffers", [c, u])
      )
    ).flat();
    const o = await this.applyFilter(a, e);
    return await Promise.all(o.map((c) => this.mapOffer(c)));
  }
  async getAllValid(e) {
    const r = await this.getTotalCount(),
      n = ae.from((e == null ? void 0 : e.start) || 0).toNumber(),
      i = r.toNumber();
    if (i === 0) throw new Error("No offers exist on the contract.");
    let a = [];
    a = (
      await Bf(n, i, (c, u) =>
        this.contractWrapper.read("getAllValidOffers", [c, u])
      )
    ).flat();
    const o = await this.applyFilter(a, e);
    return await Promise.all(o.map((c) => this.mapOffer(c)));
  }
  async getOffer(e) {
    const r = await this.contractWrapper.read("getOffer", [e]);
    return await this.mapOffer(r);
  }
  async validateOffer(e) {
    try {
      return await this.getOffer(e);
    } catch (r) {
      throw (console.error(`Error getting the offer with id ${e}`), r);
    }
  }
  async mapOffer(e) {
    let r = zn.UNSET;
    const i = (await this.contractWrapper.getProvider().getBlock("latest"))
      .timestamp;
    switch (e.status) {
      case 1:
        r = ae.from(e.expirationTimestamp).lt(i) ? zn.Expired : zn.Active;
        break;
      case 2:
        r = zn.Completed;
        break;
      case 3:
        r = zn.Cancelled;
        break;
    }
    return {
      id: e.offerId.toString(),
      offerorAddress: e.offeror,
      assetContractAddress: e.assetContract,
      currencyContractAddress: e.currency,
      tokenId: e.tokenId.toString(),
      quantity: e.quantity.toString(),
      totalPrice: e.totalPrice.toString(),
      currencyValue: await hs(
        this.contractWrapper.getProvider(),
        e.currency,
        e.totalPrice
      ),
      asset: await Iv(
        e.assetContract,
        this.contractWrapper.getProvider(),
        e.tokenId,
        this.storage
      ),
      endTimeInSeconds: ae.from(e.expirationTimestamp).toNumber(),
      status: r,
    };
  }
  async isStillValidOffer(e) {
    if (ae.from(Math.floor(Date.now() / 1e3)).gt(e.endTimeInSeconds))
      return {
        valid: !1,
        error: `Offer with ID ${e.id} has expired`,
      };
    const n = await this.contractWrapper.getChainID(),
      i = mo(e.currencyContractAddress)
        ? d2[n].wrapped.address
        : e.currencyContractAddress,
      a = this.contractWrapper.getProvider(),
      s = new Gn(a, i, Ri, {}, this.storage);
    return (await s.read("balanceOf", [e.offerorAddress])).lt(e.totalPrice)
      ? {
          valid: !1,
          error: `Offeror ${e.offerorAddress} doesn't have enough balance of token ${i}`,
        }
      : (await s.read("allowance", [e.offerorAddress, this.getAddress()])).lt(
          e.totalPrice
        )
      ? {
          valid: !1,
          error: `Offeror ${e.offerorAddress} hasn't approved enough amount of token ${i}`,
        }
      : {
          valid: !0,
          error: "",
        };
  }
  async applyFilter(e, r) {
    let n = [...e];
    if (r) {
      if (r.offeror) {
        const i = await Se(r.offeror);
        n = n.filter(
          (a) =>
            a.offeror.toString().toLowerCase() ===
            (i == null ? void 0 : i.toString().toLowerCase())
        );
      }
      if (r.tokenContract) {
        const i = await Se(r.tokenContract);
        n = n.filter(
          (a) =>
            a.assetContract.toString().toLowerCase() ===
            (i == null ? void 0 : i.toString().toLowerCase())
        );
      }
      r.tokenId !== void 0 &&
        (n = n.filter((i) => {
          var a;
          return (
            i.tokenId.toString() ===
            ((a = r == null ? void 0 : r.tokenId) == null
              ? void 0
              : a.toString())
          );
        }));
    }
    return r != null && r.count && r.count < n.length ? n.slice(0, r.count) : n;
  }
}
class _de {
  constructor(e) {
    oe(this, "featureName", B2.name);
    oe(
      this,
      "set",
      be(async (e) => {
        const r = await Va.parseAsync(e);
        return ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "setPlatformFeeInfo",
          args: [r.platform_fee_recipient, r.platform_fee_basis_points],
        });
      })
    );
    this.contractWrapper = e;
  }
  async get() {
    const [e, r] = await this.contractWrapper.read("getPlatformFeeInfo", []);
    return Va.parseAsync({
      platform_fee_recipient: e,
      platform_fee_basis_points: r,
    });
  }
}
function Ede(t, e) {
  const n = Gt.parse(t || []).filter((a) => a.type === "event"),
    i = [];
  for (const a of n) {
    const s = jF(a.name, e, "events");
    i.push({
      inputs: a.inputs || [],
      outputs: a.outputs || [],
      name: a.name || "unknown",
      comment: s,
    });
  }
  return i;
}
class Tde {
  constructor(e, r) {
    (this.contractWrapper = e), (this.storage = r);
  }
  async get() {
    return this._cachedMetadata
      ? this._cachedMetadata
      : ((this._cachedMetadata = await Ai(
          this.contractWrapper.address,
          this.contractWrapper.getProvider(),
          this.storage,
          this.contractWrapper.options
        )),
        this._cachedMetadata);
  }
  async extractFunctions() {
    let e;
    try {
      e = await this.get();
    } catch {}
    return Pf(
      Gt.parse(this.contractWrapper.abi),
      e == null ? void 0 : e.metadata
    );
  }
  async extractEvents() {
    let e;
    try {
      e = await this.get();
    } catch {}
    return Ede(
      Gt.parse(this.contractWrapper.abi),
      e == null ? void 0 : e.metadata
    );
  }
}
class Cde {
  constructor(e) {
    oe(this, "featureName", L2.name);
    oe(
      this,
      "set",
      be(async (e) => {
        const r = await Se(e);
        return ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "setOwner",
          args: [r],
        });
      })
    );
    this.contractWrapper = e;
  }
  async get() {
    return this.contractWrapper.read("owner", []);
  }
}
class t9 {
  constructor(e, r, n) {
    oe(this, "featureName", F2.name);
    oe(
      this,
      "set",
      be(async (e) =>
        Qe(this.contractWrapper, "AppURI")
          ? ze.fromContractWrapper({
              contractWrapper: this.contractWrapper,
              method: "setAppURI",
              args: [e],
            })
          : await this.metadata.update.prepare({
              app_uri: e,
            })
      )
    );
    (this.contractWrapper = e), (this.metadata = r), (this.storage = n);
  }
  async get() {
    return Qe(this.contractWrapper, "AppURI")
      ? await this.contractWrapper.read("appURI", [])
      : QO(
          (await this.metadata.get()).app_uri || "",
          this.storage.getGatewayUrls()
        );
  }
}
async function Ade(t, e) {
  const r = await am(t, e);
  return _d(r.abi);
}
async function kde(t, e) {
  const r = await am(t, e);
  return Pf(r.abi, r.metadata);
}
function sb(t) {
  return (
    "(" +
    t
      .map((e) =>
        e.type === "tuple"
          ? sb(e.components)
          : e.type === "tuple[]"
          ? sb(e.components) + "[]"
          : e.type
      )
      .join(",") +
    ")"
  );
}
function Sde(t, e) {
  const r = new ls(e),
    n = [];
  for (const i of Object.values(r.functions)) {
    const a = r.getFunction(r.getSighash(i));
    a.name.includes("_") ||
      n.push({
        functionSelector: r.getSighash(a),
        functionSignature: a.name + sb(a.inputs),
        pluginAddress: t,
      });
  }
  return n;
}
function J_(t) {
  const e = new ls(t),
    r = [];
  for (const n of Object.values(e.functions)) {
    const i = e.getFunction(e.getSighash(n));
    i.name.startsWith("_") ||
      r.push({
        functionSelector: e.getSighash(i),
        functionSignature: i.name + sb(i.inputs),
      });
  }
  return r;
}
async function om(t, e, r, n, i, a) {
  Ls.deploymentPresets = {};
  const s = n || (await xl(r)),
    o = {},
    c = [],
    { compilerMetadata: u, extendedMetadata: d } = await Vi(t, e),
    m = d == null ? void 0 : d.defaultExtensions;
  if ((d == null ? void 0 : d.routerType) === "plugin" && m) {
    Je(i || a);
    const A = await Promise.all(
        m.map((k) =>
          po(k.publisherAddress, k.extensionName, k.extensionVersion, e, i, a)
        )
      ),
      I = (await Promise.all(A.map(async (k) => Vi(k.metadataUri, e)))).map(
        (k) => k.compilerMetadata
      ),
      b = await Promise.all(
        I.map(
          async (k) =>
            await Oa(
              "plugin",
              r,
              e,
              s,
              {
                metadata: k,
              },
              i,
              a
            )
        )
      ),
      w = [];
    I.forEach((k, N) => {
      const O = Sde(b[N].transaction.predictedAddress, k.abi);
      w.push(...O);
    });
    const S = await Oa(
      "plugin",
      r,
      e,
      s,
      {
        contractName: "PluginMap",
        constructorParams: {
          _pluginsToAdd: {
            value: w,
          },
        },
      },
      i,
      a
    );
    (o._pluginMap = {
      value: S.transaction.predictedAddress,
    }),
      c.push(...b, S);
  } else if ((d == null ? void 0 : d.routerType) === "dynamic" && m) {
    Je(i || a);
    const A = await Promise.all(
        m.map((S) =>
          po(S.publisherAddress, S.extensionName, S.extensionVersion, e, i, a)
        )
      ),
      I = (await Promise.all(A.map(async (S) => Vi(S.metadataUri, e)))).map(
        (S) => S.compilerMetadata
      ),
      b = await Promise.all(
        I.map(
          async (S) =>
            await Oa(
              "extension",
              r,
              e,
              s,
              {
                metadata: S,
              },
              i,
              a
            )
        )
      ),
      w = [];
    I.forEach((S, k) => {
      const N = J_(S.abi);
      w.push({
        metadata: {
          name: S.name,
          metadataURI: "",
          implementation: b[k].transaction.predictedAddress,
        },
        functions: N,
      });
    }),
      (o._extensions = {
        value: w,
      }),
      c.push(...b);
  }
  const v = await Oa(
      "implementation",
      r,
      e,
      s,
      {
        metadata: u,
        constructorParams: o,
      },
      i,
      a
    ),
    E = await Oa(
      "infra",
      r,
      e,
      s,
      {
        contractName: "TWCloneFactory",
      },
      i,
      a
    );
  return (
    c.push(E), c.push(...Object.values(Ls.deploymentPresets)), c.push(v), c
  );
}
async function BL(t, e, r) {
  var a, s;
  let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 7e6;
  if ((Je(t.provider), !(await ho(e.predictedAddress, t.provider)))) {
    console.debug(
      `deploying contract via create2 factory at: ${e.predictedAddress}`
    );
    const o = {
      to: e.to,
      data: e.data,
    };
    try {
      await t.estimateGas(o);
    } catch (c) {
      console.debug("error estimating gas while deploying prebuilt: ", c),
        (o.gasLimit = ae.from(n));
    }
    (a = r == null ? void 0 : r.notifier) == null ||
      a.call(r, "deploying", "preset"),
      await (await t.sendTransaction(o)).wait(),
      (s = r == null ? void 0 : r.notifier) == null ||
        s.call(r, "deployed", "preset");
  }
}
function Mde(t) {
  let e =
    qe(t)
      .map((r) => (r === 0 ? 4 : 16))
      .reduce((r, n) => r + n) +
    (200 * t.length) / 2 +
    6 * Math.ceil(t.length / 64) +
    32e3 +
    21e3;
  return (e = Math.floor((e * 64) / 63)), e;
}
function DL(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : I0e;
  if (((t = t.filter((a) => a.data.length > 0)), t.length === 0)) return [];
  const r = [];
  let n = 0,
    i = [];
  return (
    t.forEach((a) => {
      const s = Mde(a.data);
      n + s > e
        ? i.length === 0
          ? r.push([a])
          : (r.push(i), (n = s), (i = [a]))
        : ((n += s), i.push(a));
    }),
    i.length > 0 && r.push(i),
    r
  );
}
async function OL(t, e, r) {
  var a, s;
  const n = DL(e);
  if (n.length === 0) return;
  (a = r == null ? void 0 : r.notifier) == null ||
    a.call(r, "deploying", "infra");
  const i = await Promise.all(
    n.map((o) => new CD(P0e, R0e).connect(t).deploy(o))
  );
  await Promise.all(i.map((o) => o.deployed())),
    (s = r == null ? void 0 : r.notifier) == null ||
      s.call(r, "deployed", "infra");
}
async function Ide(t, e) {
  const { extendedMetadata: r } = await Vi(t, e);
  return (r == null ? void 0 : r.compositeAbi) || [];
}
async function r9(t, e, r) {
  return (
    await Promise.all(
      t.map((n) =>
        Ai(n, e, r).catch(
          (i) => (
            console.error(`Failed to fetch plug-in for ${n}`, i),
            {
              abi: [],
            }
          )
        )
      )
    )
  ).map((n) => n.abi);
}
async function Q_(t, e, r, n, i) {
  let a = [];
  try {
    const s = xu(Gt.parse(e), "PluginRouter");
    if (xu(Gt.parse(e), "DynamicContract")) {
      const d = (await new Gn(r, t, UF, n, i).call("getAllExtensions")).map(
        (m) => m.metadata.implementation
      );
      a = await r9(d, r, i);
    } else if (s) {
      const d = (await new Gn(r, t, $F, n, i).call("getAllPlugins")).map(
          (v) => v.pluginAddress
        ),
        m = Array.from(new Set(d));
      a = await r9(m, r, i);
    }
  } catch {}
  return a.length > 0 ? Nf([e, ...a]) : e;
}
const FL = Qn.merge(bl).merge(gn),
  Rde = Ja.merge(bl).merge(gn),
  Pde = FL.merge(Va).merge(vl).merge(Ji),
  Nde = {
    deploy: Pde,
    output: Rde,
    input: FL,
  },
  LL = Qn.merge(Bn).merge(gn),
  Bde = Ja.merge(Bn).merge(gn),
  Dde = LL.merge(Ji),
  Ode = {
    deploy: Dde,
    output: Bde,
    input: LL,
  },
  Fde = ["admin"],
  Td = ["admin", "minter", "transfer"],
  $L = ["admin", "lister", "asset"],
  Lde = ["admin", "minter", "asset", "transfer"],
  $de = ["admin", "transfer"],
  Ude = ["admin", "transfer", "minter", "unwrap", "asset"],
  Et = {
    vote: "vote",
    token: "token",
    "edition-drop": "edition-drop",
    edition: "edition",
    marketplace: "marketplace",
    "marketplace-v3": "marketplace-v3",
    multiwrap: "multiwrap",
    "nft-collection": "nft-collection",
    "nft-drop": "nft-drop",
    pack: "pack",
    "signature-drop": "signature-drop",
    split: "split",
    "token-drop": "token-drop",
  },
  Lc = {
    name: "DropERC1155",
    contractType: Et["edition-drop"],
    schema: $0e,
    roles: Td,
    initialize: async function () {
      for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)
        e[r] = arguments[r];
      let [n, i, a, s] = e;
      const [, o] = Jn(n, s),
        [c, u, d] = await Promise.all([
          Lc.getAbi(i, o, a),
          Zt(
            () => import("./edition-drop-24708d00.browser.esm-BALu-ei5.js"),
            __vite__mapDeps([0, 1, 2])
          ),
          o.getNetwork(),
        ]);
      return new u.EditionDrop(n, i, a, s, c, d.chainId);
    },
    getAbi: async (t, e, r) => {
      const n = await xa(t, e, r);
      if (n) return n;
      const i = await Nv(t, e);
      return !i || i.version > 2
        ? (
            await Zt(async () => {
              const { default: a } = await import("./DropERC1155-vWt9xv9Z.js");
              return {
                default: a,
              };
            }, [])
          ).default
        : (
            await Zt(async () => {
              const { default: a } = await import(
                "./DropERC1155_V2-Bs9UUa6p.js"
              );
              return {
                default: a,
              };
            }, [])
          ).default;
    },
  },
  Of = {
    name: "TokenERC1155",
    contractType: Et.edition,
    schema: nfe,
    roles: Td,
    initialize: async function () {
      for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)
        e[r] = arguments[r];
      let [n, i, a, s] = e;
      const [, o] = Jn(n, s),
        [c, u, d] = await Promise.all([
          Of.getAbi(i, o, a),
          Zt(
            () => import("./edition-b3122b64.browser.esm-BsAXhO03.js"),
            __vite__mapDeps([3, 1])
          ),
          o.getNetwork(),
        ]);
      return new u.Edition(n, i, a, s, c, d.chainId);
    },
    getAbi: async (t, e, r) => {
      const n = await xa(t, e, r);
      return (
        n ||
        (
          await Zt(async () => {
            const { default: i } = await import("./TokenERC1155-BkVebabe.js");
            return {
              default: i,
            };
          }, [])
        ).default
      );
    },
  },
  $c = {
    name: "Marketplace",
    contractType: Et.marketplace,
    schema: sL,
    roles: $L,
    initialize: async function () {
      for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)
        e[r] = arguments[r];
      let [n, i, a, s] = e;
      const [, o] = Jn(n, s),
        [c, u, d] = await Promise.all([
          $c.getAbi(i, o, a),
          Zt(
            () => import("./marketplace-5b738c1b.browser.esm-C1seYQ-N.js"),
            []
          ),
          o.getNetwork(),
        ]);
      return new u.Marketplace(n, i, a, s, c, d.chainId);
    },
    getAbi: async (t, e, r) => {
      const n = await xa(t, e, r);
      return (
        n ||
        (
          await Zt(async () => {
            const { default: i } = await import("./Marketplace-CsDAmACl.js");
            return {
              default: i,
            };
          }, [])
        ).default
      );
    },
  },
  au = {
    name: "MarketplaceV3",
    contractType: Et["marketplace-v3"],
    schema: sL,
    roles: $L,
    initialize: async function () {
      for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)
        e[r] = arguments[r];
      let [n, i, a, s] = e;
      const [, o] = Jn(n, s),
        [c, u, d] = await Promise.all([
          au.getAbi(i, o, a, s),
          Zt(
            () => import("./marketplacev3-e02b24ac.browser.esm-DpkUIe5h.js"),
            []
          ),
          o.getNetwork(),
        ]);
      return new u.MarketplaceV3(n, i, a, s, c, d.chainId);
    },
    getAbi: async (t, e, r, n) => {
      const i = (await e.getNetwork()).chainId;
      if (i === 280 || i === 324) {
        const u = (
          await po(
            _u,
            "MarketplaceV3",
            "latest",
            r,
            n == null ? void 0 : n.clientId,
            n == null ? void 0 : n.secretKey
          )
        ).metadataUri;
        return await Ide(u, r);
      }
      const s = await xa(t, e, r);
      if (s) return await Q_(t, s, e, {}, r);
      const o = (
        await Zt(async () => {
          const { default: c } = await import("./MarketplaceV3-BZkpdZXP.js");
          return {
            default: c,
          };
        }, [])
      ).default;
      return await Q_(t, Gt.parse(o || []), e, {}, r);
    },
  },
  Uc = {
    name: "Multiwrap",
    contractType: Et.multiwrap,
    schema: Ode,
    roles: Ude,
    initialize: async function () {
      for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)
        e[r] = arguments[r];
      let [n, i, a, s] = e;
      const [, o] = Jn(n, s),
        [c, u, d] = await Promise.all([
          Uc.getAbi(i, o, a),
          Zt(
            () => import("./multiwrap-18fab528.browser.esm-CuLM__Iq.js"),
            __vite__mapDeps([4, 5, 6])
          ),
          o.getNetwork(),
        ]);
      return new u.Multiwrap(n, i, a, s, c, d.chainId);
    },
    getAbi: async (t, e, r) => {
      const n = await xa(t, e, r);
      return (
        n ||
        (
          await Zt(async () => {
            const { default: i } = await import("./Multiwrap-BarnMKKf.js");
            return {
              default: i,
            };
          }, [])
        ).default
      );
    },
  },
  Ff = {
    name: "TokenERC721",
    contractType: Et["nft-collection"],
    schema: efe,
    roles: Td,
    initialize: async function () {
      for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)
        e[r] = arguments[r];
      let [n, i, a, s] = e;
      const [, o] = Jn(n, s),
        [c, u, d] = await Promise.all([
          Ff.getAbi(i, o, a),
          Zt(
            () => import("./nft-collection-0cf43f4d.browser.esm-gNMFqgQJ.js"),
            __vite__mapDeps([7, 6])
          ),
          o.getNetwork(),
        ]);
      return new u.NFTCollection(n, i, a, s, c, d.chainId);
    },
    getAbi: async (t, e, r) => {
      const n = await xa(t, e, r);
      return (
        n ||
        (
          await Zt(async () => {
            const { default: i } = await import("./TokenERC721-DAPh_NRE.js");
            return {
              default: i,
            };
          }, [])
        ).default
      );
    },
  },
  Wc = {
    name: "DropERC721",
    contractType: Et["nft-drop"],
    schema: WE,
    roles: Td,
    initialize: async function () {
      for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)
        e[r] = arguments[r];
      let [n, i, a, s] = e;
      const [, o] = Jn(n, s),
        [c, u, d] = await Promise.all([
          Wc.getAbi(i, o, a),
          Zt(
            () => import("./nft-drop-399edfe0.browser.esm-j1yx62mK.js"),
            __vite__mapDeps([8, 6, 2])
          ),
          o.getNetwork(),
        ]);
      return new u.NFTDrop(n, i, a, s, c, d.chainId);
    },
    getAbi: async (t, e, r) => {
      const n = await xa(t, e, r);
      if (n) return n;
      const i = await Nv(t, e);
      return !i || i.version > 3
        ? (
            await Zt(async () => {
              const { default: a } = await import("./DropERC721-CmkhQGos.js");
              return {
                default: a,
              };
            }, [])
          ).default
        : (
            await Zt(async () => {
              const { default: a } = await import(
                "./DropERC721_V3-BGDuwwxP.js"
              );
              return {
                default: a,
              };
            }, [])
          ).default;
    },
  },
  Gs = {
    name: "Pack",
    contractType: Et.pack,
    schema: z0e,
    roles: Lde,
    initialize: async function () {
      for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)
        e[r] = arguments[r];
      let [n, i, a, s] = e;
      const [, o] = Jn(n, s),
        [c, u, d] = await Promise.all([
          Gs.getAbi(i, o, a),
          Zt(
            () => import("./pack-bd61f578.browser.esm-BQH3tqr9.js"),
            __vite__mapDeps([9, 5, 1])
          ),
          o.getNetwork(),
        ]);
      return new u.Pack(n, i, a, s, c, d.chainId);
    },
    getAbi: async (t, e, r) => {
      const n = await xa(t, e, r);
      return (
        n ||
        Gt.parse(
          (
            await Zt(async () => {
              const { default: i } = await import("./Pack-DiHou1nP.js");
              return {
                default: i,
              };
            }, [])
          ).default || []
        )
      );
    },
  },
  jc = {
    name: "SignatureDrop",
    contractType: Et["signature-drop"],
    schema: WE,
    roles: Td,
    initialize: async function () {
      for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)
        e[r] = arguments[r];
      let [n, i, a, s] = e;
      const [, o] = Jn(n, s),
        [c, u, d] = await Promise.all([
          jc.getAbi(i, o, a),
          Zt(
            () => import("./signature-drop-224b723c.browser.esm-D6WJ2a4H.js"),
            __vite__mapDeps([10, 6, 2])
          ),
          o.getNetwork(),
        ]);
      return new u.SignatureDrop(n, i, a, s, c, d.chainId);
    },
    getAbi: async (t, e, r) => {
      const n = await xa(t, e, r);
      if (n) return n;
      const i = await Nv(t, e);
      return !i || i.version > 4
        ? (
            await Zt(async () => {
              const { default: a } = await import(
                "./SignatureDrop-D9ww4tRm.js"
              );
              return {
                default: a,
              };
            }, [])
          ).default
        : (
            await Zt(async () => {
              const { default: a } = await import(
                "./SignatureDrop_V4-axuReNZE.js"
              );
              return {
                default: a,
              };
            }, [])
          ).default;
    },
  },
  Hc = {
    name: "Split",
    contractType: Et.split,
    schema: G0e,
    roles: Fde,
    initialize: async function () {
      for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)
        e[r] = arguments[r];
      let [n, i, a, s] = e;
      const [, o] = Jn(n, s),
        [c, u, d] = await Promise.all([
          Hc.getAbi(i, o, a),
          Zt(() => import("./split-8c412664.browser.esm-B4sbZJdu.js"), []),
          o.getNetwork(),
        ]);
      return new u.Split(n, i, a, s, c, d.chainId);
    },
    getAbi: async (t, e, r) => {
      const n = await xa(t, e, r);
      return (
        n ||
        (
          await Zt(async () => {
            const { default: i } = await import("./Split-D6kznVXU.js");
            return {
              default: i,
            };
          }, [])
        ).default
      );
    },
  },
  Lf = {
    name: "DropERC20",
    contractType: Et["token-drop"],
    schema: Nde,
    roles: $de,
    initialize: async function () {
      for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)
        e[r] = arguments[r];
      let [n, i, a, s] = e;
      const [, o] = Jn(n, s),
        [c, u, d] = await Promise.all([
          Lf.getAbi(i, o, a),
          Zt(
            () => import("./token-drop-90cb00e6.browser.esm-DBXTQt3l.js"),
            __vite__mapDeps([11, 12])
          ),
          o.getNetwork(),
        ]);
      return new u.TokenDrop(n, i, a, s, c, d.chainId);
    },
    getAbi: async (t, e, r) => {
      const n = await xa(t, e, r);
      if (n) return n;
      const i = await Nv(t, e);
      return !i || i.version > 2
        ? (
            await Zt(async () => {
              const { default: a } = await import("./DropERC20-Cf-dwfdg.js");
              return {
                default: a,
              };
            }, [])
          ).default
        : (
            await Zt(async () => {
              const { default: a } = await import("./DropERC20_V2-DdnxZARj.js");
              return {
                default: a,
              };
            }, [])
          ).default;
    },
  },
  zc = {
    name: "TokenERC20",
    contractType: Et.token,
    schema: Q0e,
    roles: Td,
    initialize: async function () {
      for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)
        e[r] = arguments[r];
      let [n, i, a, s] = e;
      const [, o] = Jn(n, s),
        [c, u, d] = await Promise.all([
          zc.getAbi(i, o, a),
          Zt(
            () => import("./token-1023bf9c.browser.esm-Bl5opv9y.js"),
            __vite__mapDeps([13, 12])
          ),
          o.getNetwork(),
        ]);
      return new u.Token(n, i, a, s, c, d.chainId);
    },
    getAbi: async (t, e, r) => {
      const n = await xa(t, e, r);
      return (
        n ||
        (
          await Zt(async () => {
            const { default: i } = await import("./TokenERC20-W0Cpdtzb.js");
            return {
              default: i,
            };
          }, [])
        ).default
      );
    },
  },
  qc = {
    name: "VoteERC20",
    contractType: Et.vote,
    schema: ofe,
    roles: [],
    initialize: async function () {
      for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)
        e[r] = arguments[r];
      let [n, i, a, s] = e;
      const [, o] = Jn(n, s),
        [c, u, d] = await Promise.all([
          qc.getAbi(i, o, a),
          Zt(() => import("./vote-8af4ac9b.browser.esm-3hlEdYOK.js"), []),
          o.getNetwork(),
        ]);
      return new u.Vote(n, i, a, s, c, d.chainId);
    },
    getAbi: async (t, e, r) => {
      const n = await xa(t, e, r);
      return (
        n ||
        (
          await Zt(async () => {
            const { default: i } = await import("./VoteERC20-CioJc_tt.js");
            return {
              default: i,
            };
          }, [])
        ).default
      );
    },
  };
async function Nv(t, e) {
  try {
    return await KE(t, e);
  } catch {
    return;
  }
}
const X0 = {
    [Et["edition-drop"]]: Lc,
    [Et.edition]: Of,
    [Et.marketplace]: $c,
    [Et["marketplace-v3"]]: au,
    [Et.multiwrap]: Uc,
    [Et["nft-collection"]]: Ff,
    [Et["nft-drop"]]: Wc,
    [Et.pack]: Gs,
    [Et["signature-drop"]]: jc,
    [Et.split]: Hc,
    [Et["token-drop"]]: Lf,
    [Et.token]: zc,
    [Et.vote]: qc,
  },
  Wde = {
    [Et["edition-drop"]]:
      "ipfs://QmNm3wRzpKYWo1SRtJfgfxtvudp5p2nXD6EttcsQJHwTmk",
    [Et.edition]: "",
    [Et.marketplace]:
      "ipfs://QmbAgC8YwY36n8H2kuvSWsRisxDZ15QZw3xGZyk9aDvcv7/marketplace.html",
    [Et["marketplace-v3"]]:
      "ipfs://QmbAgC8YwY36n8H2kuvSWsRisxDZ15QZw3xGZyk9aDvcv7/marketplace-v3.html",
    [Et.multiwrap]: "",
    [Et["nft-collection"]]: "",
    [Et["nft-drop"]]: "ipfs://QmZptmVipc6SGFbKAyXcxGgohzTwYRXZ9LauRX5ite1xDK",
    [Et.pack]: "",
    [Et["signature-drop"]]:
      "ipfs://QmZptmVipc6SGFbKAyXcxGgohzTwYRXZ9LauRX5ite1xDK",
    [Et.split]: "",
    [Et["token-drop"]]:
      "ipfs://QmbAgC8YwY36n8H2kuvSWsRisxDZ15QZw3xGZyk9aDvcv7/erc20.html",
    [Et.token]: "",
    [Et.vote]: "",
  },
  n9 = {
    name: "SmartContract",
    contractType: "custom",
    schema: {},
    roles: TL,
  },
  UL = {
    ...X0,
    [n9.contractType]: n9,
  };
function jde(t) {
  var e;
  return (
    ((e = Object.values(UL).find((r) => r.name === t)) == null
      ? void 0
      : e.contractType) || "custom"
  );
}
function WL(t) {
  var e;
  return (e = Object.values(UL).find((r) => r.contractType === t)) == null
    ? void 0
    : e.name;
}
const Y_ = ne.object({
    startDate: SE,
    expirationDate: Hm,
    nativeTokenLimitPerTransaction: Gi.default(0),
    approvedCallTargets: ne.array(wr),
  }),
  Hde = ne.array(
    ne.object({
      signer: wr,
      makeAdmin: ne.boolean(),
      permissions: Y_,
    })
  ),
  zde = [
    {
      name: "signer",
      type: "address",
    },
    {
      name: "approvedTargets",
      type: "address[]",
    },
    {
      name: "nativeTokenLimitPerTransaction",
      type: "uint256",
    },
    {
      name: "permissionStartTimestamp",
      type: "uint128",
    },
    {
      name: "permissionEndTimestamp",
      type: "uint128",
    },
    {
      name: "reqValidityStartTimestamp",
      type: "uint128",
    },
    {
      name: "reqValidityEndTimestamp",
      type: "uint128",
    },
    {
      name: "uid",
      type: "bytes32",
    },
  ];
class qde {
  constructor(e) {
    oe(this, "featureName", si.name);
    oe(
      this,
      "grantAdminPermissions",
      be(async (e) => {
        const r = await Se(e);
        return ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "setAdmin",
          args: [r, !0],
        });
      })
    );
    oe(
      this,
      "revokeAdminPermissions",
      be(async (e) => {
        const r = await Se(e);
        return ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "setAdmin",
          args: [r, !1],
        });
      })
    );
    oe(
      this,
      "grantPermissions",
      be(async (e, r) => {
        const n = await Se(e),
          i = await Y_.parseAsync(r);
        if (await this.isAdmin(n))
          throw new Error(
            "Signer is already an admin. Cannot grant permissions to an existing admin."
          );
        if (await this.isSigner(n))
          throw new Error(
            "Signer already has permissions. Cannot grant permissions to an existing signer. You can update permissions using `updatePermissions`."
          );
        return await this.sendSignerPermissionRequest(n, i);
      })
    );
    oe(
      this,
      "updatePermissions",
      be(async (e, r) => {
        const n = await Se(e),
          i = await Y_.parseAsync(r);
        if (await this.isAdmin(n))
          throw new Error(
            "Signer is already an admin. Cannot update permissions of an existing admin."
          );
        if (!(await this.isSigner(n)))
          throw new Error(
            "Signer does not already have permissions. You can grant permissions using `grantPermissions`."
          );
        return await this.sendSignerPermissionRequest(n, i);
      })
    );
    oe(
      this,
      "revokeAccess",
      be(async (e) => {
        const r = await Se(e);
        if (await this.isAdmin(r))
          throw new Error(
            "Signer is already an admin. Cannot revoke permissions of an admin."
          );
        if (!(await this.isSigner(r)))
          throw new Error(
            "Signer does not already have permissions. You can grant permissions using `grantPermissions`."
          );
        return await this.sendSignerPermissionRequest(r, {
          startDate: ae.from(0),
          expirationDate: ae.from(0),
          approvedCallTargets: [],
          nativeTokenLimitPerTransaction: "0",
        });
      })
    );
    oe(
      this,
      "approveTargetForSigner",
      be(async (e, r) => {
        const n = await Se(e),
          i = await Se(r);
        if (await this.isAdmin(n))
          throw new Error(
            "Signer is already an admin. Cannot approve targets for an admin."
          );
        if (!(await this.isSigner(n)))
          throw new Error(
            "Signer does not already have permissions. You can grant permissions using `grantPermissions`."
          );
        const a = await this.contractWrapper.read("getPermissionsForSigner", [
          n,
        ]);
        if (a.approvedTargets.includes(r))
          throw new Error("Target is already approved");
        const s = [...a.approvedTargets, i];
        return await this.sendSignerPermissionRequest(n, {
          startDate: ae.from(a.startTimestamp),
          expirationDate: ae.from(a.endTimestamp),
          approvedCallTargets: s,
          nativeTokenLimitPerTransaction:
            a.nativeTokenLimitPerTransaction.toString(),
        });
      })
    );
    oe(
      this,
      "disapproveTargetForSigner",
      be(async (e, r) => {
        const n = await Se(e),
          i = await Se(r);
        if (await this.isAdmin(n))
          throw new Error(
            "Signer is already an admin. Cannot approve targets for an admin."
          );
        if (!(await this.isSigner(n)))
          throw new Error(
            "Signer does not already have permissions. You can grant permissions using `grantPermissions`."
          );
        const a = await this.contractWrapper.read("getPermissionsForSigner", [
          n,
        ]);
        if (!a.approvedTargets.includes(i))
          throw new Error("Target is currently not approved");
        const s = a.approvedTargets.filter((o) => Xt(o) !== Xt(i));
        return await this.sendSignerPermissionRequest(n, {
          startDate: ae.from(a.startTimestamp),
          expirationDate: ae.from(a.endTimestamp),
          approvedCallTargets: s,
          nativeTokenLimitPerTransaction:
            a.nativeTokenLimitPerTransaction.toString(),
        });
      })
    );
    oe(
      this,
      "resetAllPermissions",
      be(async (e) => {
        const r = await Hde.parseAsync(e);
        if (this.hasDuplicateSigners(r))
          throw new Error("Duplicate signers found in input.");
        const n = [],
          i = [],
          a = [],
          s = [],
          o = await this.getAllAdmins(),
          c = r.filter((v) => v.makeAdmin).map((v) => v.signer);
        o.forEach((v) => {
          c.includes(v) ||
            i.push(
              this.contractWrapper.writeContract.interface.encodeFunctionData(
                "setAdmin",
                [v, !1]
              )
            );
        });
        const u = await this.getAllSigners(),
          d = r.filter((v) => !v.makeAdmin).map((v) => v.signer);
        await Promise.all(
          u.map(async (v) => {
            if (!d.includes(v.signer)) {
              const E = await this.buildSignerPermissionRequest(v.signer, {
                startDate: ae.from(0),
                expirationDate: ae.from(0),
                approvedCallTargets: [],
                nativeTokenLimitPerTransaction: "0",
              });
              s.push(E);
            }
          })
        );
        for (const v of r)
          if (v.makeAdmin)
            n.push(
              this.contractWrapper.writeContract.interface.encodeFunctionData(
                "setAdmin",
                [v.signer, !0]
              )
            );
          else {
            const E = await this.buildSignerPermissionRequest(
              v.signer,
              v.permissions
            );
            a.push(E);
          }
        const m = [];
        return (
          i.forEach((v) => {
            m.push(v);
          }),
          s.forEach((v) => {
            m.push(v);
          }),
          a.forEach((v) => {
            m.push(v);
          }),
          ze.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "multicall",
            args: [m],
          })
        );
      })
    );
    this.contractWrapper = e;
  }
  getAddress() {
    return this.contractWrapper.address;
  }
  hasDuplicateSigners(e) {
    const r = {},
      n = e.map((i) => i.signer);
    for (const i of n)
      if (!r[i]) r[i] = !0;
      else return !0;
    return !1;
  }
  parseSignerPermissionsStruct(e) {
    return {
      startDate: new Date(parseInt(e.startTimestamp.toString()) * 1e3),
      expirationDate: new Date(parseInt(e.endTimestamp.toString()) * 1e3),
      nativeTokenLimitPerTransaction: ae.from(e.nativeTokenLimitPerTransaction),
      approvedCallTargets: e.approvedTargets,
    };
  }
  async sendSignerPermissionRequest(e, r) {
    const { payload: n, signature: i } = await this.generatePayload(e, r),
      [a] = await this.contractWrapper.read("verifySignerPermissionRequest", [
        n,
        i,
      ]);
    if (!a) throw new Error("Invalid signature.");
    return ze.fromContractWrapper({
      contractWrapper: this.contractWrapper,
      method: "setPermissionsForSigner",
      args: [n, i],
    });
  }
  async buildSignerPermissionRequest(e, r) {
    const { payload: n, signature: i } = await this.generatePayload(e, r);
    if (
      !(await this.contractWrapper.read("verifySignerPermissionRequest", [
        n,
        i,
      ]))
    )
      throw new Error("Invalid signature.");
    return this.contractWrapper.writeContract.interface.encodeFunctionData(
      "setPermissionsForSigner",
      [n, i]
    );
  }
  async generatePayload(e, r) {
    const n = {
        signer: e,
        approvedTargets: r.approvedCallTargets,
        nativeTokenLimitPerTransaction: lv(r.nativeTokenLimitPerTransaction),
        permissionStartTimestamp: r.startDate,
        permissionEndTimestamp: r.expirationDate,
        reqValidityStartTimestamp: 0,
        reqValidityEndTimestamp: ae.from(
          Math.floor(new Date(Date.now() + 31536e7).getTime() / 1e3)
        ),
        uid: PF(void 0),
      },
      i = await this.contractWrapper.getChainID(),
      a = this.contractWrapper.getSigner();
    Je(a);
    const s = await this.contractWrapper.signTypedData(
      a,
      {
        name: "Account",
        version: "1",
        chainId: i,
        verifyingContract: this.getAddress(),
      },
      {
        SignerPermissionRequest: zde,
      },
      n
    );
    return {
      payload: n,
      signature: s,
    };
  }
  async isAdmin(e) {
    const r = await Se(e);
    return await this.contractWrapper.read("isAdmin", [r]);
  }
  async isSigner(e) {
    const r = await Se(e);
    return await this.contractWrapper.read("isActiveSigner", [r]);
  }
  async getAllAdmins() {
    return await this.contractWrapper.read("getAllAdmins", []);
  }
  async getAllSigners() {
    const e = await this.contractWrapper.read("getAllActiveSigners", []);
    return await Promise.all(
      e.map(async (r) => {
        const n = r.signer,
          i = this.parseSignerPermissionsStruct(r);
        return {
          signer: n,
          permissions: i,
        };
      })
    );
  }
  async getAllAdminsAndSigners() {
    const r = (await this.getAllAdmins()).map((i) => ({
        isAdmin: !0,
        signer: i,
        permissions: {
          startDate: new Date(0),
          expirationDate: new Date(0),
          nativeTokenLimitPerTransaction: ae.from(0),
          approvedCallTargets: [],
        },
      })),
      n = await this.getAllSigners();
    return [...r, ...n];
  }
}
class Vde {
  constructor(e) {
    oe(this, "featureName", rm.name);
    oe(
      this,
      "grantAdminPermissions",
      be(async (e) =>
        et(this.accountPermissions, si).grantAdminPermissions.prepare(e)
      )
    );
    oe(
      this,
      "revokeAdminPermissions",
      be(async (e) =>
        et(this.accountPermissions, si).revokeAdminPermissions.prepare(e)
      )
    );
    oe(
      this,
      "grantPermissions",
      be(async (e, r) =>
        et(this.accountPermissions, si).grantPermissions.prepare(e, r)
      )
    );
    oe(
      this,
      "updatePermissions",
      be(async (e, r) =>
        et(this.accountPermissions, si).updatePermissions.prepare(e, r)
      )
    );
    oe(
      this,
      "revokeAccess",
      be(async (e) => et(this.accountPermissions, si).revokeAccess.prepare(e))
    );
    oe(
      this,
      "approveTargetForSigner",
      be(async (e, r) =>
        et(this.accountPermissions, si).approveTargetForSigner.prepare(e, r)
      )
    );
    oe(
      this,
      "disapproveTargetForSigner",
      be(async (e, r) =>
        et(this.accountPermissions, si).disapproveTargetForSigner.prepare(e, r)
      )
    );
    oe(
      this,
      "resetAllPermissions",
      be(async (e) =>
        et(this.accountPermissions, si).resetAllPermissions.prepare(e)
      )
    );
    (this.contractWrapper = e),
      (this.accountPermissions = this.detectAccountPermissions());
  }
  detectAccountPermissions() {
    if (Qe(this.contractWrapper, "AccountPermissions"))
      return new qde(this.contractWrapper);
  }
  getAddress() {
    return this.contractWrapper.address;
  }
  async isAdmin(e) {
    return et(this.accountPermissions, si).isAdmin(e);
  }
  async isSigner(e) {
    return et(this.accountPermissions, si).isSigner(e);
  }
  async getAllAdmins() {
    return et(this.accountPermissions, si).getAllAdmins();
  }
  async getAllSigners() {
    return et(this.accountPermissions, si).getAllSigners();
  }
  async getAllAdminsAndSigners() {
    return et(this.accountPermissions, si).getAllAdminsAndSigners();
  }
}
class Kde {
  constructor(e) {
    oe(this, "featureName", tm.name);
    oe(
      this,
      "createAccount",
      be(async (e, r) => {
        if (await this.isAccountDeployed(e, r))
          throw new Error(`Account already deployed for admin: ${e}`);
        let n = Lt("");
        return (
          r && (n = r),
          ze.fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "createAccount",
            args: [e, n],
            parse: (i) => ({
              address: this.contractWrapper.parseLogs(
                "AccountCreated",
                i == null ? void 0 : i.logs
              )[0].args.account,
              receipt: i,
            }),
          })
        );
      })
    );
    (this.contractWrapper = e), (this.events = new Df(this.contractWrapper));
  }
  getAddress() {
    return this.contractWrapper.address;
  }
  async predictAccountAddress(e, r) {
    let n = Lt("");
    return r && (n = r), this.contractWrapper.read("getAddress", [e, n]);
  }
  async getAssociatedAccounts(e) {
    return this.contractWrapper.read("getAccountsOfSigner", [e]);
  }
  async getAllAccounts() {
    return await this.contractWrapper.read("getAllAccounts", []);
  }
  async isAccountDeployed(e, r) {
    const n = await this.predictAccountAddress(e, r);
    return ho(n, this.contractWrapper.getProvider());
  }
}
class Gde {
  constructor(e) {
    oe(this, "featureName", z2.name);
    oe(
      this,
      "drop",
      be(async (e, r, n) =>
        ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "airdropERC1155",
          args: [e, r, n],
          parse: (i) => {
            const s = this.contractWrapper
              .parseLogs("AirdropFailed", i.logs)
              .map((o) => ({
                recipient: o.args.recipient,
                tokenId: o.args.tokenId.toNumber(),
                amount: o.args.amount.toString(),
              }));
            return {
              successfulDropCount: n.length - s.length,
              failedDropCount: s.length,
              failedDrops: s,
            };
          },
        })
      )
    );
    this.contractWrapper = e;
  }
  getAddress() {
    return this.contractWrapper.address;
  }
}
class Zde {
  constructor(e) {
    oe(this, "featureName", j2.name);
    oe(
      this,
      "drop",
      be(async (e, r, n) =>
        ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "airdropERC20",
          args: [e, r, n],
          parse: (i) => {
            const s = this.contractWrapper
              .parseLogs("AirdropFailed", i.logs)
              .map((o) => ({
                recipient: o.args.recipient,
                amount: o.args.amount.toString(),
              }));
            return {
              successfulDropCount: n.length - s.length,
              failedDropCount: s.length,
              failedDrops: s,
            };
          },
        })
      )
    );
    this.contractWrapper = e;
  }
  getAddress() {
    return this.contractWrapper.address;
  }
}
class Jde {
  constructor(e) {
    oe(this, "featureName", H2.name);
    oe(
      this,
      "drop",
      be(async (e, r, n) =>
        ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "airdropERC721",
          args: [e, r, n],
          parse: (i) => {
            const s = this.contractWrapper
              .parseLogs("AirdropFailed", i.logs)
              .map((o) => ({
                recipient: o.args.recipient,
                tokenId: o.args.tokenId.toNumber(),
              }));
            return {
              successfulDropCount: n.length - s.length,
              failedDropCount: s.length,
              failedDrops: s,
            };
          },
        })
      )
    );
    this.contractWrapper = e;
  }
  getAddress() {
    return this.contractWrapper.address;
  }
}
class Qde {
  constructor(e) {
    oe(this, "featureName", em.name);
    oe(
      this,
      "add",
      be(async (e) =>
        ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "addExtension",
          args: [e.extension],
          parse: async (r) => {
            if (
              this.contractWrapper.parseLogs("ExtensionAdded", r.logs).length <
              1
            )
              throw new Error("No ExtensionAdded event found");
            const i = e.extensionAbi
                ? Gt.parse(e.extensionAbi)
                : (
                    await Ai(
                      e.extension.metadata.implementation,
                      this.contractWrapper.getProvider(),
                      this.contractWrapper.storage
                    )
                  ).abi,
              a = this.filterAbiForAdd(i, e.extension),
              s = Nf([Gt.parse(this.contractWrapper.abi), a]);
            return this.contractWrapper.updateAbi(s), r;
          },
        })
      )
    );
    oe(
      this,
      "addDeployed",
      be(async (e) => {
        let r = e.extensionAbi;
        r ||
          (r = (
            await Ai(
              e.extensionAddress,
              this.contractWrapper.getProvider(),
              this.contractWrapper.storage,
              this.contractWrapper.options
            )
          ).abi),
          Je(r);
        let n = "";
        if (e.extensionMetadata)
          if (typeof e.extensionMetadata == "string") n = e.extensionMetadata;
          else {
            const s = await Qn.parseAsync(e.extensionMetadata);
            n = await this.contractWrapper.storage.upload(s);
          }
        const i = J_(Gt.parse(r)),
          a = {
            metadata: {
              name: e.extensionName,
              metadataURI: n,
              implementation: e.extensionAddress,
            },
            functions: i,
          };
        return this.add.prepare({
          extension: a,
          extensionAbi: r,
        });
      })
    );
    oe(
      this,
      "addPublished",
      be(async (e) => {
        const r = e.version || "latest",
          { deployedExtensionAddress: n, extensionMetadata: i } =
            await this.deployExtension(
              e.extensionName,
              e.publisherAddress || _u,
              r
            );
        return this.addDeployed.prepare({
          extensionName: e.extensionName,
          extensionAddress: n,
          extensionMetadata: e.extensionMetadataOverride || i,
        });
      })
    );
    oe(
      this,
      "replace",
      be(async (e) =>
        ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "replaceExtension",
          args: [e.extension],
          parse: async (r) => {
            if (
              this.contractWrapper.parseLogs("ExtensionReplaced", r.logs)
                .length < 1
            )
              throw new Error("No ExtensionReplaced event found");
            const i = e.extensionAbi
                ? Gt.parse(e.extensionAbi)
                : (
                    await Ai(
                      e.extension.metadata.implementation,
                      this.contractWrapper.getProvider(),
                      this.contractWrapper.storage
                    )
                  ).abi,
              a = this.filterAbiForRemove(
                Gt.parse(this.contractWrapper.abi),
                i
              ),
              s = this.filterAbiForAdd(i, e.extension),
              o = Nf([a, s]);
            return this.contractWrapper.updateAbi(o), r;
          },
        })
      )
    );
    oe(
      this,
      "replaceDeployed",
      be(async (e) => {
        let r = e.extensionAbi;
        r ||
          (r = (
            await Ai(
              e.extensionAddress,
              this.contractWrapper.getProvider(),
              this.contractWrapper.storage,
              this.contractWrapper.options
            )
          ).abi),
          Je(r);
        let n = "";
        if (e.extensionMetadata)
          if (typeof e.extensionMetadata == "string") n = e.extensionMetadata;
          else {
            const s = await Qn.parseAsync(e.extensionMetadata);
            n = await this.contractWrapper.storage.upload(s);
          }
        const i = J_(Gt.parse(r)),
          a = {
            metadata: {
              name: e.extensionName,
              metadataURI: n,
              implementation: e.extensionAddress,
            },
            functions: i,
          };
        return this.replace.prepare({
          extension: a,
          extensionAbi: r,
        });
      })
    );
    oe(
      this,
      "replacePublished",
      be(async (e) => {
        const r = e.version || "latest",
          { deployedExtensionAddress: n, extensionMetadata: i } =
            await this.deployExtension(
              e.extensionName,
              e.publisherAddress || _u,
              r
            );
        return this.replaceDeployed.prepare({
          extensionName: e.extensionName,
          extensionAddress: n,
          extensionMetadata: e.extensionMetadataOverride || i,
        });
      })
    );
    oe(
      this,
      "remove",
      be(async (e) => {
        const r = await this.getExtensionAddress(e.extensionName);
        return ze.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "removeExtension",
          args: [e.extensionName],
          parse: async (n) => {
            if (
              this.contractWrapper.parseLogs("ExtensionRemoved", n.logs)
                .length < 1
            )
              throw new Error("No ExtensionRemoved event found");
            const a = (
                await Ai(
                  r,
                  this.contractWrapper.getProvider(),
                  this.contractWrapper.storage
                )
              ).abi,
              s = this.filterAbiForRemove(
                Gt.parse(this.contractWrapper.abi),
                a
              );
            return this.contractWrapper.updateAbi(s), n;
          },
        });
      })
    );
    this.contractWrapper = e;
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }
  async getAll() {
    return await this.contractWrapper.readContract.getAllExtensions();
  }
  async get(e) {
    return await this.contractWrapper.readContract.getExtension(e);
  }
  async getExtensionAddress(e) {
    return (await this.get(e)).metadata.implementation;
  }
  async getAllFunctions(e) {
    return (await this.get(e)).functions;
  }
  async getExtensionForFunction(e) {
    let r = e.functionSelector;
    return (
      r ||
        (Je(e.functionSignature),
        (r = ui(e.functionSignature).substring(0, 10))),
      await this.contractWrapper.readContract.getMetadataForFunction(r)
    );
  }
  async getExtensionAddressForFunction(e) {
    return (await this.getExtensionForFunction(e)).implementation;
  }
  filterAbiForAdd(e, r) {
    const n = new ls(e),
      i = r.functions.map((s) => s.functionSelector);
    return e.filter((s) => {
      const o = Object.values(new ls([s]).functions);
      if (o.length === 0) return !1;
      const c = n.getSighash(o[0]);
      return i.includes(c);
    });
  }
  filterAbiForRemove(e, r) {
    const n = new ls(e),
      i = new ls(r),
      a = Object.values(i.functions).map((o) => i.getSighash(o));
    return e.filter((o) => {
      const c = Object.values(new ls([o]).functions);
      if (c.length === 0) return !1;
      const u = n.getSighash(c[0]);
      return !a.includes(u);
    });
  }
  async deployExtension(e, r) {
    var m;
    let n =
      arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "latest";
    const i = await po(
        r,
        e,
        n,
        this.contractWrapper.storage,
        this.contractWrapper.options.clientId,
        this.contractWrapper.options.secretKey
      ),
      a = await om(
        i.metadataUri,
        this.contractWrapper.storage,
        this.contractWrapper.getProvider(),
        "",
        this.contractWrapper.options.clientId,
        this.contractWrapper.options.secretKey
      ),
      s =
        (m = a.find((v) => v.type === "implementation")) == null
          ? void 0
          : m.transaction.predictedAddress,
      o = a.filter((v) => v.transaction.data && v.transaction.data.length > 0),
      c = o.filter((v) => v.type !== "infra").map((v) => v.transaction),
      u = o.filter((v) => v.type === "infra").map((v) => v.transaction),
      d = this.contractWrapper.getSigner();
    Je(d), await OL(d, u, {});
    for (const v of c)
      try {
        await BL(d, v);
      } catch (E) {
        console.debug(
          `Error deploying contract at ${v.predictedAddress}`,
          E == null ? void 0 : E.message
        );
      }
    return {
      deployedExtensionAddress: s,
      extensionMetadata: i.metadataUri,
    };
  }
}
class Yde {
  get abi() {
    return Gt.parse(this.contractWrapper.abi || []);
  }
  get royalties() {
    return et(this.detectRoyalties(), P2);
  }
  get roles() {
    return et(this.detectRoles(), D2);
  }
  get sales() {
    return et(this.detectPrimarySales(), N2);
  }
  get platformFees() {
    return et(this.detectPlatformFees(), B2);
  }
  get owner() {
    return et(this.detectOwnable(), L2);
  }
  get erc20() {
    return et(this.detectErc20(), y2);
  }
  get erc721() {
    return et(this.detectErc721(), A2);
  }
  get erc1155() {
    return et(this.detectErc1155(), R2);
  }
  get app() {
    return et(this.detectApp(), F2);
  }
  get directListings() {
    return et(this.detectDirectListings(), $2);
  }
  get englishAuctions() {
    return et(this.detectEnglishAuctions(), U2);
  }
  get offers() {
    return et(this.detectOffers(), W2);
  }
  get airdrop20() {
    return et(this.detectAirdrop20(), j2);
  }
  get airdrop721() {
    return et(this.detectAirdrop721(), H2);
  }
  get airdrop1155() {
    return et(this.detectAirdrop1155(), z2);
  }
  get accountFactory() {
    return et(this.detectAccountFactory(), tm);
  }
  get account() {
    return et(this.detectAccount(), rm);
  }
  get extensions() {
    return et(this.detectBaseRouter(), em);
  }
  get chainId() {
    return this._chainId;
  }
  constructor(e, r, n, i) {
    let a = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {},
      s = arguments.length > 5 ? arguments[5] : void 0,
      o =
        arguments.length > 6 && arguments[6] !== void 0
          ? arguments[6]
          : new Gn(e, r, n, a, i);
    (this._chainId = s),
      (this.storage = i),
      (this.contractWrapper = o),
      (this.events = new Df(this.contractWrapper)),
      (this.encoder = new Sr(this.contractWrapper)),
      (this.interceptor = new Rv(this.contractWrapper)),
      (this.estimator = new Pv(this.contractWrapper)),
      (this.publishedMetadata = new Tde(this.contractWrapper, this.storage)),
      (this.metadata = new Q0(this.contractWrapper, Z0, this.storage));
  }
  onNetworkUpdated(e) {
    this.contractWrapper.updateSignerOrProvider(e);
  }
  getAddress() {
    return this.contractWrapper.address;
  }
  prepare(e, r, n) {
    return ze.fromContractWrapper({
      contractWrapper: this.contractWrapper,
      method: e,
      args: r,
      overrides: n,
    });
  }
  async call(e, r, n) {
    return this.contractWrapper.call(e, r, n);
  }
  detectRoyalties() {
    if (Qe(this.contractWrapper, "Royalty")) {
      const e = new Q0(this.contractWrapper, Z0, this.storage);
      return new Tfe(this.contractWrapper, e);
    }
  }
  detectRoles() {
    if (Qe(this.contractWrapper, "Permissions"))
      return new Efe(this.contractWrapper, TL);
  }
  detectPrimarySales() {
    if (Qe(this.contractWrapper, "PrimarySale"))
      return new Cfe(this.contractWrapper);
  }
  detectPlatformFees() {
    if (Qe(this.contractWrapper, "PlatformFee"))
      return new _de(this.contractWrapper);
  }
  detectErc20() {
    if (Qe(this.contractWrapper, "ERC20"))
      return new jfe(this.contractWrapper, this.storage, this.chainId);
  }
  detectErc721() {
    if (Qe(this.contractWrapper, "ERC721"))
      return new ade(this.contractWrapper, this.storage, this.chainId);
  }
  detectErc1155() {
    if (Qe(this.contractWrapper, "ERC1155"))
      return new mde(this.contractWrapper, this.storage, this.chainId);
  }
  detectOwnable() {
    if (Qe(this.contractWrapper, "Ownable"))
      return new Cde(this.contractWrapper);
  }
  detectApp() {
    const e = new Q0(this.contractWrapper, Z0, this.storage);
    if (Qe(this.contractWrapper, "AppURI"))
      return new t9(this.contractWrapper, e, this.storage);
    if (Qe(this.contractWrapper, "ContractMetadata"))
      return new t9(this.contractWrapper, e, this.storage);
  }
  detectDirectListings() {
    if (Qe(this.contractWrapper, "DirectListings"))
      return new gde(this.contractWrapper, this.storage);
  }
  detectEnglishAuctions() {
    if (Qe(this.contractWrapper, "EnglishAuctions"))
      return new vde(this.contractWrapper, this.storage);
  }
  detectOffers() {
    if (Qe(this.contractWrapper, "Offers"))
      return new wde(this.contractWrapper, this.storage);
  }
  detectBaseRouter() {
    if (Qe(this.contractWrapper, em.name)) return new Qde(this.contractWrapper);
  }
  detectAirdrop20() {
    if (Qe(this.contractWrapper, "AirdropERC20"))
      return new Zde(this.contractWrapper);
  }
  detectAirdrop721() {
    if (Qe(this.contractWrapper, "AirdropERC721"))
      return new Jde(this.contractWrapper);
  }
  detectAirdrop1155() {
    if (Qe(this.contractWrapper, "AirdropERC1155"))
      return new Gde(this.contractWrapper);
  }
  detectAccountFactory() {
    if (Qe(this.contractWrapper, tm.name)) return new Kde(this.contractWrapper);
  }
  detectAccount() {
    if (Qe(this.contractWrapper, rm.name)) return new Vde(this.contractWrapper);
  }
}
class Xde extends Ed {
  constructor(r, n, i) {
    super(r, n);
    oe(
      this,
      "updatePublisherProfile",
      be(async (r) => {
        const n = this.getSigner();
        Je(n);
        const i = await n.getAddress(),
          a = await this.storage.upload(r);
        return ze.fromContractWrapper({
          contractWrapper: this.publisher,
          method: "setPublisherProfileUri",
          args: [i, a],
        });
      })
    );
    oe(
      this,
      "publish",
      be(async (r, n) => {
        const i = this.getSigner();
        Je(i);
        const a = await i.getAddress(),
          s = await pL(r, this.storage),
          o = await FE(s.metadataUri, this.storage),
          c = xu(Gt.parse(o.abi), "PluginRouter"),
          u = xu(Gt.parse(o.abi), "DynamicContract");
        if (((n.routerType = c ? "plugin" : u ? "dynamic" : "none"), u || c)) {
          const w = n.defaultExtensions;
          if (w && w.length > 0)
            try {
              const k = (
                  await Promise.all(
                    w.map((F) =>
                      po(
                        F.publisherAddress,
                        F.extensionName,
                        F.extensionVersion,
                        this.storage,
                        this.options.clientId,
                        this.options.secretKey
                      )
                    )
                  )
                ).map((F) => F.metadataUri),
                N = (
                  await Promise.all(k.map(async (F) => Vi(F, this.storage)))
                ).map((F) => F.compilerMetadata.abi),
                O = Nf([o.abi, ...N]);
              n.compositeAbi = Gt.parse(O);
            } catch {}
        }
        const d = await this.getLatest(a, s.name);
        if (d && d.metadataUri) {
          const S = (await this.fetchPublishedContractInfo(d)).publishedMetadata
            .version;
          if (!eue(S, n.version))
            throw Error(`Version ${n.version} is not greater than ${S}`);
        }
        const m = await (await this.storage.download(s.bytecodeUri)).text(),
          v = m.startsWith("0x") ? m : `0x${m}`,
          E = ha(["bytes"], [v]),
          A = s.name,
          I = await Oue.parseAsync({
            ...n,
            metadataUri: s.metadataUri,
            bytecodeUri: s.bytecodeUri,
            name: s.name,
            analytics: s.analytics,
            publisher: a,
          }),
          b = await this.storage.upload(I);
        return ze.fromContractWrapper({
          contractWrapper: this.publisher,
          method: "publishContract",
          args: [a, A, b, s.metadataUri, E, Ft],
          parse: (w) => {
            const S = this.publisher.parseLogs("ContractPublished", w.logs);
            if (S.length < 1)
              throw new Error("No ContractPublished event found");
            const k = S[0].args.publishedContract;
            return {
              receipt: w,
              data: async () => this.toPublishedContract(k),
            };
          },
        });
      })
    );
    oe(
      this,
      "unpublish",
      be(async (r, n) => {
        const i = await Se(r);
        return ze.fromContractWrapper({
          contractWrapper: this.publisher,
          method: "unpublishContract",
          args: [i, n],
        });
      })
    );
    (this.storage = i), (this.publisher = new Gn(r, UE(), EE, n, i));
  }
  updateSignerOrProvider(r) {
    super.updateSignerOrProvider(r), this.publisher.updateSignerOrProvider(r);
  }
  async extractConstructorParams(r) {
    return Ade(r, this.storage);
  }
  async extractFunctions(r) {
    return kde(r, this.storage);
  }
  async fetchCompilerMetadataFromPredeployURI(r) {
    return am(r, this.storage);
  }
  async fetchPrePublishMetadata(r, n) {
    const i = await am(r, this.storage),
      a = n ? await this.getLatest(n, i.name) : void 0,
      s = a ? await this.fetchPublishedContractInfo(a) : void 0;
    return {
      preDeployMetadata: i,
      latestPublishedContractMetadata: s,
    };
  }
  async fetchCompilerMetadataFromAddress(r) {
    const n = await Se(r);
    return Ai(n, this.getProvider(), this.storage, this.options);
  }
  async fetchPublishedContractInfo(r) {
    return {
      name: r.id,
      publishedTimestamp: r.timestamp,
      publishedMetadata: await this.fetchFullPublishMetadata(r.metadataUri),
    };
  }
  async fetchFullPublishMetadata(r) {
    return jE(r, this.storage);
  }
  async resolvePublishMetadataFromCompilerMetadata(r) {
    const n = await this.publisher.read("getPublishedUriFromCompilerUri", [r]);
    if (n.length === 0)
      throw Error(`Could not resolve published metadata URI from ${r}`);
    return await Promise.all(
      n.filter((i) => i.length > 0).map((i) => this.fetchFullPublishMetadata(i))
    );
  }
  async resolveContractUriFromAddress(r) {
    const n = await Se(r),
      i = await YF(n, this.getProvider());
    return Je(i), i;
  }
  async fetchContractSourcesFromAddress(r) {
    const n = await Se(r),
      i = await this.fetchCompilerMetadataFromAddress(n);
    return await Av(i, this.storage);
  }
  async getPublisherProfile(r) {
    const n = await Se(r),
      i = await this.publisher.read("getPublisherProfileUri", [n]);
    return !i || i.length === 0
      ? {}
      : $ue.parse(await this.storage.downloadJSON(i));
  }
  async getAll(r) {
    const n = await Se(r),
      a = (await this.publisher.read("getAllPublishedContracts", [n])).reduce(
        (s, o) => ((s[o.contractId] = o), s),
        {}
      );
    return Object.entries(a).map((s) => {
      let [, o] = s;
      return this.toPublishedContract(o);
    });
  }
  async getAllVersions(r, n) {
    const i = await Se(r),
      a = await this.publisher.read("getPublishedContractVersions", [i, n]);
    if (a.length === 0) throw Error("Not found");
    return a.map((s) => this.toPublishedContract(s));
  }
  async getVersion(r, n) {
    let i =
      arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "latest";
    const a = await Se(r);
    if (i === "latest") return this.getLatest(a, n);
    const s = await this.getAllVersions(a, n),
      c = (
        await Promise.all(s.map((u) => this.fetchPublishedContractInfo(u)))
      ).find((u) => u.publishedMetadata.version === i);
    return Je(c), s.find((u) => u.timestamp === c.publishedTimestamp);
  }
  async getLatest(r, n) {
    const i = await Se(r),
      a = await this.publisher.read("getPublishedContract", [i, n]);
    if (a && a.publishMetadataUri) return this.toPublishedContract(a);
  }
  toPublishedContract(r) {
    return B_.parse({
      id: r.contractId,
      timestamp: r.publishTimestamp,
      metadataUri: r.publishMetadataUri,
    });
  }
}
const i9 = {},
  ehe = [
    {
      inputs: [
        {
          internalType: "address",
          name: "_pluginMap",
          type: "address",
        },
        {
          internalType: "address[]",
          name: "_trustedForwarders",
          type: "address[]",
        },
      ],
      stateMutability: "nonpayable",
      type: "constructor",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "bytes4",
          name: "functionSelector",
          type: "bytes4",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "pluginAddress",
          type: "address",
        },
      ],
      name: "PluginAdded",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "bytes4",
          name: "functionSelector",
          type: "bytes4",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "pluginAddress",
          type: "address",
        },
      ],
      name: "PluginRemoved",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "bytes4",
          name: "functionSelector",
          type: "bytes4",
        },
        {
          indexed: !0,
          internalType: "string",
          name: "functionSignature",
          type: "string",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "pluginAddress",
          type: "address",
        },
      ],
      name: "PluginSet",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "bytes4",
          name: "functionSelector",
          type: "bytes4",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "oldPluginAddress",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "newPluginAddress",
          type: "address",
        },
      ],
      name: "PluginUpdated",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          indexed: !0,
          internalType: "bytes32",
          name: "previousAdminRole",
          type: "bytes32",
        },
        {
          indexed: !0,
          internalType: "bytes32",
          name: "newAdminRole",
          type: "bytes32",
        },
      ],
      name: "RoleAdminChanged",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "account",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "sender",
          type: "address",
        },
      ],
      name: "RoleGranted",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "account",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "sender",
          type: "address",
        },
      ],
      name: "RoleRevoked",
      type: "event",
    },
    {
      stateMutability: "payable",
      type: "fallback",
    },
    {
      inputs: [],
      name: "DEFAULT_ADMIN_ROLE",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_selector",
          type: "bytes4",
        },
      ],
      name: "_getPluginForFunction",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "bytes4",
              name: "functionSelector",
              type: "bytes4",
            },
            {
              internalType: "string",
              name: "functionSignature",
              type: "string",
            },
            {
              internalType: "address",
              name: "pluginAddress",
              type: "address",
            },
          ],
          internalType: "struct IPluginMap.Plugin",
          name: "_plugin",
          type: "tuple",
        },
      ],
      name: "addPlugin",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_pluginAddress",
          type: "address",
        },
      ],
      name: "getAllFunctionsOfPlugin",
      outputs: [
        {
          internalType: "bytes4[]",
          name: "registered",
          type: "bytes4[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "getAllPlugins",
      outputs: [
        {
          components: [
            {
              internalType: "bytes4",
              name: "functionSelector",
              type: "bytes4",
            },
            {
              internalType: "string",
              name: "functionSignature",
              type: "string",
            },
            {
              internalType: "address",
              name: "pluginAddress",
              type: "address",
            },
          ],
          internalType: "struct IPluginMap.Plugin[]",
          name: "registered",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_selector",
          type: "bytes4",
        },
      ],
      name: "getPluginForFunction",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
      ],
      name: "getRoleAdmin",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          internalType: "uint256",
          name: "index",
          type: "uint256",
        },
      ],
      name: "getRoleMember",
      outputs: [
        {
          internalType: "address",
          name: "member",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
      ],
      name: "getRoleMemberCount",
      outputs: [
        {
          internalType: "uint256",
          name: "count",
          type: "uint256",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          internalType: "address",
          name: "account",
          type: "address",
        },
      ],
      name: "grantRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          internalType: "address",
          name: "account",
          type: "address",
        },
      ],
      name: "hasRole",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          internalType: "address",
          name: "account",
          type: "address",
        },
      ],
      name: "hasRoleWithSwitch",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "forwarder",
          type: "address",
        },
      ],
      name: "isTrustedForwarder",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes[]",
          name: "data",
          type: "bytes[]",
        },
      ],
      name: "multicall",
      outputs: [
        {
          internalType: "bytes[]",
          name: "results",
          type: "bytes[]",
        },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "pluginMap",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "_selector",
          type: "bytes4",
        },
      ],
      name: "removePlugin",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          internalType: "address",
          name: "account",
          type: "address",
        },
      ],
      name: "renounceRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          internalType: "address",
          name: "account",
          type: "address",
        },
      ],
      name: "revokeRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "interfaceId",
          type: "bytes4",
        },
      ],
      name: "supportsInterface",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "bytes4",
              name: "functionSelector",
              type: "bytes4",
            },
            {
              internalType: "string",
              name: "functionSignature",
              type: "string",
            },
            {
              internalType: "address",
              name: "pluginAddress",
              type: "address",
            },
          ],
          internalType: "struct IPluginMap.Plugin",
          name: "_plugin",
          type: "tuple",
        },
      ],
      name: "updatePlugin",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      stateMutability: "payable",
      type: "receive",
    },
  ],
  the = [
    {
      inputs: [
        {
          internalType: "address",
          name: "_trustedForwarder",
          type: "address",
        },
        {
          internalType: "address",
          name: "_registry",
          type: "address",
        },
      ],
      stateMutability: "nonpayable",
      type: "constructor",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "address",
          name: "implementation",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "bytes32",
          name: "contractType",
          type: "bytes32",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "version",
          type: "uint256",
        },
      ],
      name: "ImplementationAdded",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: "address",
          name: "implementation",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "bool",
          name: "isApproved",
          type: "bool",
        },
      ],
      name: "ImplementationApproved",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "implementation",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "address",
          name: "proxy",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "deployer",
          type: "address",
        },
      ],
      name: "ProxyDeployed",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          indexed: !0,
          internalType: "bytes32",
          name: "previousAdminRole",
          type: "bytes32",
        },
        {
          indexed: !0,
          internalType: "bytes32",
          name: "newAdminRole",
          type: "bytes32",
        },
      ],
      name: "RoleAdminChanged",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "account",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "sender",
          type: "address",
        },
      ],
      name: "RoleGranted",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "account",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "sender",
          type: "address",
        },
      ],
      name: "RoleRevoked",
      type: "event",
    },
    {
      inputs: [],
      name: "DEFAULT_ADMIN_ROLE",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "FACTORY_ROLE",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_implementation",
          type: "address",
        },
      ],
      name: "addImplementation",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "",
          type: "address",
        },
      ],
      name: "approval",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_implementation",
          type: "address",
        },
        {
          internalType: "bool",
          name: "_toApprove",
          type: "bool",
        },
      ],
      name: "approveImplementation",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32",
        },
      ],
      name: "currentVersion",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "_type",
          type: "bytes32",
        },
        {
          internalType: "bytes",
          name: "_data",
          type: "bytes",
        },
      ],
      name: "deployProxy",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_implementation",
          type: "address",
        },
        {
          internalType: "bytes",
          name: "_data",
          type: "bytes",
        },
        {
          internalType: "bytes32",
          name: "_salt",
          type: "bytes32",
        },
      ],
      name: "deployProxyByImplementation",
      outputs: [
        {
          internalType: "address",
          name: "deployedProxy",
          type: "address",
        },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "_type",
          type: "bytes32",
        },
        {
          internalType: "bytes",
          name: "_data",
          type: "bytes",
        },
        {
          internalType: "bytes32",
          name: "_salt",
          type: "bytes32",
        },
      ],
      name: "deployProxyDeterministic",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "",
          type: "address",
        },
      ],
      name: "deployer",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "_type",
          type: "bytes32",
        },
        {
          internalType: "uint256",
          name: "_version",
          type: "uint256",
        },
      ],
      name: "getImplementation",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "_type",
          type: "bytes32",
        },
      ],
      name: "getLatestImplementation",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
      ],
      name: "getRoleAdmin",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          internalType: "uint256",
          name: "index",
          type: "uint256",
        },
      ],
      name: "getRoleMember",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
      ],
      name: "getRoleMemberCount",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          internalType: "address",
          name: "account",
          type: "address",
        },
      ],
      name: "grantRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          internalType: "address",
          name: "account",
          type: "address",
        },
      ],
      name: "hasRole",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32",
        },
        {
          internalType: "uint256",
          name: "",
          type: "uint256",
        },
      ],
      name: "implementation",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "forwarder",
          type: "address",
        },
      ],
      name: "isTrustedForwarder",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes[]",
          name: "data",
          type: "bytes[]",
        },
      ],
      name: "multicall",
      outputs: [
        {
          internalType: "bytes[]",
          name: "results",
          type: "bytes[]",
        },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "registry",
      outputs: [
        {
          internalType: "contract TWRegistry",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          internalType: "address",
          name: "account",
          type: "address",
        },
      ],
      name: "renounceRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          internalType: "address",
          name: "account",
          type: "address",
        },
      ],
      name: "revokeRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "interfaceId",
          type: "bytes4",
        },
      ],
      name: "supportsInterface",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  rhe = [
    {
      inputs: [
        {
          internalType: "address",
          name: "_trustedForwarder",
          type: "address",
        },
      ],
      stateMutability: "nonpayable",
      type: "constructor",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "deployer",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "deployment",
          type: "address",
        },
      ],
      name: "Added",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "deployer",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "deployment",
          type: "address",
        },
      ],
      name: "Deleted",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          indexed: !0,
          internalType: "bytes32",
          name: "previousAdminRole",
          type: "bytes32",
        },
        {
          indexed: !0,
          internalType: "bytes32",
          name: "newAdminRole",
          type: "bytes32",
        },
      ],
      name: "RoleAdminChanged",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "account",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "sender",
          type: "address",
        },
      ],
      name: "RoleGranted",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "account",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "sender",
          type: "address",
        },
      ],
      name: "RoleRevoked",
      type: "event",
    },
    {
      inputs: [],
      name: "DEFAULT_ADMIN_ROLE",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "OPERATOR_ROLE",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_deployer",
          type: "address",
        },
        {
          internalType: "address",
          name: "_deployment",
          type: "address",
        },
      ],
      name: "add",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_deployer",
          type: "address",
        },
      ],
      name: "count",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_deployer",
          type: "address",
        },
      ],
      name: "getAll",
      outputs: [
        {
          internalType: "address[]",
          name: "",
          type: "address[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
      ],
      name: "getRoleAdmin",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          internalType: "uint256",
          name: "index",
          type: "uint256",
        },
      ],
      name: "getRoleMember",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
      ],
      name: "getRoleMemberCount",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          internalType: "address",
          name: "account",
          type: "address",
        },
      ],
      name: "grantRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          internalType: "address",
          name: "account",
          type: "address",
        },
      ],
      name: "hasRole",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "forwarder",
          type: "address",
        },
      ],
      name: "isTrustedForwarder",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes[]",
          name: "data",
          type: "bytes[]",
        },
      ],
      name: "multicall",
      outputs: [
        {
          internalType: "bytes[]",
          name: "results",
          type: "bytes[]",
        },
      ],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "_deployer",
          type: "address",
        },
        {
          internalType: "address",
          name: "_deployment",
          type: "address",
        },
      ],
      name: "remove",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          internalType: "address",
          name: "account",
          type: "address",
        },
      ],
      name: "renounceRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32",
        },
        {
          internalType: "address",
          name: "account",
          type: "address",
        },
      ],
      name: "revokeRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "interfaceId",
          type: "bytes4",
        },
      ],
      name: "supportsInterface",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
  ];
let a9 = !1;
function jL(t, e, r) {
  a9 || ((a9 = !0), !(e || r) && console.warn(t));
}
const nhe =
    "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80",
  s9 = {
    [Ve.Mainnet]: {
      "nft-drop": "0x60fF9952e0084A6DEac44203838cDC91ABeC8736",
      "edition-drop": "0x74af262d0671F378F97a1EDC3d0970Dbe8A1C550",
      "token-drop": "0xE1eE43D23f247b6A9aF81fcE2766E76709482728",
      "signature-drop": "0x6fD690EB509BdE4C50028C5D9C0dE3750C2Fad6A",
    },
    [Ve.Polygon]: {
      "nft-drop": "0xB96508050Ba0925256184103560EBADA912Fcc69",
      "edition-drop": "0x74af262d0671F378F97a1EDC3d0970Dbe8A1C550",
      "token-drop": "0x5A8eA4Adad8289746D073947BA06D69A62499aaf",
      "signature-drop": "0xBE2fDc35410E268e41Bec62DBb01AEb43245c7d5",
    },
    [Ve.Fantom]: {
      "nft-drop": "0x2A396b2D90BAcEF19cDa973586B2633d22710fC2",
      "edition-drop": "0x06395FCF9AC6ED827f9dD6e776809cEF1Be0d21B",
      "token-drop": "0x0148b28a38efaaC31b6aa0a6D9FEb70FE7C91FFa",
      "signature-drop": "0xe135Ef65C2B2213C3fD56d0Bd6500A2cA147aC10",
    },
    [Ve.Avalanche]: {
      "nft-drop": "0x9cF91118C8ee2913F0588e0F10e36B3d63F68bF6",
      "edition-drop": "0x135fC9D26E5eC51260ece1DF4ED424E2f55c7766",
      "token-drop": "0xca0B071899E575BA86495D46c5066971b6f3A901",
      "signature-drop": "0x1d47526C3292B0130ef0afD5F02c1DA052A017B3",
    },
    [Ve.Optimism]: {
      "nft-drop": "0xFBd7D24d80ee005671E731a7287DEB6073264dD1",
      "edition-drop": "0xe135Ef65C2B2213C3fD56d0Bd6500A2cA147aC10",
      "token-drop": "0x902Dd246e66d8C3CE652375a723F2a52b43b9AAE",
      "signature-drop": "0x8a4cd3549e548bbEEb38C16E041FFf040a5acabD",
    },
    [Ve.Arbitrum]: {
      "nft-drop": "0xC4903c1Ff5367b9ac2c349B63DC2409421AaEE2a",
      "edition-drop": "0xCcddcec1831646Beff2753249f1B9C580327E89F",
      "token-drop": "0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9",
      "signature-drop": "0x2dF9851af45dd41C8584ac55D983C604da985Bc7",
    },
    [Ve.BinanceSmartChainMainnet]: {
      "nft-drop": "0x902Dd246e66d8C3CE652375a723F2a52b43b9AAE",
      "edition-drop": "0x2A396b2D90BAcEF19cDa973586B2633d22710fC2",
      "token-drop": "0xe135Ef65C2B2213C3fD56d0Bd6500A2cA147aC10",
      "signature-drop": "0xFBd7D24d80ee005671E731a7287DEB6073264dD1",
    },
    [Ve.Goerli]: {
      "nft-drop": "0xD11c97DD5F5546B5bBd630D7D1d7327481B0b92C",
      "edition-drop": "0x5A8eA4Adad8289746D073947BA06D69A62499aaf",
      "token-drop": "0x5680933221B752EB443654a014f88B101F868d50",
      "signature-drop": "0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9",
    },
    [Ve.Mumbai]: {
      "nft-drop": "0xC4903c1Ff5367b9ac2c349B63DC2409421AaEE2a",
      "edition-drop": "0xCcddcec1831646Beff2753249f1B9C580327E89F",
      "token-drop": "0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9",
      "signature-drop": "0x2dF9851af45dd41C8584ac55D983C604da985Bc7",
    },
    [Ve.FantomTestnet]: {
      "nft-drop": "0x8a4cd3549e548bbEEb38C16E041FFf040a5acabD",
      "edition-drop": "0x902Dd246e66d8C3CE652375a723F2a52b43b9AAE",
      "token-drop": "0xFBd7D24d80ee005671E731a7287DEB6073264dD1",
      "signature-drop": "0x5A8eA4Adad8289746D073947BA06D69A62499aaf",
    },
    [Ve.AvalancheFujiTestnet]: {
      "nft-drop": "0xD11c97DD5F5546B5bBd630D7D1d7327481B0b92C",
      "edition-drop": "0xE1eE43D23f247b6A9aF81fcE2766E76709482728",
      "token-drop": "0x6fD690EB509BdE4C50028C5D9C0dE3750C2Fad6A",
      "signature-drop": "0xCcddcec1831646Beff2753249f1B9C580327E89F",
    },
    [Ve.OptimismGoerli]: {
      "nft-drop": "0xCcddcec1831646Beff2753249f1B9C580327E89F",
      "edition-drop": "0x6fD690EB509BdE4C50028C5D9C0dE3750C2Fad6A",
      "token-drop": "0xD11c97DD5F5546B5bBd630D7D1d7327481B0b92C",
      "signature-drop": "0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9",
    },
    [Ve.ArbitrumGoerli]: {
      "nft-drop": "0x9CfE807a5b124b962064Fa8F7FD823Cc701255b6",
      "edition-drop": "0x9cF91118C8ee2913F0588e0F10e36B3d63F68bF6",
      "token-drop": "0x1d47526C3292B0130ef0afD5F02c1DA052A017B3",
      "signature-drop": "0xE1eE43D23f247b6A9aF81fcE2766E76709482728",
    },
    [Ve.BinanceSmartChainTestnet]: {
      "nft-drop": "",
      "edition-drop": "",
      "token-drop": "",
      "signature-drop": "",
    },
    [Ve.Hardhat]: {
      "nft-drop": "",
      "edition-drop": "",
      "token-drop": "",
      "signature-drop": "",
    },
    [Ve.Localhost]: {
      "nft-drop": "",
      "edition-drop": "",
      "token-drop": "",
      "signature-drop": "",
    },
  };
function ihe(t, e) {
  if (t in s9) {
    const r = s9[t];
    if (e in r) return r[e];
  }
  return null;
}
const HL = [
  Ve.Mainnet,
  Ve.Goerli,
  Ve.Polygon,
  Ve.Mumbai,
  Ve.Fantom,
  Ve.FantomTestnet,
  Ve.Avalanche,
  Ve.AvalancheFujiTestnet,
  Ve.Optimism,
  Ve.OptimismGoerli,
  Ve.Arbitrum,
  Ve.ArbitrumGoerli,
  Ve.BinanceSmartChainMainnet,
  Ve.BinanceSmartChainTestnet,
  Ve.Hardhat,
  Ve.Localhost,
];
function Fl(t) {
  const e = HL.find((i) => i === t),
    r = e ? wu[e].biconomyForwarder : fr;
  return [e ? wu[e].openzeppelinForwarder : fr, r].filter((i) => i !== fr);
}
function o9(t, e) {
  const r = Gt.parse(t || []);
  for (const n of r)
    if (n.type === "function" && n.name === e) return n.inputs || [];
  return [];
}
function ahe(t) {
  const e = [];
  return LE(DE(t), e), e.map((r) => r.name);
}
function c9(t) {
  return ahe(t);
}
async function she(t, e, r) {
  var A;
  let n =
      arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "latest",
    i = arguments.length > 4 ? arguments[4] : void 0,
    a = arguments.length > 5 ? arguments[5] : void 0,
    s = arguments.length > 6 ? arguments[6] : void 0;
  const o = Es(e, {
      clientId: i,
      secretKey: a,
    }),
    u = (await po(_u, t, n, r, i, a)).metadataUri,
    d = await Vi(u, r),
    m = await xl(o);
  Je(m);
  const { extendedMetadata: v } = await Vi(u, r);
  let E;
  return (
    (v == null ? void 0 : v.routerType) === "plugin" ||
    (v == null ? void 0 : v.routerType) === "dynamic"
      ? (E =
          (A = (await om(u, r, o, m, i, a)).find(
            (b) => b.type === "implementation"
          )) == null
            ? void 0
            : A.encodedArgs)
      : (E = await yL(d.compilerMetadata, o, r, m, s, i, a)),
    E
  );
}
async function ohe(t, e, r) {
  var v;
  let n =
      arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "latest",
    i = arguments.length > 4 ? arguments[4] : void 0,
    a = arguments.length > 5 ? arguments[5] : void 0;
  const s = Es(e, {
      clientId: i,
      secretKey: a,
    }),
    c = (await po(_u, t, n, r, i, a)).metadataUri,
    u = await xl(s);
  Je(u);
  const { extendedMetadata: d } = await Vi(c, r);
  if (
    (d == null ? void 0 : d.routerType) === "plugin" ||
    (d == null ? void 0 : d.routerType) === "dynamic"
  ) {
    const A =
      (v = (await om(c, r, s, u, i, a)).find(
        (I) => I.type === "implementation"
      )) == null
        ? void 0
        : v.transaction.predictedAddress;
    return Je(A), A;
  }
  return (
    await Oa(
      "implementation",
      s,
      r,
      u,
      {
        contractName: t,
      },
      i,
      a
    )
  ).transaction.predictedAddress;
}
async function che(t, e, r) {
  let n =
      arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "latest",
    i = arguments.length > 4 ? arguments[4] : void 0,
    a = arguments.length > 5 ? arguments[5] : void 0;
  const s = Es(e, {
      clientId: i,
      secretKey: a,
    }),
    o = await ohe(t, e, r, n, i, a),
    c = await ho(o, s);
  return Je(c), o;
}
const lhe = {
    FAILED: "Fail - Unable to verify",
    SUCCESS: "Pass - Verified",
    PENDING: "Pending in queue",
    ALREADY_VERIFIED: "Contract source code already verified",
    AUTOMATICALLY_VERIFIED: "Already Verified",
  },
  zL = {
    OK: "1",
    NOTOK: "0",
  };
async function uhe(t, e, r, n, i) {
  let a =
      arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "latest",
    s = arguments.length > 6 ? arguments[6] : void 0,
    o = arguments.length > 7 ? arguments[7] : void 0,
    c = arguments.length > 8 ? arguments[8] : void 0;
  const u = await che(t, e, i, a, s, o),
    d = await she(t, e, i, a, s, o, c);
  return (
    console.info(`Verifying ${t} at address ${u}`),
    await qL(u, e, r, n, i, d == null ? void 0 : d.toString().replace("0x", ""))
  );
}
async function qL(t, e, r, n, i, a) {
  try {
    const s = Es(e, {}),
      o = await Ai(t, s, i),
      c = o.metadata.compiler.version,
      u = await Av(o, i),
      d = o.metadata.sources,
      m = {};
    for (const O of Object.keys(d)) {
      const F = u.find((V) => O === V.filename);
      if (!F) throw new Error(`Could not find source file for ${O}`);
      m[O] = {
        content: F.source,
      };
    }
    const v = {
        language: "Solidity",
        sources: m,
        settings: {
          optimizer: o.metadata.settings.optimizer,
          evmVersion: o.metadata.settings.evmVersion,
          remappings: o.metadata.settings.remappings,
          outputSelection: {
            "*": {
              "*": [
                "abi",
                "evm.bytecode",
                "evm.deployedBytecode",
                "evm.methodIdentifiers",
                "metadata",
              ],
              "": ["ast"],
            },
          },
        },
      },
      E = o.metadata.settings.compilationTarget,
      I = Object.keys(E)[0],
      b = a || (await fhe(r, n, t, o.abi, s, i)),
      w = {
        apikey: n,
        module: "contract",
        action: "verifysourcecode",
        contractaddress: t,
        sourceCode: JSON.stringify(v),
        codeformat: "solidity-standard-json-input",
        contractname: `${I}:${o.name}`,
        compilerversion: `v${c}`,
        constructorArguements: b,
      },
      S = new URLSearchParams({
        ...w,
      }),
      N = await (
        await _s(r, {
          method: "POST",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
          },
          body: S.toString(),
        })
      ).json();
    if (N.status === zL.OK) return N.result;
    throw new Error(`${N.result}`);
  } catch (s) {
    throw new Error(s.toString());
  }
}
async function l9(t, e, r) {
  const n = `${t}?module=contract&action=checkverifystatus&guid=${r}&apikey=${e}"`;
  return new Promise((i, a) => {
    const s = setInterval(async () => {
      try {
        const c = await (
          await _s(n, {
            method: "GET",
          })
        ).json();
        (c == null ? void 0 : c.result) !== lhe.PENDING &&
          (clearInterval(s), i(c));
      } catch (o) {
        clearInterval(s), a(o);
      }
    }, 3e3);
  });
}
async function fhe(t, e, r, n, i, a) {
  const s = _d(n);
  if (s.length === 0) return "";
  const o = {
      apiKey: e,
      module: "account",
      action: "txlist",
      address: r,
      page: "1",
      sort: "asc",
      offset: "1",
    },
    c = new URLSearchParams({
      ...o,
    }),
    d = await (
      await _s(t, {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
        },
        body: c.toString(),
      })
    ).json();
  if (d && d.status === zL.OK && d.result[0] !== void 0) {
    const m = new ls(n),
      v = d.result[0].input;
    let E = "";
    if (m.deploy.inputs.length === 0) return "";
    try {
      const A = await dhe(r, i, a);
      if (A) {
        const I = A.startsWith("0x") ? A : `0x${A}`;
        E = v.substring(I.length);
      }
    } catch {}
    if (!E) {
      const A = [...v.matchAll(/(64736f6c6343[\w]{6}[\w]{4})(?!.*\1)(.*)$/g)];
      A.length > 0 && (E = A[0][2]);
    }
    if (!E) {
      const A = s.length * 64;
      E = v.substring(v.length - A);
    }
    try {
      xs.decode(m.deploy.inputs, `0x${E}`);
    } catch {
      throw new Error(
        "Verifying this contract requires it to be published. Run `npx thirdweb publish` to publish this contract, then try again."
      );
    }
    return E;
  } else return "";
}
async function dhe(t, e, r) {
  const n = await YF(t, e);
  if (n) {
    const a = await new Yt(
      UE(),
      EE,
      Es("polygon", {})
    ).getPublishedUriFromCompilerUri(n);
    if (a.length === 0)
      throw Error(`Could not resolve published metadata URI from ${n}`);
    const s = await Promise.all(
      a.filter((o) => o.length > 0).map((o) => jE(o, r))
    );
    return s.length > 0
      ? await (await r.download(s[0].bytecodeUri)).text()
      : void 0;
  }
}
async function hhe(t, e, r, n, i) {
  return (
    r || (r = await xl(t)),
    (
      await Oa(
        "infra",
        t,
        e,
        r,
        {
          contractName: "TWCloneFactory",
        },
        n,
        i
      )
    ).transaction.predictedAddress
  );
}
async function VL(t, e) {
  var c, u;
  if ((Je(t.provider), await ho(Z2, t.provider))) return Z2;
  const n = await rL(t.provider),
    i = (await t.provider.getNetwork()).chainId,
    a = n ? i : 0;
  console.debug(`ChainId ${i} enforces EIP155: ${n}`);
  const s = O0[i] ? J2(a, O0[i].gasPrice) : J2(a);
  if (!(await ho(s.deployment, t.provider))) {
    const d = O0[i] ? ae.from(O0[i].gasPrice).mul(1e5) : NL("0.01");
    (await t.provider.getBalance(s.signer)).lt(d) &&
      (await (
        await t.sendTransaction({
          to: s.signer,
          value: d,
        })
      ).wait());
    try {
      console.debug(`deploying CREATE2 factory at: ${s.deployment}`),
        (c = e == null ? void 0 : e.notifier) == null ||
          c.call(e, "deploying", "create2Factory"),
        await (await t.provider.sendTransaction(s.transaction)).wait(),
        (u = e == null ? void 0 : e.notifier) == null ||
          u.call(e, "deployed", "create2Factory");
    } catch (m) {
      throw new Error(`Couldn't deploy CREATE2 factory: ${JSON.stringify(m)}`);
    }
  }
  return s.deployment;
}
function qh(t, e) {
  if (t.length !== e.length)
    throw Error(
      `Passed the wrong number of constructor arguments: ${e.length}, expected ${t.length}`
    );
  return t.map((r, n) =>
    r === "tuple" || r.endsWith("[]")
      ? typeof e[n] == "string"
        ? JSON.parse(e[n])
        : e[n]
      : r === "bytes32"
      ? (Je(
          gt(e[n]),
          `Could not parse bytes32 value. Expected valid hex string but got "${e[n]}".`
        ),
        Rt(e[n], 32))
      : r.startsWith("bytes")
      ? (Je(
          gt(e[n]),
          `Could not parse bytes value. Expected valid hex string but got "${e[n]}".`
        ),
        e[n])
      : r.startsWith("uint") || r.startsWith("int")
      ? ae.from(e[n].toString())
      : e[n]
  );
}
async function phe(t, e, r, n, i) {
  let a = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 7e6;
  Je(r.provider);
  const s = t.startsWith("0x") ? t : `0x${t}`,
    o = await VL(r),
    c = _d(e),
    u = c.map((b) => b.type),
    d = qh(u, n),
    m = c.map((b) => (b.type === "tuple[]" ? rn.from(b) : b.type)),
    v = xs.encode(m, d),
    E = Y2(s, v, o, i),
    A = await ho(E, r.provider);
  let I = "";
  if (A) throw new Error(`Contract already deployed at ${E}`);
  {
    console.debug(`deploying contract via create2 factory at: ${E}`),
      (I = G_(s, v, i));
    const b = {
      to: o,
      data: I,
    };
    try {
      await r.estimateGas(b);
    } catch (w) {
      console.debug("error estimating gas while deploying prebuilt: ", w),
        (b.gasLimit = ae.from(a));
    }
    await (await r.sendTransaction(b)).wait();
  }
  return E;
}
async function mhe(t, e) {
  let r =
      arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "latest",
    n = arguments.length > 3 ? arguments[3] : void 0,
    i = arguments.length > 4 ? arguments[4] : void 0,
    a = arguments.length > 5 ? arguments[5] : void 0,
    s = arguments.length > 6 ? arguments[6] : void 0,
    o = arguments.length > 7 ? arguments[7] : void 0,
    c = arguments.length > 8 ? arguments[8] : void 0,
    u = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : 7e6;
  const d = (await po(e, t, r, a, s, o)).metadataUri,
    { compilerMetadata: m, extendedMetadata: v } = await Vi(d, a);
  return (
    Je((v == null ? void 0 : v.deployType) === "standard"),
    await phe(m.bytecode, m.abi, i, n, c, u)
  );
}
async function yhe(t, e, r, n, i) {
  const a = t.startsWith("0x") ? t : `0x${t}`,
    s = await xl(r),
    o = _d(e),
    c = o.map((E) => E.type),
    u = qh(c, n),
    d = o.map((E) => (E.type === "tuple[]" ? rn.from(E) : E.type)),
    m = xs.encode(d, u);
  return Y2(a, m, s, i);
}
async function ghe(t, e) {
  let r =
      arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "latest",
    n = arguments.length > 3 ? arguments[3] : void 0,
    i = arguments.length > 4 ? arguments[4] : void 0,
    a = arguments.length > 5 ? arguments[5] : void 0,
    s = arguments.length > 6 ? arguments[6] : void 0,
    o = arguments.length > 7 ? arguments[7] : void 0,
    c = arguments.length > 8 ? arguments[8] : void 0;
  const u = (await po(e, t, r, a, s, o)).metadataUri,
    { compilerMetadata: d, extendedMetadata: m } = await Vi(u, a);
  return (
    Je((m == null ? void 0 : m.deployType) === "standard"),
    await yhe(d.bytecode, d.abi, i, n, c)
  );
}
async function KL(t, e, r, n, i) {
  const a = await n.getChainId(),
    s = await n.getAddress(),
    o = HL.find((u) => u === a);
  let c = [];
  switch (
    (o
      ? (c = t === Gs.contractType ? [] : Fl(a))
      : (c = [await HE(n.provider, i)]),
    e.trusted_forwarders &&
      e.trusted_forwarders.length > 0 &&
      c.push(...e.trusted_forwarders),
    t)
  ) {
    case Wc.contractType:
    case Ff.contractType:
      const u = await Wc.schema.deploy.parseAsync(e);
      return [
        s,
        u.name,
        u.symbol,
        r,
        c,
        u.primary_sale_recipient,
        u.fee_recipient,
        u.seller_fee_basis_points,
        u.platform_fee_basis_points,
        u.platform_fee_recipient,
      ];
    case jc.contractType:
      const d = await jc.schema.deploy.parseAsync(e);
      return [
        s,
        d.name,
        d.symbol,
        r,
        c,
        d.primary_sale_recipient,
        d.fee_recipient,
        d.seller_fee_basis_points,
        d.platform_fee_basis_points,
        d.platform_fee_recipient,
      ];
    case Uc.contractType:
      const m = await Uc.schema.deploy.parseAsync(e);
      return [
        s,
        m.name,
        m.symbol,
        r,
        c,
        m.fee_recipient,
        m.seller_fee_basis_points,
      ];
    case Lc.contractType:
    case Of.contractType:
      const v = await Lc.schema.deploy.parseAsync(e);
      return [
        s,
        v.name,
        v.symbol,
        r,
        c,
        v.primary_sale_recipient,
        v.fee_recipient,
        v.seller_fee_basis_points,
        v.platform_fee_basis_points,
        v.platform_fee_recipient,
      ];
    case Lf.contractType:
    case zc.contractType:
      const E = await zc.schema.deploy.parseAsync(e);
      return [
        s,
        E.name,
        E.symbol,
        r,
        c,
        E.primary_sale_recipient,
        E.platform_fee_recipient,
        E.platform_fee_basis_points,
      ];
    case qc.contractType:
      const A = await qc.schema.deploy.parseAsync(e);
      return [
        A.name,
        r,
        c,
        A.voting_token_address,
        A.voting_delay_in_blocks,
        A.voting_period_in_blocks,
        ae.from(A.proposal_token_threshold),
        A.voting_quorum_fraction,
      ];
    case Hc.contractType:
      const I = await Hc.schema.deploy.parseAsync(e);
      return [
        s,
        r,
        c,
        I.recipients.map((S) => S.address),
        I.recipients.map((S) => ae.from(S.sharesBps)),
      ];
    case $c.contractType:
    case au.contractType:
      const b = await $c.schema.deploy.parseAsync(e);
      return [s, r, c, b.platform_fee_recipient, b.platform_fee_basis_points];
    case Gs.contractType:
      const w = await Gs.schema.deploy.parseAsync(e);
      return [
        s,
        w.name,
        w.symbol,
        r,
        c,
        w.fee_recipient,
        w.seller_fee_basis_points,
      ];
    default:
      return [];
  }
}
class Bv {
  constructor(e, r, n) {
    oe(this, "events", new Mf());
    (this.connection = new Ed(e, r)),
      (this.options = r),
      (this.events = new Mf()),
      (this.storage = n);
  }
  connect(e) {
    this.connection.updateSignerOrProvider(e),
      this.events.emit("signerChanged", this.connection.getSigner());
  }
  async transfer(e, r) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : qi;
    const [i, a, s] = await Promise.all([
        Se(e),
        Se(n),
        pi(this.connection.getProvider(), r, n),
      ]),
      o = this.requireWallet();
    if (mo(a)) {
      const c = await o.getAddress();
      return {
        receipt: await (
          await o.sendTransaction({
            from: c,
            to: i,
            value: s,
          })
        ).wait(),
      };
    } else
      return {
        receipt: await this.createErc20(a).sendTransaction("transfer", [i, s]),
      };
  }
  async balance() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : qi;
    this.requireWallet();
    const r = await Se(e),
      n = this.connection.getProvider();
    let i;
    return (
      mo(r)
        ? (i = await n.getBalance(await this.getAddress()))
        : (i = await this.createErc20(r).read("balanceOf", [
            await this.getAddress(),
          ])),
      await hs(n, r, i)
    );
  }
  async getAddress() {
    return await this.requireWallet().getAddress();
  }
  async getChainId() {
    return await this.requireWallet().getChainId();
  }
  async getNonce(e) {
    return await this.connection
      .getProvider()
      .getTransactionCount(await this.getAddress(), e);
  }
  isConnected() {
    try {
      return this.requireWallet(), !0;
    } catch {
      return !1;
    }
  }
  async sign(e) {
    return await this.requireWallet().signMessage(e);
  }
  async signTypedData(e, r, n) {
    return await sm(this.requireWallet(), e, r, n);
  }
  recoverAddress(e, r) {
    const n = Jb(e),
      i = qe(n);
    return Du(i, r);
  }
  async sendRawTransaction(e) {
    const r = this.requireWallet(),
      n = !!e.gasPrice,
      i = !!e.maxFeePerGas && !!e.maxPriorityFeePerGas;
    if (!(n || i)) {
      const s = await $E(this.connection.getProvider());
      (e.maxFeePerGas = s.maxFeePerGas),
        (e.maxPriorityFeePerGas = s.maxPriorityFeePerGas),
        (e.gasPrice = s.gasPrice);
    }
    return r.sendTransaction(e);
  }
  async executeRawTransaction(e) {
    return {
      receipt: await (await this.sendRawTransaction(e)).wait(),
    };
  }
  async requestFunds(e) {
    const r = await this.getChainId();
    if (r === Ve.Localhost || r === Ve.Hardhat)
      return new Bv(
        new Do(nhe, Es(r, this.options)),
        this.options,
        this.storage
      ).transfer(await this.getAddress(), e);
    throw new Error(`Requesting funds is not supported on chain: '${r}'.`);
  }
  requireWallet() {
    const e = this.connection.getSigner();
    return Je(e), e;
  }
  createErc20(e) {
    return new Gn(
      this.connection.getSignerOrProvider(),
      e,
      Ri,
      this.options,
      this.storage
    );
  }
}
function bhe(t, e) {
  return (
    t ||
    (e != null && e.gatewayUrls
      ? new LS({
          gatewayUrls: e.gatewayUrls,
          clientId: e.clientId,
          secretKey: e.secretKey,
        })
      : new LS({
          clientId: e == null ? void 0 : e.clientId,
          secretKey: e == null ? void 0 : e.secretKey,
        }))
  );
}
class vhe {
  constructor(e, r) {
    oe(
      this,
      "addContract",
      be(async (e) => await this.addContracts.prepare([e]))
    );
    oe(
      this,
      "addContracts",
      be(async (e) => {
        const r = await this.registryRouter.getSignerAddress(),
          n = [],
          i = new Sr(this.registryLogic);
        return (
          e.forEach((a) => {
            n.push(
              i.encode("add", [r, a.address, a.chainId, a.metadataURI || ""])
            );
          }),
          ze.fromContractWrapper({
            contractWrapper: this.registryRouter,
            method: "multicall",
            args: [n],
          })
        );
      })
    );
    oe(
      this,
      "removeContract",
      be(async (e) => await this.removeContracts.prepare([e]))
    );
    oe(
      this,
      "removeContracts",
      be(async (e) => {
        const r = await this.registryRouter.getSignerAddress(),
          n = new Sr(this.registryLogic),
          i = await Promise.all(
            e.map(async (a) =>
              n.encode("remove", [r, await Se(a.address), a.chainId])
            )
          );
        return ze.fromContractWrapper({
          contractWrapper: this.registryRouter,
          method: "multicall",
          args: [i],
        });
      })
    );
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    (this.storage = r),
      (this.registryLogic = new Gn(e, V_(), uF, n, r)),
      (this.registryRouter = new Gn(e, V_(), ehe, n, r));
  }
  async updateSigner(e) {
    this.registryLogic.updateSignerOrProvider(e),
      this.registryRouter.updateSignerOrProvider(e);
  }
  async getContractMetadataURI(e, r) {
    return await this.registryLogic.read("getMetadataUri", [e, await Se(r)]);
  }
  async getContractMetadata(e, r) {
    const n = await this.getContractMetadataURI(e, r);
    if (!n)
      throw new Error(`No metadata URI found for contract ${r} on chain ${e}`);
    return await this.storage.downloadJSON(n);
  }
  async getContractAddresses(e) {
    return (await this.registryLogic.read("getAll", [await Se(e)]))
      .filter(
        (r) =>
          ud(r.deploymentAddress) && r.deploymentAddress.toLowerCase() !== Ft
      )
      .map((r) => ({
        address: r.deploymentAddress,
        chainId: r.chainId.toNumber(),
      }));
  }
}
class xhe extends Ed {
  constructor(e, r, n) {
    super(e, r), (this.storage = n);
  }
  updateSignerOrProvider(e) {
    super.updateSignerOrProvider(e);
  }
  async verifyThirdwebContract(e, r, n) {
    let i =
        arguments.length > 3 && arguments[3] !== void 0
          ? arguments[3]
          : "latest",
      a = arguments.length > 4 ? arguments[4] : void 0;
    const s = (await this.getProvider().getNetwork()).chainId,
      o = await uhe(
        e,
        s,
        r,
        n,
        this.storage,
        i,
        this.options.clientId,
        this.options.secretKey,
        a
      );
    console.info("Checking verification status...");
    const c = await l9(r, n, o);
    console.info(c);
  }
  async verifyContract(e, r, n, i) {
    const a = (await this.getProvider().getNetwork()).chainId;
    let s;
    if (i) {
      const u = Object.values(i).map((m) => (Je(m.type), m.type)),
        d = Object.values(i).map((m) => m.value);
      s = xs.encode(u, d);
    }
    const o = await qL(e, a, r, n, this.storage, s);
    console.info("Checking verification status...");
    const c = await l9(r, n, o);
    console.info(c);
  }
}
class u9 extends Gn {
  constructor(r, n, i, a) {
    super(n, r, the, a, i);
    oe(this, "DEFAULT_VERSION_MAP", {
      [Wc.contractType]: 3,
      [Ff.contractType]: 1,
      [jc.contractType]: 4,
      [Uc.contractType]: 1,
      [Lc.contractType]: 2,
      [Of.contractType]: 1,
      [Lf.contractType]: 2,
      [zc.contractType]: 1,
      [qc.contractType]: 1,
      [Hc.contractType]: 1,
      [$c.contractType]: 2,
      [au.contractType]: 1,
      [Gs.contractType]: 2,
    });
    oe(
      this,
      "deploy",
      be(async (r, n, i, a, s, o) => {
        const c = X0[r],
          u = await c.schema.deploy.parseAsync(n),
          d = await this.storage.upload(u),
          m = (await this.getImplementation(c, a)) || void 0;
        if (!m || m === Ft) throw new Error(`No implementation found for ${r}`);
        const v = await c.getAbi(m, this.getProvider(), this.storage),
          E = this.getSigner();
        Je(E);
        const A = await KL(r, u, d, E, this.storage),
          I = Yt.getInterface(v).encodeFunctionData("initialize", A),
          b = await this.getProvider().getBlockNumber(),
          w =
            s != null && s.saltForProxyDeploy
              ? ui(s.saltForProxyDeploy)
              : xh(b.toString());
        return ze.fromContractWrapper({
          contractWrapper: this,
          method: "deployProxyByImplementation",
          args: [m, I, w],
          parse: (S) => {
            o && o();
            const k = this.parseLogs("ProxyDeployed", S.logs);
            if (k.length < 1) throw new Error("No ProxyDeployed event found");
            const N = k[0].args.proxy;
            return (
              i.emit("contractDeployed", {
                status: "completed",
                contractAddress: N,
                transactionHash: S.transactionHash,
              }),
              N
            );
          },
        });
      })
    );
    oe(
      this,
      "deployProxyByImplementation",
      be(async (r, n, i, a, s, o, c) => {
        const u = Yt.getInterface(n).encodeFunctionData(i, a),
          d = await this.getProvider().getBlockNumber(),
          m = o ? ui(o) : xh(d.toString());
        return ze.fromContractWrapper({
          contractWrapper: this,
          method: "deployProxyByImplementation",
          args: [r, u, m],
          parse: (v) => {
            c && c();
            const E = this.parseLogs("ProxyDeployed", v.logs);
            if (E.length < 1) throw new Error("No ProxyDeployed event found");
            const A = E[0].args.proxy;
            return (
              s.emit("contractDeployed", {
                status: "completed",
                contractAddress: A,
                transactionHash: v.transactionHash,
              }),
              A
            );
          },
        });
      })
    );
    this.storage = i;
  }
  async getDeployArguments(r, n, i) {
    let a =
      r === Gs.contractType ? [] : await this.getDefaultTrustedForwarders();
    switch (
      (n.trusted_forwarders &&
        n.trusted_forwarders.length > 0 &&
        (a = n.trusted_forwarders),
      r)
    ) {
      case Wc.contractType:
      case Ff.contractType:
        const s = await Wc.schema.deploy.parseAsync(n);
        return [
          await this.getSignerAddress(),
          s.name,
          s.symbol,
          i,
          a,
          s.primary_sale_recipient,
          s.fee_recipient,
          s.seller_fee_basis_points,
          s.platform_fee_basis_points,
          s.platform_fee_recipient,
        ];
      case jc.contractType:
        const o = await jc.schema.deploy.parseAsync(n);
        return [
          await this.getSignerAddress(),
          o.name,
          o.symbol,
          i,
          a,
          o.primary_sale_recipient,
          o.fee_recipient,
          o.seller_fee_basis_points,
          o.platform_fee_basis_points,
          o.platform_fee_recipient,
        ];
      case Uc.contractType:
        const c = await Uc.schema.deploy.parseAsync(n);
        return [
          await this.getSignerAddress(),
          c.name,
          c.symbol,
          i,
          a,
          c.fee_recipient,
          c.seller_fee_basis_points,
        ];
      case Lc.contractType:
      case Of.contractType:
        const u = await Lc.schema.deploy.parseAsync(n);
        return [
          await this.getSignerAddress(),
          u.name,
          u.symbol,
          i,
          a,
          u.primary_sale_recipient,
          u.fee_recipient,
          u.seller_fee_basis_points,
          u.platform_fee_basis_points,
          u.platform_fee_recipient,
        ];
      case Lf.contractType:
      case zc.contractType:
        const d = await zc.schema.deploy.parseAsync(n);
        return [
          await this.getSignerAddress(),
          d.name,
          d.symbol,
          i,
          a,
          d.primary_sale_recipient,
          d.platform_fee_recipient,
          d.platform_fee_basis_points,
        ];
      case qc.contractType:
        const m = await qc.schema.deploy.parseAsync(n);
        return [
          m.name,
          i,
          a,
          m.voting_token_address,
          m.voting_delay_in_blocks,
          m.voting_period_in_blocks,
          ae.from(m.proposal_token_threshold),
          m.voting_quorum_fraction,
        ];
      case Hc.contractType:
        const v = await Hc.schema.deploy.parseAsync(n);
        return [
          await this.getSignerAddress(),
          i,
          a,
          v.recipients.map((b) => b.address),
          v.recipients.map((b) => ae.from(b.sharesBps)),
        ];
      case $c.contractType:
        const E = await $c.schema.deploy.parseAsync(n);
        return [
          await this.getSignerAddress(),
          i,
          a,
          E.platform_fee_recipient,
          E.platform_fee_basis_points,
        ];
      case au.contractType:
        const A = await au.schema.deploy.parseAsync(n);
        return [
          await this.getSignerAddress(),
          i,
          a,
          A.platform_fee_recipient,
          A.platform_fee_basis_points,
        ];
      case Gs.contractType:
        const I = await Gs.schema.deploy.parseAsync(n);
        return [
          await this.getSignerAddress(),
          I.name,
          I.symbol,
          i,
          a,
          I.fee_recipient,
          I.seller_fee_basis_points,
        ];
      default:
        return [];
    }
  }
  async getDefaultTrustedForwarders() {
    const r = await this.getChainID();
    return Fl(r);
  }
  async getImplementation(r, n) {
    const i = xh(r.name),
      a = await this.getChainID(),
      s = ihe(a, r.contractType);
    return s && s.length > 0 && n === void 0
      ? s
      : this.read("getImplementation", [
          i,
          n !== void 0 ? n : this.DEFAULT_VERSION_MAP[r.contractType],
        ]);
  }
  async getLatestVersion(r) {
    const n = WL(r);
    if (!n) throw new Error(`Invalid contract type ${r}`);
    const i = xh(n);
    return this.read("currentVersion", [i]);
  }
}
class whe extends Gn {
  constructor(r, n, i, a) {
    super(n, r, rhe, a, i);
    oe(
      this,
      "addContract",
      be(async (r) => await this.addContracts.prepare([r]))
    );
    oe(
      this,
      "addContracts",
      be(async (r) => {
        const n = await this.getSignerAddress(),
          i = new Sr(this),
          a = (await Promise.all(r.map((s) => Se(s)))).map((s) =>
            i.encode("add", [n, s])
          );
        return ze.fromContractWrapper({
          contractWrapper: this,
          method: "multicall",
          args: [a],
        });
      })
    );
    oe(
      this,
      "removeContract",
      be(async (r) => await this.removeContracts.prepare([r]))
    );
    oe(
      this,
      "removeContracts",
      be(async (r) => {
        const n = await this.getSignerAddress(),
          i = new Sr(this),
          a = (await Promise.all(r.map((s) => Se(s)))).map((s) =>
            i.encode("remove", [n, s])
          );
        return ze.fromContractWrapper({
          contractWrapper: this,
          method: "multicall",
          args: [a],
        });
      })
    );
  }
  async getContractAddresses(r) {
    return (await this.read("getAll", [await Se(r)])).filter(
      (n) => ud(n) && n.toLowerCase() !== Ft
    );
  }
}
const _he = Qn.merge(Bn).merge(gn),
  Ehe = _he.merge(Va).merge(vl).merge(Ji),
  The = Qn.merge(gn),
  Q3 = The.merge(Ji);
class Cc extends Ed {
  constructor(r) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
      i = arguments.length > 2 ? arguments[2] : void 0;
    jL(
      "No API key. Please provide a clientId. It is required to access thirdweb's services. You can create a key at https://thirdweb.com/create-api-key",
      n.clientId,
      n.secretKey
    ),
      (n = Y3(r, n));
    super(r, n);
    oe(this, "contractCache", new Map());
    uue(n == null ? void 0 : n.supportedChains);
    const o = bhe(i, n);
    (this.storage = o),
      (this.storageHandler = o),
      (this.wallet = new Bv(r, n, o)),
      (this.deployer = new Che(r, n, o)),
      (this.verifier = new xhe(r, n, o)),
      (this.multiChainRegistry = new vhe(r, this.storageHandler, this.options)),
      (this._publisher = new Xde(r, this.options, this.storageHandler));
  }
  static async fromWallet(r, n) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
      a = arguments.length > 3 ? arguments[3] : void 0;
    const s = await r.getSigner();
    return Cc.fromSigner(s, n, i, a);
  }
  static fromSigner(r, n) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
      a = arguments.length > 3 ? arguments[3] : void 0,
      s = r;
    if (n)
      try {
        const c = Es(n, i);
        s = r.connect(c);
      } catch {}
    const o = new Cc(n || s, n ? Y3(n, i) : i, a);
    return o.updateSignerOrProvider(s), o;
  }
  static fromPrivateKey(r, n) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
      a = arguments.length > 3 ? arguments[3] : void 0;
    const s = Es(n, i),
      o = new Do(r, s);
    return new Cc(o, Y3(n, i), a);
  }
  get auth() {
    throw new Error(`The sdk.auth namespace has been moved to the @thirdweb-dev/auth package and is no longer available after @thirdweb-dev/sdk >= 3.7.0.
      Please visit https://portal.thirdweb.com/auth for instructions on how to switch to using the new auth package (@thirdweb-dev/auth@3.0.0).

      If you still want to use the old @thirdweb-dev/auth@2.0.0 package, you can downgrade the SDK to version 3.6.0.`);
  }
  async getNFTDrop(r) {
    return await this.getContract(r, "nft-drop");
  }
  async getSignatureDrop(r) {
    return await this.getContract(r, "signature-drop");
  }
  async getNFTCollection(r) {
    return await this.getContract(r, "nft-collection");
  }
  async getEditionDrop(r) {
    return await this.getContract(r, "edition-drop");
  }
  async getEdition(r) {
    return await this.getContract(r, "edition");
  }
  async getTokenDrop(r) {
    return await this.getContract(r, "token-drop");
  }
  async getToken(r) {
    return await this.getContract(r, "token");
  }
  async getVote(r) {
    return await this.getContract(r, "vote");
  }
  async getSplit(r) {
    return await this.getContract(r, "split");
  }
  async getMarketplace(r) {
    return await this.getContract(r, "marketplace");
  }
  async getMarketplaceV3(r) {
    return await this.getContract(r, "marketplace-v3");
  }
  async getPack(r) {
    return await this.getContract(r, "pack");
  }
  async getMultiwrap(r) {
    return await this.getContract(r, "multiwrap");
  }
  async getContract(r, n) {
    const i = await Se(r);
    if (this.contractCache.has(i)) return this.contractCache.get(i);
    if (i in i9) return await this.getContractFromAbi(i, i9[i]);
    let a;
    if (!n || n === "custom")
      try {
        const s = await this.getPublisher().fetchCompilerMetadataFromAddress(i);
        a = await this.getContractFromAbi(i, s.abi);
      } catch (s) {
        const o = await this.resolveContractType(i);
        if (o && o !== "custom") {
          const c = await X0[o].getAbi(i, this.getProvider(), this.storage);
          a = await this.getContractFromAbi(i, c);
        } else throw s;
      }
    else
      typeof n == "string" && n in X0
        ? (a = await X0[n].initialize(
            this.getSignerOrProvider(),
            i,
            this.storage,
            this.options
          ))
        : (a = await this.getContractFromAbi(i, n));
    return this.contractCache.set(i, a), a;
  }
  async getBuiltInContract(r, n) {
    return await this.getContract(r, n);
  }
  async resolveContractType(r) {
    try {
      const n = new Yt(await Se(r), lF, this.getProvider()),
        i = go(await n.contractType()).replace(/\x00/g, "");
      return jde(i);
    } catch {
      return "custom";
    }
  }
  async getContractList(r) {
    var a;
    const n =
        (await ((a = await this.deployer.getRegistry()) == null
          ? void 0
          : a.getContractAddresses(await Se(r)))) || [],
      i = (await this.getProvider().getNetwork()).chainId;
    return await Promise.all(
      n.map(async (s) => ({
        address: s,
        chainId: i,
        contractType: () => this.resolveContractType(s),
        metadata: async () => (await this.getContract(s)).metadata.get(),
        extensions: async () => c9((await this.getContract(s)).abi),
      }))
    );
  }
  async getMultichainContractList(r) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : wv;
    const i = await this.multiChainRegistry.getContractAddresses(r),
      a = n.reduce((o, c) => ((o[c.chainId] = c), o), {}),
      s = {};
    return i.map((o) => {
      let { address: c, chainId: u } = o;
      if (!a[u])
        return {
          address: c,
          chainId: u,
          contractType: async () => "custom",
          metadata: async () => ({
            name: "",
          }),
          extensions: async () => [],
        };
      try {
        let d = s[u];
        return (
          d ||
            ((d = new Cc(
              u,
              {
                ...this.options,
                readonlySettings: void 0,
                supportedChains: n,
              },
              this.storage
            )),
            (s[u] = d)),
          {
            address: c,
            chainId: u,
            contractType: () => d.resolveContractType(c),
            metadata: async () => (await d.getContract(c)).metadata.get(),
            extensions: async () => c9((await d.getContract(c)).abi),
          }
        );
      } catch {
        return {
          address: c,
          chainId: u,
          contractType: async () => "custom",
          metadata: async () => ({
            name: "",
          }),
          extensions: async () => [],
        };
      }
    });
  }
  updateSignerOrProvider(r) {
    super.updateSignerOrProvider(r), this.updateContractSignerOrProvider();
  }
  updateContractSignerOrProvider() {
    this.wallet.connect(this.getSignerOrProvider()),
      this.deployer.updateSignerOrProvider(this.getSignerOrProvider()),
      this._publisher.updateSignerOrProvider(this.getSignerOrProvider()),
      this.multiChainRegistry.updateSigner(this.getSignerOrProvider()),
      this.verifier.updateSignerOrProvider(this.getSignerOrProvider());
    for (const [, r] of this.contractCache)
      r.onNetworkUpdated(this.getSignerOrProvider());
  }
  async getContractFromAbi(r, n) {
    const i = await Se(r);
    if (this.contractCache.has(i)) return this.contractCache.get(i);
    const [, a] = Jn(this.getSignerOrProvider(), this.options),
      s = typeof n == "string" ? JSON.parse(n) : n,
      o = new Yde(
        this.getSignerOrProvider(),
        i,
        await Q_(i, Gt.parse(s), a, this.options, this.storage),
        this.storageHandler,
        this.options,
        (await a.getNetwork()).chainId
      );
    return this.contractCache.set(i, o), o;
  }
  async getBalance(r) {
    return hs(
      this.getProvider(),
      qi,
      await this.getProvider().getBalance(await Se(r))
    );
  }
  getPublisher() {
    return this._publisher;
  }
}
function Y3(t, e) {
  return (
    kE(t) &&
      (e = {
        ...e,
        supportedChains: [
          ...((e == null ? void 0 : e.supportedChains) || []),
          t,
        ],
      }),
    e
  );
}
const sc = "0xdd99b75f095d0c4d5112aCe938e4e6ed962fb024";
class Che extends Ed {
  constructor(r, n, i) {
    super(r, n);
    oe(this, "transactionListener", (r) => {
      r.status === "submitted" &&
        this.events.emit("contractDeployed", {
          status: "submitted",
          transactionHash: r.transactionHash,
        });
    });
    oe(
      this,
      "deployNFTCollection",
      Tr(
        async (r, n) =>
          await this.deployBuiltInContract.prepare(
            Ff.contractType,
            r,
            "latest",
            n
          )
      )
    );
    oe(
      this,
      "deployNFTDrop",
      Tr(
        async (r, n) =>
          await this.deployBuiltInContract.prepare(
            Wc.contractType,
            r,
            "latest",
            n
          )
      )
    );
    oe(
      this,
      "deployLoyaltyCard",
      Tr(async (r, n) => {
        var d;
        const i = await Ehe.parseAsync(r),
          a = await this.storage.upload(i),
          s = (await this.getProvider().getNetwork()).chainId,
          o = Fl(s);
        r.trusted_forwarders &&
          r.trusted_forwarders.length > 0 &&
          o.push(...r.trusted_forwarders);
        const u = [
          await ((d = this.getSigner()) == null ? void 0 : d.getAddress()),
          i.name,
          i.symbol,
          a,
          o,
          i.primary_sale_recipient,
          i.fee_recipient,
          i.seller_fee_basis_points,
          i.platform_fee_basis_points,
          i.platform_fee_recipient,
        ];
        return await this.deployReleasedContract.prepare(
          sc,
          "LoyaltyCard",
          u,
          n
        );
      })
    );
    oe(
      this,
      "deployOpenEdition",
      Tr(async (r, n) => {
        var d;
        const i = await WE.deploy.parseAsync(r),
          a = await this.storage.upload(i),
          s = (await this.getProvider().getNetwork()).chainId,
          o = Fl(s);
        r.trusted_forwarders &&
          r.trusted_forwarders.length > 0 &&
          o.push(...r.trusted_forwarders);
        const u = [
          await ((d = this.getSigner()) == null ? void 0 : d.getAddress()),
          i.name,
          i.symbol,
          a,
          o,
          i.primary_sale_recipient,
          i.fee_recipient,
          i.seller_fee_basis_points,
        ];
        return await this.deployPublishedContract.prepare(
          sc,
          "OpenEditionERC721",
          u,
          n
        );
      })
    );
    oe(
      this,
      "deploySignatureDrop",
      Tr(
        async (r, n) =>
          await this.deployBuiltInContract.prepare(
            jc.contractType,
            r,
            "latest",
            n
          )
      )
    );
    oe(
      this,
      "deployMultiwrap",
      Tr(
        async (r, n) =>
          await this.deployBuiltInContract.prepare(
            Uc.contractType,
            r,
            "latest",
            n
          )
      )
    );
    oe(
      this,
      "deployEdition",
      Tr(
        async (r, n) =>
          await this.deployBuiltInContract.prepare(
            Of.contractType,
            r,
            "latest",
            n
          )
      )
    );
    oe(
      this,
      "deployEditionDrop",
      Tr(
        async (r, n) =>
          await this.deployBuiltInContract.prepare(
            Lc.contractType,
            r,
            "latest",
            n
          )
      )
    );
    oe(
      this,
      "deployToken",
      Tr(
        async (r, n) =>
          await this.deployBuiltInContract.prepare(
            zc.contractType,
            r,
            "latest",
            n
          )
      )
    );
    oe(
      this,
      "deployTokenDrop",
      Tr(
        async (r, n) =>
          await this.deployBuiltInContract.prepare(
            Lf.contractType,
            r,
            "latest",
            n
          )
      )
    );
    oe(
      this,
      "deployMarketplace",
      Tr(
        async (r, n) =>
          await this.deployBuiltInContract.prepare(
            $c.contractType,
            r,
            "latest",
            n
          )
      )
    );
    oe(
      this,
      "deployMarketplaceV3",
      Tr(
        async (r, n) =>
          await this.deployBuiltInContract.prepare(
            au.contractType,
            r,
            "latest",
            n
          )
      )
    );
    oe(
      this,
      "deployPack",
      Tr(
        async (r, n) =>
          await this.deployBuiltInContract.prepare(
            Gs.contractType,
            r,
            "latest",
            n
          )
      )
    );
    oe(
      this,
      "deploySplit",
      Tr(
        async (r, n) =>
          await this.deployBuiltInContract.prepare(
            Hc.contractType,
            r,
            "latest",
            n
          )
      )
    );
    oe(
      this,
      "deployVote",
      Tr(
        async (r, n) =>
          await this.deployBuiltInContract.prepare(
            qc.contractType,
            r,
            "latest",
            n
          )
      )
    );
    oe(
      this,
      "deployAirdropERC20",
      Tr(async (r, n) => {
        var d;
        const i = await Q3.parseAsync(r),
          a = await this.storage.upload(i),
          s = (await this.getProvider().getNetwork()).chainId,
          o = Fl(s);
        r.trusted_forwarders &&
          r.trusted_forwarders.length > 0 &&
          o.push(...r.trusted_forwarders);
        const u = [
          await ((d = this.getSigner()) == null ? void 0 : d.getAddress()),
          a,
          o,
        ];
        return await this.deployReleasedContract.prepare(
          sc,
          "AirdropERC20",
          u,
          n
        );
      })
    );
    oe(
      this,
      "deployAirdropERC721",
      Tr(async (r, n) => {
        var d;
        const i = await Q3.parseAsync(r),
          a = await this.storage.upload(i),
          s = (await this.getProvider().getNetwork()).chainId,
          o = Fl(s);
        r.trusted_forwarders &&
          r.trusted_forwarders.length > 0 &&
          o.push(...r.trusted_forwarders);
        const u = [
          await ((d = this.getSigner()) == null ? void 0 : d.getAddress()),
          a,
          o,
        ];
        return await this.deployReleasedContract.prepare(
          sc,
          "AirdropERC721",
          u,
          n
        );
      })
    );
    oe(
      this,
      "deployAirdropERC1155",
      Tr(async (r, n) => {
        var d;
        const i = await Q3.parseAsync(r),
          a = await this.storage.upload(i),
          s = (await this.getProvider().getNetwork()).chainId,
          o = Fl(s);
        r.trusted_forwarders &&
          r.trusted_forwarders.length > 0 &&
          o.push(...r.trusted_forwarders);
        const u = [
          await ((d = this.getSigner()) == null ? void 0 : d.getAddress()),
          a,
          o,
        ];
        return await this.deployReleasedContract.prepare(
          sc,
          "AirdropERC1155",
          u,
          n
        );
      })
    );
    oe(
      this,
      "deployBuiltInContract",
      Tr(
        (() => {
          var r = this;
          return async function (n, i) {
            let a =
                arguments.length > 2 && arguments[2] !== void 0
                  ? arguments[2]
                  : "latest",
              s = arguments.length > 3 ? arguments[3] : void 0;
            const o = r.getSigner();
            Je(o);
            const c = {
              app_uri: Wde[n],
              ...(await X0[n].schema.deploy.parseAsync(i)),
            };
            if (r.hasLocalFactory()) {
              let E;
              try {
                (E = parseInt(a)), isNaN(E) && (E = void 0);
              } catch {
                E = void 0;
              }
              const A = await r.getFactory();
              if (!A) throw new Error("Factory not found");
              return (
                A.on(ia.Transaction, r.transactionListener),
                A.deploy.prepare(n, c, r.events, E, s, () => {
                  A.off(ia.Transaction, r.transactionListener);
                })
              );
            }
            const u = WL(n);
            Je(u);
            const d = await r.storage.upload(c),
              m = await KL(n, c, d, o, r.storage),
              v = await r.fetchPublishedContractFromPolygon(sc, u, a);
            return r.deployContractFromUri.prepare(v.metadataUri, m, s);
          };
        })()
      )
    );
    oe(
      this,
      "deployReleasedContract",
      Tr(
        (() => {
          var r = this;
          return async function (n, i, a) {
            let s =
                arguments.length > 3 && arguments[3] !== void 0
                  ? arguments[3]
                  : "latest",
              o = arguments.length > 4 ? arguments[4] : void 0;
            const c = await r.fetchPublishedContractFromPolygon(n, i, s);
            return await r.deployContractFromUri.prepare(c.metadataUri, a, o);
          };
        })()
      )
    );
    oe(this, "deployPublishedContract", this.deployReleasedContract);
    oe(
      this,
      "deployViaFactory",
      be(async (r, n, i, a, s, o) => {
        const c = await Se(r),
          u = await Se(n),
          d = this.getSigner();
        Je(d);
        const m = new u9(
          c,
          this.getSignerOrProvider(),
          this.storage,
          this.options
        );
        return (
          m.on(ia.Transaction, this.transactionListener),
          await m.deployProxyByImplementation.prepare(
            u,
            i,
            a,
            s,
            this.events,
            o,
            () => {
              m.off(ia.Transaction, this.transactionListener);
            }
          )
        );
      })
    );
    oe(
      this,
      "deployProxy",
      Tr(async (r, n, i, a) => {
        const s = await Se(r),
          o = Yt.getInterface(n).encodeFunctionData(i, a),
          { TWProxy__factory: c } = await Zt(async () => {
            const { TWProxy__factory: u } = await import(
              "./thirdweb-dev-contracts-js-factories-TWProxy__factory.browser.esm-BLTNxkfq.js"
            );
            return {
              TWProxy__factory: u,
            };
          }, []);
        return this.deployContractWithAbi.prepare(c.abi, c.bytecode, [s, o]);
      })
    );
    oe(
      this,
      "deployViaAutoFactory",
      Tr(async (r, n, i, a, s, o) => {
        var w, S, k;
        const c = await VL(i, o),
          u = await om(
            r,
            this.storage,
            this.getProvider(),
            c,
            this.options.clientId,
            this.options.secretKey
          ),
          d =
            (w = u.find((N) => N.type === "implementation")) == null
              ? void 0
              : w.transaction.predictedAddress,
          m = u.filter(
            (N) => N.transaction.data && N.transaction.data.length > 0
          ),
          v = m.filter((N) => N.type !== "infra").map((N) => N.transaction),
          E = m.filter((N) => N.type === "infra").map((N) => N.transaction);
        await OL(i, E, o);
        for (const N of v)
          try {
            await BL(i, N, o);
          } catch (O) {
            console.debug(
              `Error deploying contract at ${N.predictedAddress}`,
              O == null ? void 0 : O.message
            );
          }
        const A = await Se(d),
          I = await hhe(
            this.getProvider(),
            this.storage,
            c,
            this.options.clientId,
            this.options.secretKey
          );
        (S = o == null ? void 0 : o.notifier) == null ||
          S.call(o, "deploying", "proxy");
        const b = await this.deployViaFactory.prepare(
          I,
          A,
          n.compilerMetadata.abi,
          a,
          s,
          o == null ? void 0 : o.saltForProxyDeploy
        );
        return (
          (k = o == null ? void 0 : o.notifier) == null ||
            k.call(o, "deployed", "proxy"),
          b
        );
      })
    );
    oe(
      this,
      "deployViaCustomFactory",
      Tr(async (r, n, i, a) => {
        var E, A, I, b, w, S;
        const s =
            (I =
              (A =
                (E = n.extendedMetadata) == null
                  ? void 0
                  : E.factoryDeploymentData) == null
                ? void 0
                : A.customFactoryInput) == null
              ? void 0
              : I.customFactoryAddresses[a],
          o = await Se(s);
        Je(o),
          Je(
            (S =
              (w =
                (b = n.extendedMetadata) == null
                  ? void 0
                  : b.factoryDeploymentData) == null
                ? void 0
                : w.customFactoryInput) == null
              ? void 0
              : S.factoryFunction
          );
        const c = await Ai(o, this.getProvider(), this.storage, this.options),
          u = o9(
            c.abi,
            n.extendedMetadata.factoryDeploymentData.customFactoryInput
              .factoryFunction
          ).map((k) => k.type),
          d = qh(u, r);
        let m;
        const v = await ze.fromContractInfo({
          contractAddress: o,
          contractAbi: c.abi,
          provider: this.getProvider(),
          signer: i,
          method:
            n.extendedMetadata.factoryDeploymentData.customFactoryInput
              .factoryFunction,
          args: d,
          parse: () => m,
          storage: this.storage,
        });
        return (m = await v.simulate()), v;
      })
    );
    oe(
      this,
      "deployContractFromUri",
      Tr(async (r, n, i) => {
        var A, I;
        const a = this.getSigner();
        Je(a);
        const { compilerMetadata: s, extendedMetadata: o } = await Vi(
            r,
            this.storage
          ),
          c = (i == null ? void 0 : i.forceDirectDeploy) || !1,
          u = (await this.getProvider().getNetwork()).chainId,
          d =
            ((A = o == null ? void 0 : o.networksForDeployment) == null
              ? void 0
              : A.networksEnabled.includes(u)) ||
            ((I = o == null ? void 0 : o.networksForDeployment) == null
              ? void 0
              : I.allNetworks);
        if (o != null && o.networksForDeployment && !d)
          throw new Error(
            `Deployments disabled on this network, with chainId: ${u}`
          );
        if (
          o &&
          o.factoryDeploymentData &&
          (o.isDeployableViaProxy ||
            o.isDeployableViaFactory ||
            (o.deployType && o.deployType !== "standard")) &&
          !c
        ) {
          if (o.deployType === "customFactory")
            return await this.deployViaCustomFactory.prepare(
              n,
              {
                compilerMetadata: s,
                extendedMetadata: o,
              },
              a,
              u
            );
          {
            Je(o.factoryDeploymentData.implementationInitializerFunction);
            const b = o9(
                s.abi,
                o.factoryDeploymentData.implementationInitializerFunction
              ).map((N) => N.type),
              w = qh(b, n),
              S = o.factoryDeploymentData.implementationAddresses[u];
            if (!S || o.deployType === "autoFactory")
              return await this.deployViaAutoFactory.prepare(
                r,
                {
                  compilerMetadata: s,
                  extendedMetadata: o,
                },
                a,
                o.factoryDeploymentData.implementationInitializerFunction,
                w,
                i
              );
            const k = await Se(S);
            if ((Je(k), o.isDeployableViaFactory)) {
              Je(o.factoryDeploymentData.factoryAddresses);
              const N = o.factoryDeploymentData.factoryAddresses[u];
              Je(N);
              const O = await Se(N);
              return await this.deployViaFactory.prepare(
                O,
                k,
                s.abi,
                o.factoryDeploymentData.implementationInitializerFunction,
                w,
                i == null ? void 0 : i.saltForProxyDeploy
              );
            } else if (o.isDeployableViaProxy)
              return await this.deployProxy.prepare(
                k,
                s.abi,
                o.factoryDeploymentData.implementationInitializerFunction,
                w
              );
          }
        }
        const m = s.bytecode.startsWith("0x") ? s.bytecode : `0x${s.bytecode}`;
        if (!gt(m))
          throw new Error(`Contract bytecode is invalid.

${m}`);
        const v = _d(s.abi).map((b) => b.type),
          E = qh(v, n);
        return this.deployContractWithAbi.prepare(s.abi, m, E);
      })
    );
    oe(
      this,
      "deployContractWithAbi",
      Tr(async (r, n, i) => {
        const a = this.getSigner(),
          s = this.getProvider();
        Je(a);
        const o = new CD(r, n).connect(a);
        return new gfe({
          args: i,
          provider: s,
          signer: a,
          factory: o,
          storage: this.storage,
          events: this.events,
        });
      })
    );
    (this.storage = i),
      (this.events = new Mf()),
      this.getFactory(),
      this.getRegistry();
  }
  async getLatestBuiltInContractVersion(r) {
    const n = await this.getFactory();
    if (!n) throw new Error("Factory not found");
    return await n.getLatestVersion(r);
  }
  async deployPublishedContractDeterministic(r, n) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : sc,
      a =
        arguments.length > 3 && arguments[3] !== void 0
          ? arguments[3]
          : "latest",
      s = arguments.length > 4 ? arguments[4] : void 0;
    const o = this.getSigner();
    return (
      Je(o),
      mhe(
        r,
        i,
        a,
        n,
        o,
        this.storage,
        this.options.clientId,
        this.options.secretKey,
        s
      )
    );
  }
  async predictAddressDeterministic(r, n) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : sc,
      a =
        arguments.length > 3 && arguments[3] !== void 0
          ? arguments[3]
          : "latest",
      s = arguments.length > 4 ? arguments[4] : void 0;
    const o = this.getProvider();
    return (
      Je(o),
      ghe(
        r,
        i,
        a,
        n,
        o,
        this.storage,
        this.options.clientId,
        this.options.secretKey,
        s
      )
    );
  }
  async getRegistry() {
    return this._registry
      ? this._registry
      : (this._registry = this.getProvider()
          .getNetwork()
          .then(async (r) => {
            let { chainId: n } = r;
            const i = Q2(n, "twRegistry");
            if (i)
              return new whe(
                i,
                this.getSignerOrProvider(),
                this.storage,
                this.options
              );
          }));
  }
  async getFactory() {
    return this._factory
      ? this._factory
      : (this._factory = this.getProvider()
          .getNetwork()
          .then(async (r) => {
            let { chainId: n } = r;
            const i = Q2(n, "twFactory");
            return i
              ? new u9(
                  i,
                  this.getSignerOrProvider(),
                  this.storage,
                  this.options
                )
              : void 0;
          }));
  }
  updateSignerOrProvider(r) {
    super.updateSignerOrProvider(r), this.updateContractSignerOrProvider();
  }
  updateContractSignerOrProvider() {
    var r, n;
    (r = this._factory) == null ||
      r
        .then((i) => {
          i == null || i.updateSignerOrProvider(this.getSignerOrProvider());
        })
        .catch(() => {}),
      (n = this._registry) == null ||
        n
          .then((i) => {
            i == null || i.updateSignerOrProvider(this.getSignerOrProvider());
          })
          .catch(() => {});
  }
  async getTransactionsForDeploy(r, n) {
    let i = [];
    const a = this.getProvider();
    Je(a);
    const { extendedMetadata: s } = await Vi(r, this.storage),
      o = (n == null ? void 0 : n.forceDirectDeploy) || !1;
    if (
      s &&
      s.factoryDeploymentData &&
      (s.isDeployableViaProxy ||
        s.isDeployableViaFactory ||
        s.deployType === "autoFactory") &&
      !o
    ) {
      const c = (await this.getProvider().getNetwork()).chainId;
      if (
        !s.factoryDeploymentData.implementationAddresses[c] ||
        s.deployType === "autoFactory"
      ) {
        const d = await xl(this.getProvider());
        i.push({
          contractType: "create2Factory",
          addresses: [d],
        });
        const v = (
          await om(
            r,
            this.storage,
            this.getProvider(),
            d,
            this.options.clientId,
            this.options.secretKey
          )
        ).filter((b) => b.transaction.data && b.transaction.data.length > 0);
        v.filter((b) => b.type !== "infra")
          .map((b) => b.transaction)
          .forEach((b) => {
            i.push({
              contractType: "preset",
              addresses: [b.predictedAddress],
            });
          });
        const A = v.filter((b) => b.type === "infra").map((b) => b.transaction);
        DL(A).forEach((b) => {
          const w = b.map((S) => S.predictedAddress);
          i.push({
            contractType: "infra",
            addresses: w,
          });
        });
      }
      (i = (
        await Promise.all(
          i.map(async (d) =>
            (
              await Promise.all(
                d.addresses.map(async (v) => ((await ho(v, a)) ? null : v))
              )
            ).filter(Boolean).length > 0
              ? d
              : null
          )
        )
      ).filter(Boolean)),
        i.push({
          contractType: "proxy",
          addresses: [],
        });
    } else
      i.push({
        contractType: "custom",
        addresses: [],
      });
    return i;
  }
  addDeployListener(r) {
    this.events.on("contractDeployed", r);
  }
  removeDeployListener(r) {
    this.events.off("contractDeployed", r);
  }
  removeAllDeployListeners() {
    this.events.removeAllListeners("contractDeployed");
  }
  async fetchPublishedContractFromPolygon(r, n, i) {
    const a = await Se(r),
      s = await new Cc(
        "polygon",
        {
          clientId: this.options.clientId,
          secretKey: this.options.secretKey,
        },
        this.storage
      )
        .getPublisher()
        .getVersion(a, n, i);
    if (!s)
      throw new Error(
        `No published contract found for '${n}' at version '${i}' by '${a}'`
      );
    return s;
  }
  hasLocalFactory() {
    return !!im("factoryAddress");
  }
}
var GE = {
    exports: {},
  },
  ef = typeof Reflect == "object" ? Reflect : null,
  f9 =
    ef && typeof ef.apply == "function"
      ? ef.apply
      : function (e, r, n) {
          return Function.prototype.apply.call(e, r, n);
        },
  eg;
ef && typeof ef.ownKeys == "function"
  ? (eg = ef.ownKeys)
  : Object.getOwnPropertySymbols
  ? (eg = function (e) {
      return Object.getOwnPropertyNames(e).concat(
        Object.getOwnPropertySymbols(e)
      );
    })
  : (eg = function (e) {
      return Object.getOwnPropertyNames(e);
    });
function Ahe(t) {
  console && console.warn && console.warn(t);
}
var GL =
  Number.isNaN ||
  function (e) {
    return e !== e;
  };
function lr() {
  lr.init.call(this);
}
GE.exports = lr;
GE.exports.once = Ihe;
lr.EventEmitter = lr;
lr.prototype._events = void 0;
lr.prototype._eventsCount = 0;
lr.prototype._maxListeners = void 0;
var d9 = 10;
function Dv(t) {
  if (typeof t != "function")
    throw new TypeError(
      'The "listener" argument must be of type Function. Received type ' +
        typeof t
    );
}
Object.defineProperty(lr, "defaultMaxListeners", {
  enumerable: !0,
  get: function () {
    return d9;
  },
  set: function (t) {
    if (typeof t != "number" || t < 0 || GL(t))
      throw new RangeError(
        'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
          t +
          "."
      );
    d9 = t;
  },
});
lr.init = function () {
  (this._events === void 0 ||
    this._events === Object.getPrototypeOf(this)._events) &&
    ((this._events = Object.create(null)), (this._eventsCount = 0)),
    (this._maxListeners = this._maxListeners || void 0);
};
lr.prototype.setMaxListeners = function (e) {
  if (typeof e != "number" || e < 0 || GL(e))
    throw new RangeError(
      'The value of "n" is out of range. It must be a non-negative number. Received ' +
        e +
        "."
    );
  return (this._maxListeners = e), this;
};
function ZL(t) {
  return t._maxListeners === void 0 ? lr.defaultMaxListeners : t._maxListeners;
}
lr.prototype.getMaxListeners = function () {
  return ZL(this);
};
lr.prototype.emit = function (e) {
  for (var r = [], n = 1; n < arguments.length; n++) r.push(arguments[n]);
  var i = e === "error",
    a = this._events;
  if (a !== void 0) i = i && a.error === void 0;
  else if (!i) return !1;
  if (i) {
    var s;
    if ((r.length > 0 && (s = r[0]), s instanceof Error)) throw s;
    var o = new Error("Unhandled error." + (s ? " (" + s.message + ")" : ""));
    throw ((o.context = s), o);
  }
  var c = a[e];
  if (c === void 0) return !1;
  if (typeof c == "function") f9(c, this, r);
  else
    for (var u = c.length, d = e$(c, u), n = 0; n < u; ++n) f9(d[n], this, r);
  return !0;
};
function JL(t, e, r, n) {
  var i, a, s;
  if (
    (Dv(r),
    (a = t._events),
    a === void 0
      ? ((a = t._events = Object.create(null)), (t._eventsCount = 0))
      : (a.newListener !== void 0 &&
          (t.emit("newListener", e, r.listener ? r.listener : r),
          (a = t._events)),
        (s = a[e])),
    s === void 0)
  )
    (s = a[e] = r), ++t._eventsCount;
  else if (
    (typeof s == "function"
      ? (s = a[e] = n ? [r, s] : [s, r])
      : n
      ? s.unshift(r)
      : s.push(r),
    (i = ZL(t)),
    i > 0 && s.length > i && !s.warned)
  ) {
    s.warned = !0;
    var o = new Error(
      "Possible EventEmitter memory leak detected. " +
        s.length +
        " " +
        String(e) +
        " listeners added. Use emitter.setMaxListeners() to increase limit"
    );
    (o.name = "MaxListenersExceededWarning"),
      (o.emitter = t),
      (o.type = e),
      (o.count = s.length),
      Ahe(o);
  }
  return t;
}
lr.prototype.addListener = function (e, r) {
  return JL(this, e, r, !1);
};
lr.prototype.on = lr.prototype.addListener;
lr.prototype.prependListener = function (e, r) {
  return JL(this, e, r, !0);
};
function khe() {
  if (!this.fired)
    return (
      this.target.removeListener(this.type, this.wrapFn),
      (this.fired = !0),
      arguments.length === 0
        ? this.listener.call(this.target)
        : this.listener.apply(this.target, arguments)
    );
}
function QL(t, e, r) {
  var n = {
      fired: !1,
      wrapFn: void 0,
      target: t,
      type: e,
      listener: r,
    },
    i = khe.bind(n);
  return (i.listener = r), (n.wrapFn = i), i;
}
lr.prototype.once = function (e, r) {
  return Dv(r), this.on(e, QL(this, e, r)), this;
};
lr.prototype.prependOnceListener = function (e, r) {
  return Dv(r), this.prependListener(e, QL(this, e, r)), this;
};
lr.prototype.removeListener = function (e, r) {
  var n, i, a, s, o;
  if ((Dv(r), (i = this._events), i === void 0)) return this;
  if (((n = i[e]), n === void 0)) return this;
  if (n === r || n.listener === r)
    --this._eventsCount === 0
      ? (this._events = Object.create(null))
      : (delete i[e],
        i.removeListener && this.emit("removeListener", e, n.listener || r));
  else if (typeof n != "function") {
    for (a = -1, s = n.length - 1; s >= 0; s--)
      if (n[s] === r || n[s].listener === r) {
        (o = n[s].listener), (a = s);
        break;
      }
    if (a < 0) return this;
    a === 0 ? n.shift() : She(n, a),
      n.length === 1 && (i[e] = n[0]),
      i.removeListener !== void 0 && this.emit("removeListener", e, o || r);
  }
  return this;
};
lr.prototype.off = lr.prototype.removeListener;
lr.prototype.removeAllListeners = function (e) {
  var r, n, i;
  if (((n = this._events), n === void 0)) return this;
  if (n.removeListener === void 0)
    return (
      arguments.length === 0
        ? ((this._events = Object.create(null)), (this._eventsCount = 0))
        : n[e] !== void 0 &&
          (--this._eventsCount === 0
            ? (this._events = Object.create(null))
            : delete n[e]),
      this
    );
  if (arguments.length === 0) {
    var a = Object.keys(n),
      s;
    for (i = 0; i < a.length; ++i)
      (s = a[i]), s !== "removeListener" && this.removeAllListeners(s);
    return (
      this.removeAllListeners("removeListener"),
      (this._events = Object.create(null)),
      (this._eventsCount = 0),
      this
    );
  }
  if (((r = n[e]), typeof r == "function")) this.removeListener(e, r);
  else if (r !== void 0)
    for (i = r.length - 1; i >= 0; i--) this.removeListener(e, r[i]);
  return this;
};
function YL(t, e, r) {
  var n = t._events;
  if (n === void 0) return [];
  var i = n[e];
  return i === void 0
    ? []
    : typeof i == "function"
    ? r
      ? [i.listener || i]
      : [i]
    : r
    ? Mhe(i)
    : e$(i, i.length);
}
lr.prototype.listeners = function (e) {
  return YL(this, e, !0);
};
lr.prototype.rawListeners = function (e) {
  return YL(this, e, !1);
};
lr.listenerCount = function (t, e) {
  return typeof t.listenerCount == "function"
    ? t.listenerCount(e)
    : XL.call(t, e);
};
lr.prototype.listenerCount = XL;
function XL(t) {
  var e = this._events;
  if (e !== void 0) {
    var r = e[t];
    if (typeof r == "function") return 1;
    if (r !== void 0) return r.length;
  }
  return 0;
}
lr.prototype.eventNames = function () {
  return this._eventsCount > 0 ? eg(this._events) : [];
};
function e$(t, e) {
  for (var r = new Array(e), n = 0; n < e; ++n) r[n] = t[n];
  return r;
}
function She(t, e) {
  for (; e + 1 < t.length; e++) t[e] = t[e + 1];
  t.pop();
}
function Mhe(t) {
  for (var e = new Array(t.length), r = 0; r < e.length; ++r)
    e[r] = t[r].listener || t[r];
  return e;
}
function Ihe(t, e) {
  return new Promise(function (r, n) {
    function i(s) {
      t.removeListener(e, a), n(s);
    }
    function a() {
      typeof t.removeListener == "function" && t.removeListener("error", i),
        r([].slice.call(arguments));
    }
    t$(t, e, a, {
      once: !0,
    }),
      e !== "error" &&
        Rhe(t, i, {
          once: !0,
        });
  });
}
function Rhe(t, e, r) {
  typeof t.on == "function" && t$(t, "error", e, r);
}
function t$(t, e, r, n) {
  if (typeof t.on == "function") n.once ? t.once(e, r) : t.on(e, r);
  else if (typeof t.addEventListener == "function")
    t.addEventListener(e, function i(a) {
      n.once && t.removeEventListener(e, i), r(a);
    });
  else
    throw new TypeError(
      'The "emitter" argument must be of type EventEmitter. Received type ' +
        typeof t
    );
}
var Cd = GE.exports;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var X_ = function (t, e) {
  return (
    (X_ =
      Object.setPrototypeOf ||
      ({
        __proto__: [],
      } instanceof Array &&
        function (r, n) {
          r.__proto__ = n;
        }) ||
      function (r, n) {
        for (var i in n) n.hasOwnProperty(i) && (r[i] = n[i]);
      }),
    X_(t, e)
  );
};
function Phe(t, e) {
  X_(t, e);
  function r() {
    this.constructor = t;
  }
  t.prototype =
    e === null ? Object.create(e) : ((r.prototype = e.prototype), new r());
}
var e4 = function () {
  return (
    (e4 =
      Object.assign ||
      function (e) {
        for (var r, n = 1, i = arguments.length; n < i; n++) {
          r = arguments[n];
          for (var a in r)
            Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
        }
        return e;
      }),
    e4.apply(this, arguments)
  );
};
function Nhe(t, e) {
  var r = {};
  for (var n in t)
    Object.prototype.hasOwnProperty.call(t, n) &&
      e.indexOf(n) < 0 &&
      (r[n] = t[n]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(t); i < n.length; i++)
      e.indexOf(n[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, n[i]) &&
        (r[n[i]] = t[n[i]]);
  return r;
}
function Bhe(t, e, r, n) {
  var i = arguments.length,
    a =
      i < 3 ? e : n === null ? (n = Object.getOwnPropertyDescriptor(e, r)) : n,
    s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    a = Reflect.decorate(t, e, r, n);
  else
    for (var o = t.length - 1; o >= 0; o--)
      (s = t[o]) && (a = (i < 3 ? s(a) : i > 3 ? s(e, r, a) : s(e, r)) || a);
  return i > 3 && a && Object.defineProperty(e, r, a), a;
}
function Dhe(t, e) {
  return function (r, n) {
    e(r, n, t);
  };
}
function Ohe(t, e) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata(t, e);
}
function Fhe(t, e, r, n) {
  function i(a) {
    return a instanceof r
      ? a
      : new r(function (s) {
          s(a);
        });
  }
  return new (r || (r = Promise))(function (a, s) {
    function o(d) {
      try {
        u(n.next(d));
      } catch (m) {
        s(m);
      }
    }
    function c(d) {
      try {
        u(n.throw(d));
      } catch (m) {
        s(m);
      }
    }
    function u(d) {
      d.done ? a(d.value) : i(d.value).then(o, c);
    }
    u((n = n.apply(t, e || [])).next());
  });
}
function Lhe(t, e) {
  var r = {
      label: 0,
      sent: function () {
        if (a[0] & 1) throw a[1];
        return a[1];
      },
      trys: [],
      ops: [],
    },
    n,
    i,
    a,
    s;
  return (
    (s = {
      next: o(0),
      throw: o(1),
      return: o(2),
    }),
    typeof Symbol == "function" &&
      (s[Symbol.iterator] = function () {
        return this;
      }),
    s
  );
  function o(u) {
    return function (d) {
      return c([u, d]);
    };
  }
  function c(u) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; r; )
      try {
        if (
          ((n = 1),
          i &&
            (a =
              u[0] & 2
                ? i.return
                : u[0]
                ? i.throw || ((a = i.return) && a.call(i), 0)
                : i.next) &&
            !(a = a.call(i, u[1])).done)
        )
          return a;
        switch (((i = 0), a && (u = [u[0] & 2, a.value]), u[0])) {
          case 0:
          case 1:
            a = u;
            break;
          case 4:
            return (
              r.label++,
              {
                value: u[1],
                done: !1,
              }
            );
          case 5:
            r.label++, (i = u[1]), (u = [0]);
            continue;
          case 7:
            (u = r.ops.pop()), r.trys.pop();
            continue;
          default:
            if (
              ((a = r.trys),
              !(a = a.length > 0 && a[a.length - 1]) &&
                (u[0] === 6 || u[0] === 2))
            ) {
              r = 0;
              continue;
            }
            if (u[0] === 3 && (!a || (u[1] > a[0] && u[1] < a[3]))) {
              r.label = u[1];
              break;
            }
            if (u[0] === 6 && r.label < a[1]) {
              (r.label = a[1]), (a = u);
              break;
            }
            if (a && r.label < a[2]) {
              (r.label = a[2]), r.ops.push(u);
              break;
            }
            a[2] && r.ops.pop(), r.trys.pop();
            continue;
        }
        u = e.call(t, r);
      } catch (d) {
        (u = [6, d]), (i = 0);
      } finally {
        n = a = 0;
      }
    if (u[0] & 5) throw u[1];
    return {
      value: u[0] ? u[1] : void 0,
      done: !0,
    };
  }
}
function $he(t, e, r, n) {
  n === void 0 && (n = r), (t[n] = e[r]);
}
function Uhe(t, e) {
  for (var r in t) r !== "default" && !e.hasOwnProperty(r) && (e[r] = t[r]);
}
function t4(t) {
  var e = typeof Symbol == "function" && Symbol.iterator,
    r = e && t[e],
    n = 0;
  if (r) return r.call(t);
  if (t && typeof t.length == "number")
    return {
      next: function () {
        return (
          t && n >= t.length && (t = void 0),
          {
            value: t && t[n++],
            done: !t,
          }
        );
      },
    };
  throw new TypeError(
    e ? "Object is not iterable." : "Symbol.iterator is not defined."
  );
}
function r$(t, e) {
  var r = typeof Symbol == "function" && t[Symbol.iterator];
  if (!r) return t;
  var n = r.call(t),
    i,
    a = [],
    s;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; ) a.push(i.value);
  } catch (o) {
    s = {
      error: o,
    };
  } finally {
    try {
      i && !i.done && (r = n.return) && r.call(n);
    } finally {
      if (s) throw s.error;
    }
  }
  return a;
}
function Whe() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t = t.concat(r$(arguments[e]));
  return t;
}
function jhe() {
  for (var t = 0, e = 0, r = arguments.length; e < r; e++)
    t += arguments[e].length;
  for (var n = Array(t), i = 0, e = 0; e < r; e++)
    for (var a = arguments[e], s = 0, o = a.length; s < o; s++, i++)
      n[i] = a[s];
  return n;
}
function cm(t) {
  return this instanceof cm ? ((this.v = t), this) : new cm(t);
}
function Hhe(t, e, r) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var n = r.apply(t, e || []),
    i,
    a = [];
  return (
    (i = {}),
    s("next"),
    s("throw"),
    s("return"),
    (i[Symbol.asyncIterator] = function () {
      return this;
    }),
    i
  );
  function s(v) {
    n[v] &&
      (i[v] = function (E) {
        return new Promise(function (A, I) {
          a.push([v, E, A, I]) > 1 || o(v, E);
        });
      });
  }
  function o(v, E) {
    try {
      c(n[v](E));
    } catch (A) {
      m(a[0][3], A);
    }
  }
  function c(v) {
    v.value instanceof cm
      ? Promise.resolve(v.value.v).then(u, d)
      : m(a[0][2], v);
  }
  function u(v) {
    o("next", v);
  }
  function d(v) {
    o("throw", v);
  }
  function m(v, E) {
    v(E), a.shift(), a.length && o(a[0][0], a[0][1]);
  }
}
function zhe(t) {
  var e, r;
  return (
    (e = {}),
    n("next"),
    n("throw", function (i) {
      throw i;
    }),
    n("return"),
    (e[Symbol.iterator] = function () {
      return this;
    }),
    e
  );
  function n(i, a) {
    e[i] = t[i]
      ? function (s) {
          return (r = !r)
            ? {
                value: cm(t[i](s)),
                done: i === "return",
              }
            : a
            ? a(s)
            : s;
        }
      : a;
  }
}
function qhe(t) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = t[Symbol.asyncIterator],
    r;
  return e
    ? e.call(t)
    : ((t = typeof t4 == "function" ? t4(t) : t[Symbol.iterator]()),
      (r = {}),
      n("next"),
      n("throw"),
      n("return"),
      (r[Symbol.asyncIterator] = function () {
        return this;
      }),
      r);
  function n(a) {
    r[a] =
      t[a] &&
      function (s) {
        return new Promise(function (o, c) {
          (s = t[a](s)), i(o, c, s.done, s.value);
        });
      };
  }
  function i(a, s, o, c) {
    Promise.resolve(c).then(function (u) {
      a({
        value: u,
        done: o,
      });
    }, s);
  }
}
function Vhe(t, e) {
  return (
    Object.defineProperty
      ? Object.defineProperty(t, "raw", {
          value: e,
        })
      : (t.raw = e),
    t
  );
}
function Khe(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null)
    for (var r in t) Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
  return (e.default = t), e;
}
function Ghe(t) {
  return t && t.__esModule
    ? t
    : {
        default: t,
      };
}
function Zhe(t, e) {
  if (!e.has(t))
    throw new TypeError("attempted to get private field on non-instance");
  return e.get(t);
}
function Jhe(t, e, r) {
  if (!e.has(t))
    throw new TypeError("attempted to set private field on non-instance");
  return e.set(t, r), r;
}
const Qhe = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        get __assign() {
          return e4;
        },
        __asyncDelegator: zhe,
        __asyncGenerator: Hhe,
        __asyncValues: qhe,
        __await: cm,
        __awaiter: Fhe,
        __classPrivateFieldGet: Zhe,
        __classPrivateFieldSet: Jhe,
        __createBinding: $he,
        __decorate: Bhe,
        __exportStar: Uhe,
        __extends: Phe,
        __generator: Lhe,
        __importDefault: Ghe,
        __importStar: Khe,
        __makeTemplateObject: Vhe,
        __metadata: Ohe,
        __param: Dhe,
        __read: r$,
        __rest: Nhe,
        __spread: Whe,
        __spreadArrays: jhe,
        __values: t4,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  Yhe = Pt(Qhe),
  Xhe = (t) =>
    JSON.stringify(t, (e, r) =>
      typeof r == "bigint" ? r.toString() + "n" : r
    ),
  epe = (t) => {
    const e =
        /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g,
      r = t.replace(e, '$1"$2n"$3');
    return JSON.parse(r, (n, i) =>
      typeof i == "string" && i.match(/^\d+n$/)
        ? BigInt(i.substring(0, i.length - 1))
        : i
    );
  };
function tpe(t) {
  if (typeof t != "string")
    throw new Error(`Cannot safe json parse value of type ${typeof t}`);
  try {
    return epe(t);
  } catch {
    return t;
  }
}
function h9(t) {
  return typeof t == "string" ? t : Xhe(t) || "";
}
var p9 = function (t, e, r) {
    if (r || arguments.length === 2)
      for (var n = 0, i = e.length, a; n < i; n++)
        (a || !(n in e)) &&
          (a || (a = Array.prototype.slice.call(e, 0, n)), (a[n] = e[n]));
    return t.concat(a || Array.prototype.slice.call(e));
  },
  rpe = (function () {
    function t(e, r, n) {
      (this.name = e),
        (this.version = r),
        (this.os = n),
        (this.type = "browser");
    }
    return t;
  })(),
  npe = (function () {
    function t(e) {
      (this.version = e),
        (this.type = "node"),
        (this.name = "node"),
        (this.os = process.platform);
    }
    return t;
  })(),
  ipe = (function () {
    function t(e, r, n, i) {
      (this.name = e),
        (this.version = r),
        (this.os = n),
        (this.bot = i),
        (this.type = "bot-device");
    }
    return t;
  })(),
  ape = (function () {
    function t() {
      (this.type = "bot"),
        (this.bot = !0),
        (this.name = "bot"),
        (this.version = null),
        (this.os = null);
    }
    return t;
  })(),
  spe = (function () {
    function t() {
      (this.type = "react-native"),
        (this.name = "react-native"),
        (this.version = null),
        (this.os = null);
    }
    return t;
  })(),
  ope =
    /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/,
  cpe =
    /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,
  m9 = 3,
  lpe = [
    ["aol", /AOLShield\/([0-9\._]+)/],
    ["edge", /Edge\/([0-9\._]+)/],
    ["edge-ios", /EdgiOS\/([0-9\._]+)/],
    ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
    ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
    ["samsung", /SamsungBrowser\/([0-9\.]+)/],
    ["silk", /\bSilk\/([0-9._-]+)\b/],
    ["miui", /MiuiBrowser\/([0-9\.]+)$/],
    ["beaker", /BeakerBrowser\/([0-9\.]+)/],
    ["edge-chromium", /EdgA?\/([0-9\.]+)/],
    [
      "chromium-webview",
      /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/,
    ],
    ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
    ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
    ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
    ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
    ["fxios", /FxiOS\/([0-9\.]+)/],
    ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
    ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
    ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
    ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
    [
      "pie",
      /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/,
    ],
    ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
    ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
    ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
    ["ie", /MSIE\s(7\.0)/],
    ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
    ["android", /Android\s([0-9\.]+)/],
    ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
    ["safari", /Version\/([0-9\._]+).*Safari/],
    ["facebook", /FB[AS]V\/([0-9\.]+)/],
    ["instagram", /Instagram\s([0-9\.]+)/],
    ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
    ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
    ["curl", /^curl\/([0-9\.]+)$/],
    ["searchbot", ope],
  ],
  y9 = [
    ["iOS", /iP(hone|od|ad)/],
    ["Android OS", /Android/],
    ["BlackBerry OS", /BlackBerry|BB10/],
    ["Windows Mobile", /IEMobile/],
    ["Amazon OS", /Kindle/],
    ["Windows 3.11", /Win16/],
    ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
    ["Windows 98", /(Windows 98)|(Win98)/],
    ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
    ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
    ["Windows Server 2003", /(Windows NT 5.2)/],
    ["Windows Vista", /(Windows NT 6.0)/],
    ["Windows 7", /(Windows NT 6.1)/],
    ["Windows 8", /(Windows NT 6.2)/],
    ["Windows 8.1", /(Windows NT 6.3)/],
    ["Windows 10", /(Windows NT 10.0)/],
    ["Windows ME", /Windows ME/],
    ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
    ["Open BSD", /OpenBSD/],
    ["Sun OS", /SunOS/],
    ["Chrome OS", /CrOS/],
    ["Linux", /(Linux)|(X11)/],
    ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
    ["QNX", /QNX/],
    ["BeOS", /BeOS/],
    ["OS/2", /OS\/2/],
  ];
function upe(t) {
  return typeof document > "u" &&
    typeof navigator < "u" &&
    navigator.product === "ReactNative"
    ? new spe()
    : typeof navigator < "u"
    ? dpe(navigator.userAgent)
    : ppe();
}
function fpe(t) {
  return (
    t !== "" &&
    lpe.reduce(function (e, r) {
      var n = r[0],
        i = r[1];
      if (e) return e;
      var a = i.exec(t);
      return !!a && [n, a];
    }, !1)
  );
}
function dpe(t) {
  var e = fpe(t);
  if (!e) return null;
  var r = e[0],
    n = e[1];
  if (r === "searchbot") return new ape();
  var i = n[1] && n[1].split(".").join("_").split("_").slice(0, 3);
  i
    ? i.length < m9 && (i = p9(p9([], i, !0), mpe(m9 - i.length), !0))
    : (i = []);
  var a = i.join("."),
    s = hpe(t),
    o = cpe.exec(t);
  return o && o[1] ? new ipe(r, a, s, o[1]) : new rpe(r, a, s);
}
function hpe(t) {
  for (var e = 0, r = y9.length; e < r; e++) {
    var n = y9[e],
      i = n[0],
      a = n[1],
      s = a.exec(t);
    if (s) return i;
  }
  return null;
}
function ppe() {
  var t = typeof process < "u" && process.version;
  return t ? new npe(process.version.slice(1)) : null;
}
function mpe(t) {
  for (var e = [], r = 0; r < t; r++) e.push("0");
  return e;
}
var Ov = (t) =>
    encodeURIComponent(t).replace(
      /[!'()*]/g,
      (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`
    ),
  n$ = "%[a-f0-9]{2}",
  g9 = new RegExp("(" + n$ + ")|([^%]+?)", "gi"),
  b9 = new RegExp("(" + n$ + ")+", "gi");
function r4(t, e) {
  try {
    return [decodeURIComponent(t.join(""))];
  } catch {}
  if (t.length === 1) return t;
  e = e || 1;
  var r = t.slice(0, e),
    n = t.slice(e);
  return Array.prototype.concat.call([], r4(r), r4(n));
}
function ype(t) {
  try {
    return decodeURIComponent(t);
  } catch {
    for (var e = t.match(g9) || [], r = 1; r < e.length; r++)
      (t = r4(e, r).join("")), (e = t.match(g9) || []);
    return t;
  }
}
function gpe(t) {
  for (
    var e = {
        "%FE%FF": "��",
        "%FF%FE": "��",
      },
      r = b9.exec(t);
    r;

  ) {
    try {
      e[r[0]] = decodeURIComponent(r[0]);
    } catch {
      var n = ype(r[0]);
      n !== r[0] && (e[r[0]] = n);
    }
    r = b9.exec(t);
  }
  e["%C2"] = "�";
  for (var i = Object.keys(e), a = 0; a < i.length; a++) {
    var s = i[a];
    t = t.replace(new RegExp(s, "g"), e[s]);
  }
  return t;
}
var Fv = function (t) {
    if (typeof t != "string")
      throw new TypeError(
        "Expected `encodedURI` to be of type `string`, got `" + typeof t + "`"
      );
    try {
      return (t = t.replace(/\+/g, " ")), decodeURIComponent(t);
    } catch {
      return gpe(t);
    }
  },
  Lv = (t, e) => {
    if (!(typeof t == "string" && typeof e == "string"))
      throw new TypeError("Expected the arguments to be of type `string`");
    if (e === "") return [t];
    const r = t.indexOf(e);
    return r === -1 ? [t] : [t.slice(0, r), t.slice(r + e.length)];
  };
const bpe = "PARSE_ERROR",
  vpe = "INVALID_REQUEST",
  xpe = "METHOD_NOT_FOUND",
  wpe = "INVALID_PARAMS",
  i$ = "INTERNAL_ERROR",
  ZE = "SERVER_ERROR",
  _pe = [-32700, -32600, -32601, -32602, -32603],
  Vh = {
    [bpe]: {
      code: -32700,
      message: "Parse error",
    },
    [vpe]: {
      code: -32600,
      message: "Invalid Request",
    },
    [xpe]: {
      code: -32601,
      message: "Method not found",
    },
    [wpe]: {
      code: -32602,
      message: "Invalid params",
    },
    [i$]: {
      code: -32603,
      message: "Internal error",
    },
    [ZE]: {
      code: -32e3,
      message: "Server error",
    },
  },
  a$ = ZE;
function Epe(t) {
  return _pe.includes(t);
}
function v9(t) {
  return Object.keys(Vh).includes(t) ? Vh[t] : Vh[a$];
}
function Tpe(t) {
  const e = Object.values(Vh).find((r) => r.code === t);
  return e || Vh[a$];
}
function Cpe(t, e, r) {
  return t.message.includes("getaddrinfo ENOTFOUND") ||
    t.message.includes("connect ECONNREFUSED")
    ? new Error(`Unavailable ${r} RPC url at ${e}`)
    : t;
}
var Ad = {},
  _o = {},
  x9;
function Ape() {
  if (x9) return _o;
  (x9 = 1),
    Object.defineProperty(_o, "__esModule", {
      value: !0,
    }),
    (_o.isBrowserCryptoAvailable =
      _o.getSubtleCrypto =
      _o.getBrowerCrypto =
        void 0);
  function t() {
    return (
      (ke == null ? void 0 : ke.crypto) ||
      (ke == null ? void 0 : ke.msCrypto) ||
      {}
    );
  }
  _o.getBrowerCrypto = t;
  function e() {
    const n = t();
    return n.subtle || n.webkitSubtle;
  }
  _o.getSubtleCrypto = e;
  function r() {
    return !!t() && !!e();
  }
  return (_o.isBrowserCryptoAvailable = r), _o;
}
var Eo = {},
  w9;
function kpe() {
  if (w9) return Eo;
  (w9 = 1),
    Object.defineProperty(Eo, "__esModule", {
      value: !0,
    }),
    (Eo.isBrowser = Eo.isNode = Eo.isReactNative = void 0);
  function t() {
    return (
      typeof document > "u" &&
      typeof navigator < "u" &&
      navigator.product === "ReactNative"
    );
  }
  Eo.isReactNative = t;
  function e() {
    return (
      typeof process < "u" &&
      typeof process.versions < "u" &&
      typeof process.versions.node < "u"
    );
  }
  Eo.isNode = e;
  function r() {
    return !t() && !e();
  }
  return (Eo.isBrowser = r), Eo;
}
(function (t) {
  Object.defineProperty(t, "__esModule", {
    value: !0,
  });
  const e = Yhe;
  e.__exportStar(Ape(), t), e.__exportStar(kpe(), t);
})(Ad);
function JE(t = 3) {
  const e = Date.now() * Math.pow(10, t),
    r = Math.floor(Math.random() * Math.pow(10, t));
  return e + r;
}
function Spe(t = 6) {
  return BigInt(JE(t));
}
function Mpe(t, e, r) {
  return {
    id: r || JE(),
    jsonrpc: "2.0",
    method: t,
    params: e,
  };
}
function n4(t, e, r) {
  return {
    id: t,
    jsonrpc: "2.0",
    error: Ipe(e, r),
  };
}
function Ipe(t, e) {
  return typeof t > "u"
    ? v9(i$)
    : (typeof t == "string" &&
        (t = Object.assign(Object.assign({}, v9(ZE)), {
          message: t,
        })),
      typeof e < "u" && (t.data = e),
      Epe(t.code) && (t = Tpe(t.code)),
      t);
}
let s$ = class {},
  Rpe = class extends s$ {
    constructor(e) {
      super();
    }
  },
  Ppe = class extends s$ {
    constructor() {
      super();
    }
  },
  Npe = class extends Ppe {
    constructor(e) {
      super();
    }
  };
const Bpe = "^https?:";
function Dpe(t) {
  const e = t.match(new RegExp(/^\w+:/, "gi"));
  if (!(!e || !e.length)) return e[0];
}
function Ope(t, e) {
  const r = Dpe(t);
  return typeof r > "u" ? !1 : new RegExp(e).test(r);
}
function _9(t) {
  return Ope(t, Bpe);
}
function Fpe(t) {
  return (
    typeof t == "object" && "id" in t && "jsonrpc" in t && t.jsonrpc === "2.0"
  );
}
function Lpe(t) {
  return Fpe(t) && ($pe(t) || o$(t));
}
function $pe(t) {
  return "result" in t;
}
function o$(t) {
  return "error" in t;
}
let E9 = class extends Npe {
  constructor(e) {
    super(e),
      (this.events = new Cd.EventEmitter()),
      (this.hasRegisteredEventListeners = !1),
      (this.connection = this.setConnection(e)),
      this.connection.connected && this.registerEventListeners();
  }
  async connect(e = this.connection) {
    await this.open(e);
  }
  async disconnect() {
    await this.close();
  }
  on(e, r) {
    this.events.on(e, r);
  }
  once(e, r) {
    this.events.once(e, r);
  }
  off(e, r) {
    this.events.off(e, r);
  }
  removeListener(e, r) {
    this.events.removeListener(e, r);
  }
  async request(e, r) {
    return this.requestStrict(
      Mpe(e.method, e.params || [], e.id || Spe().toString()),
      r
    );
  }
  async requestStrict(e, r) {
    return new Promise(async (n, i) => {
      if (!this.connection.connected)
        try {
          await this.open();
        } catch (a) {
          i(a);
        }
      this.events.on(`${e.id}`, (a) => {
        o$(a) ? i(a.error) : n(a.result);
      });
      try {
        await this.connection.send(e, r);
      } catch (a) {
        i(a);
      }
    });
  }
  setConnection(e = this.connection) {
    return e;
  }
  onPayload(e) {
    this.events.emit("payload", e),
      Lpe(e)
        ? this.events.emit(`${e.id}`, e)
        : this.events.emit("message", {
            type: e.method,
            data: e.params,
          });
  }
  onClose(e) {
    e &&
      e.code === 3e3 &&
      this.events.emit(
        "error",
        new Error(
          `WebSocket connection closed abnormally with code: ${e.code} ${
            e.reason ? `(${e.reason})` : ""
          }`
        )
      ),
      this.events.emit("disconnect");
  }
  async open(e = this.connection) {
    (this.connection === e && this.connection.connected) ||
      (this.connection.connected && this.close(),
      typeof e == "string" &&
        (await this.connection.open(e), (e = this.connection)),
      (this.connection = this.setConnection(e)),
      await this.connection.open(),
      this.registerEventListeners(),
      this.events.emit("connect"));
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    this.hasRegisteredEventListeners ||
      (this.connection.on("payload", (e) => this.onPayload(e)),
      this.connection.on("close", (e) => this.onClose(e)),
      this.connection.on("error", (e) => this.events.emit("error", e)),
      this.connection.on("register_error", (e) => this.onClose()),
      (this.hasRegisteredEventListeners = !0));
  }
};
function Upe(t, e, r) {
  const n = ye.useMemo(() => t.map((a) => bS(a, r)), [t, r]),
    i = ye.useMemo(
      () => (!e || typeof e == "string" || typeof e == "number" ? e : bS(e, r)),
      [e, r]
    );
  return [n, i];
}
const c$ = ye.createContext(void 0),
  Wpe = (t) => {
    let { value: e, children: r } = t;
    return de.jsx(c$.Provider, {
      value: e,
      children: r,
    });
  };
function jpe() {
  const t = ye.useContext(c$);
  return Je(t), t;
}
const l$ = ye.createContext({});
function Hpe() {
  const t = ye.useContext(l$);
  return Je(t._inProvider), t;
}
function zpe() {
  const { sdk: t } = Hpe();
  return t;
}
const T9 = {
    wallet: void 0,
    address: void 0,
    chainId: void 0,
    signer: void 0,
  },
  u$ = ye.createContext(void 0),
  qpe = (t) => {
    var c;
    let { signer: e, children: r } = t;
    const { chains: n, clientId: i } = jpe(),
      a = (c = zpe()) == null ? void 0 : c.storage,
      [s, o] = ye.useState({
        ...T9,
        signer: e || void 0,
      });
    return (
      ye.useEffect(() => {
        o((u) => ({
          ...u,
          signer: e || void 0,
        }));
      }, [e]),
      ye.useEffect(() => {
        if (!a) return;
        let u = e;
        return (
          e
            ? Promise.all([e.getAddress(), e.getChainId()])
                .then((d) => {
                  let [m, v] = d;
                  const E = n.find((I) => I.chainId === v);
                  let A;
                  if (E)
                    try {
                      A = uE(E, i)[0];
                    } catch (I) {
                      console.error(I);
                    }
                  if (e === u) {
                    const I = new Bv(
                      e,
                      {
                        readonlySettings: A
                          ? {
                              rpcUrl: A,
                              chainId: v,
                            }
                          : void 0,
                      },
                      a
                    );
                    o({
                      wallet: I,
                      address: m,
                      chainId: v,
                      signer: e,
                    });
                  }
                })
                .catch((d) => {})
            : o(T9),
          () => {
            u = void 0;
          }
        );
      }, [e, i]),
      de.jsx(u$.Provider, {
        value: s,
        children: r,
      })
    );
  },
  Vpe = (t) => {
    let {
      sdkOptions: e = {},
      storageInterface: r,
      supportedChains: n,
      activeChain: i,
      signer: a,
      children: s,
      clientId: o,
      secretKey: c,
    } = t;
    const u = ye.useMemo(() => {
        var v, E;
        return i
          ? typeof i == "number"
            ? i
            : typeof i == "string"
            ? (E = n.find((A) => A.slug === i)) == null
              ? void 0
              : E.chainId
            : i.chainId
          : (v = n[0]) == null
          ? void 0
          : v.chainId;
      }, [i, n]),
      d = ye.useMemo(() => {
        let v = u;
        const E = n.find((w) => w.chainId === v);
        !E &&
          v !== void 0 &&
          (console.warn(
            `The chainId ${v} is not in the configured chains, please add it to the ThirdwebProvider`
          ),
          (v = void 0));
        let A;
        if (E && E.rpc.length > 0)
          try {
            const w = uE(E, o)[0];
            A = {
              chainId: E.chainId,
              rpcUrl: w,
            };
          } catch {}
        const I = {
          readonlySettings: A,
          ...e,
          supportedChains: n,
        };
        let b;
        if (
          (v &&
            (b = new Cc(
              v,
              {
                ...I,
                clientId: o,
                secretKey: c,
              },
              r
            )),
          !b)
        )
          if (n.length > 0) (v = n[0].chainId), (b = new Cc(v, I, r));
          else {
            console.error(
              "No chains configured, please pass a chain or chains to the ThirdwebProvider"
            );
            return;
          }
        return (b._chainId = v), b;
      }, [u, n, e, r, o, c]);
    ye.useEffect(() => {
      d &&
        d._chainId === u &&
        (a ? d.updateSignerOrProvider(a) : u && d.updateSignerOrProvider(u));
    }, [d, d == null ? void 0 : d._chainId, a, u]);
    const m = ye.useMemo(
      () => ({
        sdk: d && d._chainId === u ? d : void 0,
        _inProvider: !0,
      }),
      [u, d]
    );
    return de.jsx(l$.Provider, {
      value: m,
      children: s,
    });
  },
  Kpe = (t) => {
    let {
      signer: e,
      children: r,
      queryClient: n,
      supportedChains: i,
      activeChain: a,
      clientId: s,
      ...o
    } = t;
    s ||
      jL(
        "No API key. Please provide a clientId. It is required to access thirdweb's services. You can create a key at https://thirdweb.com/create-api-key",
        s,
        void 0
      );
    const c = i || ene,
      u = ye.useMemo(
        () =>
          typeof a == "object" && a !== null
            ? c.find((I) => I.chainId === a.chainId)
              ? c.map((I) => (I.chainId === a.chainId ? a : I))
              : [...c, a]
            : c,
        [c, a]
      ),
      [d, m] = Upe(u, a || u[0], s),
      v = ye.useMemo(
        () =>
          !m || typeof m == "string" || typeof m == "number"
            ? d
            : [...d.filter((A) => A.chainId !== m.chainId), m].filter(
                (A, I, b) => I === b.findIndex((w) => w.chainId === A.chainId)
              ),
        [d, m]
      );
    return de.jsx(Wpe, {
      value: {
        chains: v,
        clientId: s,
      },
      children: de.jsx(tne, {
        queryClient: n,
        children: de.jsx(Vpe, {
          signer: e,
          supportedChains: v,
          clientId: s,
          activeChain: m,
          ...o,
          children: de.jsx(qpe, {
            signer: e,
            children: r,
          }),
        }),
      }),
    });
  };
function Gpe() {
  const t = ye.useContext(u$);
  return Je(t), t.address;
}
var f$ = {
  exports: {},
};
(function (t) {
  var e = Object.prototype.hasOwnProperty,
    r = "~";
  function n() {}
  Object.create &&
    ((n.prototype = Object.create(null)), new n().__proto__ || (r = !1));
  function i(c, u, d) {
    (this.fn = c), (this.context = u), (this.once = d || !1);
  }
  function a(c, u, d, m, v) {
    if (typeof d != "function")
      throw new TypeError("The listener must be a function");
    var E = new i(d, m || c, v),
      A = r ? r + u : u;
    return (
      c._events[A]
        ? c._events[A].fn
          ? (c._events[A] = [c._events[A], E])
          : c._events[A].push(E)
        : ((c._events[A] = E), c._eventsCount++),
      c
    );
  }
  function s(c, u) {
    --c._eventsCount === 0 ? (c._events = new n()) : delete c._events[u];
  }
  function o() {
    (this._events = new n()), (this._eventsCount = 0);
  }
  (o.prototype.eventNames = function () {
    var u = [],
      d,
      m;
    if (this._eventsCount === 0) return u;
    for (m in (d = this._events)) e.call(d, m) && u.push(r ? m.slice(1) : m);
    return Object.getOwnPropertySymbols
      ? u.concat(Object.getOwnPropertySymbols(d))
      : u;
  }),
    (o.prototype.listeners = function (u) {
      var d = r ? r + u : u,
        m = this._events[d];
      if (!m) return [];
      if (m.fn) return [m.fn];
      for (var v = 0, E = m.length, A = new Array(E); v < E; v++)
        A[v] = m[v].fn;
      return A;
    }),
    (o.prototype.listenerCount = function (u) {
      var d = r ? r + u : u,
        m = this._events[d];
      return m ? (m.fn ? 1 : m.length) : 0;
    }),
    (o.prototype.emit = function (u, d, m, v, E, A) {
      var I = r ? r + u : u;
      if (!this._events[I]) return !1;
      var b = this._events[I],
        w = arguments.length,
        S,
        k;
      if (b.fn) {
        switch ((b.once && this.removeListener(u, b.fn, void 0, !0), w)) {
          case 1:
            return b.fn.call(b.context), !0;
          case 2:
            return b.fn.call(b.context, d), !0;
          case 3:
            return b.fn.call(b.context, d, m), !0;
          case 4:
            return b.fn.call(b.context, d, m, v), !0;
          case 5:
            return b.fn.call(b.context, d, m, v, E), !0;
          case 6:
            return b.fn.call(b.context, d, m, v, E, A), !0;
        }
        for (k = 1, S = new Array(w - 1); k < w; k++) S[k - 1] = arguments[k];
        b.fn.apply(b.context, S);
      } else {
        var N = b.length,
          O;
        for (k = 0; k < N; k++)
          switch (
            (b[k].once && this.removeListener(u, b[k].fn, void 0, !0), w)
          ) {
            case 1:
              b[k].fn.call(b[k].context);
              break;
            case 2:
              b[k].fn.call(b[k].context, d);
              break;
            case 3:
              b[k].fn.call(b[k].context, d, m);
              break;
            case 4:
              b[k].fn.call(b[k].context, d, m, v);
              break;
            default:
              if (!S)
                for (O = 1, S = new Array(w - 1); O < w; O++)
                  S[O - 1] = arguments[O];
              b[k].fn.apply(b[k].context, S);
          }
      }
      return !0;
    }),
    (o.prototype.on = function (u, d, m) {
      return a(this, u, d, m, !1);
    }),
    (o.prototype.once = function (u, d, m) {
      return a(this, u, d, m, !0);
    }),
    (o.prototype.removeListener = function (u, d, m, v) {
      var E = r ? r + u : u;
      if (!this._events[E]) return this;
      if (!d) return s(this, E), this;
      var A = this._events[E];
      if (A.fn)
        A.fn === d && (!v || A.once) && (!m || A.context === m) && s(this, E);
      else {
        for (var I = 0, b = [], w = A.length; I < w; I++)
          (A[I].fn !== d || (v && !A[I].once) || (m && A[I].context !== m)) &&
            b.push(A[I]);
        b.length ? (this._events[E] = b.length === 1 ? b[0] : b) : s(this, E);
      }
      return this;
    }),
    (o.prototype.removeAllListeners = function (u) {
      var d;
      return (
        u
          ? ((d = r ? r + u : u), this._events[d] && s(this, d))
          : ((this._events = new n()), (this._eventsCount = 0)),
        this
      );
    }),
    (o.prototype.off = o.prototype.removeListener),
    (o.prototype.addListener = o.prototype.on),
    (o.prefixed = r),
    (o.EventEmitter = o),
    (t.exports = o);
})(f$);
var Zpe = f$.exports;
const d$ = mn(Zpe);
function h$(t, e) {
  if (e.has(t))
    throw new TypeError(
      "Cannot initialize the same private elements twice on an object"
    );
}
function ob(t, e, r) {
  h$(t, e), e.set(t, r);
}
function Dt(t, e, r) {
  return (
    e in t
      ? Object.defineProperty(t, e, {
          value: r,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (t[e] = r),
    t
  );
}
function Jpe(t, e) {
  return e.get ? e.get.call(t) : e.value;
}
function p$(t, e, r) {
  if (!e.has(t))
    throw new TypeError("attempted to " + r + " private field on non-instance");
  return e.get(t);
}
function Zl(t, e) {
  var r = p$(t, e, "get");
  return Jpe(t, r);
}
function Qpe(t, e, r) {
  if (e.set) e.set.call(t, r);
  else {
    if (!e.writable)
      throw new TypeError("attempted to set read only private field");
    e.value = r;
  }
}
function cb(t, e, r) {
  var n = p$(t, e, "set");
  return Qpe(t, n, r), r;
}
const p0 = {
    mainnet: {
      id: 1,
      name: "Mainnet",
      nativeCurrency: {
        name: "Ether",
        symbol: "ETH",
        decimals: 18,
      },
      rpcUrls: ["https://mainnet.infura.io/v3"],
      blockExplorers: [
        {
          name: "Etherscan",
          url: "https://etherscan.io",
        },
      ],
    },
    ropsten: {
      id: 3,
      name: "Ropsten",
      nativeCurrency: {
        name: "Ropsten Ether",
        symbol: "ropETH",
        decimals: 18,
      },
      rpcUrls: ["https://ropsten.infura.io/v3"],
      blockExplorers: [
        {
          name: "Etherscan",
          url: "https://ropsten.etherscan.io",
        },
      ],
      testnet: !0,
    },
    rinkeby: {
      id: 4,
      name: "Rinkeby",
      nativeCurrency: {
        name: "Rinkeby Ether",
        symbol: "rETH",
        decimals: 18,
      },
      rpcUrls: ["https://rinkeby.infura.io/v3"],
      blockExplorers: [
        {
          name: "Etherscan",
          url: "https://rinkeby.etherscan.io",
        },
      ],
      testnet: !0,
    },
    gnosis: {
      id: 100,
      name: "Gnosis Chain",
      nativeCurrency: {
        name: "xDai",
        symbol: "xDAI",
        decimals: 18,
      },
      rpcUrls: ["https://rpc.gnosischain.com"],
      blockExplorers: [
        {
          name: "Blockscout",
          url: "https://blockscout.com",
        },
      ],
    },
    goerli: {
      id: 5,
      name: "Goerli",
      nativeCurrency: {
        name: "Goerli Ether",
        symbol: "gETH",
        decimals: 18,
      },
      rpcUrls: ["https://goerli.infura.io/v3"],
      blockExplorers: [
        {
          name: "Etherscan",
          url: "https://goerli.etherscan.io",
        },
      ],
      testnet: !0,
    },
    kovan: {
      id: 42,
      name: "Kovan",
      nativeCurrency: {
        name: "Kovan Ether",
        symbol: "kETH",
        decimals: 18,
      },
      rpcUrls: ["https://kovan.infura.io/v3"],
      blockExplorers: [
        {
          name: "Etherscan",
          url: "https://kovan.etherscan.io",
        },
      ],
      testnet: !0,
    },
    optimism: {
      id: 10,
      name: "Optimism",
      nativeCurrency: {
        name: "Ether",
        symbol: "ETH",
        decimals: 18,
      },
      rpcUrls: ["https://mainnet.optimism.io"],
      blockExplorers: [
        {
          name: "Etherscan",
          url: "https://optimistic.etherscan.io",
        },
      ],
    },
    optimismKovan: {
      id: 69,
      name: "Optimism Kovan",
      nativeCurrency: {
        name: "Kovan Ether",
        symbol: "KOR",
        decimals: 18,
      },
      rpcUrls: ["https://kovan.optimism.io"],
      blockExplorers: [
        {
          name: "Etherscan",
          url: "https://kovan-optimistic.etherscan.io",
        },
      ],
      testnet: !0,
    },
    polygonMainnet: {
      id: 137,
      name: "Polygon Mainnet",
      nativeCurrency: {
        name: "MATIC",
        symbol: "MATIC",
        decimals: 18,
      },
      rpcUrls: [
        "https://polygon-rpc.com",
        "https://rpc-mainnet.matic.network",
        "https://matic-mainnet.chainstacklabs.com",
        "https://rpc-mainnet.maticvigil.com",
        "https://rpc-mainnet.matic.quiknode.pro",
        "https://matic-mainnet-full-rpc.bwarelabs.com",
      ],
      blockExplorers: [
        {
          name: "Polygonscan",
          url: "https://polygonscan.com",
        },
      ],
    },
    polygonTestnetMumbai: {
      id: 80001,
      name: "Mumbai",
      nativeCurrency: {
        name: "MATIC",
        symbol: "MATIC",
        decimals: 18,
      },
      rpcUrls: [
        "https://matic-mumbai.chainstacklabs.com",
        "https://rpc-mumbai.maticvigil.com",
        "https://matic-testnet-archive-rpc.bwarelabs.com",
      ],
      blockExplorers: [
        {
          name: "Polygonscan",
          url: "https://mumbai.polygonscan.com",
        },
      ],
      testnet: !0,
    },
    arbitrumOne: {
      id: 42161,
      name: "Arbitrum One",
      nativeCurrency: {
        name: "Ether",
        symbol: "AETH",
        decimals: 18,
      },
      rpcUrls: ["https://arb1.arbitrum.io/rpc"],
      blockExplorers: [
        {
          name: "Arbiscan",
          url: "https://arbiscan.io",
        },
        {
          name: "Arbitrum Explorer",
          url: "https://explorer.arbitrum.io",
        },
      ],
    },
    arbitrumRinkeby: {
      id: 421611,
      name: "Arbitrum Rinkeby",
      nativeCurrency: {
        name: "Arbitrum Rinkeby Ether",
        symbol: "ARETH",
        decimals: 18,
      },
      rpcUrls: ["https://rinkeby.arbitrum.io/rpc"],
      blockExplorers: [
        {
          name: "Arbitrum Explorer",
          url: "https://rinkeby-explorer.arbitrum.io",
        },
      ],
      testnet: !0,
    },
    avalanche: {
      id: 43114,
      name: "Avalanche Mainnet",
      nativeCurrency: {
        name: "Avalanche",
        symbol: "AVAX",
        decimals: 18,
      },
      rpcUrls: ["https://api.avax.network/ext/bc/C/rpc"],
      blockExplorers: [
        {
          name: "SnowTrace",
          url: "https://snowtrace.io",
        },
      ],
      testnet: !1,
    },
    avalancheFuji: {
      id: 43113,
      name: "Avalanche Fuji Testnet",
      nativeCurrency: {
        name: "Avalanche",
        symbol: "AVAX",
        decimals: 18,
      },
      rpcUrls: ["https://api.avax-test.network/ext/bc/C/rpc"],
      blockExplorers: [
        {
          name: "SnowTrace",
          url: "https://testnet.snowtrace.io",
        },
      ],
      testnet: !0,
    },
    localhost: {
      id: 1337,
      name: "Localhost",
      rpcUrls: ["https://127.0.0.1:8545"],
    },
    hardhat: {
      id: 31337,
      name: "Hardhat",
      rpcUrls: ["http://127.0.0.1:8545"],
    },
  },
  QE = Object.values(p0),
  Ype = [p0.mainnet, p0.ropsten, p0.rinkeby, p0.goerli, p0.kovan],
  $f = (t) =>
    typeof t == "string"
      ? Number.parseInt(t, t.trim().substring(0, 2) === "0x" ? 16 : 10)
      : t;
class Xpe extends Error {
  constructor() {
    super(...arguments),
      Dt(this, "name", "AddChainError"),
      Dt(this, "message", "Error adding chain");
  }
}
class eme extends Error {
  constructor() {
    super(...arguments),
      Dt(this, "name", "ChainNotConfigured"),
      Dt(this, "message", "Chain not configured");
  }
}
class tme extends Error {
  constructor() {
    super(...arguments),
      Dt(this, "name", "ConnectorAlreadyConnectedError"),
      Dt(this, "message", "Connector already connected");
  }
}
class r0 extends Error {
  constructor() {
    super(...arguments),
      Dt(this, "name", "ConnectorNotFoundError"),
      Dt(this, "message", "Connector not found");
  }
}
class YE extends Error {
  constructor() {
    super(...arguments),
      Dt(this, "name", "SwitchChainError"),
      Dt(this, "message", "Error switching chain");
  }
}
class Uf extends Error {
  constructor() {
    super(...arguments),
      Dt(this, "name", "UserRejectedRequestError"),
      Dt(this, "message", "User rejected request");
  }
}
let $v = class extends d$ {
  constructor(e) {
    let { chains: r = Ype, options: n } = e;
    super(),
      Dt(this, "id", void 0),
      Dt(this, "name", void 0),
      Dt(this, "chains", void 0),
      Dt(this, "options", void 0),
      Dt(this, "ready", void 0),
      (this.chains = r),
      (this.options = n);
  }
  isChainUnsupported(e) {
    return !this.chains.some((r) => r.id === e);
  }
};
const rme = (t) =>
    t
      ? t.isBraveWallet
        ? "Brave Wallet"
        : t.isMetaMask
        ? "MetaMask"
        : t.isCoinbaseWallet
        ? "Coinbase Wallet"
        : t.isFrame
        ? "Frame"
        : t.isTally
        ? "Tally"
        : "Injected"
      : "Injected",
  uy = "wagmi.shimDisconnect";
var X3 = new WeakMap();
class m$ extends $v {
  constructor(e) {
    super({
      ...e,
      options: e == null ? void 0 : e.options,
    }),
      Dt(this, "id", "injected"),
      Dt(this, "name", void 0),
      Dt(this, "ready", typeof window < "u" && !!window.ethereum),
      ob(this, X3, {
        writable: !0,
        value: void 0,
      }),
      Dt(this, "onAccountsChanged", (n) => {
        n.length === 0
          ? this.emit("disconnect")
          : this.emit("change", {
              account: oa.getAddress(n[0]),
            });
      }),
      Dt(this, "onChainChanged", (n) => {
        const i = $f(n),
          a = this.isChainUnsupported(i);
        this.emit("change", {
          chain: {
            id: i,
            unsupported: a,
          },
        });
      }),
      Dt(this, "onDisconnect", () => {
        var n;
        this.emit("disconnect"),
          (n = this.options) !== null &&
            n !== void 0 &&
            n.shimDisconnect &&
            typeof localStorage < "u" &&
            localStorage.removeItem(uy);
      });
    let r = "Injected";
    typeof window < "u" && (r = rme(window.ethereum)), (this.name = r);
  }
  async connect() {
    try {
      var e;
      const n = this.getProvider();
      if (!n) throw new r0();
      if (n.on) {
        var r;
        n.on("accountsChanged", this.onAccountsChanged),
          n.on("chainChanged", this.onChainChanged),
          ((r = this.options) !== null &&
            r !== void 0 &&
            r.shimChainChangedDisconnect) ||
            n.on("disconnect", this.onDisconnect);
      }
      const i = await this.getAccount(),
        a = await this.getChainId(),
        s = this.isChainUnsupported(a);
      return (
        (e = this.options) !== null &&
          e !== void 0 &&
          e.shimDisconnect &&
          typeof localStorage < "u" &&
          localStorage.setItem(uy, "true"),
        {
          account: i,
          chain: {
            id: a,
            unsupported: s,
          },
          provider: n,
        }
      );
    } catch (n) {
      throw n.code === 4001 ? new Uf() : n;
    }
  }
  async disconnect() {
    var e;
    const r = this.getProvider();
    r != null &&
      r.removeListener &&
      (r.removeListener("accountsChanged", this.onAccountsChanged),
      r.removeListener("chainChanged", this.onChainChanged),
      r.removeListener("disconnect", this.onDisconnect),
      (e = this.options) !== null &&
        e !== void 0 &&
        e.shimDisconnect &&
        typeof localStorage < "u" &&
        localStorage.removeItem(uy));
  }
  async getAccount() {
    const e = this.getProvider();
    if (!e) throw new r0();
    const r = await e.request({
      method: "eth_requestAccounts",
    });
    return oa.getAddress(r[0]);
  }
  async getChainId() {
    const e = this.getProvider();
    if (!e) throw new r0();
    return await e
      .request({
        method: "eth_chainId",
      })
      .then($f);
  }
  getProvider() {
    return (
      typeof window < "u" && window.ethereum && cb(this, X3, window.ethereum),
      Zl(this, X3)
    );
  }
  async getSigner() {
    const e = this.getProvider(),
      r = await this.getAccount();
    return new kf(e).getSigner(r);
  }
  async isAuthorized() {
    try {
      var e;
      if (
        (e = this.options) !== null &&
        e !== void 0 &&
        e.shimDisconnect &&
        typeof localStorage < "u" &&
        !localStorage.getItem(uy)
      )
        return !1;
      const r = this.getProvider();
      if (!r) throw new r0();
      return !!(
        await r.request({
          method: "eth_accounts",
        })
      )[0];
    } catch {
      return !1;
    }
  }
  async switchChain(e) {
    const r = this.getProvider();
    if (!r) throw new r0();
    const n = oa.hexValue(e);
    try {
      return (
        await r.request({
          method: "wallet_switchEthereumChain",
          params: [
            {
              chainId: n,
            },
          ],
        }),
        [...this.chains, ...QE].find((s) => s.id === e)
      );
    } catch (a) {
      if (a.code === 4902)
        try {
          var i;
          const s = this.chains.find((o) => o.id === e);
          if (!s) throw new eme();
          return (
            await r.request({
              method: "wallet_addEthereumChain",
              params: [
                {
                  chainId: n,
                  chainName: s.name,
                  nativeCurrency: s.nativeCurrency,
                  rpcUrls: s.rpcUrls,
                  blockExplorerUrls:
                    (i = s.blockExplorers) === null || i === void 0
                      ? void 0
                      : i.map((o) => o.url),
                },
              ],
            }),
            s
          );
        } catch {
          throw new Xpe();
        }
      else throw a.code === 4001 ? new Uf() : new YE();
    }
  }
  async watchAsset(e) {
    let { address: r, decimals: n = 18, image: i, symbol: a } = e;
    const s = this.getProvider();
    if (!s) throw new r0();
    await s.request({
      method: "wallet_watchAsset",
      params: {
        type: "ERC20",
        options: {
          address: r,
          decimals: n,
          image: i,
          symbol: a,
        },
      },
    });
  }
}
const nme = () => qm().state.cacheBuster,
  y$ = () => {
    const t = ye.useRef(null);
    return (
      ye.useEffect(
        () => () => {
          var r;
          return (r = t.current) === null || r === void 0 ? void 0 : r.call(t);
        },
        []
      ),
      ye.useCallback((r) => {
        var n;
        (n = t.current) === null || n === void 0 || n.call(t),
          r && (t.current = r);
      }, [])
    );
  },
  ime = function (t) {
    let e =
      arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    const [r, n] = ye.useState(() => {
        if (typeof localStorage > "u") return e;
        const a = localStorage.getItem(t);
        try {
          return a ? JSON.parse(a) : e;
        } catch (s) {
          return console.warn(s), e;
        }
      }),
      i = ye.useCallback(
        (a) => {
          if (a !== r)
            if (
              (n(a),
              a === null
                ? localStorage.removeItem(t)
                : localStorage.setItem(t, JSON.stringify(a)),
              a === null)
            )
              localStorage.removeItem(t);
            else
              try {
                localStorage.setItem(t, JSON.stringify(a));
              } catch (s) {
                console.error(s);
              }
        },
        [r, n, t]
      );
    return [r, i];
  },
  ame = {
    loading: !1,
  },
  sme = () => {
    var t;
    const { state: e, setState: r, setLastUsedConnector: n } = qm(),
      [i, a] = ye.useState(ame),
      s = y$(),
      o = ye.useCallback(
        async (c) => {
          let u = !1;
          s(() => {
            u = !0;
          });
          try {
            const d = e == null ? void 0 : e.connector;
            if (c === d) throw new tme();
            a((v) => ({
              ...v,
              loading: !0,
              connector: c,
              error: void 0,
            }));
            const m = await c.connect();
            return (
              u ||
                (r((v) => ({
                  ...v,
                  connector: c,
                  data: m,
                })),
                n(c.name),
                a((v) => ({
                  ...v,
                  loading: !1,
                }))),
              {
                data: m,
                error: void 0,
              }
            );
          } catch (d) {
            const m = d;
            return (
              u ||
                a((v) => ({
                  ...v,
                  connector: void 0,
                  error: m,
                  loading: !1,
                })),
              {
                data: void 0,
                error: m,
              }
            );
          }
        },
        [s, e.connector, r, n]
      );
    return (
      ye.useEffect(
        () => (
          a((c) => ({
            ...c,
            connector: e.connector,
            error: void 0,
          })),
          s
        ),
        [s, e.connector]
      ),
      [
        {
          data: {
            connected: !!((t = e.data) !== null && t !== void 0 && t.account),
            connector: i.connector,
            connectors: e.connectors,
          },
          error: i.error,
          loading: i.loading || e.connecting,
        },
        o,
      ]
    );
  },
  ome = {
    data: void 0,
    error: void 0,
    loading: !1,
  },
  cme = function () {
    let { skip: t } =
      arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const e = nme(),
      {
        state: { connector: r },
      } = qm(),
      [n, i] = ye.useState(ome),
      a = y$(),
      s = ye.useCallback(async () => {
        let o = !1;
        a(() => {
          o = !0;
        });
        try {
          i((u) => ({
            ...u,
            error: void 0,
            loading: !0,
          }));
          const c = await (r == null ? void 0 : r.getSigner());
          return (
            o ||
              i((u) => ({
                ...u,
                data: c,
                loading: !1,
              })),
            c
          );
        } catch (c) {
          const u = c;
          o ||
            i((d) => ({
              ...d,
              data: void 0,
              error: u,
              loading: !1,
            }));
        }
      }, [a, r]);
    return (
      ye.useEffect(() => {
        if (!t) return s(), a;
      }, [e, r, a, t]),
      [n, s]
    );
  },
  g$ = ye.createContext(null),
  lme = (t) => {
    var e, r, n, i, a, s;
    let {
      autoConnect: o = !1,
      children: c,
      connectors: u = [new m$()],
      connectorStorageKey: d = "wagmi.wallet",
      provider: m = XD(),
      webSocketProvider: v,
    } = t;
    const [E, A] = ime(d),
      [I, b] = ye.useState({
        cacheBuster: 1,
        connecting: o,
      }),
      w = ye.useMemo(() => {
        var O, F;
        return typeof u != "function"
          ? u
          : u({
              chainId:
                (O = I.data) === null ||
                O === void 0 ||
                (F = O.chain) === null ||
                F === void 0
                  ? void 0
                  : F.id,
            });
      }, [
        u,
        (e = I.data) === null ||
        e === void 0 ||
        (r = e.chain) === null ||
        r === void 0
          ? void 0
          : r.id,
      ]),
      S = ye.useMemo(() => {
        var O, F;
        return typeof m != "function"
          ? m
          : m({
              chainId:
                (O = I.data) === null ||
                O === void 0 ||
                (F = O.chain) === null ||
                F === void 0
                  ? void 0
                  : F.id,
              connector: I.connector,
            });
      }, [
        m,
        (n = I.data) === null ||
        n === void 0 ||
        (i = n.chain) === null ||
        i === void 0
          ? void 0
          : i.id,
        I.connector,
      ]),
      k = ye.useMemo(() => {
        var O, F;
        if (v)
          return typeof v != "function"
            ? v
            : v({
                chainId:
                  (O = I.data) === null ||
                  O === void 0 ||
                  (F = O.chain) === null ||
                  F === void 0
                    ? void 0
                    : F.id,
                connector: I.connector,
              });
      }, [
        v,
        (a = I.data) === null ||
        a === void 0 ||
        (s = a.chain) === null ||
        s === void 0
          ? void 0
          : s.id,
        I.connector,
      ]);
    ye.useEffect(() => {
      o &&
        (async () => {
          b((F) => ({
            ...F,
            connecting: !0,
          }));
          const O = E ? [...w].sort((F) => (F.name === E ? -1 : 1)) : w;
          for (const F of O) {
            if (!F.ready || !F.isAuthorized || !(await F.isAuthorized()))
              continue;
            const j = await F.connect();
            b((X) => ({
              ...X,
              connector: F,
              data: j,
            }));
            break;
          }
          b((F) => ({
            ...F,
            connecting: !1,
          }));
        })();
    }, []),
      ye.useEffect(
        () => () => {
          I.connector && I.connector.disconnect();
        },
        [I.connector]
      ),
      ye.useEffect(() => {
        if (!I.connector) return;
        const O = (j) =>
            b((X) => ({
              ...X,
              cacheBuster: X.cacheBuster + 1,
              data: {
                ...X.data,
                ...j,
              },
            })),
          F = () =>
            b({
              cacheBuster: 1,
            }),
          V = (j) =>
            b((X) => ({
              ...X,
              error: j,
            }));
        return (
          I.connector.on("change", O),
          I.connector.on("disconnect", F),
          I.connector.on("error", V),
          () => {
            I.connector &&
              (I.connector.off("change", O),
              I.connector.off("disconnect", F),
              I.connector.off("error", V));
          }
        );
      }, [I.connector]);
    const N = {
      state: {
        cacheBuster: I.cacheBuster,
        connecting: I.connecting,
        connectors: w,
        connector: I.connector,
        data: I.data,
        provider: S,
        webSocketProvider: k,
      },
      setState: b,
      setLastUsedConnector: A,
    };
    return ye.createElement(
      g$.Provider,
      {
        value: N,
      },
      c
    );
  },
  qm = () => {
    const t = ye.useContext(g$);
    if (!t) throw Error("Must be used within Provider");
    return t;
  };
var b$ = {},
  lm = {},
  Uv = {};
Object.defineProperty(Uv, "__esModule", {
  value: !0,
});
Uv.walletLogo = void 0;
const ume = (t, e) => {
  let r;
  switch (t) {
    case "standard":
      return (
        (r = e),
        `data:image/svg+xml,%3Csvg width='${e}' height='${r}' viewBox='0 0 1024 1024' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Crect width='1024' height='1024' fill='%230052FF'/%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M152 512C152 710.823 313.177 872 512 872C710.823 872 872 710.823 872 512C872 313.177 710.823 152 512 152C313.177 152 152 313.177 152 512ZM420 396C406.745 396 396 406.745 396 420V604C396 617.255 406.745 628 420 628H604C617.255 628 628 617.255 628 604V420C628 406.745 617.255 396 604 396H420Z' fill='white'/%3E %3C/svg%3E `
      );
    case "circle":
      return (
        (r = e),
        `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='${e}' height='${r}' viewBox='0 0 999.81 999.81'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052fe;%7D.cls-2%7Bfill:%23fefefe;%7D.cls-3%7Bfill:%230152fe;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M655-115.9h56c.83,1.59,2.36.88,3.56,1a478,478,0,0,1,75.06,10.42C891.4-81.76,978.33-32.58,1049.19,44q116.7,126,131.94,297.61c.38,4.14-.34,8.53,1.78,12.45v59c-1.58.84-.91,2.35-1,3.56a482.05,482.05,0,0,1-10.38,74.05c-24,106.72-76.64,196.76-158.83,268.93s-178.18,112.82-287.2,122.6c-4.83.43-9.86-.25-14.51,1.77H654c-1-1.68-2.69-.91-4.06-1a496.89,496.89,0,0,1-105.9-18.59c-93.54-27.42-172.78-77.59-236.91-150.94Q199.34,590.1,184.87,426.58c-.47-5.19.25-10.56-1.77-15.59V355c1.68-1,.91-2.7,1-4.06a498.12,498.12,0,0,1,18.58-105.9c26-88.75,72.64-164.9,140.6-227.57q126-116.27,297.21-131.61C645.32-114.57,650.35-113.88,655-115.9Zm377.92,500c0-192.44-156.31-349.49-347.56-350.15-194.13-.68-350.94,155.13-352.29,347.42-1.37,194.55,155.51,352.1,348.56,352.47C876.15,734.23,1032.93,577.84,1032.93,384.11Z' transform='translate(-183.1 115.9)'/%3E%3Cpath class='cls-2' d='M1032.93,384.11c0,193.73-156.78,350.12-351.29,349.74-193-.37-349.93-157.92-348.56-352.47C334.43,189.09,491.24,33.28,685.37,34,876.62,34.62,1032.94,191.67,1032.93,384.11ZM683,496.81q43.74,0,87.48,0c15.55,0,25.32-9.72,25.33-25.21q0-87.48,0-175c0-15.83-9.68-25.46-25.59-25.46H595.77c-15.88,0-25.57,9.64-25.58,25.46q0,87.23,0,174.45c0,16.18,9.59,25.7,25.84,25.71Z' transform='translate(-183.1 115.9)'/%3E%3Cpath class='cls-3' d='M683,496.81H596c-16.25,0-25.84-9.53-25.84-25.71q0-87.23,0-174.45c0-15.82,9.7-25.46,25.58-25.46H770.22c15.91,0,25.59,9.63,25.59,25.46q0,87.47,0,175c0,15.49-9.78,25.2-25.33,25.21Q726.74,496.84,683,496.81Z' transform='translate(-183.1 115.9)'/%3E%3C/svg%3E`
      );
    case "text":
      return (
        (r = (0.1 * e).toFixed(2)),
        `data:image/svg+xml,%3Csvg width='${e}' height='${r}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 528.15 53.64'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052ff;%7D%3C/style%3E%3C/defs%3E%3Ctitle%3ECoinbase_Wordmark_SubBrands_ALL%3C/title%3E%3Cpath class='cls-1' d='M164.45,15a15,15,0,0,0-11.74,5.4V0h-8.64V52.92h8.5V48a15,15,0,0,0,11.88,5.62c10.37,0,18.21-8.21,18.21-19.3S174.67,15,164.45,15Zm-1.3,30.67c-6.19,0-10.73-4.83-10.73-11.31S157,23,163.22,23s10.66,4.82,10.66,11.37S169.34,45.65,163.15,45.65Zm83.31-14.91-6.34-.93c-3-.43-5.18-1.44-5.18-3.82,0-2.59,2.8-3.89,6.62-3.89,4.18,0,6.84,1.8,7.42,4.76h8.35c-.94-7.49-6.7-11.88-15.55-11.88-9.15,0-15.2,4.68-15.2,11.3,0,6.34,4,10,12,11.16l6.33.94c3.1.43,4.83,1.65,4.83,4,0,2.95-3,4.17-7.2,4.17-5.12,0-8-2.09-8.43-5.25h-8.49c.79,7.27,6.48,12.38,16.84,12.38,9.44,0,15.7-4.32,15.7-11.74C258.12,35.28,253.58,31.82,246.46,30.74Zm-27.65-2.3c0-8.06-4.9-13.46-15.27-13.46-9.79,0-15.26,5-16.34,12.6h8.57c.43-3,2.73-5.4,7.63-5.4,4.39,0,6.55,1.94,6.55,4.32,0,3.09-4,3.88-8.85,4.39-6.63.72-14.84,3-14.84,11.66,0,6.7,5,11,12.89,11,6.19,0,10.08-2.59,12-6.7.28,3.67,3,6.05,6.84,6.05h5v-7.7h-4.25Zm-8.5,9.36c0,5-4.32,8.64-9.57,8.64-3.24,0-6-1.37-6-4.25,0-3.67,4.39-4.68,8.42-5.11s6-1.22,7.13-2.88ZM281.09,15c-11.09,0-19.23,8.35-19.23,19.36,0,11.6,8.72,19.3,19.37,19.3,9,0,16.06-5.33,17.86-12.89h-9c-1.3,3.31-4.47,5.19-8.71,5.19-5.55,0-9.72-3.46-10.66-9.51H299.3V33.12C299.3,22.46,291.53,15,281.09,15Zm-9.87,15.26c1.37-5.18,5.26-7.7,9.72-7.7,4.9,0,8.64,2.8,9.51,7.7ZM19.3,23a9.84,9.84,0,0,1,9.5,7h9.14c-1.65-8.93-9-15-18.57-15A19,19,0,0,0,0,34.34c0,11.09,8.28,19.3,19.37,19.3,9.36,0,16.85-6,18.5-15H28.8a9.75,9.75,0,0,1-9.43,7.06c-6.27,0-10.66-4.83-10.66-11.31S13,23,19.3,23Zm41.11-8A19,19,0,0,0,41,34.34c0,11.09,8.28,19.3,19.37,19.3A19,19,0,0,0,79.92,34.27C79.92,23.33,71.64,15,60.41,15Zm.07,30.67c-6.19,0-10.73-4.83-10.73-11.31S54.22,23,60.41,23s10.8,4.89,10.8,11.37S66.67,45.65,60.48,45.65ZM123.41,15c-5.62,0-9.29,2.3-11.45,5.54V15.7h-8.57V52.92H112V32.69C112,27,115.63,23,121,23c5,0,8.06,3.53,8.06,8.64V52.92h8.64V31C137.66,21.6,132.84,15,123.41,15ZM92,.36a5.36,5.36,0,0,0-5.55,5.47,5.55,5.55,0,0,0,11.09,0A5.35,5.35,0,0,0,92,.36Zm-9.72,23h5.4V52.92h8.64V15.7h-14Zm298.17-7.7L366.2,52.92H372L375.29,44H392l3.33,8.88h6L386.87,15.7ZM377,39.23l6.45-17.56h.1l6.56,17.56ZM362.66,15.7l-7.88,29h-.11l-8.14-29H341l-8,28.93h-.1l-8-28.87H319L329.82,53h5.45l8.19-29.24h.11L352,53h5.66L368.1,15.7Zm135.25,0v4.86h12.32V52.92h5.6V20.56h12.32V15.7ZM467.82,52.92h25.54V48.06H473.43v-12h18.35V31.35H473.43V20.56h19.93V15.7H467.82ZM443,15.7h-5.6V52.92h24.32V48.06H443Zm-30.45,0h-5.61V52.92h24.32V48.06H412.52Z'/%3E%3C/svg%3E`
      );
    case "textWithLogo":
      return (
        (r = (0.25 * e).toFixed(2)),
        `data:image/svg+xml,%3Csvg width='${e}' height='${r}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 308.44 77.61'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052ff;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M142.94,20.2l-7.88,29H135l-8.15-29h-5.55l-8,28.93h-.11l-8-28.87H99.27l10.84,37.27h5.44l8.2-29.24h.1l8.41,29.24h5.66L148.39,20.2Zm17.82,0L146.48,57.42h5.82l3.28-8.88h16.65l3.34,8.88h6L167.16,20.2Zm-3.44,23.52,6.45-17.55h.11l6.56,17.55ZM278.2,20.2v4.86h12.32V57.42h5.6V25.06h12.32V20.2ZM248.11,57.42h25.54V52.55H253.71V40.61h18.35V35.85H253.71V25.06h19.94V20.2H248.11ZM223.26,20.2h-5.61V57.42H242V52.55H223.26Zm-30.46,0h-5.6V57.42h24.32V52.55H192.8Zm-154,38A19.41,19.41,0,1,1,57.92,35.57H77.47a38.81,38.81,0,1,0,0,6.47H57.92A19.39,19.39,0,0,1,38.81,58.21Z'/%3E%3C/svg%3E`
      );
    case "textLight":
      return (
        (r = (0.1 * e).toFixed(2)),
        `data:image/svg+xml,%3Csvg width='${e}' height='${r}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 528.15 53.64'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fefefe;%7D%3C/style%3E%3C/defs%3E%3Ctitle%3ECoinbase_Wordmark_SubBrands_ALL%3C/title%3E%3Cpath class='cls-1' d='M164.45,15a15,15,0,0,0-11.74,5.4V0h-8.64V52.92h8.5V48a15,15,0,0,0,11.88,5.62c10.37,0,18.21-8.21,18.21-19.3S174.67,15,164.45,15Zm-1.3,30.67c-6.19,0-10.73-4.83-10.73-11.31S157,23,163.22,23s10.66,4.82,10.66,11.37S169.34,45.65,163.15,45.65Zm83.31-14.91-6.34-.93c-3-.43-5.18-1.44-5.18-3.82,0-2.59,2.8-3.89,6.62-3.89,4.18,0,6.84,1.8,7.42,4.76h8.35c-.94-7.49-6.7-11.88-15.55-11.88-9.15,0-15.2,4.68-15.2,11.3,0,6.34,4,10,12,11.16l6.33.94c3.1.43,4.83,1.65,4.83,4,0,2.95-3,4.17-7.2,4.17-5.12,0-8-2.09-8.43-5.25h-8.49c.79,7.27,6.48,12.38,16.84,12.38,9.44,0,15.7-4.32,15.7-11.74C258.12,35.28,253.58,31.82,246.46,30.74Zm-27.65-2.3c0-8.06-4.9-13.46-15.27-13.46-9.79,0-15.26,5-16.34,12.6h8.57c.43-3,2.73-5.4,7.63-5.4,4.39,0,6.55,1.94,6.55,4.32,0,3.09-4,3.88-8.85,4.39-6.63.72-14.84,3-14.84,11.66,0,6.7,5,11,12.89,11,6.19,0,10.08-2.59,12-6.7.28,3.67,3,6.05,6.84,6.05h5v-7.7h-4.25Zm-8.5,9.36c0,5-4.32,8.64-9.57,8.64-3.24,0-6-1.37-6-4.25,0-3.67,4.39-4.68,8.42-5.11s6-1.22,7.13-2.88ZM281.09,15c-11.09,0-19.23,8.35-19.23,19.36,0,11.6,8.72,19.3,19.37,19.3,9,0,16.06-5.33,17.86-12.89h-9c-1.3,3.31-4.47,5.19-8.71,5.19-5.55,0-9.72-3.46-10.66-9.51H299.3V33.12C299.3,22.46,291.53,15,281.09,15Zm-9.87,15.26c1.37-5.18,5.26-7.7,9.72-7.7,4.9,0,8.64,2.8,9.51,7.7ZM19.3,23a9.84,9.84,0,0,1,9.5,7h9.14c-1.65-8.93-9-15-18.57-15A19,19,0,0,0,0,34.34c0,11.09,8.28,19.3,19.37,19.3,9.36,0,16.85-6,18.5-15H28.8a9.75,9.75,0,0,1-9.43,7.06c-6.27,0-10.66-4.83-10.66-11.31S13,23,19.3,23Zm41.11-8A19,19,0,0,0,41,34.34c0,11.09,8.28,19.3,19.37,19.3A19,19,0,0,0,79.92,34.27C79.92,23.33,71.64,15,60.41,15Zm.07,30.67c-6.19,0-10.73-4.83-10.73-11.31S54.22,23,60.41,23s10.8,4.89,10.8,11.37S66.67,45.65,60.48,45.65ZM123.41,15c-5.62,0-9.29,2.3-11.45,5.54V15.7h-8.57V52.92H112V32.69C112,27,115.63,23,121,23c5,0,8.06,3.53,8.06,8.64V52.92h8.64V31C137.66,21.6,132.84,15,123.41,15ZM92,.36a5.36,5.36,0,0,0-5.55,5.47,5.55,5.55,0,0,0,11.09,0A5.35,5.35,0,0,0,92,.36Zm-9.72,23h5.4V52.92h8.64V15.7h-14Zm298.17-7.7L366.2,52.92H372L375.29,44H392l3.33,8.88h6L386.87,15.7ZM377,39.23l6.45-17.56h.1l6.56,17.56ZM362.66,15.7l-7.88,29h-.11l-8.14-29H341l-8,28.93h-.1l-8-28.87H319L329.82,53h5.45l8.19-29.24h.11L352,53h5.66L368.1,15.7Zm135.25,0v4.86h12.32V52.92h5.6V20.56h12.32V15.7ZM467.82,52.92h25.54V48.06H473.43v-12h18.35V31.35H473.43V20.56h19.93V15.7H467.82ZM443,15.7h-5.6V52.92h24.32V48.06H443Zm-30.45,0h-5.61V52.92h24.32V48.06H412.52Z'/%3E%3C/svg%3E`
      );
    case "textWithLogoLight":
      return (
        (r = (0.25 * e).toFixed(2)),
        `data:image/svg+xml,%3Csvg width='${e}' height='${r}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 308.44 77.61'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fefefe;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M142.94,20.2l-7.88,29H135l-8.15-29h-5.55l-8,28.93h-.11l-8-28.87H99.27l10.84,37.27h5.44l8.2-29.24h.1l8.41,29.24h5.66L148.39,20.2Zm17.82,0L146.48,57.42h5.82l3.28-8.88h16.65l3.34,8.88h6L167.16,20.2Zm-3.44,23.52,6.45-17.55h.11l6.56,17.55ZM278.2,20.2v4.86h12.32V57.42h5.6V25.06h12.32V20.2ZM248.11,57.42h25.54V52.55H253.71V40.61h18.35V35.85H253.71V25.06h19.94V20.2H248.11ZM223.26,20.2h-5.61V57.42H242V52.55H223.26Zm-30.46,0h-5.6V57.42h24.32V52.55H192.8Zm-154,38A19.41,19.41,0,1,1,57.92,35.57H77.47a38.81,38.81,0,1,0,0,6.47H57.92A19.39,19.39,0,0,1,38.81,58.21Z'/%3E%3C/svg%3E`
      );
    default:
      return (
        (r = e),
        `data:image/svg+xml,%3Csvg width='${e}' height='${r}' viewBox='0 0 1024 1024' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Crect width='1024' height='1024' fill='%230052FF'/%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M152 512C152 710.823 313.177 872 512 872C710.823 872 872 710.823 872 512C872 313.177 710.823 152 512 152C313.177 152 152 313.177 152 512ZM420 396C406.745 396 396 406.745 396 420V604C396 617.255 406.745 628 420 628H604C617.255 628 628 617.255 628 604V420C628 406.745 617.255 396 604 396H420Z' fill='white'/%3E %3C/svg%3E `
      );
  }
};
Uv.walletLogo = ume;
var Wv = {};
Object.defineProperty(Wv, "__esModule", {
  value: !0,
});
Wv.LINK_API_URL = void 0;
Wv.LINK_API_URL = "https://www.walletlink.org";
var ot = {},
  Vm = {},
  Jo = {};
Object.defineProperty(Jo, "__esModule", {
  value: !0,
});
Jo.errorValues = Jo.standardErrorCodes = void 0;
Jo.standardErrorCodes = {
  rpc: {
    invalidInput: -32e3,
    resourceNotFound: -32001,
    resourceUnavailable: -32002,
    transactionRejected: -32003,
    methodNotSupported: -32004,
    limitExceeded: -32005,
    parse: -32700,
    invalidRequest: -32600,
    methodNotFound: -32601,
    invalidParams: -32602,
    internal: -32603,
  },
  provider: {
    userRejectedRequest: 4001,
    unauthorized: 4100,
    unsupportedMethod: 4200,
    disconnected: 4900,
    chainDisconnected: 4901,
    unsupportedChain: 4902,
  },
};
Jo.errorValues = {
  "-32700": {
    standard: "JSON RPC 2.0",
    message:
      "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.",
  },
  "-32600": {
    standard: "JSON RPC 2.0",
    message: "The JSON sent is not a valid Request object.",
  },
  "-32601": {
    standard: "JSON RPC 2.0",
    message: "The method does not exist / is not available.",
  },
  "-32602": {
    standard: "JSON RPC 2.0",
    message: "Invalid method parameter(s).",
  },
  "-32603": {
    standard: "JSON RPC 2.0",
    message: "Internal JSON-RPC error.",
  },
  "-32000": {
    standard: "EIP-1474",
    message: "Invalid input.",
  },
  "-32001": {
    standard: "EIP-1474",
    message: "Resource not found.",
  },
  "-32002": {
    standard: "EIP-1474",
    message: "Resource unavailable.",
  },
  "-32003": {
    standard: "EIP-1474",
    message: "Transaction rejected.",
  },
  "-32004": {
    standard: "EIP-1474",
    message: "Method not supported.",
  },
  "-32005": {
    standard: "EIP-1474",
    message: "Request limit exceeded.",
  },
  4001: {
    standard: "EIP-1193",
    message: "User rejected the request.",
  },
  4100: {
    standard: "EIP-1193",
    message:
      "The requested account and/or method has not been authorized by the user.",
  },
  4200: {
    standard: "EIP-1193",
    message: "The requested method is not supported by this Ethereum provider.",
  },
  4900: {
    standard: "EIP-1193",
    message: "The provider is disconnected from all chains.",
  },
  4901: {
    standard: "EIP-1193",
    message: "The provider is disconnected from the specified chain.",
  },
  4902: {
    standard: "EIP-3085",
    message: "Unrecognized chain ID.",
  },
};
var jv = {},
  Hv = {};
(function (t) {
  Object.defineProperty(t, "__esModule", {
    value: !0,
  }),
    (t.serialize =
      t.getErrorCode =
      t.isValidCode =
      t.getMessageFromCode =
      t.JSON_RPC_SERVER_ERROR_MESSAGE =
        void 0);
  const e = Jo,
    r = "Unspecified error message.";
  t.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
  function n(v, E = r) {
    if (v && Number.isInteger(v)) {
      const A = v.toString();
      if (d(e.errorValues, A)) return e.errorValues[A].message;
      if (c(v)) return t.JSON_RPC_SERVER_ERROR_MESSAGE;
    }
    return E;
  }
  t.getMessageFromCode = n;
  function i(v) {
    if (!Number.isInteger(v)) return !1;
    const E = v.toString();
    return !!(e.errorValues[E] || c(v));
  }
  t.isValidCode = i;
  function a(v) {
    var E;
    if (typeof v == "number") return v;
    if (s(v)) return (E = v.code) !== null && E !== void 0 ? E : v.errorCode;
  }
  t.getErrorCode = a;
  function s(v) {
    return (
      typeof v == "object" &&
      v !== null &&
      (typeof v.code == "number" || typeof v.errorCode == "number")
    );
  }
  function o(v, { shouldIncludeStack: E = !1 } = {}) {
    const A = {};
    if (
      v &&
      typeof v == "object" &&
      !Array.isArray(v) &&
      d(v, "code") &&
      i(v.code)
    ) {
      const I = v;
      (A.code = I.code),
        I.message && typeof I.message == "string"
          ? ((A.message = I.message), d(I, "data") && (A.data = I.data))
          : ((A.message = n(A.code)),
            (A.data = {
              originalError: u(v),
            }));
    } else
      (A.code = e.standardErrorCodes.rpc.internal),
        (A.message = m(v, "message") ? v.message : r),
        (A.data = {
          originalError: u(v),
        });
    return E && (A.stack = m(v, "stack") ? v.stack : void 0), A;
  }
  t.serialize = o;
  function c(v) {
    return v >= -32099 && v <= -32e3;
  }
  function u(v) {
    return v && typeof v == "object" && !Array.isArray(v)
      ? Object.assign({}, v)
      : v;
  }
  function d(v, E) {
    return Object.prototype.hasOwnProperty.call(v, E);
  }
  function m(v, E) {
    return (
      typeof v == "object" && v !== null && E in v && typeof v[E] == "string"
    );
  }
})(Hv);
Object.defineProperty(jv, "__esModule", {
  value: !0,
});
jv.standardErrors = void 0;
const Ln = Jo,
  v$ = Hv;
jv.standardErrors = {
  rpc: {
    parse: (t) => Ca(Ln.standardErrorCodes.rpc.parse, t),
    invalidRequest: (t) => Ca(Ln.standardErrorCodes.rpc.invalidRequest, t),
    invalidParams: (t) => Ca(Ln.standardErrorCodes.rpc.invalidParams, t),
    methodNotFound: (t) => Ca(Ln.standardErrorCodes.rpc.methodNotFound, t),
    internal: (t) => Ca(Ln.standardErrorCodes.rpc.internal, t),
    server: (t) => {
      if (!t || typeof t != "object" || Array.isArray(t))
        throw new Error(
          "Ethereum RPC Server errors must provide single object argument."
        );
      const { code: e } = t;
      if (!Number.isInteger(e) || e > -32005 || e < -32099)
        throw new Error(
          '"code" must be an integer such that: -32099 <= code <= -32005'
        );
      return Ca(e, t);
    },
    invalidInput: (t) => Ca(Ln.standardErrorCodes.rpc.invalidInput, t),
    resourceNotFound: (t) => Ca(Ln.standardErrorCodes.rpc.resourceNotFound, t),
    resourceUnavailable: (t) =>
      Ca(Ln.standardErrorCodes.rpc.resourceUnavailable, t),
    transactionRejected: (t) =>
      Ca(Ln.standardErrorCodes.rpc.transactionRejected, t),
    methodNotSupported: (t) =>
      Ca(Ln.standardErrorCodes.rpc.methodNotSupported, t),
    limitExceeded: (t) => Ca(Ln.standardErrorCodes.rpc.limitExceeded, t),
  },
  provider: {
    userRejectedRequest: (t) =>
      n0(Ln.standardErrorCodes.provider.userRejectedRequest, t),
    unauthorized: (t) => n0(Ln.standardErrorCodes.provider.unauthorized, t),
    unsupportedMethod: (t) =>
      n0(Ln.standardErrorCodes.provider.unsupportedMethod, t),
    disconnected: (t) => n0(Ln.standardErrorCodes.provider.disconnected, t),
    chainDisconnected: (t) =>
      n0(Ln.standardErrorCodes.provider.chainDisconnected, t),
    unsupportedChain: (t) =>
      n0(Ln.standardErrorCodes.provider.unsupportedChain, t),
    custom: (t) => {
      if (!t || typeof t != "object" || Array.isArray(t))
        throw new Error(
          "Ethereum Provider custom errors must provide single object argument."
        );
      const { code: e, message: r, data: n } = t;
      if (!r || typeof r != "string")
        throw new Error('"message" must be a nonempty string');
      return new _$(e, r, n);
    },
  },
};
function Ca(t, e) {
  const [r, n] = x$(e);
  return new w$(t, r || (0, v$.getMessageFromCode)(t), n);
}
function n0(t, e) {
  const [r, n] = x$(e);
  return new _$(t, r || (0, v$.getMessageFromCode)(t), n);
}
function x$(t) {
  if (t) {
    if (typeof t == "string") return [t];
    if (typeof t == "object" && !Array.isArray(t)) {
      const { message: e, data: r } = t;
      if (e && typeof e != "string")
        throw new Error("Must specify string message.");
      return [e || void 0, r];
    }
  }
  return [];
}
let w$ = class extends Error {
    constructor(e, r, n) {
      if (!Number.isInteger(e)) throw new Error('"code" must be an integer.');
      if (!r || typeof r != "string")
        throw new Error('"message" must be a nonempty string.');
      super(r), (this.code = e), n !== void 0 && (this.data = n);
    }
  },
  _$ = class extends w$ {
    constructor(e, r, n) {
      if (!fme(e))
        throw new Error(
          '"code" must be an integer such that: 1000 <= code <= 4999'
        );
      super(e, r, n);
    }
  };
function fme(t) {
  return Number.isInteger(t) && t >= 1e3 && t <= 4999;
}
var zv = {},
  kd = {};
Object.defineProperty(kd, "__esModule", {
  value: !0,
});
kd.isErrorResponse = void 0;
function dme(t) {
  return t.errorMessage !== void 0;
}
kd.isErrorResponse = dme;
var Sd = {};
Object.defineProperty(Sd, "__esModule", {
  value: !0,
});
Sd.LIB_VERSION = void 0;
Sd.LIB_VERSION = "3.9.3";
Object.defineProperty(zv, "__esModule", {
  value: !0,
});
zv.serializeError = void 0;
const hme = kd,
  pme = Sd,
  mme = Jo,
  yme = Hv;
function gme(t, e) {
  const r = (0, yme.serialize)(bme(t), {
      shouldIncludeStack: !0,
    }),
    n = new URL("https://docs.cloud.coinbase.com/wallet-sdk/docs/errors");
  n.searchParams.set("version", pme.LIB_VERSION),
    n.searchParams.set("code", r.code.toString());
  const i = vme(r.data, e);
  return (
    i && n.searchParams.set("method", i),
    n.searchParams.set("message", r.message),
    Object.assign(Object.assign({}, r), {
      docUrl: n.href,
    })
  );
}
zv.serializeError = gme;
function bme(t) {
  return typeof t == "string"
    ? {
        message: t,
        code: mme.standardErrorCodes.rpc.internal,
      }
    : (0, hme.isErrorResponse)(t)
    ? Object.assign(Object.assign({}, t), {
        message: t.errorMessage,
        code: t.errorCode,
        data: {
          method: t.method,
        },
      })
    : t;
}
function vme(t, e) {
  const r = t == null ? void 0 : t.method;
  if (r) return r;
  if (e !== void 0) {
    if (typeof e == "string") return e;
    if (Array.isArray(e)) {
      if (e.length > 0) return e[0].method;
    } else return e.method;
  }
}
(function (t) {
  Object.defineProperty(t, "__esModule", {
    value: !0,
  }),
    (t.standardErrors =
      t.standardErrorCodes =
      t.serializeError =
      t.getMessageFromCode =
      t.getErrorCode =
        void 0);
  const e = Jo;
  Object.defineProperty(t, "standardErrorCodes", {
    enumerable: !0,
    get: function () {
      return e.standardErrorCodes;
    },
  });
  const r = jv;
  Object.defineProperty(t, "standardErrors", {
    enumerable: !0,
    get: function () {
      return r.standardErrors;
    },
  });
  const n = zv;
  Object.defineProperty(t, "serializeError", {
    enumerable: !0,
    get: function () {
      return n.serializeError;
    },
  });
  const i = Hv;
  Object.defineProperty(t, "getErrorCode", {
    enumerable: !0,
    get: function () {
      return i.getErrorCode;
    },
  }),
    Object.defineProperty(t, "getMessageFromCode", {
      enumerable: !0,
      get: function () {
        return i.getMessageFromCode;
      },
    });
})(Vm);
var En = {};
Object.defineProperty(En, "__esModule", {
  value: !0,
});
En.ProviderType =
  En.RegExpString =
  En.IntNumber =
  En.BigIntString =
  En.AddressString =
  En.HexString =
  En.OpaqueType =
    void 0;
function Km() {
  return (t) => t;
}
En.OpaqueType = Km;
En.HexString = Km();
En.AddressString = Km();
En.BigIntString = Km();
function xme(t) {
  return Math.floor(t);
}
En.IntNumber = xme;
En.RegExpString = Km();
var C9;
(function (t) {
  (t.CoinbaseWallet = "CoinbaseWallet"),
    (t.MetaMask = "MetaMask"),
    (t.Unselected = "");
})(C9 || (En.ProviderType = C9 = {}));
var wme =
  (ke && ke.__importDefault) ||
  function (t) {
    return t && t.__esModule
      ? t
      : {
          default: t,
        };
  };
Object.defineProperty(ot, "__esModule", {
  value: !0,
});
ot.isMobileWeb =
  ot.getLocation =
  ot.isInIFrame =
  ot.createQrUrl =
  ot.getFavicon =
  ot.range =
  ot.isBigNumber =
  ot.ensureParsedJSONObject =
  ot.ensureBN =
  ot.ensureRegExpString =
  ot.ensureIntNumber =
  ot.ensureBuffer =
  ot.ensureAddressString =
  ot.ensureEvenLengthHexString =
  ot.ensureHexString =
  ot.isHexString =
  ot.prepend0x =
  ot.strip0x =
  ot.has0xPrefix =
  ot.hexStringFromIntNumber =
  ot.intNumberFromHexString =
  ot.bigIntStringFromBN =
  ot.hexStringFromBuffer =
  ot.hexStringToUint8Array =
  ot.uint8ArrayToHex =
  ot.randomBytesHex =
    void 0;
const xc = wme(Nm),
  Uu = Vm,
  Ua = En,
  E$ = /^[0-9]*$/,
  T$ = /^[a-f0-9]*$/;
function _me(t) {
  return C$(crypto.getRandomValues(new Uint8Array(t)));
}
ot.randomBytesHex = _me;
function C$(t) {
  return [...t].map((e) => e.toString(16).padStart(2, "0")).join("");
}
ot.uint8ArrayToHex = C$;
function Eme(t) {
  return new Uint8Array(t.match(/.{1,2}/g).map((e) => parseInt(e, 16)));
}
ot.hexStringToUint8Array = Eme;
function Tme(t, e = !1) {
  const r = t.toString("hex");
  return (0, Ua.HexString)(e ? `0x${r}` : r);
}
ot.hexStringFromBuffer = Tme;
function Cme(t) {
  return (0, Ua.BigIntString)(t.toString(10));
}
ot.bigIntStringFromBN = Cme;
function Ame(t) {
  return (0, Ua.IntNumber)(new xc.default(Zm(t, !1), 16).toNumber());
}
ot.intNumberFromHexString = Ame;
function kme(t) {
  return (0, Ua.HexString)(`0x${new xc.default(t).toString(16)}`);
}
ot.hexStringFromIntNumber = kme;
function XE(t) {
  return t.startsWith("0x") || t.startsWith("0X");
}
ot.has0xPrefix = XE;
function qv(t) {
  return XE(t) ? t.slice(2) : t;
}
ot.strip0x = qv;
function A$(t) {
  return XE(t) ? `0x${t.slice(2)}` : `0x${t}`;
}
ot.prepend0x = A$;
function Gm(t) {
  if (typeof t != "string") return !1;
  const e = qv(t).toLowerCase();
  return T$.test(e);
}
ot.isHexString = Gm;
function k$(t, e = !1) {
  if (typeof t == "string") {
    const r = qv(t).toLowerCase();
    if (T$.test(r)) return (0, Ua.HexString)(e ? `0x${r}` : r);
  }
  throw Uu.standardErrors.rpc.invalidParams(
    `"${String(t)}" is not a hexadecimal string`
  );
}
ot.ensureHexString = k$;
function Zm(t, e = !1) {
  let r = k$(t, !1);
  return (
    r.length % 2 === 1 && (r = (0, Ua.HexString)(`0${r}`)),
    e ? (0, Ua.HexString)(`0x${r}`) : r
  );
}
ot.ensureEvenLengthHexString = Zm;
function Sme(t) {
  if (typeof t == "string") {
    const e = qv(t).toLowerCase();
    if (Gm(e) && e.length === 40) return (0, Ua.AddressString)(A$(e));
  }
  throw Uu.standardErrors.rpc.invalidParams(
    `Invalid Ethereum address: ${String(t)}`
  );
}
ot.ensureAddressString = Sme;
function Mme(t) {
  if (Buffer.isBuffer(t)) return t;
  if (typeof t == "string") {
    if (Gm(t)) {
      const e = Zm(t, !1);
      return Buffer.from(e, "hex");
    }
    return Buffer.from(t, "utf8");
  }
  throw Uu.standardErrors.rpc.invalidParams(`Not binary data: ${String(t)}`);
}
ot.ensureBuffer = Mme;
function S$(t) {
  if (typeof t == "number" && Number.isInteger(t)) return (0, Ua.IntNumber)(t);
  if (typeof t == "string") {
    if (E$.test(t)) return (0, Ua.IntNumber)(Number(t));
    if (Gm(t))
      return (0, Ua.IntNumber)(new xc.default(Zm(t, !1), 16).toNumber());
  }
  throw Uu.standardErrors.rpc.invalidParams(`Not an integer: ${String(t)}`);
}
ot.ensureIntNumber = S$;
function Ime(t) {
  if (t instanceof RegExp) return (0, Ua.RegExpString)(t.toString());
  throw Uu.standardErrors.rpc.invalidParams(`Not a RegExp: ${String(t)}`);
}
ot.ensureRegExpString = Ime;
function Rme(t) {
  if (t !== null && (xc.default.isBN(t) || M$(t)))
    return new xc.default(t.toString(10), 10);
  if (typeof t == "number") return new xc.default(S$(t));
  if (typeof t == "string") {
    if (E$.test(t)) return new xc.default(t, 10);
    if (Gm(t)) return new xc.default(Zm(t, !1), 16);
  }
  throw Uu.standardErrors.rpc.invalidParams(`Not an integer: ${String(t)}`);
}
ot.ensureBN = Rme;
function Pme(t) {
  if (typeof t == "string") return JSON.parse(t);
  if (typeof t == "object") return t;
  throw Uu.standardErrors.rpc.invalidParams(
    `Not a JSON string or an object: ${String(t)}`
  );
}
ot.ensureParsedJSONObject = Pme;
function M$(t) {
  if (t == null || typeof t.constructor != "function") return !1;
  const { constructor: e } = t;
  return typeof e.config == "function" && typeof e.EUCLID == "number";
}
ot.isBigNumber = M$;
function Nme(t, e) {
  return Array.from(
    {
      length: e - t,
    },
    (r, n) => t + n
  );
}
ot.range = Nme;
function Bme() {
  const t =
      document.querySelector('link[sizes="192x192"]') ||
      document.querySelector('link[sizes="180x180"]') ||
      document.querySelector('link[rel="icon"]') ||
      document.querySelector('link[rel="shortcut icon"]'),
    { protocol: e, host: r } = document.location,
    n = t ? t.getAttribute("href") : null;
  return !n || n.startsWith("javascript:") || n.startsWith("vbscript:")
    ? null
    : n.startsWith("http://") ||
      n.startsWith("https://") ||
      n.startsWith("data:")
    ? n
    : n.startsWith("//")
    ? e + n
    : `${e}//${r}${n}`;
}
ot.getFavicon = Bme;
function Dme(t, e, r, n, i, a) {
  const s = n ? "parent-id" : "id",
    o = new URLSearchParams({
      [s]: t,
      secret: e,
      server: r,
      v: i,
      chainId: a.toString(),
    }).toString();
  return `${r}/#/link?${o}`;
}
ot.createQrUrl = Dme;
function I$() {
  try {
    return window.frameElement !== null;
  } catch {
    return !1;
  }
}
ot.isInIFrame = I$;
function Ome() {
  try {
    return I$() && window.top ? window.top.location : window.location;
  } catch {
    return window.location;
  }
}
ot.getLocation = Ome;
function Fme() {
  var t;
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
    (t = window == null ? void 0 : window.navigator) === null || t === void 0
      ? void 0
      : t.userAgent
  );
}
ot.isMobileWeb = Fme;
var Vv = {};
Object.defineProperty(Vv, "__esModule", {
  value: !0,
});
Vv.ScopedLocalStorage = void 0;
class Lme {
  constructor(e) {
    this.scope = e;
  }
  setItem(e, r) {
    localStorage.setItem(this.scopedKey(e), r);
  }
  getItem(e) {
    return localStorage.getItem(this.scopedKey(e));
  }
  removeItem(e) {
    localStorage.removeItem(this.scopedKey(e));
  }
  clear() {
    const e = this.scopedKey(""),
      r = [];
    for (let n = 0; n < localStorage.length; n++) {
      const i = localStorage.key(n);
      typeof i == "string" && i.startsWith(e) && r.push(i);
    }
    r.forEach((n) => localStorage.removeItem(n));
  }
  scopedKey(e) {
    return `${this.scope}:${e}`;
  }
}
Vv.ScopedLocalStorage = Lme;
var Wf = {};
const $me = Pt(Qle);
var Jm = {},
  Qm = {},
  Md = {};
Object.defineProperty(Md, "__esModule", {
  value: !0,
});
Md.EVENTS = void 0;
Md.EVENTS = {
  STARTED_CONNECTING: "walletlink_sdk.started.connecting",
  CONNECTED_STATE_CHANGE: "walletlink_sdk.connected",
  DISCONNECTED: "walletlink_sdk.disconnected",
  METADATA_DESTROYED: "walletlink_sdk_metadata_destroyed",
  LINKED: "walletlink_sdk.linked",
  FAILURE: "walletlink_sdk.generic_failure",
  SESSION_CONFIG_RECEIVED: "walletlink_sdk.session_config_event_received",
  ETH_ACCOUNTS_STATE: "walletlink_sdk.eth_accounts_state",
  SESSION_STATE_CHANGE: "walletlink_sdk.session_state_change",
  UNLINKED_ERROR_STATE: "walletlink_sdk.unlinked_error_state",
  SKIPPED_CLEARING_SESSION: "walletlink_sdk.skipped_clearing_session",
  GENERAL_ERROR: "walletlink_sdk.general_error",
  WEB3_REQUEST: "walletlink_sdk.web3.request",
  WEB3_REQUEST_PUBLISHED: "walletlink_sdk.web3.request_published",
  WEB3_RESPONSE: "walletlink_sdk.web3.response",
  METHOD_NOT_IMPLEMENTED: "walletlink_sdk.method_not_implemented",
  UNKNOWN_ADDRESS_ENCOUNTERED: "walletlink_sdk.unknown_address_encountered",
};
var La = {};
Object.defineProperty(La, "__esModule", {
  value: !0,
});
La.RelayAbstract =
  La.APP_VERSION_KEY =
  La.LOCAL_STORAGE_ADDRESSES_KEY =
  La.WALLET_USER_NAME_KEY =
    void 0;
const A9 = Vm;
La.WALLET_USER_NAME_KEY = "walletUsername";
La.LOCAL_STORAGE_ADDRESSES_KEY = "Addresses";
La.APP_VERSION_KEY = "AppVersion";
class Ume {
  async makeEthereumJSONRPCRequest(e, r) {
    if (!r) throw new Error("Error: No jsonRpcUrl provided");
    return window
      .fetch(r, {
        method: "POST",
        body: JSON.stringify(e),
        mode: "cors",
        headers: {
          "Content-Type": "application/json",
        },
      })
      .then((n) => n.json())
      .then((n) => {
        if (!n) throw A9.standardErrors.rpc.parse({});
        const i = n,
          { error: a } = i;
        if (a) throw (0, A9.serializeError)(a, e.method);
        return i;
      });
  }
}
La.RelayAbstract = Ume;
var Id = {},
  R$ = {
    exports: {},
  },
  i4 = {
    exports: {},
  };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function (t, e) {
  var r = vo,
    n = r.Buffer;
  function i(s, o) {
    for (var c in s) o[c] = s[c];
  }
  n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow
    ? (t.exports = r)
    : (i(r, e), (e.Buffer = a));
  function a(s, o, c) {
    return n(s, o, c);
  }
  (a.prototype = Object.create(n.prototype)),
    i(n, a),
    (a.from = function (s, o, c) {
      if (typeof s == "number")
        throw new TypeError("Argument must not be a number");
      return n(s, o, c);
    }),
    (a.alloc = function (s, o, c) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      var u = n(s);
      return (
        o !== void 0
          ? typeof c == "string"
            ? u.fill(o, c)
            : u.fill(o)
          : u.fill(0),
        u
      );
    }),
    (a.allocUnsafe = function (s) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      return n(s);
    }),
    (a.allocUnsafeSlow = function (s) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      return r.SlowBuffer(s);
    });
})(i4, i4.exports);
var wl = i4.exports,
  P$ = wl.Buffer;
function Kv(t, e) {
  (this._block = P$.alloc(t)),
    (this._finalSize = e),
    (this._blockSize = t),
    (this._len = 0);
}
Kv.prototype.update = function (t, e) {
  typeof t == "string" && ((e = e || "utf8"), (t = P$.from(t, e)));
  for (
    var r = this._block,
      n = this._blockSize,
      i = t.length,
      a = this._len,
      s = 0;
    s < i;

  ) {
    for (var o = a % n, c = Math.min(i - s, n - o), u = 0; u < c; u++)
      r[o + u] = t[s + u];
    (a += c), (s += c), a % n === 0 && this._update(r);
  }
  return (this._len += i), this;
};
Kv.prototype.digest = function (t) {
  var e = this._len % this._blockSize;
  (this._block[e] = 128),
    this._block.fill(0, e + 1),
    e >= this._finalSize && (this._update(this._block), this._block.fill(0));
  var r = this._len * 8;
  if (r <= 4294967295) this._block.writeUInt32BE(r, this._blockSize - 4);
  else {
    var n = (r & 4294967295) >>> 0,
      i = (r - n) / 4294967296;
    this._block.writeUInt32BE(i, this._blockSize - 8),
      this._block.writeUInt32BE(n, this._blockSize - 4);
  }
  this._update(this._block);
  var a = this._hash();
  return t ? a.toString(t) : a;
};
Kv.prototype._update = function () {
  throw new Error("_update must be implemented by subclass");
};
var Rd = Kv,
  Wme = Ka,
  N$ = Rd,
  jme = wl.Buffer,
  Hme = [1518500249, 1859775393, -1894007588, -899497514],
  zme = new Array(80);
function Ym() {
  this.init(), (this._w = zme), N$.call(this, 64, 56);
}
Wme(Ym, N$);
Ym.prototype.init = function () {
  return (
    (this._a = 1732584193),
    (this._b = 4023233417),
    (this._c = 2562383102),
    (this._d = 271733878),
    (this._e = 3285377520),
    this
  );
};
function qme(t) {
  return (t << 5) | (t >>> 27);
}
function Vme(t) {
  return (t << 30) | (t >>> 2);
}
function Kme(t, e, r, n) {
  return t === 0
    ? (e & r) | (~e & n)
    : t === 2
    ? (e & r) | (e & n) | (r & n)
    : e ^ r ^ n;
}
Ym.prototype._update = function (t) {
  for (
    var e = this._w,
      r = this._a | 0,
      n = this._b | 0,
      i = this._c | 0,
      a = this._d | 0,
      s = this._e | 0,
      o = 0;
    o < 16;
    ++o
  )
    e[o] = t.readInt32BE(o * 4);
  for (; o < 80; ++o) e[o] = e[o - 3] ^ e[o - 8] ^ e[o - 14] ^ e[o - 16];
  for (var c = 0; c < 80; ++c) {
    var u = ~~(c / 20),
      d = (qme(r) + Kme(u, n, i, a) + s + e[c] + Hme[u]) | 0;
    (s = a), (a = i), (i = Vme(n)), (n = r), (r = d);
  }
  (this._a = (r + this._a) | 0),
    (this._b = (n + this._b) | 0),
    (this._c = (i + this._c) | 0),
    (this._d = (a + this._d) | 0),
    (this._e = (s + this._e) | 0);
};
Ym.prototype._hash = function () {
  var t = jme.allocUnsafe(20);
  return (
    t.writeInt32BE(this._a | 0, 0),
    t.writeInt32BE(this._b | 0, 4),
    t.writeInt32BE(this._c | 0, 8),
    t.writeInt32BE(this._d | 0, 12),
    t.writeInt32BE(this._e | 0, 16),
    t
  );
};
var Gme = Ym,
  Zme = Ka,
  B$ = Rd,
  Jme = wl.Buffer,
  Qme = [1518500249, 1859775393, -1894007588, -899497514],
  Yme = new Array(80);
function Xm() {
  this.init(), (this._w = Yme), B$.call(this, 64, 56);
}
Zme(Xm, B$);
Xm.prototype.init = function () {
  return (
    (this._a = 1732584193),
    (this._b = 4023233417),
    (this._c = 2562383102),
    (this._d = 271733878),
    (this._e = 3285377520),
    this
  );
};
function Xme(t) {
  return (t << 1) | (t >>> 31);
}
function e1e(t) {
  return (t << 5) | (t >>> 27);
}
function t1e(t) {
  return (t << 30) | (t >>> 2);
}
function r1e(t, e, r, n) {
  return t === 0
    ? (e & r) | (~e & n)
    : t === 2
    ? (e & r) | (e & n) | (r & n)
    : e ^ r ^ n;
}
Xm.prototype._update = function (t) {
  for (
    var e = this._w,
      r = this._a | 0,
      n = this._b | 0,
      i = this._c | 0,
      a = this._d | 0,
      s = this._e | 0,
      o = 0;
    o < 16;
    ++o
  )
    e[o] = t.readInt32BE(o * 4);
  for (; o < 80; ++o) e[o] = Xme(e[o - 3] ^ e[o - 8] ^ e[o - 14] ^ e[o - 16]);
  for (var c = 0; c < 80; ++c) {
    var u = ~~(c / 20),
      d = (e1e(r) + r1e(u, n, i, a) + s + e[c] + Qme[u]) | 0;
    (s = a), (a = i), (i = t1e(n)), (n = r), (r = d);
  }
  (this._a = (r + this._a) | 0),
    (this._b = (n + this._b) | 0),
    (this._c = (i + this._c) | 0),
    (this._d = (a + this._d) | 0),
    (this._e = (s + this._e) | 0);
};
Xm.prototype._hash = function () {
  var t = Jme.allocUnsafe(20);
  return (
    t.writeInt32BE(this._a | 0, 0),
    t.writeInt32BE(this._b | 0, 4),
    t.writeInt32BE(this._c | 0, 8),
    t.writeInt32BE(this._d | 0, 12),
    t.writeInt32BE(this._e | 0, 16),
    t
  );
};
var n1e = Xm,
  i1e = Ka,
  D$ = Rd,
  a1e = wl.Buffer,
  s1e = [
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
    2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
    1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
    264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711,
    113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
    1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
    3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
    1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424,
    2428436474, 2756734187, 3204031479, 3329325298,
  ],
  o1e = new Array(64);
function e1() {
  this.init(), (this._w = o1e), D$.call(this, 64, 56);
}
i1e(e1, D$);
e1.prototype.init = function () {
  return (
    (this._a = 1779033703),
    (this._b = 3144134277),
    (this._c = 1013904242),
    (this._d = 2773480762),
    (this._e = 1359893119),
    (this._f = 2600822924),
    (this._g = 528734635),
    (this._h = 1541459225),
    this
  );
};
function c1e(t, e, r) {
  return r ^ (t & (e ^ r));
}
function l1e(t, e, r) {
  return (t & e) | (r & (t | e));
}
function u1e(t) {
  return (
    ((t >>> 2) | (t << 30)) ^
    ((t >>> 13) | (t << 19)) ^
    ((t >>> 22) | (t << 10))
  );
}
function f1e(t) {
  return (
    ((t >>> 6) | (t << 26)) ^ ((t >>> 11) | (t << 21)) ^ ((t >>> 25) | (t << 7))
  );
}
function d1e(t) {
  return ((t >>> 7) | (t << 25)) ^ ((t >>> 18) | (t << 14)) ^ (t >>> 3);
}
function h1e(t) {
  return ((t >>> 17) | (t << 15)) ^ ((t >>> 19) | (t << 13)) ^ (t >>> 10);
}
e1.prototype._update = function (t) {
  for (
    var e = this._w,
      r = this._a | 0,
      n = this._b | 0,
      i = this._c | 0,
      a = this._d | 0,
      s = this._e | 0,
      o = this._f | 0,
      c = this._g | 0,
      u = this._h | 0,
      d = 0;
    d < 16;
    ++d
  )
    e[d] = t.readInt32BE(d * 4);
  for (; d < 64; ++d)
    e[d] = (h1e(e[d - 2]) + e[d - 7] + d1e(e[d - 15]) + e[d - 16]) | 0;
  for (var m = 0; m < 64; ++m) {
    var v = (u + f1e(s) + c1e(s, o, c) + s1e[m] + e[m]) | 0,
      E = (u1e(r) + l1e(r, n, i)) | 0;
    (u = c),
      (c = o),
      (o = s),
      (s = (a + v) | 0),
      (a = i),
      (i = n),
      (n = r),
      (r = (v + E) | 0);
  }
  (this._a = (r + this._a) | 0),
    (this._b = (n + this._b) | 0),
    (this._c = (i + this._c) | 0),
    (this._d = (a + this._d) | 0),
    (this._e = (s + this._e) | 0),
    (this._f = (o + this._f) | 0),
    (this._g = (c + this._g) | 0),
    (this._h = (u + this._h) | 0);
};
e1.prototype._hash = function () {
  var t = a1e.allocUnsafe(32);
  return (
    t.writeInt32BE(this._a, 0),
    t.writeInt32BE(this._b, 4),
    t.writeInt32BE(this._c, 8),
    t.writeInt32BE(this._d, 12),
    t.writeInt32BE(this._e, 16),
    t.writeInt32BE(this._f, 20),
    t.writeInt32BE(this._g, 24),
    t.writeInt32BE(this._h, 28),
    t
  );
};
var O$ = e1,
  p1e = Ka,
  m1e = O$,
  y1e = Rd,
  g1e = wl.Buffer,
  b1e = new Array(64);
function Gv() {
  this.init(), (this._w = b1e), y1e.call(this, 64, 56);
}
p1e(Gv, m1e);
Gv.prototype.init = function () {
  return (
    (this._a = 3238371032),
    (this._b = 914150663),
    (this._c = 812702999),
    (this._d = 4144912697),
    (this._e = 4290775857),
    (this._f = 1750603025),
    (this._g = 1694076839),
    (this._h = 3204075428),
    this
  );
};
Gv.prototype._hash = function () {
  var t = g1e.allocUnsafe(28);
  return (
    t.writeInt32BE(this._a, 0),
    t.writeInt32BE(this._b, 4),
    t.writeInt32BE(this._c, 8),
    t.writeInt32BE(this._d, 12),
    t.writeInt32BE(this._e, 16),
    t.writeInt32BE(this._f, 20),
    t.writeInt32BE(this._g, 24),
    t
  );
};
var v1e = Gv,
  x1e = Ka,
  F$ = Rd,
  w1e = wl.Buffer,
  k9 = [
    1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399,
    3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265,
    2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394,
    310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994,
    1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317,
    3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139,
    264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901,
    1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837,
    2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879,
    3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901,
    113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964,
    773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823,
    1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142,
    2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273,
    3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344,
    3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720,
    430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593,
    883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403,
    1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012,
    2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044,
    2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573,
    3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711,
    3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554,
    174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315,
    685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100,
    1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866,
    1607167915, 987167468, 1816402316, 1246189591,
  ],
  _1e = new Array(160);
function t1() {
  this.init(), (this._w = _1e), F$.call(this, 128, 112);
}
x1e(t1, F$);
t1.prototype.init = function () {
  return (
    (this._ah = 1779033703),
    (this._bh = 3144134277),
    (this._ch = 1013904242),
    (this._dh = 2773480762),
    (this._eh = 1359893119),
    (this._fh = 2600822924),
    (this._gh = 528734635),
    (this._hh = 1541459225),
    (this._al = 4089235720),
    (this._bl = 2227873595),
    (this._cl = 4271175723),
    (this._dl = 1595750129),
    (this._el = 2917565137),
    (this._fl = 725511199),
    (this._gl = 4215389547),
    (this._hl = 327033209),
    this
  );
};
function S9(t, e, r) {
  return r ^ (t & (e ^ r));
}
function M9(t, e, r) {
  return (t & e) | (r & (t | e));
}
function I9(t, e) {
  return (
    ((t >>> 28) | (e << 4)) ^ ((e >>> 2) | (t << 30)) ^ ((e >>> 7) | (t << 25))
  );
}
function R9(t, e) {
  return (
    ((t >>> 14) | (e << 18)) ^
    ((t >>> 18) | (e << 14)) ^
    ((e >>> 9) | (t << 23))
  );
}
function E1e(t, e) {
  return ((t >>> 1) | (e << 31)) ^ ((t >>> 8) | (e << 24)) ^ (t >>> 7);
}
function T1e(t, e) {
  return (
    ((t >>> 1) | (e << 31)) ^ ((t >>> 8) | (e << 24)) ^ ((t >>> 7) | (e << 25))
  );
}
function C1e(t, e) {
  return ((t >>> 19) | (e << 13)) ^ ((e >>> 29) | (t << 3)) ^ (t >>> 6);
}
function A1e(t, e) {
  return (
    ((t >>> 19) | (e << 13)) ^ ((e >>> 29) | (t << 3)) ^ ((t >>> 6) | (e << 26))
  );
}
function Sn(t, e) {
  return t >>> 0 < e >>> 0 ? 1 : 0;
}
t1.prototype._update = function (t) {
  for (
    var e = this._w,
      r = this._ah | 0,
      n = this._bh | 0,
      i = this._ch | 0,
      a = this._dh | 0,
      s = this._eh | 0,
      o = this._fh | 0,
      c = this._gh | 0,
      u = this._hh | 0,
      d = this._al | 0,
      m = this._bl | 0,
      v = this._cl | 0,
      E = this._dl | 0,
      A = this._el | 0,
      I = this._fl | 0,
      b = this._gl | 0,
      w = this._hl | 0,
      S = 0;
    S < 32;
    S += 2
  )
    (e[S] = t.readInt32BE(S * 4)), (e[S + 1] = t.readInt32BE(S * 4 + 4));
  for (; S < 160; S += 2) {
    var k = e[S - 30],
      N = e[S - 15 * 2 + 1],
      O = E1e(k, N),
      F = T1e(N, k);
    (k = e[S - 2 * 2]), (N = e[S - 2 * 2 + 1]);
    var V = C1e(k, N),
      j = A1e(N, k),
      X = e[S - 7 * 2],
      C = e[S - 7 * 2 + 1],
      l = e[S - 16 * 2],
      p = e[S - 16 * 2 + 1],
      y = (F + C) | 0,
      h = (O + X + Sn(y, F)) | 0;
    (y = (y + j) | 0),
      (h = (h + V + Sn(y, j)) | 0),
      (y = (y + p) | 0),
      (h = (h + l + Sn(y, p)) | 0),
      (e[S] = h),
      (e[S + 1] = y);
  }
  for (var g = 0; g < 160; g += 2) {
    (h = e[g]), (y = e[g + 1]);
    var T = M9(r, n, i),
      R = M9(d, m, v),
      x = I9(r, d),
      f = I9(d, r),
      _ = R9(s, A),
      P = R9(A, s),
      M = k9[g],
      D = k9[g + 1],
      q = S9(s, o, c),
      B = S9(A, I, b),
      H = (w + P) | 0,
      Q = (u + _ + Sn(H, w)) | 0;
    (H = (H + B) | 0),
      (Q = (Q + q + Sn(H, B)) | 0),
      (H = (H + D) | 0),
      (Q = (Q + M + Sn(H, D)) | 0),
      (H = (H + y) | 0),
      (Q = (Q + h + Sn(H, y)) | 0);
    var Z = (f + R) | 0,
      te = (x + T + Sn(Z, f)) | 0;
    (u = c),
      (w = b),
      (c = o),
      (b = I),
      (o = s),
      (I = A),
      (A = (E + H) | 0),
      (s = (a + Q + Sn(A, E)) | 0),
      (a = i),
      (E = v),
      (i = n),
      (v = m),
      (n = r),
      (m = d),
      (d = (H + Z) | 0),
      (r = (Q + te + Sn(d, H)) | 0);
  }
  (this._al = (this._al + d) | 0),
    (this._bl = (this._bl + m) | 0),
    (this._cl = (this._cl + v) | 0),
    (this._dl = (this._dl + E) | 0),
    (this._el = (this._el + A) | 0),
    (this._fl = (this._fl + I) | 0),
    (this._gl = (this._gl + b) | 0),
    (this._hl = (this._hl + w) | 0),
    (this._ah = (this._ah + r + Sn(this._al, d)) | 0),
    (this._bh = (this._bh + n + Sn(this._bl, m)) | 0),
    (this._ch = (this._ch + i + Sn(this._cl, v)) | 0),
    (this._dh = (this._dh + a + Sn(this._dl, E)) | 0),
    (this._eh = (this._eh + s + Sn(this._el, A)) | 0),
    (this._fh = (this._fh + o + Sn(this._fl, I)) | 0),
    (this._gh = (this._gh + c + Sn(this._gl, b)) | 0),
    (this._hh = (this._hh + u + Sn(this._hl, w)) | 0);
};
t1.prototype._hash = function () {
  var t = w1e.allocUnsafe(64);
  function e(r, n, i) {
    t.writeInt32BE(r, i), t.writeInt32BE(n, i + 4);
  }
  return (
    e(this._ah, this._al, 0),
    e(this._bh, this._bl, 8),
    e(this._ch, this._cl, 16),
    e(this._dh, this._dl, 24),
    e(this._eh, this._el, 32),
    e(this._fh, this._fl, 40),
    e(this._gh, this._gl, 48),
    e(this._hh, this._hl, 56),
    t
  );
};
var L$ = t1,
  k1e = Ka,
  S1e = L$,
  M1e = Rd,
  I1e = wl.Buffer,
  R1e = new Array(160);
function Zv() {
  this.init(), (this._w = R1e), M1e.call(this, 128, 112);
}
k1e(Zv, S1e);
Zv.prototype.init = function () {
  return (
    (this._ah = 3418070365),
    (this._bh = 1654270250),
    (this._ch = 2438529370),
    (this._dh = 355462360),
    (this._eh = 1731405415),
    (this._fh = 2394180231),
    (this._gh = 3675008525),
    (this._hh = 1203062813),
    (this._al = 3238371032),
    (this._bl = 914150663),
    (this._cl = 812702999),
    (this._dl = 4144912697),
    (this._el = 4290775857),
    (this._fl = 1750603025),
    (this._gl = 1694076839),
    (this._hl = 3204075428),
    this
  );
};
Zv.prototype._hash = function () {
  var t = I1e.allocUnsafe(48);
  function e(r, n, i) {
    t.writeInt32BE(r, i), t.writeInt32BE(n, i + 4);
  }
  return (
    e(this._ah, this._al, 0),
    e(this._bh, this._bl, 8),
    e(this._ch, this._cl, 16),
    e(this._dh, this._dl, 24),
    e(this._eh, this._el, 32),
    e(this._fh, this._fl, 40),
    t
  );
};
var P1e = Zv,
  Wu = (R$.exports = function (e) {
    e = e.toLowerCase();
    var r = Wu[e];
    if (!r) throw new Error(e + " is not supported (we accept pull requests)");
    return new r();
  });
Wu.sha = Gme;
Wu.sha1 = n1e;
Wu.sha224 = v1e;
Wu.sha256 = O$;
Wu.sha384 = P1e;
Wu.sha512 = L$;
var N1e = R$.exports;
Object.defineProperty(Id, "__esModule", {
  value: !0,
});
Id.Session = void 0;
const P9 = N1e,
  N9 = ot,
  B9 = "session:id",
  D9 = "session:secret",
  O9 = "session:linked";
class eT {
  constructor(e, r, n, i) {
    (this._storage = e),
      (this._id = r || (0, N9.randomBytesHex)(16)),
      (this._secret = n || (0, N9.randomBytesHex)(32)),
      (this._key = new P9.sha256()
        .update(`${this._id}, ${this._secret} WalletLink`)
        .digest("hex")),
      (this._linked = !!i);
  }
  static load(e) {
    const r = e.getItem(B9),
      n = e.getItem(O9),
      i = e.getItem(D9);
    return r && i ? new eT(e, r, i, n === "1") : null;
  }
  static hash(e) {
    return new P9.sha256().update(e).digest("hex");
  }
  get id() {
    return this._id;
  }
  get secret() {
    return this._secret;
  }
  get key() {
    return this._key;
  }
  get linked() {
    return this._linked;
  }
  set linked(e) {
    (this._linked = e), this.persistLinked();
  }
  save() {
    return (
      this._storage.setItem(B9, this._id),
      this._storage.setItem(D9, this._secret),
      this.persistLinked(),
      this
    );
  }
  persistLinked() {
    this._storage.setItem(O9, this._linked ? "1" : "0");
  }
}
Id.Session = eT;
var Jv = {},
  Qv = {};
Object.defineProperty(Qv, "__esModule", {
  value: !0,
});
Qv.Cipher = void 0;
const fy = ot;
class B1e {
  constructor(e) {
    this.secret = e;
  }
  async encrypt(e) {
    const r = this.secret;
    if (r.length !== 64) throw Error("secret must be 256 bits");
    const n = crypto.getRandomValues(new Uint8Array(12)),
      i = await crypto.subtle.importKey(
        "raw",
        (0, fy.hexStringToUint8Array)(r),
        {
          name: "aes-gcm",
        },
        !1,
        ["encrypt", "decrypt"]
      ),
      a = new TextEncoder(),
      s = await window.crypto.subtle.encrypt(
        {
          name: "AES-GCM",
          iv: n,
        },
        i,
        a.encode(e)
      ),
      o = 16,
      c = s.slice(s.byteLength - o),
      u = s.slice(0, s.byteLength - o),
      d = new Uint8Array(c),
      m = new Uint8Array(u),
      v = new Uint8Array([...n, ...d, ...m]);
    return (0, fy.uint8ArrayToHex)(v);
  }
  async decrypt(e) {
    const r = this.secret;
    if (r.length !== 64) throw Error("secret must be 256 bits");
    return new Promise((n, i) => {
      (async function () {
        const a = await crypto.subtle.importKey(
            "raw",
            (0, fy.hexStringToUint8Array)(r),
            {
              name: "aes-gcm",
            },
            !1,
            ["encrypt", "decrypt"]
          ),
          s = (0, fy.hexStringToUint8Array)(e),
          o = s.slice(0, 12),
          c = s.slice(12, 28),
          u = s.slice(28),
          d = new Uint8Array([...u, ...c]),
          m = {
            name: "AES-GCM",
            iv: new Uint8Array(o),
          };
        try {
          const v = await window.crypto.subtle.decrypt(m, a, d),
            E = new TextDecoder();
          n(E.decode(v));
        } catch (v) {
          i(v);
        }
      })();
    });
  }
}
Qv.Cipher = B1e;
var Yv = {};
Object.defineProperty(Yv, "__esModule", {
  value: !0,
});
Yv.WalletLinkHTTP = void 0;
class D1e {
  constructor(e, r, n) {
    (this.linkAPIUrl = e), (this.sessionId = r);
    const i = `${r}:${n}`;
    this.auth = `Basic ${btoa(i)}`;
  }
  async markUnseenEventsAsSeen(e) {
    return Promise.all(
      e.map((r) =>
        fetch(`${this.linkAPIUrl}/events/${r.eventId}/seen`, {
          method: "POST",
          headers: {
            Authorization: this.auth,
          },
        })
      )
    ).catch((r) => console.error("Unabled to mark event as failed:", r));
  }
  async fetchUnseenEvents() {
    var e;
    const r = await fetch(`${this.linkAPIUrl}/events?unseen=true`, {
      headers: {
        Authorization: this.auth,
      },
    });
    if (r.ok) {
      const { events: n, error: i } = await r.json();
      if (i) throw new Error(`Check unseen events failed: ${i}`);
      const a =
        (e =
          n == null
            ? void 0
            : n
                .filter((s) => s.event === "Web3Response")
                .map((s) => ({
                  type: "Event",
                  sessionId: this.sessionId,
                  eventId: s.id,
                  event: s.event,
                  data: s.data,
                }))) !== null && e !== void 0
          ? e
          : [];
      return this.markUnseenEventsAsSeen(a), a;
    }
    throw new Error(`Check unseen events failed: ${r.status}`);
  }
}
Yv.WalletLinkHTTP = D1e;
var jf = {};
Object.defineProperty(jf, "__esModule", {
  value: !0,
});
jf.WalletLinkWebSocket = jf.ConnectionState = void 0;
var F0;
(function (t) {
  (t[(t.DISCONNECTED = 0)] = "DISCONNECTED"),
    (t[(t.CONNECTING = 1)] = "CONNECTING"),
    (t[(t.CONNECTED = 2)] = "CONNECTED");
})(F0 || (jf.ConnectionState = F0 = {}));
class O1e {
  setConnectionStateListener(e) {
    this.connectionStateListener = e;
  }
  setIncomingDataListener(e) {
    this.incomingDataListener = e;
  }
  constructor(e, r = WebSocket) {
    (this.WebSocketClass = r),
      (this.webSocket = null),
      (this.pendingData = []),
      (this.url = e.replace(/^http/, "ws"));
  }
  async connect() {
    if (this.webSocket) throw new Error("webSocket object is not null");
    return new Promise((e, r) => {
      var n;
      let i;
      try {
        this.webSocket = i = new this.WebSocketClass(this.url);
      } catch (a) {
        r(a);
        return;
      }
      (n = this.connectionStateListener) === null ||
        n === void 0 ||
        n.call(this, F0.CONNECTING),
        (i.onclose = (a) => {
          var s;
          this.clearWebSocket(),
            r(new Error(`websocket error ${a.code}: ${a.reason}`)),
            (s = this.connectionStateListener) === null ||
              s === void 0 ||
              s.call(this, F0.DISCONNECTED);
        }),
        (i.onopen = (a) => {
          var s;
          e(),
            (s = this.connectionStateListener) === null ||
              s === void 0 ||
              s.call(this, F0.CONNECTED),
            this.pendingData.length > 0 &&
              ([...this.pendingData].forEach((c) => this.sendData(c)),
              (this.pendingData = []));
        }),
        (i.onmessage = (a) => {
          var s, o;
          if (a.data === "h")
            (s = this.incomingDataListener) === null ||
              s === void 0 ||
              s.call(this, {
                type: "Heartbeat",
              });
          else
            try {
              const c = JSON.parse(a.data);
              (o = this.incomingDataListener) === null ||
                o === void 0 ||
                o.call(this, c);
            } catch {}
        });
    });
  }
  disconnect() {
    var e;
    const { webSocket: r } = this;
    if (r) {
      this.clearWebSocket(),
        (e = this.connectionStateListener) === null ||
          e === void 0 ||
          e.call(this, F0.DISCONNECTED),
        (this.connectionStateListener = void 0),
        (this.incomingDataListener = void 0);
      try {
        r.close();
      } catch {}
    }
  }
  sendData(e) {
    const { webSocket: r } = this;
    if (!r) {
      this.pendingData.push(e), this.connect();
      return;
    }
    r.send(e);
  }
  clearWebSocket() {
    const { webSocket: e } = this;
    e &&
      ((this.webSocket = null),
      (e.onclose = null),
      (e.onerror = null),
      (e.onmessage = null),
      (e.onopen = null));
  }
}
jf.WalletLinkWebSocket = O1e;
Object.defineProperty(Jv, "__esModule", {
  value: !0,
});
Jv.WalletLinkConnection = void 0;
const i0 = En,
  F1e = Qv,
  Ss = Md,
  F9 = La,
  a0 = Id,
  L1e = Yv,
  dy = jf,
  L9 = 1e4,
  $1e = 6e4;
class U1e {
  constructor({
    session: e,
    linkAPIUrl: r,
    listener: n,
    diagnostic: i,
    WebSocketClass: a = WebSocket,
  }) {
    (this.destroyed = !1),
      (this.lastHeartbeatResponse = 0),
      (this.nextReqId = (0, i0.IntNumber)(1)),
      (this._connected = !1),
      (this._linked = !1),
      (this.shouldFetchUnseenEventsOnConnect = !1),
      (this.requestResolutions = new Map()),
      (this.handleSessionMetadataUpdated = (o) => {
        if (!o) return;
        new Map([
          ["__destroyed", this.handleDestroyed],
          ["EthereumAddress", this.handleAccountUpdated],
          ["WalletUsername", this.handleWalletUsernameUpdated],
          ["AppVersion", this.handleAppVersionUpdated],
          [
            "ChainId",
            (u) => o.JsonRpcUrl && this.handleChainUpdated(u, o.JsonRpcUrl),
          ],
        ]).forEach((u, d) => {
          const m = o[d];
          m !== void 0 && u(m);
        });
      }),
      (this.handleDestroyed = (o) => {
        var c, u;
        o === "1" &&
          ((c = this.listener) === null || c === void 0 || c.resetAndReload(),
          (u = this.diagnostic) === null ||
            u === void 0 ||
            u.log(Ss.EVENTS.METADATA_DESTROYED, {
              alreadyDestroyed: this.isDestroyed,
              sessionIdHash: a0.Session.hash(this.session.id),
            }));
      }),
      (this.handleAccountUpdated = async (o) => {
        var c, u;
        try {
          const d = await this.cipher.decrypt(o);
          (c = this.listener) === null || c === void 0 || c.accountUpdated(d);
        } catch {
          (u = this.diagnostic) === null ||
            u === void 0 ||
            u.log(Ss.EVENTS.GENERAL_ERROR, {
              message: "Had error decrypting",
              value: "selectedAddress",
            });
        }
      }),
      (this.handleMetadataUpdated = async (o, c) => {
        var u, d;
        try {
          const m = await this.cipher.decrypt(c);
          (u = this.listener) === null ||
            u === void 0 ||
            u.metadataUpdated(o, m);
        } catch {
          (d = this.diagnostic) === null ||
            d === void 0 ||
            d.log(Ss.EVENTS.GENERAL_ERROR, {
              message: "Had error decrypting",
              value: o,
            });
        }
      }),
      (this.handleWalletUsernameUpdated = async (o) => {
        this.handleMetadataUpdated(F9.WALLET_USER_NAME_KEY, o);
      }),
      (this.handleAppVersionUpdated = async (o) => {
        this.handleMetadataUpdated(F9.APP_VERSION_KEY, o);
      }),
      (this.handleChainUpdated = async (o, c) => {
        var u, d;
        try {
          const m = await this.cipher.decrypt(o),
            v = await this.cipher.decrypt(c);
          (u = this.listener) === null || u === void 0 || u.chainUpdated(m, v);
        } catch {
          (d = this.diagnostic) === null ||
            d === void 0 ||
            d.log(Ss.EVENTS.GENERAL_ERROR, {
              message: "Had error decrypting",
              value: "chainId|jsonRpcUrl",
            });
        }
      }),
      (this.session = e),
      (this.cipher = new F1e.Cipher(e.secret)),
      (this.diagnostic = i),
      (this.listener = n);
    const s = new dy.WalletLinkWebSocket(`${r}/rpc`, a);
    s.setConnectionStateListener(async (o) => {
      var c;
      (c = this.diagnostic) === null ||
        c === void 0 ||
        c.log(Ss.EVENTS.CONNECTED_STATE_CHANGE, {
          state: o,
          sessionIdHash: a0.Session.hash(e.id),
        });
      let u = !1;
      switch (o) {
        case dy.ConnectionState.DISCONNECTED:
          if (!this.destroyed) {
            const d = async () => {
              await new Promise((m) => setTimeout(m, 5e3)),
                this.destroyed ||
                  s.connect().catch(() => {
                    d();
                  });
            };
            d();
          }
          break;
        case dy.ConnectionState.CONNECTED:
          try {
            await this.authenticate(),
              this.sendIsLinked(),
              this.sendGetSessionConfig(),
              (u = !0);
          } catch {}
          this.updateLastHeartbeat(),
            setInterval(() => {
              this.heartbeat();
            }, L9),
            this.shouldFetchUnseenEventsOnConnect &&
              this.fetchUnseenEventsAPI();
          break;
        case dy.ConnectionState.CONNECTING:
          break;
      }
      this.connected !== u && (this.connected = u);
    }),
      s.setIncomingDataListener((o) => {
        var c, u, d;
        switch (o.type) {
          case "Heartbeat":
            this.updateLastHeartbeat();
            return;
          case "IsLinkedOK":
          case "Linked": {
            const m = o.type === "IsLinkedOK" ? o.linked : void 0;
            (c = this.diagnostic) === null ||
              c === void 0 ||
              c.log(Ss.EVENTS.LINKED, {
                sessionIdHash: a0.Session.hash(e.id),
                linked: m,
                type: o.type,
                onlineGuests: o.onlineGuests,
              }),
              (this.linked = m || o.onlineGuests > 0);
            break;
          }
          case "GetSessionConfigOK":
          case "SessionConfigUpdated": {
            (u = this.diagnostic) === null ||
              u === void 0 ||
              u.log(Ss.EVENTS.SESSION_CONFIG_RECEIVED, {
                sessionIdHash: a0.Session.hash(e.id),
                metadata_keys:
                  o && o.metadata ? Object.keys(o.metadata) : void 0,
              }),
              this.handleSessionMetadataUpdated(o.metadata);
            break;
          }
          case "Event": {
            this.handleIncomingEvent(o);
            break;
          }
        }
        o.id !== void 0 &&
          ((d = this.requestResolutions.get(o.id)) === null ||
            d === void 0 ||
            d(o));
      }),
      (this.ws = s),
      (this.http = new L1e.WalletLinkHTTP(r, e.id, e.key));
  }
  connect() {
    var e;
    if (this.destroyed) throw new Error("instance is destroyed");
    (e = this.diagnostic) === null ||
      e === void 0 ||
      e.log(Ss.EVENTS.STARTED_CONNECTING, {
        sessionIdHash: a0.Session.hash(this.session.id),
      }),
      this.ws.connect();
  }
  destroy() {
    var e;
    (this.destroyed = !0),
      this.ws.disconnect(),
      (e = this.diagnostic) === null ||
        e === void 0 ||
        e.log(Ss.EVENTS.DISCONNECTED, {
          sessionIdHash: a0.Session.hash(this.session.id),
        }),
      (this.listener = void 0);
  }
  get isDestroyed() {
    return this.destroyed;
  }
  get connected() {
    return this._connected;
  }
  set connected(e) {
    var r, n;
    (this._connected = e),
      e && ((r = this.onceConnected) === null || r === void 0 || r.call(this)),
      (n = this.listener) === null || n === void 0 || n.connectedUpdated(e);
  }
  setOnceConnected(e) {
    return new Promise((r) => {
      this.connected
        ? e().then(r)
        : (this.onceConnected = () => {
            e().then(r), (this.onceConnected = void 0);
          });
    });
  }
  get linked() {
    return this._linked;
  }
  set linked(e) {
    var r, n;
    (this._linked = e),
      e && ((r = this.onceLinked) === null || r === void 0 || r.call(this)),
      (n = this.listener) === null || n === void 0 || n.linkedUpdated(e);
  }
  setOnceLinked(e) {
    return new Promise((r) => {
      this.linked
        ? e().then(r)
        : (this.onceLinked = () => {
            e().then(r), (this.onceLinked = void 0);
          });
    });
  }
  async handleIncomingEvent(e) {
    var r, n;
    if (!(e.type !== "Event" || e.event !== "Web3Response"))
      try {
        const i = await this.cipher.decrypt(e.data),
          a = JSON.parse(i);
        if (a.type !== "WEB3_RESPONSE") return;
        (r = this.listener) === null ||
          r === void 0 ||
          r.handleWeb3ResponseMessage(a);
      } catch {
        (n = this.diagnostic) === null ||
          n === void 0 ||
          n.log(Ss.EVENTS.GENERAL_ERROR, {
            message: "Had error decrypting",
            value: "incomingEvent",
          });
      }
  }
  async checkUnseenEvents() {
    if (!this.connected) {
      this.shouldFetchUnseenEventsOnConnect = !0;
      return;
    }
    await new Promise((e) => setTimeout(e, 250));
    try {
      await this.fetchUnseenEventsAPI();
    } catch (e) {
      console.error("Unable to check for unseen events", e);
    }
  }
  async fetchUnseenEventsAPI() {
    (this.shouldFetchUnseenEventsOnConnect = !1),
      (await this.http.fetchUnseenEvents()).forEach((r) =>
        this.handleIncomingEvent(r)
      );
  }
  async setSessionMetadata(e, r) {
    const n = {
      type: "SetSessionConfig",
      id: (0, i0.IntNumber)(this.nextReqId++),
      sessionId: this.session.id,
      metadata: {
        [e]: r,
      },
    };
    return this.setOnceConnected(async () => {
      const i = await this.makeRequest(n);
      if (i.type === "Fail")
        throw new Error(i.error || "failed to set session metadata");
    });
  }
  async publishEvent(e, r, n = !1) {
    const i = await this.cipher.encrypt(
        JSON.stringify(
          Object.assign(Object.assign({}, r), {
            origin: location.origin,
            relaySource: window.coinbaseWalletExtension
              ? "injected_sdk"
              : "sdk",
          })
        )
      ),
      a = {
        type: "PublishEvent",
        id: (0, i0.IntNumber)(this.nextReqId++),
        sessionId: this.session.id,
        event: e,
        data: i,
        callWebhook: n,
      };
    return this.setOnceLinked(async () => {
      const s = await this.makeRequest(a);
      if (s.type === "Fail")
        throw new Error(s.error || "failed to publish event");
      return s.eventId;
    });
  }
  sendData(e) {
    this.ws.sendData(JSON.stringify(e));
  }
  updateLastHeartbeat() {
    this.lastHeartbeatResponse = Date.now();
  }
  heartbeat() {
    if (Date.now() - this.lastHeartbeatResponse > L9 * 2) {
      this.ws.disconnect();
      return;
    }
    try {
      this.ws.sendData("h");
    } catch {}
  }
  async makeRequest(e, r = $1e) {
    const n = e.id;
    this.sendData(e);
    let i;
    return Promise.race([
      new Promise((a, s) => {
        i = window.setTimeout(() => {
          s(new Error(`request ${n} timed out`));
        }, r);
      }),
      new Promise((a) => {
        this.requestResolutions.set(n, (s) => {
          clearTimeout(i), a(s), this.requestResolutions.delete(n);
        });
      }),
    ]);
  }
  async authenticate() {
    const e = {
        type: "HostSession",
        id: (0, i0.IntNumber)(this.nextReqId++),
        sessionId: this.session.id,
        sessionKey: this.session.key,
      },
      r = await this.makeRequest(e);
    if (r.type === "Fail") throw new Error(r.error || "failed to authentcate");
  }
  sendIsLinked() {
    const e = {
      type: "IsLinked",
      id: (0, i0.IntNumber)(this.nextReqId++),
      sessionId: this.session.id,
    };
    this.sendData(e);
  }
  sendGetSessionConfig() {
    const e = {
      type: "GetSessionConfig",
      id: (0, i0.IntNumber)(this.nextReqId++),
      sessionId: this.session.id,
    };
    this.sendData(e);
  }
}
Jv.WalletLinkConnection = U1e;
var r1 = {},
  n1 = {},
  tT = {};
Object.defineProperty(tT, "__esModule", {
  value: !0,
});
tT.default =
  '@namespace svg "http://www.w3.org/2000/svg";.-cbwsdk-css-reset,.-cbwsdk-css-reset *{animation:none;animation-delay:0;animation-direction:normal;animation-duration:0;animation-fill-mode:none;animation-iteration-count:1;animation-name:none;animation-play-state:running;animation-timing-function:ease;backface-visibility:visible;background:0;background-attachment:scroll;background-clip:border-box;background-color:rgba(0,0,0,0);background-image:none;background-origin:padding-box;background-position:0 0;background-position-x:0;background-position-y:0;background-repeat:repeat;background-size:auto auto;border:0;border-style:none;border-width:medium;border-color:inherit;border-bottom:0;border-bottom-color:inherit;border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-style:none;border-bottom-width:medium;border-collapse:separate;border-image:none;border-left:0;border-left-color:inherit;border-left-style:none;border-left-width:medium;border-radius:0;border-right:0;border-right-color:inherit;border-right-style:none;border-right-width:medium;border-spacing:0;border-top:0;border-top-color:inherit;border-top-left-radius:0;border-top-right-radius:0;border-top-style:none;border-top-width:medium;box-shadow:none;box-sizing:border-box;caption-side:top;clear:none;clip:auto;color:inherit;columns:auto;column-count:auto;column-fill:balance;column-gap:normal;column-rule:medium none currentColor;column-rule-color:currentColor;column-rule-style:none;column-rule-width:none;column-span:1;column-width:auto;counter-increment:none;counter-reset:none;direction:ltr;empty-cells:show;float:none;font:normal;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;font-size:medium;font-style:normal;font-variant:normal;font-weight:normal;height:auto;hyphens:none;letter-spacing:normal;line-height:normal;list-style:none;list-style-image:none;list-style-position:outside;list-style-type:disc;margin:0;margin-bottom:0;margin-left:0;margin-right:0;margin-top:0;opacity:1;orphans:0;outline:0;outline-color:invert;outline-style:none;outline-width:medium;overflow:visible;overflow-x:visible;overflow-y:visible;padding:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;page-break-after:auto;page-break-before:auto;page-break-inside:auto;perspective:none;perspective-origin:50% 50%;pointer-events:auto;position:static;quotes:"\\201C" "\\201D" "\\2018" "\\2019";tab-size:8;table-layout:auto;text-align:inherit;text-align-last:auto;text-decoration:none;text-decoration-color:inherit;text-decoration-line:none;text-decoration-style:solid;text-indent:0;text-shadow:none;text-transform:none;transform:none;transform-style:flat;transition:none;transition-delay:0s;transition-duration:0s;transition-property:none;transition-timing-function:ease;unicode-bidi:normal;vertical-align:baseline;visibility:visible;white-space:normal;widows:0;word-spacing:normal;z-index:auto}.-cbwsdk-css-reset strong{font-weight:bold}.-cbwsdk-css-reset *{box-sizing:border-box;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;line-height:1}.-cbwsdk-css-reset [class*=container]{margin:0;padding:0}.-cbwsdk-css-reset style{display:none}';
var W1e =
  (ke && ke.__importDefault) ||
  function (t) {
    return t && t.__esModule
      ? t
      : {
          default: t,
        };
  };
Object.defineProperty(n1, "__esModule", {
  value: !0,
});
n1.injectCssReset = void 0;
const j1e = W1e(tT);
function H1e() {
  const t = document.createElement("style");
  (t.type = "text/css"),
    t.appendChild(document.createTextNode(j1e.default)),
    document.documentElement.appendChild(t);
}
n1.injectCssReset = H1e;
var Xv = {},
  i1,
  xr,
  $$,
  U$,
  Ll,
  $9,
  W$,
  a4,
  rT,
  s4,
  o4,
  j$,
  um = {},
  H$ = [],
  z1e = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i,
  ex = Array.isArray;
function Lo(t, e) {
  for (var r in e) t[r] = e[r];
  return t;
}
function z$(t) {
  t && t.parentNode && t.parentNode.removeChild(t);
}
function c4(t, e, r) {
  var n,
    i,
    a,
    s = {};
  for (a in e)
    a == "key" ? (n = e[a]) : a == "ref" ? (i = e[a]) : (s[a] = e[a]);
  if (
    (arguments.length > 2 &&
      (s.children = arguments.length > 3 ? i1.call(arguments, 2) : r),
    typeof t == "function" && t.defaultProps != null)
  )
    for (a in t.defaultProps) s[a] === void 0 && (s[a] = t.defaultProps[a]);
  return Kh(t, s, n, i, null);
}
function Kh(t, e, r, n, i) {
  var a = {
    type: t,
    props: e,
    key: r,
    ref: n,
    __k: null,
    __: null,
    __b: 0,
    __e: null,
    __d: void 0,
    __c: null,
    constructor: void 0,
    __v: i ?? ++$$,
    __i: -1,
    __u: 0,
  };
  return i == null && xr.vnode != null && xr.vnode(a), a;
}
function q1e() {
  return {
    current: null,
  };
}
function a1(t) {
  return t.children;
}
function Gh(t, e) {
  (this.props = t), (this.context = e);
}
function Hf(t, e) {
  if (e == null) return t.__ ? Hf(t.__, t.__i + 1) : null;
  for (var r; e < t.__k.length; e++)
    if ((r = t.__k[e]) != null && r.__e != null) return r.__e;
  return typeof t.type == "function" ? Hf(t) : null;
}
function q$(t) {
  var e, r;
  if ((t = t.__) != null && t.__c != null) {
    for (t.__e = t.__c.base = null, e = 0; e < t.__k.length; e++)
      if ((r = t.__k[e]) != null && r.__e != null) {
        t.__e = t.__c.base = r.__e;
        break;
      }
    return q$(t);
  }
}
function l4(t) {
  ((!t.__d && (t.__d = !0) && Ll.push(t) && !lb.__r++) ||
    $9 !== xr.debounceRendering) &&
    (($9 = xr.debounceRendering) || W$)(lb);
}
function lb() {
  var t, e, r, n, i, a, s, o;
  for (Ll.sort(a4); (t = Ll.shift()); )
    t.__d &&
      ((e = Ll.length),
      (n = void 0),
      (a = (i = (r = t).__v).__e),
      (s = []),
      (o = []),
      r.__P &&
        (((n = Lo({}, i)).__v = i.__v + 1),
        xr.vnode && xr.vnode(n),
        nT(
          r.__P,
          n,
          i,
          r.__n,
          r.__P.namespaceURI,
          32 & i.__u ? [a] : null,
          s,
          a ?? Hf(i),
          !!(32 & i.__u),
          o
        ),
        (n.__v = i.__v),
        (n.__.__k[n.__i] = n),
        Z$(s, n, o),
        n.__e != a && q$(n)),
      Ll.length > e && Ll.sort(a4));
  lb.__r = 0;
}
function V$(t, e, r, n, i, a, s, o, c, u, d) {
  var m,
    v,
    E,
    A,
    I,
    b = (n && n.__k) || H$,
    w = e.length;
  for (r.__d = c, V1e(r, e, b), c = r.__d, m = 0; m < w; m++)
    (E = r.__k[m]) != null &&
      ((v = E.__i === -1 ? um : b[E.__i] || um),
      (E.__i = m),
      nT(t, E, v, i, a, s, o, c, u, d),
      (A = E.__e),
      E.ref &&
        v.ref != E.ref &&
        (v.ref && iT(v.ref, null, E), d.push(E.ref, E.__c || A, E)),
      I == null && A != null && (I = A),
      65536 & E.__u || v.__k === E.__k
        ? (c = K$(E, c, t))
        : typeof E.type == "function" && E.__d !== void 0
        ? (c = E.__d)
        : A && (c = A.nextSibling),
      (E.__d = void 0),
      (E.__u &= -196609));
  (r.__d = c), (r.__e = I);
}
function V1e(t, e, r) {
  var n,
    i,
    a,
    s,
    o,
    c = e.length,
    u = r.length,
    d = u,
    m = 0;
  for (t.__k = [], n = 0; n < c; n++)
    (i = e[n]) != null && typeof i != "boolean" && typeof i != "function"
      ? ((s = n + m),
        ((i = t.__k[n] =
          typeof i == "string" ||
          typeof i == "number" ||
          typeof i == "bigint" ||
          i.constructor == String
            ? Kh(null, i, null, null, null)
            : ex(i)
            ? Kh(
                a1,
                {
                  children: i,
                },
                null,
                null,
                null
              )
            : i.constructor === void 0 && i.__b > 0
            ? Kh(i.type, i.props, i.key, i.ref ? i.ref : null, i.__v)
            : i).__ = t),
        (i.__b = t.__b + 1),
        (a = null),
        (o = i.__i = K1e(i, r, s, d)) !== -1 &&
          (d--, (a = r[o]) && (a.__u |= 131072)),
        a == null || a.__v === null
          ? (o == -1 && m--, typeof i.type != "function" && (i.__u |= 65536))
          : o !== s &&
            (o == s - 1
              ? m--
              : o == s + 1
              ? m++
              : (o > s ? m-- : m++, (i.__u |= 65536))))
      : (i = t.__k[n] = null);
  if (d)
    for (n = 0; n < u; n++)
      (a = r[n]) != null &&
        !(131072 & a.__u) &&
        (a.__e == t.__d && (t.__d = Hf(a)), J$(a, a));
}
function K$(t, e, r) {
  var n, i;
  if (typeof t.type == "function") {
    for (n = t.__k, i = 0; n && i < n.length; i++)
      n[i] && ((n[i].__ = t), (e = K$(n[i], e, r)));
    return e;
  }
  t.__e != e &&
    (e && t.type && !r.contains(e) && (e = Hf(t)),
    r.insertBefore(t.__e, e || null),
    (e = t.__e));
  do e = e && e.nextSibling;
  while (e != null && e.nodeType === 8);
  return e;
}
function G$(t, e) {
  return (
    (e = e || []),
    t == null ||
      typeof t == "boolean" ||
      (ex(t)
        ? t.some(function (r) {
            G$(r, e);
          })
        : e.push(t)),
    e
  );
}
function K1e(t, e, r, n) {
  var i = t.key,
    a = t.type,
    s = r - 1,
    o = r + 1,
    c = e[r];
  if (c === null || (c && i == c.key && a === c.type && !(131072 & c.__u)))
    return r;
  if (n > (c != null && !(131072 & c.__u) ? 1 : 0))
    for (; s >= 0 || o < e.length; ) {
      if (s >= 0) {
        if ((c = e[s]) && !(131072 & c.__u) && i == c.key && a === c.type)
          return s;
        s--;
      }
      if (o < e.length) {
        if ((c = e[o]) && !(131072 & c.__u) && i == c.key && a === c.type)
          return o;
        o++;
      }
    }
  return -1;
}
function U9(t, e, r) {
  e[0] === "-"
    ? t.setProperty(e, r ?? "")
    : (t[e] =
        r == null ? "" : typeof r != "number" || z1e.test(e) ? r : r + "px");
}
function hy(t, e, r, n, i) {
  var a;
  e: if (e === "style")
    if (typeof r == "string") t.style.cssText = r;
    else {
      if ((typeof n == "string" && (t.style.cssText = n = ""), n))
        for (e in n) (r && e in r) || U9(t.style, e, "");
      if (r) for (e in r) (n && r[e] === n[e]) || U9(t.style, e, r[e]);
    }
  else if (e[0] === "o" && e[1] === "n")
    (a = e !== (e = e.replace(/(PointerCapture)$|Capture$/i, "$1"))),
      (e =
        e.toLowerCase() in t || e === "onFocusOut" || e === "onFocusIn"
          ? e.toLowerCase().slice(2)
          : e.slice(2)),
      t.l || (t.l = {}),
      (t.l[e + a] = r),
      r
        ? n
          ? (r.u = n.u)
          : ((r.u = rT), t.addEventListener(e, a ? o4 : s4, a))
        : t.removeEventListener(e, a ? o4 : s4, a);
  else {
    if (i == "http://www.w3.org/2000/svg")
      e = e.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
    else if (
      e != "width" &&
      e != "height" &&
      e != "href" &&
      e != "list" &&
      e != "form" &&
      e != "tabIndex" &&
      e != "download" &&
      e != "rowSpan" &&
      e != "colSpan" &&
      e != "role" &&
      e != "popover" &&
      e in t
    )
      try {
        t[e] = r ?? "";
        break e;
      } catch {}
    typeof r == "function" ||
      (r == null || (r === !1 && e[4] !== "-")
        ? t.removeAttribute(e)
        : t.setAttribute(e, e == "popover" && r == 1 ? "" : r));
  }
}
function W9(t) {
  return function (e) {
    if (this.l) {
      var r = this.l[e.type + t];
      if (e.t == null) e.t = rT++;
      else if (e.t < r.u) return;
      return r(xr.event ? xr.event(e) : e);
    }
  };
}
function nT(t, e, r, n, i, a, s, o, c, u) {
  var d,
    m,
    v,
    E,
    A,
    I,
    b,
    w,
    S,
    k,
    N,
    O,
    F,
    V,
    j,
    X,
    C = e.type;
  if (e.constructor !== void 0) return null;
  128 & r.__u && ((c = !!(32 & r.__u)), (a = [(o = e.__e = r.__e)])),
    (d = xr.__b) && d(e);
  e: if (typeof C == "function")
    try {
      if (
        ((w = e.props),
        (S = "prototype" in C && C.prototype.render),
        (k = (d = C.contextType) && n[d.__c]),
        (N = d ? (k ? k.props.value : d.__) : n),
        r.__c
          ? (b = (m = e.__c = r.__c).__ = m.__E)
          : (S
              ? (e.__c = m = new C(w, N))
              : ((e.__c = m = new Gh(w, N)),
                (m.constructor = C),
                (m.render = Z1e)),
            k && k.sub(m),
            (m.props = w),
            m.state || (m.state = {}),
            (m.context = N),
            (m.__n = n),
            (v = m.__d = !0),
            (m.__h = []),
            (m._sb = [])),
        S && m.__s == null && (m.__s = m.state),
        S &&
          C.getDerivedStateFromProps != null &&
          (m.__s == m.state && (m.__s = Lo({}, m.__s)),
          Lo(m.__s, C.getDerivedStateFromProps(w, m.__s))),
        (E = m.props),
        (A = m.state),
        (m.__v = e),
        v)
      )
        S &&
          C.getDerivedStateFromProps == null &&
          m.componentWillMount != null &&
          m.componentWillMount(),
          S && m.componentDidMount != null && m.__h.push(m.componentDidMount);
      else {
        if (
          (S &&
            C.getDerivedStateFromProps == null &&
            w !== E &&
            m.componentWillReceiveProps != null &&
            m.componentWillReceiveProps(w, N),
          !m.__e &&
            ((m.shouldComponentUpdate != null &&
              m.shouldComponentUpdate(w, m.__s, N) === !1) ||
              e.__v === r.__v))
        ) {
          for (
            e.__v !== r.__v && ((m.props = w), (m.state = m.__s), (m.__d = !1)),
              e.__e = r.__e,
              e.__k = r.__k,
              e.__k.some(function (l) {
                l && (l.__ = e);
              }),
              O = 0;
            O < m._sb.length;
            O++
          )
            m.__h.push(m._sb[O]);
          (m._sb = []), m.__h.length && s.push(m);
          break e;
        }
        m.componentWillUpdate != null && m.componentWillUpdate(w, m.__s, N),
          S &&
            m.componentDidUpdate != null &&
            m.__h.push(function () {
              m.componentDidUpdate(E, A, I);
            });
      }
      if (
        ((m.context = N),
        (m.props = w),
        (m.__P = t),
        (m.__e = !1),
        (F = xr.__r),
        (V = 0),
        S)
      ) {
        for (
          m.state = m.__s,
            m.__d = !1,
            F && F(e),
            d = m.render(m.props, m.state, m.context),
            j = 0;
          j < m._sb.length;
          j++
        )
          m.__h.push(m._sb[j]);
        m._sb = [];
      } else
        do
          (m.__d = !1),
            F && F(e),
            (d = m.render(m.props, m.state, m.context)),
            (m.state = m.__s);
        while (m.__d && ++V < 25);
      (m.state = m.__s),
        m.getChildContext != null && (n = Lo(Lo({}, n), m.getChildContext())),
        S &&
          !v &&
          m.getSnapshotBeforeUpdate != null &&
          (I = m.getSnapshotBeforeUpdate(E, A)),
        V$(
          t,
          ex(
            (X =
              d != null && d.type === a1 && d.key == null
                ? d.props.children
                : d)
          )
            ? X
            : [X],
          e,
          r,
          n,
          i,
          a,
          s,
          o,
          c,
          u
        ),
        (m.base = e.__e),
        (e.__u &= -161),
        m.__h.length && s.push(m),
        b && (m.__E = m.__ = null);
    } catch (l) {
      if (((e.__v = null), c || a != null)) {
        for (e.__u |= c ? 160 : 32; o && o.nodeType === 8 && o.nextSibling; )
          o = o.nextSibling;
        (a[a.indexOf(o)] = null), (e.__e = o);
      } else (e.__e = r.__e), (e.__k = r.__k);
      xr.__e(l, e, r);
    }
  else
    a == null && e.__v === r.__v
      ? ((e.__k = r.__k), (e.__e = r.__e))
      : (e.__e = G1e(r.__e, e, r, n, i, a, s, c, u));
  (d = xr.diffed) && d(e);
}
function Z$(t, e, r) {
  e.__d = void 0;
  for (var n = 0; n < r.length; n++) iT(r[n], r[++n], r[++n]);
  xr.__c && xr.__c(e, t),
    t.some(function (i) {
      try {
        (t = i.__h),
          (i.__h = []),
          t.some(function (a) {
            a.call(i);
          });
      } catch (a) {
        xr.__e(a, i.__v);
      }
    });
}
function G1e(t, e, r, n, i, a, s, o, c) {
  var u,
    d,
    m,
    v,
    E,
    A,
    I,
    b = r.props,
    w = e.props,
    S = e.type;
  if (
    (S === "svg"
      ? (i = "http://www.w3.org/2000/svg")
      : S === "math"
      ? (i = "http://www.w3.org/1998/Math/MathML")
      : i || (i = "http://www.w3.org/1999/xhtml"),
    a != null)
  ) {
    for (u = 0; u < a.length; u++)
      if (
        (E = a[u]) &&
        "setAttribute" in E == !!S &&
        (S ? E.localName === S : E.nodeType === 3)
      ) {
        (t = E), (a[u] = null);
        break;
      }
  }
  if (t == null) {
    if (S === null) return document.createTextNode(w);
    (t = document.createElementNS(i, S, w.is && w)),
      o && (xr.__m && xr.__m(e, a), (o = !1)),
      (a = null);
  }
  if (S === null) b === w || (o && t.data === w) || (t.data = w);
  else {
    if (
      ((a = a && i1.call(t.childNodes)), (b = r.props || um), !o && a != null)
    )
      for (b = {}, u = 0; u < t.attributes.length; u++)
        b[(E = t.attributes[u]).name] = E.value;
    for (u in b)
      if (((E = b[u]), u != "children")) {
        if (u == "dangerouslySetInnerHTML") m = E;
        else if (!(u in w)) {
          if (
            (u == "value" && "defaultValue" in w) ||
            (u == "checked" && "defaultChecked" in w)
          )
            continue;
          hy(t, u, null, E, i);
        }
      }
    for (u in w)
      (E = w[u]),
        u == "children"
          ? (v = E)
          : u == "dangerouslySetInnerHTML"
          ? (d = E)
          : u == "value"
          ? (A = E)
          : u == "checked"
          ? (I = E)
          : (o && typeof E != "function") || b[u] === E || hy(t, u, E, b[u], i);
    if (d)
      o ||
        (m && (d.__html === m.__html || d.__html === t.innerHTML)) ||
        (t.innerHTML = d.__html),
        (e.__k = []);
    else if (
      (m && (t.innerHTML = ""),
      V$(
        t,
        ex(v) ? v : [v],
        e,
        r,
        n,
        S === "foreignObject" ? "http://www.w3.org/1999/xhtml" : i,
        a,
        s,
        a ? a[0] : r.__k && Hf(r, 0),
        o,
        c
      ),
      a != null)
    )
      for (u = a.length; u--; ) z$(a[u]);
    o ||
      ((u = "value"),
      S === "progress" && A == null
        ? t.removeAttribute("value")
        : A !== void 0 &&
          (A !== t[u] ||
            (S === "progress" && !A) ||
            (S === "option" && A !== b[u])) &&
          hy(t, u, A, b[u], i),
      (u = "checked"),
      I !== void 0 && I !== t[u] && hy(t, u, I, b[u], i));
  }
  return t;
}
function iT(t, e, r) {
  try {
    if (typeof t == "function") {
      var n = typeof t.__u == "function";
      n && t.__u(), (n && e == null) || (t.__u = t(e));
    } else t.current = e;
  } catch (i) {
    xr.__e(i, r);
  }
}
function J$(t, e, r) {
  var n, i;
  if (
    (xr.unmount && xr.unmount(t),
    (n = t.ref) && ((n.current && n.current !== t.__e) || iT(n, null, e)),
    (n = t.__c) != null)
  ) {
    if (n.componentWillUnmount)
      try {
        n.componentWillUnmount();
      } catch (a) {
        xr.__e(a, e);
      }
    n.base = n.__P = null;
  }
  if ((n = t.__k))
    for (i = 0; i < n.length; i++)
      n[i] && J$(n[i], e, r || typeof t.type != "function");
  r || z$(t.__e), (t.__c = t.__ = t.__e = t.__d = void 0);
}
function Z1e(t, e, r) {
  return this.constructor(t, r);
}
function Q$(t, e, r) {
  var n, i, a, s;
  xr.__ && xr.__(t, e),
    (i = (n = typeof r == "function") ? null : (r && r.__k) || e.__k),
    (a = []),
    (s = []),
    nT(
      e,
      (t = ((!n && r) || e).__k = c4(a1, null, [t])),
      i || um,
      um,
      e.namespaceURI,
      !n && r ? [r] : i ? null : e.firstChild ? i1.call(e.childNodes) : null,
      a,
      !n && r ? r : i ? i.__e : e.firstChild,
      n,
      s
    ),
    Z$(a, t, s);
}
function Y$(t, e) {
  Q$(t, e, Y$);
}
function J1e(t, e, r) {
  var n,
    i,
    a,
    s,
    o = Lo({}, t.props);
  for (a in (t.type && t.type.defaultProps && (s = t.type.defaultProps), e))
    a == "key"
      ? (n = e[a])
      : a == "ref"
      ? (i = e[a])
      : (o[a] = e[a] === void 0 && s !== void 0 ? s[a] : e[a]);
  return (
    arguments.length > 2 &&
      (o.children = arguments.length > 3 ? i1.call(arguments, 2) : r),
    Kh(t.type, o, n || t.key, i || t.ref, null)
  );
}
function Q1e(t, e) {
  var r = {
    __c: (e = "__cC" + j$++),
    __: t,
    Consumer: function (n, i) {
      return n.children(i);
    },
    Provider: function (n) {
      var i, a;
      return (
        this.getChildContext ||
          ((i = []),
          ((a = {})[e] = this),
          (this.getChildContext = function () {
            return a;
          }),
          (this.componentWillUnmount = function () {
            i = null;
          }),
          (this.shouldComponentUpdate = function (s) {
            this.props.value !== s.value &&
              i.some(function (o) {
                (o.__e = !0), l4(o);
              });
          }),
          (this.sub = function (s) {
            i.push(s);
            var o = s.componentWillUnmount;
            s.componentWillUnmount = function () {
              i && i.splice(i.indexOf(s), 1), o && o.call(s);
            };
          })),
        n.children
      );
    },
  };
  return (r.Provider.__ = r.Consumer.contextType = r);
}
(i1 = H$.slice),
  (xr = {
    __e: function (t, e, r, n) {
      for (var i, a, s; (e = e.__); )
        if ((i = e.__c) && !i.__)
          try {
            if (
              ((a = i.constructor) &&
                a.getDerivedStateFromError != null &&
                (i.setState(a.getDerivedStateFromError(t)), (s = i.__d)),
              i.componentDidCatch != null &&
                (i.componentDidCatch(t, n || {}), (s = i.__d)),
              s)
            )
              return (i.__E = i);
          } catch (o) {
            t = o;
          }
      throw t;
    },
  }),
  ($$ = 0),
  (U$ = function (t) {
    return t != null && t.constructor == null;
  }),
  (Gh.prototype.setState = function (t, e) {
    var r;
    (r =
      this.__s != null && this.__s !== this.state
        ? this.__s
        : (this.__s = Lo({}, this.state))),
      typeof t == "function" && (t = t(Lo({}, r), this.props)),
      t && Lo(r, t),
      t != null && this.__v && (e && this._sb.push(e), l4(this));
  }),
  (Gh.prototype.forceUpdate = function (t) {
    this.__v && ((this.__e = !0), t && this.__h.push(t), l4(this));
  }),
  (Gh.prototype.render = a1),
  (Ll = []),
  (W$ =
    typeof Promise == "function"
      ? Promise.prototype.then.bind(Promise.resolve())
      : setTimeout),
  (a4 = function (t, e) {
    return t.__v.__b - e.__v.__b;
  }),
  (lb.__r = 0),
  (rT = 0),
  (s4 = W9(!1)),
  (o4 = W9(!0)),
  (j$ = 0);
const Y1e = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        Component: Gh,
        Fragment: a1,
        cloneElement: J1e,
        createContext: Q1e,
        createElement: c4,
        createRef: q1e,
        h: c4,
        hydrate: Y$,
        get isValidElement() {
          return U$;
        },
        get options() {
          return xr;
        },
        render: Q$,
        toChildArray: G$,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  Qi = Pt(Y1e);
var tx = {};
function X$(t) {
  var e,
    r,
    n = "";
  if (typeof t == "string" || typeof t == "number") n += t;
  else if (typeof t == "object")
    if (Array.isArray(t))
      for (e = 0; e < t.length; e++)
        t[e] && (r = X$(t[e])) && (n && (n += " "), (n += r));
    else for (e in t) t[e] && (n && (n += " "), (n += e));
  return n;
}
function j9() {
  for (var t, e, r = 0, n = ""; r < arguments.length; )
    (t = arguments[r++]) && (e = X$(t)) && (n && (n += " "), (n += e));
  return n;
}
const X1e = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        clsx: j9,
        default: j9,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  s1 = Pt(X1e);
var Qo,
  dr,
  e5,
  H9,
  zf = 0,
  eU = [],
  qr = xr,
  z9 = qr.__b,
  q9 = qr.__r,
  V9 = qr.diffed,
  K9 = qr.__c,
  G9 = qr.unmount,
  Z9 = qr.__;
function ju(t, e) {
  qr.__h && qr.__h(dr, t, zf || e), (zf = 0);
  var r =
    dr.__H ||
    (dr.__H = {
      __: [],
      __h: [],
    });
  return t >= r.__.length && r.__.push({}), r.__[t];
}
function tU(t) {
  return (zf = 1), rU(iU, t);
}
function rU(t, e, r) {
  var n = ju(Qo++, 2);
  if (
    ((n.t = t),
    !n.__c &&
      ((n.__ = [
        r ? r(e) : iU(void 0, e),
        function (o) {
          var c = n.__N ? n.__N[0] : n.__[0],
            u = n.t(c, o);
          c !== u && ((n.__N = [u, n.__[1]]), n.__c.setState({}));
        },
      ]),
      (n.__c = dr),
      !dr.u))
  ) {
    var i = function (o, c, u) {
      if (!n.__c.__H) return !0;
      var d = n.__c.__H.__.filter(function (v) {
        return !!v.__c;
      });
      if (
        d.every(function (v) {
          return !v.__N;
        })
      )
        return !a || a.call(this, o, c, u);
      var m = !1;
      return (
        d.forEach(function (v) {
          if (v.__N) {
            var E = v.__[0];
            (v.__ = v.__N), (v.__N = void 0), E !== v.__[0] && (m = !0);
          }
        }),
        !(!m && n.__c.props === o) && (!a || a.call(this, o, c, u))
      );
    };
    dr.u = !0;
    var a = dr.shouldComponentUpdate,
      s = dr.componentWillUpdate;
    (dr.componentWillUpdate = function (o, c, u) {
      if (this.__e) {
        var d = a;
        (a = void 0), i(o, c, u), (a = d);
      }
      s && s.call(this, o, c, u);
    }),
      (dr.shouldComponentUpdate = i);
  }
  return n.__N || n.__;
}
function eye(t, e) {
  var r = ju(Qo++, 3);
  !qr.__s && sT(r.__H, e) && ((r.__ = t), (r.i = e), dr.__H.__h.push(r));
}
function nU(t, e) {
  var r = ju(Qo++, 4);
  !qr.__s && sT(r.__H, e) && ((r.__ = t), (r.i = e), dr.__h.push(r));
}
function tye(t) {
  return (
    (zf = 5),
    aT(function () {
      return {
        current: t,
      };
    }, [])
  );
}
function rye(t, e, r) {
  (zf = 6),
    nU(
      function () {
        return typeof t == "function"
          ? (t(e()),
            function () {
              return t(null);
            })
          : t
          ? ((t.current = e()),
            function () {
              return (t.current = null);
            })
          : void 0;
      },
      r == null ? r : r.concat(t)
    );
}
function aT(t, e) {
  var r = ju(Qo++, 7);
  return sT(r.__H, e) && ((r.__ = t()), (r.__H = e), (r.__h = t)), r.__;
}
function nye(t, e) {
  return (
    (zf = 8),
    aT(function () {
      return t;
    }, e)
  );
}
function iye(t) {
  var e = dr.context[t.__c],
    r = ju(Qo++, 9);
  return (
    (r.c = t),
    e ? (r.__ == null && ((r.__ = !0), e.sub(dr)), e.props.value) : t.__
  );
}
function aye(t, e) {
  qr.useDebugValue && qr.useDebugValue(e ? e(t) : t);
}
function sye(t) {
  var e = ju(Qo++, 10),
    r = tU();
  return (
    (e.__ = t),
    dr.componentDidCatch ||
      (dr.componentDidCatch = function (n, i) {
        e.__ && e.__(n, i), r[1](n);
      }),
    [
      r[0],
      function () {
        r[1](void 0);
      },
    ]
  );
}
function oye() {
  var t = ju(Qo++, 11);
  if (!t.__) {
    for (var e = dr.__v; e !== null && !e.__m && e.__ !== null; ) e = e.__;
    var r = e.__m || (e.__m = [0, 0]);
    t.__ = "P" + r[0] + "-" + r[1]++;
  }
  return t.__;
}
function cye() {
  for (var t; (t = eU.shift()); )
    if (t.__P && t.__H)
      try {
        t.__H.__h.forEach(tg), t.__H.__h.forEach(u4), (t.__H.__h = []);
      } catch (e) {
        (t.__H.__h = []), qr.__e(e, t.__v);
      }
}
(qr.__b = function (t) {
  (dr = null), z9 && z9(t);
}),
  (qr.__ = function (t, e) {
    t && e.__k && e.__k.__m && (t.__m = e.__k.__m), Z9 && Z9(t, e);
  }),
  (qr.__r = function (t) {
    q9 && q9(t), (Qo = 0);
    var e = (dr = t.__c).__H;
    e &&
      (e5 === dr
        ? ((e.__h = []),
          (dr.__h = []),
          e.__.forEach(function (r) {
            r.__N && (r.__ = r.__N), (r.i = r.__N = void 0);
          }))
        : (e.__h.forEach(tg), e.__h.forEach(u4), (e.__h = []), (Qo = 0))),
      (e5 = dr);
  }),
  (qr.diffed = function (t) {
    V9 && V9(t);
    var e = t.__c;
    e &&
      e.__H &&
      (e.__H.__h.length &&
        ((eU.push(e) !== 1 && H9 === qr.requestAnimationFrame) ||
          ((H9 = qr.requestAnimationFrame) || lye)(cye)),
      e.__H.__.forEach(function (r) {
        r.i && (r.__H = r.i), (r.i = void 0);
      })),
      (e5 = dr = null);
  }),
  (qr.__c = function (t, e) {
    e.some(function (r) {
      try {
        r.__h.forEach(tg),
          (r.__h = r.__h.filter(function (n) {
            return !n.__ || u4(n);
          }));
      } catch (n) {
        e.some(function (i) {
          i.__h && (i.__h = []);
        }),
          (e = []),
          qr.__e(n, r.__v);
      }
    }),
      K9 && K9(t, e);
  }),
  (qr.unmount = function (t) {
    G9 && G9(t);
    var e,
      r = t.__c;
    r &&
      r.__H &&
      (r.__H.__.forEach(function (n) {
        try {
          tg(n);
        } catch (i) {
          e = i;
        }
      }),
      (r.__H = void 0),
      e && qr.__e(e, r.__v));
  });
var J9 = typeof requestAnimationFrame == "function";
function lye(t) {
  var e,
    r = function () {
      clearTimeout(n), J9 && cancelAnimationFrame(e), setTimeout(t);
    },
    n = setTimeout(r, 100);
  J9 && (e = requestAnimationFrame(r));
}
function tg(t) {
  var e = dr,
    r = t.__c;
  typeof r == "function" && ((t.__c = void 0), r()), (dr = e);
}
function u4(t) {
  var e = dr;
  (t.__c = t.__()), (dr = e);
}
function sT(t, e) {
  return (
    !t ||
    t.length !== e.length ||
    e.some(function (r, n) {
      return r !== t[n];
    })
  );
}
function iU(t, e) {
  return typeof e == "function" ? e(t) : e;
}
const uye = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        useCallback: nye,
        useContext: iye,
        useDebugValue: aye,
        useEffect: eye,
        useErrorBoundary: sye,
        useId: oye,
        useImperativeHandle: rye,
        useLayoutEffect: nU,
        useMemo: aT,
        useReducer: rU,
        useRef: tye,
        useState: tU,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  rx = Pt(uye);
var qf = {},
  nx = {};
Object.defineProperty(nx, "__esModule", {
  value: !0,
});
nx.CloseIcon = void 0;
const Q9 = Qi;
function fye(t) {
  return (0, Q9.h)(
    "svg",
    Object.assign(
      {
        width: "40",
        height: "40",
        viewBox: "0 0 40 40",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
      },
      t
    ),
    (0, Q9.h)("path", {
      d: "M13.7677 13L12.3535 14.4142L18.3535 20.4142L12.3535 26.4142L13.7677 27.8284L19.7677 21.8284L25.7677 27.8284L27.1819 26.4142L21.1819 20.4142L27.1819 14.4142L25.7677 13L19.7677 19L13.7677 13Z",
    })
  );
}
nx.CloseIcon = fye;
var ix = {};
Object.defineProperty(ix, "__esModule", {
  value: !0,
});
ix.CoinbaseWalletRound = void 0;
const py = Qi;
function dye(t) {
  return (0, py.h)(
    "svg",
    Object.assign(
      {
        width: "28",
        height: "28",
        viewBox: "0 0 28 28",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
      },
      t
    ),
    (0, py.h)("circle", {
      cx: "14",
      cy: "14",
      r: "14",
      fill: "#0052FF",
    }),
    (0, py.h)("path", {
      d: "M23.8521 14.0003C23.8521 19.455 19.455 23.8521 14.0003 23.8521C8.54559 23.8521 4.14844 19.455 4.14844 14.0003C4.14844 8.54559 8.54559 4.14844 14.0003 4.14844C19.455 4.14844 23.8521 8.54559 23.8521 14.0003Z",
      fill: "white",
    }),
    (0, py.h)("path", {
      d: "M11.1855 12.5042C11.1855 12.0477 11.1855 11.7942 11.2835 11.642C11.3814 11.4899 11.4793 11.3377 11.6261 11.287C11.8219 11.1855 12.0178 11.1855 12.5073 11.1855H15.4934C15.983 11.1855 16.1788 11.1855 16.3746 11.287C16.5215 11.3884 16.6683 11.4899 16.7173 11.642C16.8152 11.8449 16.8152 12.0477 16.8152 12.5042V15.4965C16.8152 15.953 16.8152 16.2066 16.7173 16.3587C16.6194 16.5109 16.5215 16.663 16.3746 16.7137C16.1788 16.8152 15.983 16.8152 15.4934 16.8152H12.5073C12.0178 16.8152 11.8219 16.8152 11.6261 16.7137C11.4793 16.6123 11.3324 16.5109 11.2835 16.3587C11.1855 16.1558 11.1855 15.953 11.1855 15.4965V12.5042Z",
      fill: "#0052FF",
    })
  );
}
ix.CoinbaseWalletRound = dye;
var ax = {};
Object.defineProperty(ax, "__esModule", {
  value: !0,
});
ax.QRCodeIcon = void 0;
const sh = Qi;
function hye(t) {
  return (0, sh.h)(
    "svg",
    Object.assign(
      {
        width: "18",
        height: "18",
        viewBox: "0 0 24 24",
        xmlns: "http://www.w3.org/2000/svg",
      },
      t
    ),
    (0, sh.h)("path", {
      d: "M3 3V8.99939L5 8.99996V5H9V3H3Z",
    }),
    (0, sh.h)("path", {
      d: "M15 21L21 21V15.0006L19 15V19L15 19V21Z",
    }),
    (0, sh.h)("path", {
      d: "M21 9H19V5H15.0006L15 3H21V9Z",
    }),
    (0, sh.h)("path", {
      d: "M3 15V21H8.99939L8.99996 19H5L5 15H3Z",
    })
  );
}
ax.QRCodeIcon = hye;
var sx = {};
function aU(t) {
  (this.mode = ea.MODE_8BIT_BYTE), (this.data = t), (this.parsedData = []);
  for (var e = 0, r = this.data.length; e < r; e++) {
    var n = [],
      i = this.data.charCodeAt(e);
    i > 65536
      ? ((n[0] = 240 | ((i & 1835008) >>> 18)),
        (n[1] = 128 | ((i & 258048) >>> 12)),
        (n[2] = 128 | ((i & 4032) >>> 6)),
        (n[3] = 128 | (i & 63)))
      : i > 2048
      ? ((n[0] = 224 | ((i & 61440) >>> 12)),
        (n[1] = 128 | ((i & 4032) >>> 6)),
        (n[2] = 128 | (i & 63)))
      : i > 128
      ? ((n[0] = 192 | ((i & 1984) >>> 6)), (n[1] = 128 | (i & 63)))
      : (n[0] = i),
      this.parsedData.push(n);
  }
  (this.parsedData = Array.prototype.concat.apply([], this.parsedData)),
    this.parsedData.length != this.data.length &&
      (this.parsedData.unshift(191),
      this.parsedData.unshift(187),
      this.parsedData.unshift(239));
}
aU.prototype = {
  getLength: function (t) {
    return this.parsedData.length;
  },
  write: function (t) {
    for (var e = 0, r = this.parsedData.length; e < r; e++)
      t.put(this.parsedData[e], 8);
  },
};
function Zs(t, e) {
  (this.typeNumber = t),
    (this.errorCorrectLevel = e),
    (this.modules = null),
    (this.moduleCount = 0),
    (this.dataCache = null),
    (this.dataList = []);
}
Zs.prototype = {
  addData: function (t) {
    var e = new aU(t);
    this.dataList.push(e), (this.dataCache = null);
  },
  isDark: function (t, e) {
    if (t < 0 || this.moduleCount <= t || e < 0 || this.moduleCount <= e)
      throw new Error(t + "," + e);
    return this.modules[t][e];
  },
  getModuleCount: function () {
    return this.moduleCount;
  },
  make: function () {
    this.makeImpl(!1, this.getBestMaskPattern());
  },
  makeImpl: function (t, e) {
    (this.moduleCount = this.typeNumber * 4 + 17),
      (this.modules = new Array(this.moduleCount));
    for (var r = 0; r < this.moduleCount; r++) {
      this.modules[r] = new Array(this.moduleCount);
      for (var n = 0; n < this.moduleCount; n++) this.modules[r][n] = null;
    }
    this.setupPositionProbePattern(0, 0),
      this.setupPositionProbePattern(this.moduleCount - 7, 0),
      this.setupPositionProbePattern(0, this.moduleCount - 7),
      this.setupPositionAdjustPattern(),
      this.setupTimingPattern(),
      this.setupTypeInfo(t, e),
      this.typeNumber >= 7 && this.setupTypeNumber(t),
      this.dataCache == null &&
        (this.dataCache = Zs.createData(
          this.typeNumber,
          this.errorCorrectLevel,
          this.dataList
        )),
      this.mapData(this.dataCache, e);
  },
  setupPositionProbePattern: function (t, e) {
    for (var r = -1; r <= 7; r++)
      if (!(t + r <= -1 || this.moduleCount <= t + r))
        for (var n = -1; n <= 7; n++)
          e + n <= -1 ||
            this.moduleCount <= e + n ||
            ((0 <= r && r <= 6 && (n == 0 || n == 6)) ||
            (0 <= n && n <= 6 && (r == 0 || r == 6)) ||
            (2 <= r && r <= 4 && 2 <= n && n <= 4)
              ? (this.modules[t + r][e + n] = !0)
              : (this.modules[t + r][e + n] = !1));
  },
  getBestMaskPattern: function () {
    for (var t = 0, e = 0, r = 0; r < 8; r++) {
      this.makeImpl(!0, r);
      var n = jr.getLostPoint(this);
      (r == 0 || t > n) && ((t = n), (e = r));
    }
    return e;
  },
  createMovieClip: function (t, e, r) {
    var n = t.createEmptyMovieClip(e, r),
      i = 1;
    this.make();
    for (var a = 0; a < this.modules.length; a++)
      for (var s = a * i, o = 0; o < this.modules[a].length; o++) {
        var c = o * i,
          u = this.modules[a][o];
        u &&
          (n.beginFill(0, 100),
          n.moveTo(c, s),
          n.lineTo(c + i, s),
          n.lineTo(c + i, s + i),
          n.lineTo(c, s + i),
          n.endFill());
      }
    return n;
  },
  setupTimingPattern: function () {
    for (var t = 8; t < this.moduleCount - 8; t++)
      this.modules[t][6] == null && (this.modules[t][6] = t % 2 == 0);
    for (var e = 8; e < this.moduleCount - 8; e++)
      this.modules[6][e] == null && (this.modules[6][e] = e % 2 == 0);
  },
  setupPositionAdjustPattern: function () {
    for (
      var t = jr.getPatternPosition(this.typeNumber), e = 0;
      e < t.length;
      e++
    )
      for (var r = 0; r < t.length; r++) {
        var n = t[e],
          i = t[r];
        if (this.modules[n][i] == null)
          for (var a = -2; a <= 2; a++)
            for (var s = -2; s <= 2; s++)
              a == -2 || a == 2 || s == -2 || s == 2 || (a == 0 && s == 0)
                ? (this.modules[n + a][i + s] = !0)
                : (this.modules[n + a][i + s] = !1);
      }
  },
  setupTypeNumber: function (t) {
    for (var e = jr.getBCHTypeNumber(this.typeNumber), r = 0; r < 18; r++) {
      var n = !t && ((e >> r) & 1) == 1;
      this.modules[Math.floor(r / 3)][(r % 3) + this.moduleCount - 8 - 3] = n;
    }
    for (var r = 0; r < 18; r++) {
      var n = !t && ((e >> r) & 1) == 1;
      this.modules[(r % 3) + this.moduleCount - 8 - 3][Math.floor(r / 3)] = n;
    }
  },
  setupTypeInfo: function (t, e) {
    for (
      var r = (this.errorCorrectLevel << 3) | e,
        n = jr.getBCHTypeInfo(r),
        i = 0;
      i < 15;
      i++
    ) {
      var a = !t && ((n >> i) & 1) == 1;
      i < 6
        ? (this.modules[i][8] = a)
        : i < 8
        ? (this.modules[i + 1][8] = a)
        : (this.modules[this.moduleCount - 15 + i][8] = a);
    }
    for (var i = 0; i < 15; i++) {
      var a = !t && ((n >> i) & 1) == 1;
      i < 8
        ? (this.modules[8][this.moduleCount - i - 1] = a)
        : i < 9
        ? (this.modules[8][15 - i - 1 + 1] = a)
        : (this.modules[8][15 - i - 1] = a);
    }
    this.modules[this.moduleCount - 8][8] = !t;
  },
  mapData: function (t, e) {
    for (
      var r = -1,
        n = this.moduleCount - 1,
        i = 7,
        a = 0,
        s = this.moduleCount - 1;
      s > 0;
      s -= 2
    )
      for (s == 6 && s--; ; ) {
        for (var o = 0; o < 2; o++)
          if (this.modules[n][s - o] == null) {
            var c = !1;
            a < t.length && (c = ((t[a] >>> i) & 1) == 1);
            var u = jr.getMask(e, n, s - o);
            u && (c = !c),
              (this.modules[n][s - o] = c),
              i--,
              i == -1 && (a++, (i = 7));
          }
        if (((n += r), n < 0 || this.moduleCount <= n)) {
          (n -= r), (r = -r);
          break;
        }
      }
  },
};
Zs.PAD0 = 236;
Zs.PAD1 = 17;
Zs.createData = function (t, e, r) {
  for (var n = zs.getRSBlocks(t, e), i = new sU(), a = 0; a < r.length; a++) {
    var s = r[a];
    i.put(s.mode, 4),
      i.put(s.getLength(), jr.getLengthInBits(s.mode, t)),
      s.write(i);
  }
  for (var o = 0, a = 0; a < n.length; a++) o += n[a].dataCount;
  if (i.getLengthInBits() > o * 8)
    throw new Error(
      "code length overflow. (" + i.getLengthInBits() + ">" + o * 8 + ")"
    );
  for (
    i.getLengthInBits() + 4 <= o * 8 && i.put(0, 4);
    i.getLengthInBits() % 8 != 0;

  )
    i.putBit(!1);
  for (
    ;
    !(
      i.getLengthInBits() >= o * 8 ||
      (i.put(Zs.PAD0, 8), i.getLengthInBits() >= o * 8)
    );

  )
    i.put(Zs.PAD1, 8);
  return Zs.createBytes(i, n);
};
Zs.createBytes = function (t, e) {
  for (
    var r = 0,
      n = 0,
      i = 0,
      a = new Array(e.length),
      s = new Array(e.length),
      o = 0;
    o < e.length;
    o++
  ) {
    var c = e[o].dataCount,
      u = e[o].totalCount - c;
    (n = Math.max(n, c)), (i = Math.max(i, u)), (a[o] = new Array(c));
    for (var d = 0; d < a[o].length; d++) a[o][d] = 255 & t.buffer[d + r];
    r += c;
    var m = jr.getErrorCorrectPolynomial(u),
      v = new tf(a[o], m.getLength() - 1),
      E = v.mod(m);
    s[o] = new Array(m.getLength() - 1);
    for (var d = 0; d < s[o].length; d++) {
      var A = d + E.getLength() - s[o].length;
      s[o][d] = A >= 0 ? E.get(A) : 0;
    }
  }
  for (var I = 0, d = 0; d < e.length; d++) I += e[d].totalCount;
  for (var b = new Array(I), w = 0, d = 0; d < n; d++)
    for (var o = 0; o < e.length; o++) d < a[o].length && (b[w++] = a[o][d]);
  for (var d = 0; d < i; d++)
    for (var o = 0; o < e.length; o++) d < s[o].length && (b[w++] = s[o][d]);
  return b;
};
var ea = {
    MODE_NUMBER: 1,
    MODE_ALPHA_NUM: 2,
    MODE_8BIT_BYTE: 4,
    MODE_KANJI: 8,
  },
  Ac = {
    L: 1,
    M: 0,
    Q: 3,
    H: 2,
  },
  oc = {
    PATTERN000: 0,
    PATTERN001: 1,
    PATTERN010: 2,
    PATTERN011: 3,
    PATTERN100: 4,
    PATTERN101: 5,
    PATTERN110: 6,
    PATTERN111: 7,
  },
  jr = {
    PATTERN_POSITION_TABLE: [
      [],
      [6, 18],
      [6, 22],
      [6, 26],
      [6, 30],
      [6, 34],
      [6, 22, 38],
      [6, 24, 42],
      [6, 26, 46],
      [6, 28, 50],
      [6, 30, 54],
      [6, 32, 58],
      [6, 34, 62],
      [6, 26, 46, 66],
      [6, 26, 48, 70],
      [6, 26, 50, 74],
      [6, 30, 54, 78],
      [6, 30, 56, 82],
      [6, 30, 58, 86],
      [6, 34, 62, 90],
      [6, 28, 50, 72, 94],
      [6, 26, 50, 74, 98],
      [6, 30, 54, 78, 102],
      [6, 28, 54, 80, 106],
      [6, 32, 58, 84, 110],
      [6, 30, 58, 86, 114],
      [6, 34, 62, 90, 118],
      [6, 26, 50, 74, 98, 122],
      [6, 30, 54, 78, 102, 126],
      [6, 26, 52, 78, 104, 130],
      [6, 30, 56, 82, 108, 134],
      [6, 34, 60, 86, 112, 138],
      [6, 30, 58, 86, 114, 142],
      [6, 34, 62, 90, 118, 146],
      [6, 30, 54, 78, 102, 126, 150],
      [6, 24, 50, 76, 102, 128, 154],
      [6, 28, 54, 80, 106, 132, 158],
      [6, 32, 58, 84, 110, 136, 162],
      [6, 26, 54, 82, 110, 138, 166],
      [6, 30, 58, 86, 114, 142, 170],
    ],
    G15: 1335,
    G18: 7973,
    G15_MASK: 21522,
    getBCHTypeInfo: function (t) {
      for (var e = t << 10; jr.getBCHDigit(e) - jr.getBCHDigit(jr.G15) >= 0; )
        e ^= jr.G15 << (jr.getBCHDigit(e) - jr.getBCHDigit(jr.G15));
      return ((t << 10) | e) ^ jr.G15_MASK;
    },
    getBCHTypeNumber: function (t) {
      for (var e = t << 12; jr.getBCHDigit(e) - jr.getBCHDigit(jr.G18) >= 0; )
        e ^= jr.G18 << (jr.getBCHDigit(e) - jr.getBCHDigit(jr.G18));
      return (t << 12) | e;
    },
    getBCHDigit: function (t) {
      for (var e = 0; t != 0; ) e++, (t >>>= 1);
      return e;
    },
    getPatternPosition: function (t) {
      return jr.PATTERN_POSITION_TABLE[t - 1];
    },
    getMask: function (t, e, r) {
      switch (t) {
        case oc.PATTERN000:
          return (e + r) % 2 == 0;
        case oc.PATTERN001:
          return e % 2 == 0;
        case oc.PATTERN010:
          return r % 3 == 0;
        case oc.PATTERN011:
          return (e + r) % 3 == 0;
        case oc.PATTERN100:
          return (Math.floor(e / 2) + Math.floor(r / 3)) % 2 == 0;
        case oc.PATTERN101:
          return ((e * r) % 2) + ((e * r) % 3) == 0;
        case oc.PATTERN110:
          return (((e * r) % 2) + ((e * r) % 3)) % 2 == 0;
        case oc.PATTERN111:
          return (((e * r) % 3) + ((e + r) % 2)) % 2 == 0;
        default:
          throw new Error("bad maskPattern:" + t);
      }
    },
    getErrorCorrectPolynomial: function (t) {
      for (var e = new tf([1], 0), r = 0; r < t; r++)
        e = e.multiply(new tf([1, Pn.gexp(r)], 0));
      return e;
    },
    getLengthInBits: function (t, e) {
      if (1 <= e && e < 10)
        switch (t) {
          case ea.MODE_NUMBER:
            return 10;
          case ea.MODE_ALPHA_NUM:
            return 9;
          case ea.MODE_8BIT_BYTE:
            return 8;
          case ea.MODE_KANJI:
            return 8;
          default:
            throw new Error("mode:" + t);
        }
      else if (e < 27)
        switch (t) {
          case ea.MODE_NUMBER:
            return 12;
          case ea.MODE_ALPHA_NUM:
            return 11;
          case ea.MODE_8BIT_BYTE:
            return 16;
          case ea.MODE_KANJI:
            return 10;
          default:
            throw new Error("mode:" + t);
        }
      else if (e < 41)
        switch (t) {
          case ea.MODE_NUMBER:
            return 14;
          case ea.MODE_ALPHA_NUM:
            return 13;
          case ea.MODE_8BIT_BYTE:
            return 16;
          case ea.MODE_KANJI:
            return 12;
          default:
            throw new Error("mode:" + t);
        }
      else throw new Error("type:" + e);
    },
    getLostPoint: function (t) {
      for (var e = t.getModuleCount(), r = 0, n = 0; n < e; n++)
        for (var i = 0; i < e; i++) {
          for (var a = 0, s = t.isDark(n, i), o = -1; o <= 1; o++)
            if (!(n + o < 0 || e <= n + o))
              for (var c = -1; c <= 1; c++)
                i + c < 0 ||
                  e <= i + c ||
                  (o == 0 && c == 0) ||
                  (s == t.isDark(n + o, i + c) && a++);
          a > 5 && (r += 3 + a - 5);
        }
      for (var n = 0; n < e - 1; n++)
        for (var i = 0; i < e - 1; i++) {
          var u = 0;
          t.isDark(n, i) && u++,
            t.isDark(n + 1, i) && u++,
            t.isDark(n, i + 1) && u++,
            t.isDark(n + 1, i + 1) && u++,
            (u == 0 || u == 4) && (r += 3);
        }
      for (var n = 0; n < e; n++)
        for (var i = 0; i < e - 6; i++)
          t.isDark(n, i) &&
            !t.isDark(n, i + 1) &&
            t.isDark(n, i + 2) &&
            t.isDark(n, i + 3) &&
            t.isDark(n, i + 4) &&
            !t.isDark(n, i + 5) &&
            t.isDark(n, i + 6) &&
            (r += 40);
      for (var i = 0; i < e; i++)
        for (var n = 0; n < e - 6; n++)
          t.isDark(n, i) &&
            !t.isDark(n + 1, i) &&
            t.isDark(n + 2, i) &&
            t.isDark(n + 3, i) &&
            t.isDark(n + 4, i) &&
            !t.isDark(n + 5, i) &&
            t.isDark(n + 6, i) &&
            (r += 40);
      for (var d = 0, i = 0; i < e; i++)
        for (var n = 0; n < e; n++) t.isDark(n, i) && d++;
      var m = Math.abs((100 * d) / e / e - 50) / 5;
      return (r += m * 10), r;
    },
  },
  Pn = {
    glog: function (t) {
      if (t < 1) throw new Error("glog(" + t + ")");
      return Pn.LOG_TABLE[t];
    },
    gexp: function (t) {
      for (; t < 0; ) t += 255;
      for (; t >= 256; ) t -= 255;
      return Pn.EXP_TABLE[t];
    },
    EXP_TABLE: new Array(256),
    LOG_TABLE: new Array(256),
  };
for (var jn = 0; jn < 8; jn++) Pn.EXP_TABLE[jn] = 1 << jn;
for (var jn = 8; jn < 256; jn++)
  Pn.EXP_TABLE[jn] =
    Pn.EXP_TABLE[jn - 4] ^
    Pn.EXP_TABLE[jn - 5] ^
    Pn.EXP_TABLE[jn - 6] ^
    Pn.EXP_TABLE[jn - 8];
for (var jn = 0; jn < 255; jn++) Pn.LOG_TABLE[Pn.EXP_TABLE[jn]] = jn;
function tf(t, e) {
  if (t.length == null) throw new Error(t.length + "/" + e);
  for (var r = 0; r < t.length && t[r] == 0; ) r++;
  this.num = new Array(t.length - r + e);
  for (var n = 0; n < t.length - r; n++) this.num[n] = t[n + r];
}
tf.prototype = {
  get: function (t) {
    return this.num[t];
  },
  getLength: function () {
    return this.num.length;
  },
  multiply: function (t) {
    for (
      var e = new Array(this.getLength() + t.getLength() - 1), r = 0;
      r < this.getLength();
      r++
    )
      for (var n = 0; n < t.getLength(); n++)
        e[r + n] ^= Pn.gexp(Pn.glog(this.get(r)) + Pn.glog(t.get(n)));
    return new tf(e, 0);
  },
  mod: function (t) {
    if (this.getLength() - t.getLength() < 0) return this;
    for (
      var e = Pn.glog(this.get(0)) - Pn.glog(t.get(0)),
        r = new Array(this.getLength()),
        n = 0;
      n < this.getLength();
      n++
    )
      r[n] = this.get(n);
    for (var n = 0; n < t.getLength(); n++)
      r[n] ^= Pn.gexp(Pn.glog(t.get(n)) + e);
    return new tf(r, 0).mod(t);
  },
};
function zs(t, e) {
  (this.totalCount = t), (this.dataCount = e);
}
zs.RS_BLOCK_TABLE = [
  [1, 26, 19],
  [1, 26, 16],
  [1, 26, 13],
  [1, 26, 9],
  [1, 44, 34],
  [1, 44, 28],
  [1, 44, 22],
  [1, 44, 16],
  [1, 70, 55],
  [1, 70, 44],
  [2, 35, 17],
  [2, 35, 13],
  [1, 100, 80],
  [2, 50, 32],
  [2, 50, 24],
  [4, 25, 9],
  [1, 134, 108],
  [2, 67, 43],
  [2, 33, 15, 2, 34, 16],
  [2, 33, 11, 2, 34, 12],
  [2, 86, 68],
  [4, 43, 27],
  [4, 43, 19],
  [4, 43, 15],
  [2, 98, 78],
  [4, 49, 31],
  [2, 32, 14, 4, 33, 15],
  [4, 39, 13, 1, 40, 14],
  [2, 121, 97],
  [2, 60, 38, 2, 61, 39],
  [4, 40, 18, 2, 41, 19],
  [4, 40, 14, 2, 41, 15],
  [2, 146, 116],
  [3, 58, 36, 2, 59, 37],
  [4, 36, 16, 4, 37, 17],
  [4, 36, 12, 4, 37, 13],
  [2, 86, 68, 2, 87, 69],
  [4, 69, 43, 1, 70, 44],
  [6, 43, 19, 2, 44, 20],
  [6, 43, 15, 2, 44, 16],
  [4, 101, 81],
  [1, 80, 50, 4, 81, 51],
  [4, 50, 22, 4, 51, 23],
  [3, 36, 12, 8, 37, 13],
  [2, 116, 92, 2, 117, 93],
  [6, 58, 36, 2, 59, 37],
  [4, 46, 20, 6, 47, 21],
  [7, 42, 14, 4, 43, 15],
  [4, 133, 107],
  [8, 59, 37, 1, 60, 38],
  [8, 44, 20, 4, 45, 21],
  [12, 33, 11, 4, 34, 12],
  [3, 145, 115, 1, 146, 116],
  [4, 64, 40, 5, 65, 41],
  [11, 36, 16, 5, 37, 17],
  [11, 36, 12, 5, 37, 13],
  [5, 109, 87, 1, 110, 88],
  [5, 65, 41, 5, 66, 42],
  [5, 54, 24, 7, 55, 25],
  [11, 36, 12],
  [5, 122, 98, 1, 123, 99],
  [7, 73, 45, 3, 74, 46],
  [15, 43, 19, 2, 44, 20],
  [3, 45, 15, 13, 46, 16],
  [1, 135, 107, 5, 136, 108],
  [10, 74, 46, 1, 75, 47],
  [1, 50, 22, 15, 51, 23],
  [2, 42, 14, 17, 43, 15],
  [5, 150, 120, 1, 151, 121],
  [9, 69, 43, 4, 70, 44],
  [17, 50, 22, 1, 51, 23],
  [2, 42, 14, 19, 43, 15],
  [3, 141, 113, 4, 142, 114],
  [3, 70, 44, 11, 71, 45],
  [17, 47, 21, 4, 48, 22],
  [9, 39, 13, 16, 40, 14],
  [3, 135, 107, 5, 136, 108],
  [3, 67, 41, 13, 68, 42],
  [15, 54, 24, 5, 55, 25],
  [15, 43, 15, 10, 44, 16],
  [4, 144, 116, 4, 145, 117],
  [17, 68, 42],
  [17, 50, 22, 6, 51, 23],
  [19, 46, 16, 6, 47, 17],
  [2, 139, 111, 7, 140, 112],
  [17, 74, 46],
  [7, 54, 24, 16, 55, 25],
  [34, 37, 13],
  [4, 151, 121, 5, 152, 122],
  [4, 75, 47, 14, 76, 48],
  [11, 54, 24, 14, 55, 25],
  [16, 45, 15, 14, 46, 16],
  [6, 147, 117, 4, 148, 118],
  [6, 73, 45, 14, 74, 46],
  [11, 54, 24, 16, 55, 25],
  [30, 46, 16, 2, 47, 17],
  [8, 132, 106, 4, 133, 107],
  [8, 75, 47, 13, 76, 48],
  [7, 54, 24, 22, 55, 25],
  [22, 45, 15, 13, 46, 16],
  [10, 142, 114, 2, 143, 115],
  [19, 74, 46, 4, 75, 47],
  [28, 50, 22, 6, 51, 23],
  [33, 46, 16, 4, 47, 17],
  [8, 152, 122, 4, 153, 123],
  [22, 73, 45, 3, 74, 46],
  [8, 53, 23, 26, 54, 24],
  [12, 45, 15, 28, 46, 16],
  [3, 147, 117, 10, 148, 118],
  [3, 73, 45, 23, 74, 46],
  [4, 54, 24, 31, 55, 25],
  [11, 45, 15, 31, 46, 16],
  [7, 146, 116, 7, 147, 117],
  [21, 73, 45, 7, 74, 46],
  [1, 53, 23, 37, 54, 24],
  [19, 45, 15, 26, 46, 16],
  [5, 145, 115, 10, 146, 116],
  [19, 75, 47, 10, 76, 48],
  [15, 54, 24, 25, 55, 25],
  [23, 45, 15, 25, 46, 16],
  [13, 145, 115, 3, 146, 116],
  [2, 74, 46, 29, 75, 47],
  [42, 54, 24, 1, 55, 25],
  [23, 45, 15, 28, 46, 16],
  [17, 145, 115],
  [10, 74, 46, 23, 75, 47],
  [10, 54, 24, 35, 55, 25],
  [19, 45, 15, 35, 46, 16],
  [17, 145, 115, 1, 146, 116],
  [14, 74, 46, 21, 75, 47],
  [29, 54, 24, 19, 55, 25],
  [11, 45, 15, 46, 46, 16],
  [13, 145, 115, 6, 146, 116],
  [14, 74, 46, 23, 75, 47],
  [44, 54, 24, 7, 55, 25],
  [59, 46, 16, 1, 47, 17],
  [12, 151, 121, 7, 152, 122],
  [12, 75, 47, 26, 76, 48],
  [39, 54, 24, 14, 55, 25],
  [22, 45, 15, 41, 46, 16],
  [6, 151, 121, 14, 152, 122],
  [6, 75, 47, 34, 76, 48],
  [46, 54, 24, 10, 55, 25],
  [2, 45, 15, 64, 46, 16],
  [17, 152, 122, 4, 153, 123],
  [29, 74, 46, 14, 75, 47],
  [49, 54, 24, 10, 55, 25],
  [24, 45, 15, 46, 46, 16],
  [4, 152, 122, 18, 153, 123],
  [13, 74, 46, 32, 75, 47],
  [48, 54, 24, 14, 55, 25],
  [42, 45, 15, 32, 46, 16],
  [20, 147, 117, 4, 148, 118],
  [40, 75, 47, 7, 76, 48],
  [43, 54, 24, 22, 55, 25],
  [10, 45, 15, 67, 46, 16],
  [19, 148, 118, 6, 149, 119],
  [18, 75, 47, 31, 76, 48],
  [34, 54, 24, 34, 55, 25],
  [20, 45, 15, 61, 46, 16],
];
zs.getRSBlocks = function (t, e) {
  var r = zs.getRsBlockTable(t, e);
  if (r == null)
    throw new Error(
      "bad rs block @ typeNumber:" + t + "/errorCorrectLevel:" + e
    );
  for (var n = r.length / 3, i = [], a = 0; a < n; a++)
    for (
      var s = r[a * 3 + 0], o = r[a * 3 + 1], c = r[a * 3 + 2], u = 0;
      u < s;
      u++
    )
      i.push(new zs(o, c));
  return i;
};
zs.getRsBlockTable = function (t, e) {
  switch (e) {
    case Ac.L:
      return zs.RS_BLOCK_TABLE[(t - 1) * 4 + 0];
    case Ac.M:
      return zs.RS_BLOCK_TABLE[(t - 1) * 4 + 1];
    case Ac.Q:
      return zs.RS_BLOCK_TABLE[(t - 1) * 4 + 2];
    case Ac.H:
      return zs.RS_BLOCK_TABLE[(t - 1) * 4 + 3];
    default:
      return;
  }
};
function sU() {
  (this.buffer = []), (this.length = 0);
}
sU.prototype = {
  get: function (t) {
    var e = Math.floor(t / 8);
    return ((this.buffer[e] >>> (7 - (t % 8))) & 1) == 1;
  },
  put: function (t, e) {
    for (var r = 0; r < e; r++) this.putBit(((t >>> (e - r - 1)) & 1) == 1);
  },
  getLengthInBits: function () {
    return this.length;
  },
  putBit: function (t) {
    var e = Math.floor(this.length / 8);
    this.buffer.length <= e && this.buffer.push(0),
      t && (this.buffer[e] |= 128 >>> this.length % 8),
      this.length++;
  },
};
var t5 = [
  [17, 14, 11, 7],
  [32, 26, 20, 14],
  [53, 42, 32, 24],
  [78, 62, 46, 34],
  [106, 84, 60, 44],
  [134, 106, 74, 58],
  [154, 122, 86, 64],
  [192, 152, 108, 84],
  [230, 180, 130, 98],
  [271, 213, 151, 119],
  [321, 251, 177, 137],
  [367, 287, 203, 155],
  [425, 331, 241, 177],
  [458, 362, 258, 194],
  [520, 412, 292, 220],
  [586, 450, 322, 250],
  [644, 504, 364, 280],
  [718, 560, 394, 310],
  [792, 624, 442, 338],
  [858, 666, 482, 382],
  [929, 711, 509, 403],
  [1003, 779, 565, 439],
  [1091, 857, 611, 461],
  [1171, 911, 661, 511],
  [1273, 997, 715, 535],
  [1367, 1059, 751, 593],
  [1465, 1125, 805, 625],
  [1528, 1190, 868, 658],
  [1628, 1264, 908, 698],
  [1732, 1370, 982, 742],
  [1840, 1452, 1030, 790],
  [1952, 1538, 1112, 842],
  [2068, 1628, 1168, 898],
  [2188, 1722, 1228, 958],
  [2303, 1809, 1283, 983],
  [2431, 1911, 1351, 1051],
  [2563, 1989, 1423, 1093],
  [2699, 2099, 1499, 1139],
  [2809, 2213, 1579, 1219],
  [2953, 2331, 1663, 1273],
];
function oU(t) {
  if (
    ((this.options = {
      padding: 4,
      width: 256,
      height: 256,
      typeNumber: 4,
      color: "#000000",
      background: "#ffffff",
      ecl: "M",
      image: {
        svg: "",
        width: 0,
        height: 0,
      },
    }),
    typeof t == "string" &&
      (t = {
        content: t,
      }),
    t)
  )
    for (var e in t) this.options[e] = t[e];
  if (typeof this.options.content != "string")
    throw new Error("Expected 'content' as string!");
  if (this.options.content.length === 0)
    throw new Error("Expected 'content' to be non-empty!");
  if (!(this.options.padding >= 0))
    throw new Error("Expected 'padding' value to be non-negative!");
  if (!(this.options.width > 0) || !(this.options.height > 0))
    throw new Error(
      "Expected 'width' or 'height' value to be higher than zero!"
    );
  function r(c) {
    switch (c) {
      case "L":
        return Ac.L;
      case "M":
        return Ac.M;
      case "Q":
        return Ac.Q;
      case "H":
        return Ac.H;
      default:
        throw new Error("Unknwon error correction level: " + c);
    }
  }
  function n(c, u) {
    for (var d = i(c), m = 1, v = 0, E = 0, A = t5.length; E <= A; E++) {
      var I = t5[E];
      if (!I)
        throw new Error("Content too long: expected " + v + " but got " + d);
      switch (u) {
        case "L":
          v = I[0];
          break;
        case "M":
          v = I[1];
          break;
        case "Q":
          v = I[2];
          break;
        case "H":
          v = I[3];
          break;
        default:
          throw new Error("Unknwon error correction level: " + u);
      }
      if (d <= v) break;
      m++;
    }
    if (m > t5.length) throw new Error("Content too long");
    return m;
  }
  function i(c) {
    var u = encodeURI(c)
      .toString()
      .replace(/\%[0-9a-fA-F]{2}/g, "a");
    return u.length + (u.length != c ? 3 : 0);
  }
  var a = this.options.content,
    s = n(a, this.options.ecl),
    o = r(this.options.ecl);
  (this.qrcode = new Zs(s, o)), this.qrcode.addData(a), this.qrcode.make();
}
oU.prototype.svg = function (t) {
  var e = this.options || {},
    r = this.qrcode.modules;
  typeof t > "u" &&
    (t = {
      container: e.container || "svg",
    });
  for (
    var n = typeof e.pretty < "u" ? !!e.pretty : !0,
      i = n ? "  " : "",
      a = n
        ? `\r
`
        : "",
      s = e.width,
      o = e.height,
      c = r.length,
      u = s / (c + 2 * e.padding),
      d = o / (c + 2 * e.padding),
      m = typeof e.join < "u" ? !!e.join : !1,
      v = typeof e.swap < "u" ? !!e.swap : !1,
      E = typeof e.xmlDeclaration < "u" ? !!e.xmlDeclaration : !0,
      A = typeof e.predefined < "u" ? !!e.predefined : !1,
      I = A
        ? i +
          '<defs><path id="qrmodule" d="M0 0 h' +
          d +
          " v" +
          u +
          ' H0 z" style="fill:' +
          e.color +
          ';shape-rendering:crispEdges;" /></defs>' +
          a
        : "",
      b =
        i +
        '<rect x="0" y="0" width="' +
        s +
        '" height="' +
        o +
        '" style="fill:' +
        e.background +
        ';shape-rendering:crispEdges;"/>' +
        a,
      w = "",
      S = "",
      k = 0;
    k < c;
    k++
  )
    for (var N = 0; N < c; N++) {
      var O = r[N][k];
      if (O) {
        var F = N * u + e.padding * u,
          V = k * d + e.padding * d;
        if (v) {
          var j = F;
          (F = V), (V = j);
        }
        if (m) {
          var X = u + F,
            C = d + V;
          (F = Number.isInteger(F) ? Number(F) : F.toFixed(2)),
            (V = Number.isInteger(V) ? Number(V) : V.toFixed(2)),
            (X = Number.isInteger(X) ? Number(X) : X.toFixed(2)),
            (C = Number.isInteger(C) ? Number(C) : C.toFixed(2)),
            (S +=
              "M" +
              F +
              "," +
              V +
              " V" +
              C +
              " H" +
              X +
              " V" +
              V +
              " H" +
              F +
              " Z ");
        } else
          A
            ? (w +=
                i +
                '<use x="' +
                F.toString() +
                '" y="' +
                V.toString() +
                '" href="#qrmodule" />' +
                a)
            : (w +=
                i +
                '<rect x="' +
                F.toString() +
                '" y="' +
                V.toString() +
                '" width="' +
                u +
                '" height="' +
                d +
                '" style="fill:' +
                e.color +
                ';shape-rendering:crispEdges;"/>' +
                a);
      }
    }
  m &&
    (w =
      i +
      '<path x="0" y="0" style="fill:' +
      e.color +
      ';shape-rendering:crispEdges;" d="' +
      S +
      '" />');
  let l = "";
  if (this.options.image !== void 0 && this.options.image.svg) {
    const y = (s * this.options.image.width) / 100,
      h = (o * this.options.image.height) / 100,
      g = s / 2 - y / 2,
      T = o / 2 - h / 2;
    (l += `<svg x="${g}" y="${T}" width="${y}" height="${h}" viewBox="0 0 100 100" preserveAspectRatio="xMinYMin meet">`),
      (l += this.options.image.svg + a),
      (l += "</svg>");
  }
  var p = "";
  switch (t.container) {
    case "svg":
      E && (p += '<?xml version="1.0" standalone="yes"?>' + a),
        (p +=
          '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="' +
          s +
          '" height="' +
          o +
          '">' +
          a),
        (p += I + b + w),
        (p += l),
        (p += "</svg>");
      break;
    case "svg-viewbox":
      E && (p += '<?xml version="1.0" standalone="yes"?>' + a),
        (p +=
          '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 ' +
          s +
          " " +
          o +
          '">' +
          a),
        (p += I + b + w),
        (p += l),
        (p += "</svg>");
      break;
    case "g":
      (p += '<g width="' + s + '" height="' + o + '">' + a),
        (p += I + b + w),
        (p += l),
        (p += "</g>");
      break;
    default:
      p += (I + b + w + l).replace(/^\s+/, "");
      break;
  }
  return p;
};
var pye = oU,
  mye =
    (ke && ke.__importDefault) ||
    function (t) {
      return t && t.__esModule
        ? t
        : {
            default: t,
          };
    };
Object.defineProperty(sx, "__esModule", {
  value: !0,
});
sx.QRCode = void 0;
const yye = Qi,
  Y9 = rx,
  gye = mye(pye),
  bye = (t) => {
    const [e, r] = (0, Y9.useState)("");
    return (
      (0, Y9.useEffect)(() => {
        var n, i;
        const a = new gye.default({
            content: t.content,
            background: t.bgColor || "#ffffff",
            color: t.fgColor || "#000000",
            container: "svg",
            ecl: "M",
            width: (n = t.width) !== null && n !== void 0 ? n : 256,
            height: (i = t.height) !== null && i !== void 0 ? i : 256,
            padding: 0,
            image: t.image,
          }),
          s = Buffer.from(a.svg(), "utf8").toString("base64");
        r(`data:image/svg+xml;base64,${s}`);
      }, [t.bgColor, t.content, t.fgColor, t.height, t.image, t.width]),
      e
        ? (0, yye.h)("img", {
            src: e,
            alt: "QR Code",
          })
        : null
    );
  };
sx.QRCode = bye;
var ox = {},
  oT = {};
Object.defineProperty(oT, "__esModule", {
  value: !0,
});
oT.default =
  ".-cbwsdk-css-reset .-cbwsdk-spinner{display:inline-block}.-cbwsdk-css-reset .-cbwsdk-spinner svg{display:inline-block;animation:2s linear infinite -cbwsdk-spinner-svg}.-cbwsdk-css-reset .-cbwsdk-spinner svg circle{animation:1.9s ease-in-out infinite both -cbwsdk-spinner-circle;display:block;fill:rgba(0,0,0,0);stroke-dasharray:283;stroke-dashoffset:280;stroke-linecap:round;stroke-width:10px;transform-origin:50% 50%}@keyframes -cbwsdk-spinner-svg{0%{transform:rotateZ(0deg)}100%{transform:rotateZ(360deg)}}@keyframes -cbwsdk-spinner-circle{0%,25%{stroke-dashoffset:280;transform:rotate(0)}50%,75%{stroke-dashoffset:75;transform:rotate(45deg)}100%{stroke-dashoffset:280;transform:rotate(360deg)}}";
var vye =
  (ke && ke.__importDefault) ||
  function (t) {
    return t && t.__esModule
      ? t
      : {
          default: t,
        };
  };
Object.defineProperty(ox, "__esModule", {
  value: !0,
});
ox.Spinner = void 0;
const my = Qi,
  xye = vye(oT),
  wye = (t) => {
    var e;
    const r = (e = t.size) !== null && e !== void 0 ? e : 64,
      n = t.color || "#000";
    return (0, my.h)(
      "div",
      {
        class: "-cbwsdk-spinner",
      },
      (0, my.h)("style", null, xye.default),
      (0, my.h)(
        "svg",
        {
          viewBox: "0 0 100 100",
          xmlns: "http://www.w3.org/2000/svg",
          style: {
            width: r,
            height: r,
          },
        },
        (0, my.h)("circle", {
          style: {
            cx: 50,
            cy: 50,
            r: 45,
            stroke: n,
          },
        })
      )
    );
  };
ox.Spinner = wye;
var cT = {};
Object.defineProperty(cT, "__esModule", {
  value: !0,
});
cT.default =
  ".-cbwsdk-css-reset .-cbwsdk-connect-content{height:430px;width:700px;border-radius:12px;padding:30px}.-cbwsdk-css-reset .-cbwsdk-connect-content.light{background:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content.dark{background:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-content-header{display:flex;align-items:center;justify-content:space-between;margin:0 0 30px}.-cbwsdk-css-reset .-cbwsdk-connect-content-heading{font-style:normal;font-weight:500;font-size:28px;line-height:36px;margin:0}.-cbwsdk-css-reset .-cbwsdk-connect-content-heading.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-content-heading.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content-layout{display:flex;flex-direction:row}.-cbwsdk-css-reset .-cbwsdk-connect-content-column-left{margin-right:30px;display:flex;flex-direction:column;justify-content:space-between}.-cbwsdk-css-reset .-cbwsdk-connect-content-column-right{flex:25%;margin-right:34px}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-wrapper{width:220px;height:220px;border-radius:12px;display:flex;justify-content:center;align-items:center;background:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting{position:absolute;top:0;bottom:0;left:0;right:0;display:flex;flex-direction:column;align-items:center;justify-content:center}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.light{background-color:rgba(255,255,255,.95)}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.light>p{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.dark{background-color:rgba(10,11,13,.9)}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.dark>p{color:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting>p{font-size:12px;font-weight:bold;margin-top:16px}.-cbwsdk-css-reset .-cbwsdk-connect-content-update-app{border-radius:8px;font-size:14px;line-height:20px;padding:12px;width:339px}.-cbwsdk-css-reset .-cbwsdk-connect-content-update-app.light{background:#eef0f3;color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-connect-content-update-app.dark{background:#1e2025;color:#8a919e}.-cbwsdk-css-reset .-cbwsdk-cancel-button{-webkit-appearance:none;border:none;background:none;cursor:pointer;padding:0;margin:0}.-cbwsdk-css-reset .-cbwsdk-cancel-button-x{position:relative;display:block;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-wallet-steps{padding:0 0 0 16px;margin:0;width:100%;list-style:decimal}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item{list-style-type:decimal;display:list-item;font-style:normal;font-weight:400;font-size:16px;line-height:24px;margin-top:20px}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item-wrapper{display:flex;align-items:center}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-pad-left{margin-left:6px}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon{display:flex;border-radius:50%;height:24px;width:24px}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon svg{margin:auto;display:block}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon.light{background:#0052ff}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon.dark{background:#588af5}.-cbwsdk-css-reset .-cbwsdk-connect-item{align-items:center;display:flex;flex-direction:row;padding:16px 24px;gap:12px;cursor:pointer;border-radius:100px;font-weight:600}.-cbwsdk-css-reset .-cbwsdk-connect-item.light{background:#f5f8ff;color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-connect-item.dark{background:#001033;color:#588af5}.-cbwsdk-css-reset .-cbwsdk-connect-item-copy-wrapper{margin:0 4px 0 8px}.-cbwsdk-css-reset .-cbwsdk-connect-item-title{margin:0 0 0;font-size:16px;line-height:24px;font-weight:500}.-cbwsdk-css-reset .-cbwsdk-connect-item-description{font-weight:400;font-size:14px;line-height:20px;margin:0}";
var cU =
  (ke && ke.__importDefault) ||
  function (t) {
    return t && t.__esModule
      ? t
      : {
          default: t,
        };
  };
Object.defineProperty(qf, "__esModule", {
  value: !0,
});
qf.CoinbaseWalletSteps = qf.ConnectContent = void 0;
const su = cU(s1),
  jt = Qi,
  _ye = ot,
  Eye = Sd,
  Tye = nx,
  Cye = ix,
  Aye = ax,
  kye = sx,
  Sye = ox,
  Mye = cU(cT),
  r5 = {
    title: "Coinbase Wallet app",
    description: "Connect with your self-custody wallet",
    steps: lU,
  },
  Iye = (t) => (t === "light" ? "#FFFFFF" : "#0A0B0D");
function Rye(t) {
  const { theme: e } = t,
    r = (0, _ye.createQrUrl)(
      t.sessionId,
      t.sessionSecret,
      t.linkAPIUrl,
      t.isParentConnection,
      t.version,
      t.chainId
    ),
    n = r5.steps;
  return (0, jt.h)(
    "div",
    {
      "data-testid": "connect-content",
      className: (0, su.default)("-cbwsdk-connect-content", e),
    },
    (0, jt.h)("style", null, Mye.default),
    (0, jt.h)(
      "div",
      {
        className: "-cbwsdk-connect-content-header",
      },
      (0, jt.h)(
        "h2",
        {
          className: (0, su.default)("-cbwsdk-connect-content-heading", e),
        },
        "Scan to connect with our mobile app"
      ),
      t.onCancel &&
        (0, jt.h)(
          "button",
          {
            type: "button",
            className: "-cbwsdk-cancel-button",
            onClick: t.onCancel,
          },
          (0, jt.h)(Tye.CloseIcon, {
            fill: e === "light" ? "#0A0B0D" : "#FFFFFF",
          })
        )
    ),
    (0, jt.h)(
      "div",
      {
        className: "-cbwsdk-connect-content-layout",
      },
      (0, jt.h)(
        "div",
        {
          className: "-cbwsdk-connect-content-column-left",
        },
        (0, jt.h)(Pye, {
          title: r5.title,
          description: r5.description,
          theme: e,
        })
      ),
      (0, jt.h)(
        "div",
        {
          className: "-cbwsdk-connect-content-column-right",
        },
        (0, jt.h)(
          "div",
          {
            className: "-cbwsdk-connect-content-qr-wrapper",
          },
          (0, jt.h)(kye.QRCode, {
            content: r,
            width: 200,
            height: 200,
            fgColor: "#000",
            bgColor: "transparent",
          }),
          (0, jt.h)("input", {
            type: "hidden",
            name: "cbw-cbwsdk-version",
            value: Eye.LIB_VERSION,
          }),
          (0, jt.h)("input", {
            type: "hidden",
            value: r,
          })
        ),
        (0, jt.h)(n, {
          theme: e,
        }),
        !t.isConnected &&
          (0, jt.h)(
            "div",
            {
              "data-testid": "connecting-spinner",
              className: (0, su.default)(
                "-cbwsdk-connect-content-qr-connecting",
                e
              ),
            },
            (0, jt.h)(Sye.Spinner, {
              size: 36,
              color: e === "dark" ? "#FFF" : "#000",
            }),
            (0, jt.h)("p", null, "Connecting...")
          )
      )
    )
  );
}
qf.ConnectContent = Rye;
function Pye({ title: t, description: e, theme: r }) {
  return (0, jt.h)(
    "div",
    {
      className: (0, su.default)("-cbwsdk-connect-item", r),
    },
    (0, jt.h)("div", null, (0, jt.h)(Cye.CoinbaseWalletRound, null)),
    (0, jt.h)(
      "div",
      {
        className: "-cbwsdk-connect-item-copy-wrapper",
      },
      (0, jt.h)(
        "h3",
        {
          className: "-cbwsdk-connect-item-title",
        },
        t
      ),
      (0, jt.h)(
        "p",
        {
          className: "-cbwsdk-connect-item-description",
        },
        e
      )
    )
  );
}
function lU({ theme: t }) {
  return (0, jt.h)(
    "ol",
    {
      className: "-cbwsdk-wallet-steps",
    },
    (0, jt.h)(
      "li",
      {
        className: (0, su.default)("-cbwsdk-wallet-steps-item", t),
      },
      (0, jt.h)(
        "div",
        {
          className: "-cbwsdk-wallet-steps-item-wrapper",
        },
        "Open Coinbase Wallet app"
      )
    ),
    (0, jt.h)(
      "li",
      {
        className: (0, su.default)("-cbwsdk-wallet-steps-item", t),
      },
      (0, jt.h)(
        "div",
        {
          className: "-cbwsdk-wallet-steps-item-wrapper",
        },
        (0, jt.h)("span", null, "Tap ", (0, jt.h)("strong", null, "Scan"), " "),
        (0, jt.h)(
          "span",
          {
            className: (0, su.default)(
              "-cbwsdk-wallet-steps-pad-left",
              "-cbwsdk-wallet-steps-icon",
              t
            ),
          },
          (0, jt.h)(Aye.QRCodeIcon, {
            fill: Iye(t),
          })
        )
      )
    )
  );
}
qf.CoinbaseWalletSteps = lU;
var cx = {},
  lx = {};
Object.defineProperty(lx, "__esModule", {
  value: !0,
});
lx.ArrowLeftIcon = void 0;
const X9 = Qi;
function Nye(t) {
  return (0, X9.h)(
    "svg",
    Object.assign(
      {
        width: "16",
        height: "16",
        viewBox: "0 0 16 16",
        xmlns: "http://www.w3.org/2000/svg",
      },
      t
    ),
    (0, X9.h)("path", {
      d: "M8.60675 0.155884L7.37816 1.28209L12.7723 7.16662H0V8.83328H12.6548L6.82149 14.6666L8 15.8451L15.8201 8.02501L8.60675 0.155884Z",
    })
  );
}
lx.ArrowLeftIcon = Nye;
var ux = {};
Object.defineProperty(ux, "__esModule", {
  value: !0,
});
ux.LaptopIcon = void 0;
const n5 = Qi;
function Bye(t) {
  return (0, n5.h)(
    "svg",
    Object.assign(
      {
        width: "14",
        height: "14",
        viewBox: "0 0 14 14",
        xmlns: "http://www.w3.org/2000/svg",
      },
      t
    ),
    (0, n5.h)("path", {
      d: "M1.8001 2.2002H12.2001V9.40019H1.8001V2.2002ZM3.4001 3.8002V7.80019H10.6001V3.8002H3.4001Z",
    }),
    (0, n5.h)("path", {
      d: "M13.4001 10.2002H0.600098C0.600098 11.0838 1.31644 11.8002 2.2001 11.8002H11.8001C12.6838 11.8002 13.4001 11.0838 13.4001 10.2002Z",
    })
  );
}
ux.LaptopIcon = Bye;
var fx = {};
Object.defineProperty(fx, "__esModule", {
  value: !0,
});
fx.SafeIcon = void 0;
const eM = Qi;
function Dye(t) {
  return (0, eM.h)(
    "svg",
    Object.assign(
      {
        width: "14",
        height: "14",
        viewBox: "0 0 14 14",
        xmlns: "http://www.w3.org/2000/svg",
      },
      t
    ),
    (0, eM.h)("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M0.600098 0.600098V11.8001H13.4001V0.600098H0.600098ZM7.0001 9.2001C5.3441 9.2001 4.0001 7.8561 4.0001 6.2001C4.0001 4.5441 5.3441 3.2001 7.0001 3.2001C8.6561 3.2001 10.0001 4.5441 10.0001 6.2001C10.0001 7.8561 8.6561 9.2001 7.0001 9.2001ZM0.600098 12.6001H3.8001V13.4001H0.600098V12.6001ZM10.2001 12.6001H13.4001V13.4001H10.2001V12.6001ZM8.8001 6.2001C8.8001 7.19421 7.99421 8.0001 7.0001 8.0001C6.00598 8.0001 5.2001 7.19421 5.2001 6.2001C5.2001 5.20598 6.00598 4.4001 7.0001 4.4001C7.99421 4.4001 8.8001 5.20598 8.8001 6.2001Z",
    })
  );
}
fx.SafeIcon = Dye;
var lT = {};
Object.defineProperty(lT, "__esModule", {
  value: !0,
});
lT.default =
  ".-cbwsdk-css-reset .-cbwsdk-try-extension{display:flex;margin-top:12px;height:202px;width:700px;border-radius:12px;padding:30px}.-cbwsdk-css-reset .-cbwsdk-try-extension.light{background:#fff}.-cbwsdk-css-reset .-cbwsdk-try-extension.dark{background:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-try-extension-column-half{flex:50%}.-cbwsdk-css-reset .-cbwsdk-try-extension-heading{font-style:normal;font-weight:500;font-size:25px;line-height:32px;margin:0;max-width:204px}.-cbwsdk-css-reset .-cbwsdk-try-extension-heading.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-try-extension-heading.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta{appearance:none;border:none;background:none;color:#0052ff;cursor:pointer;padding:0;text-decoration:none;display:block;font-weight:600;font-size:16px;line-height:24px}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta.light{color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta.dark{color:#588af5}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta-wrapper{display:flex;align-items:center;margin-top:12px}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta-icon{display:block;margin-left:4px;height:14px}.-cbwsdk-css-reset .-cbwsdk-try-extension-list{display:flex;flex-direction:column;justify-content:center;align-items:center;margin:0;padding:0;list-style:none;height:100%}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item{display:flex;align-items:center;flex-flow:nowrap;margin-top:24px}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item:first-of-type{margin-top:0}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon-wrapper{display:block}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon{display:flex;height:32px;width:32px;border-radius:50%}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon svg{margin:auto;display:block}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon.light{background:#eef0f3}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon.dark{background:#1e2025}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-copy{display:block;font-weight:400;font-size:14px;line-height:20px;padding-left:12px}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-copy.light{color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-copy.dark{color:#8a919e}";
var uU =
  (ke && ke.__importDefault) ||
  function (t) {
    return t && t.__esModule
      ? t
      : {
          default: t,
        };
  };
Object.defineProperty(cx, "__esModule", {
  value: !0,
});
cx.TryExtensionContent = void 0;
const Al = uU(s1),
  ln = Qi,
  i5 = rx,
  Oye = lx,
  Fye = ux,
  Lye = fx,
  $ye = uU(lT);
function Uye({ theme: t }) {
  const [e, r] = (0, i5.useState)(!1),
    n = (0, i5.useCallback)(() => {
      window.open(
        "https://api.wallet.coinbase.com/rpc/v2/desktop/chrome",
        "_blank"
      );
    }, []),
    i = (0, i5.useCallback)(() => {
      e ? window.location.reload() : (n(), r(!0));
    }, [n, e]);
  return (0, ln.h)(
    "div",
    {
      class: (0, Al.default)("-cbwsdk-try-extension", t),
    },
    (0, ln.h)("style", null, $ye.default),
    (0, ln.h)(
      "div",
      {
        class: "-cbwsdk-try-extension-column-half",
      },
      (0, ln.h)(
        "h3",
        {
          class: (0, Al.default)("-cbwsdk-try-extension-heading", t),
        },
        "Or try the Coinbase Wallet browser extension"
      ),
      (0, ln.h)(
        "div",
        {
          class: "-cbwsdk-try-extension-cta-wrapper",
        },
        (0, ln.h)(
          "button",
          {
            class: (0, Al.default)("-cbwsdk-try-extension-cta", t),
            onClick: i,
          },
          e ? "Refresh" : "Install"
        ),
        (0, ln.h)(
          "div",
          null,
          !e &&
            (0, ln.h)(Oye.ArrowLeftIcon, {
              class: "-cbwsdk-try-extension-cta-icon",
              fill: t === "light" ? "#0052FF" : "#588AF5",
            })
        )
      )
    ),
    (0, ln.h)(
      "div",
      {
        class: "-cbwsdk-try-extension-column-half",
      },
      (0, ln.h)(
        "ul",
        {
          class: "-cbwsdk-try-extension-list",
        },
        (0, ln.h)(
          "li",
          {
            class: "-cbwsdk-try-extension-list-item",
          },
          (0, ln.h)(
            "div",
            {
              class: "-cbwsdk-try-extension-list-item-icon-wrapper",
            },
            (0, ln.h)(
              "span",
              {
                class: (0, Al.default)(
                  "-cbwsdk-try-extension-list-item-icon",
                  t
                ),
              },
              (0, ln.h)(Fye.LaptopIcon, {
                fill: t === "light" ? "#0A0B0D" : "#FFFFFF",
              })
            )
          ),
          (0, ln.h)(
            "div",
            {
              class: (0, Al.default)("-cbwsdk-try-extension-list-item-copy", t),
            },
            "Connect with dapps with just one click on your desktop browser"
          )
        ),
        (0, ln.h)(
          "li",
          {
            class: "-cbwsdk-try-extension-list-item",
          },
          (0, ln.h)(
            "div",
            {
              class: "-cbwsdk-try-extension-list-item-icon-wrapper",
            },
            (0, ln.h)(
              "span",
              {
                class: (0, Al.default)(
                  "-cbwsdk-try-extension-list-item-icon",
                  t
                ),
              },
              (0, ln.h)(Lye.SafeIcon, {
                fill: t === "light" ? "#0A0B0D" : "#FFFFFF",
              })
            )
          ),
          (0, ln.h)(
            "div",
            {
              class: (0, Al.default)("-cbwsdk-try-extension-list-item-copy", t),
            },
            "Add an additional layer of security by using a supported Ledger hardware wallet"
          )
        )
      )
    )
  );
}
cx.TryExtensionContent = Uye;
var uT = {};
Object.defineProperty(uT, "__esModule", {
  value: !0,
});
uT.default =
  ".-cbwsdk-css-reset .-cbwsdk-connect-dialog{z-index:2147483647;position:fixed;top:0;left:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop{z-index:2147483647;position:fixed;top:0;left:0;right:0;bottom:0;transition:opacity .25s}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop.light{background-color:rgba(0,0,0,.5)}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop.dark{background-color:rgba(50,53,61,.4)}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop-hidden{opacity:0}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-box{display:flex;position:relative;flex-direction:column;transform:scale(1);transition:opacity .25s,transform .25s}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-box-hidden{opacity:0;transform:scale(0.85)}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-container{display:block}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-container-hidden{display:none}";
var fU =
  (ke && ke.__importDefault) ||
  function (t) {
    return t && t.__esModule
      ? t
      : {
          default: t,
        };
  };
Object.defineProperty(tx, "__esModule", {
  value: !0,
});
tx.ConnectDialog = void 0;
const a5 = fU(s1),
  kl = Qi,
  s5 = rx,
  Wye = qf,
  jye = cx,
  Hye = fU(uT),
  zye = (t) => {
    const { isOpen: e, darkMode: r } = t,
      [n, i] = (0, s5.useState)(!e),
      [a, s] = (0, s5.useState)(!e);
    (0, s5.useEffect)(() => {
      const c = [
        window.setTimeout(() => {
          s(!e);
        }, 10),
      ];
      return (
        e
          ? i(!1)
          : c.push(
              window.setTimeout(() => {
                i(!0);
              }, 360)
            ),
        () => {
          c.forEach(window.clearTimeout);
        }
      );
    }, [e]);
    const o = r ? "dark" : "light";
    return (0, kl.h)(
      "div",
      {
        class: (0, a5.default)(
          "-cbwsdk-connect-dialog-container",
          n && "-cbwsdk-connect-dialog-container-hidden"
        ),
      },
      (0, kl.h)("style", null, Hye.default),
      (0, kl.h)("div", {
        class: (0, a5.default)(
          "-cbwsdk-connect-dialog-backdrop",
          o,
          a && "-cbwsdk-connect-dialog-backdrop-hidden"
        ),
      }),
      (0, kl.h)(
        "div",
        {
          class: "-cbwsdk-connect-dialog",
        },
        (0, kl.h)(
          "div",
          {
            class: (0, a5.default)(
              "-cbwsdk-connect-dialog-box",
              a && "-cbwsdk-connect-dialog-box-hidden"
            ),
          },
          t.connectDisabled
            ? null
            : (0, kl.h)(Wye.ConnectContent, {
                theme: o,
                version: t.version,
                sessionId: t.sessionId,
                sessionSecret: t.sessionSecret,
                linkAPIUrl: t.linkAPIUrl,
                isConnected: t.isConnected,
                isParentConnection: t.isParentConnection,
                chainId: t.chainId,
                onCancel: t.onCancel,
              }),
          (0, kl.h)(jye.TryExtensionContent, {
            theme: o,
          })
        )
      )
    );
  };
tx.ConnectDialog = zye;
Object.defineProperty(Xv, "__esModule", {
  value: !0,
});
Xv.LinkFlow = void 0;
const o5 = Qi,
  qye = tx;
class Vye {
  constructor(e) {
    (this.connected = !1),
      (this.chainId = 1),
      (this.isOpen = !1),
      (this.onCancel = null),
      (this.root = null),
      (this.connectDisabled = !1),
      (this.darkMode = e.darkMode),
      (this.version = e.version),
      (this.sessionId = e.sessionId),
      (this.sessionSecret = e.sessionSecret),
      (this.linkAPIUrl = e.linkAPIUrl),
      (this.isParentConnection = e.isParentConnection);
  }
  attach(e) {
    (this.root = document.createElement("div")),
      (this.root.className = "-cbwsdk-link-flow-root"),
      e.appendChild(this.root),
      this.render();
  }
  setConnected(e) {
    this.connected !== e && ((this.connected = e), this.render());
  }
  setChainId(e) {
    this.chainId !== e && ((this.chainId = e), this.render());
  }
  detach() {
    var e;
    this.root &&
      ((0, o5.render)(null, this.root),
      (e = this.root.parentElement) === null ||
        e === void 0 ||
        e.removeChild(this.root));
  }
  setConnectDisabled(e) {
    this.connectDisabled = e;
  }
  open(e) {
    (this.isOpen = !0), (this.onCancel = e.onCancel), this.render();
  }
  close() {
    (this.isOpen = !1), (this.onCancel = null), this.render();
  }
  render() {
    this.root &&
      (0, o5.render)(
        (0, o5.h)(qye.ConnectDialog, {
          darkMode: this.darkMode,
          version: this.version,
          sessionId: this.sessionId,
          sessionSecret: this.sessionSecret,
          linkAPIUrl: this.linkAPIUrl,
          isOpen: this.isOpen,
          isConnected: this.connected,
          isParentConnection: this.isParentConnection,
          chainId: this.chainId,
          onCancel: this.onCancel,
          connectDisabled: this.connectDisabled,
        }),
        this.root
      );
  }
}
Xv.LinkFlow = Vye;
var fT = {},
  dT = {};
Object.defineProperty(dT, "__esModule", {
  value: !0,
});
dT.default =
  ".-cbwsdk-css-reset .-gear-container{margin-left:16px !important;margin-right:9px !important;display:flex;align-items:center;justify-content:center;width:24px;height:24px;transition:opacity .25s}.-cbwsdk-css-reset .-gear-container *{user-select:none}.-cbwsdk-css-reset .-gear-container svg{opacity:0;position:absolute}.-cbwsdk-css-reset .-gear-icon{height:12px;width:12px;z-index:10000}.-cbwsdk-css-reset .-cbwsdk-snackbar{align-items:flex-end;display:flex;flex-direction:column;position:fixed;right:0;top:0;z-index:2147483647}.-cbwsdk-css-reset .-cbwsdk-snackbar *{user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance{display:flex;flex-direction:column;margin:8px 16px 0 16px;overflow:visible;text-align:left;transform:translateX(0);transition:opacity .25s,transform .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header:hover .-gear-container svg{opacity:1}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header{display:flex;align-items:center;background:#fff;overflow:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-cblogo{margin:8px 8px 8px 8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-message{color:#000;font-size:13px;line-height:1.5;user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu{background:#fff;transition:opacity .25s ease-in-out,transform .25s linear,visibility 0s;visibility:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;opacity:0;flex-direction:column;padding-left:8px;padding-right:8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:last-child{margin-bottom:8px !important}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover{background:#f5f7f8;border-radius:6px;transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover span{color:#050f19;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover svg path{fill:#000;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item{visibility:inherit;height:35px;margin-top:8px;margin-bottom:0;display:flex;flex-direction:row;align-items:center;padding:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item *{visibility:inherit;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover{background:rgba(223,95,103,.2);transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover svg path{fill:#df5f67;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover span{color:#df5f67;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-info{color:#aaa;font-size:13px;margin:0 8px 0 32px;position:absolute}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-hidden{opacity:0;text-align:left;transform:translateX(25%);transition:opacity .5s linear}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-expanded .-cbwsdk-snackbar-instance-menu{opacity:1;display:flex;transform:translateY(8px);visibility:visible}";
(function (t) {
  var e =
    (ke && ke.__importDefault) ||
    function (m) {
      return m && m.__esModule
        ? m
        : {
            default: m,
          };
    };
  Object.defineProperty(t, "__esModule", {
    value: !0,
  }),
    (t.SnackbarInstance = t.SnackbarContainer = t.Snackbar = void 0);
  const r = e(s1),
    n = Qi,
    i = rx,
    a = e(dT),
    s =
      "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEuNDkyIDEwLjQxOWE4LjkzIDguOTMgMCAwMTguOTMtOC45M2gxMS4xNjNhOC45MyA4LjkzIDAgMDE4LjkzIDguOTN2MTEuMTYzYTguOTMgOC45MyAwIDAxLTguOTMgOC45M0gxMC40MjJhOC45MyA4LjkzIDAgMDEtOC45My04LjkzVjEwLjQxOXoiIGZpbGw9IiMxNjUyRjAiLz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEwLjQxOSAwSDIxLjU4QzI3LjMzNSAwIDMyIDQuNjY1IDMyIDEwLjQxOVYyMS41OEMzMiAyNy4zMzUgMjcuMzM1IDMyIDIxLjU4MSAzMkgxMC40MkM0LjY2NSAzMiAwIDI3LjMzNSAwIDIxLjU4MVYxMC40MkMwIDQuNjY1IDQuNjY1IDAgMTAuNDE5IDB6bTAgMS40ODhhOC45MyA4LjkzIDAgMDAtOC45MyA4LjkzdjExLjE2M2E4LjkzIDguOTMgMCAwMDguOTMgOC45M0gyMS41OGE4LjkzIDguOTMgMCAwMDguOTMtOC45M1YxMC40MmE4LjkzIDguOTMgMCAwMC04LjkzLTguOTNIMTAuNDJ6IiBmaWxsPSIjZmZmIi8+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNS45OTggMjYuMDQ5Yy01LjU0OSAwLTEwLjA0Ny00LjQ5OC0xMC4wNDctMTAuMDQ3IDAtNS41NDggNC40OTgtMTAuMDQ2IDEwLjA0Ny0xMC4wNDYgNS41NDggMCAxMC4wNDYgNC40OTggMTAuMDQ2IDEwLjA0NiAwIDUuNTQ5LTQuNDk4IDEwLjA0Ny0xMC4wNDYgMTAuMDQ3eiIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0xMi43NjIgMTQuMjU0YzAtLjgyMi42NjctMS40ODkgMS40ODktMS40ODloMy40OTdjLjgyMiAwIDEuNDg4LjY2NiAxLjQ4OCAxLjQ4OXYzLjQ5N2MwIC44MjItLjY2NiAxLjQ4OC0xLjQ4OCAxLjQ4OGgtMy40OTdhMS40ODggMS40ODggMCAwMS0xLjQ4OS0xLjQ4OHYtMy40OTh6IiBmaWxsPSIjMTY1MkYwIi8+PC9zdmc+",
    o =
      "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDYuNzV2LTEuNWwtMS43Mi0uNTdjLS4wOC0uMjctLjE5LS41Mi0uMzItLjc3bC44MS0xLjYyLTEuMDYtMS4wNi0xLjYyLjgxYy0uMjQtLjEzLS41LS4yNC0uNzctLjMyTDYuNzUgMGgtMS41bC0uNTcgMS43MmMtLjI3LjA4LS41My4xOS0uNzcuMzJsLTEuNjItLjgxLTEuMDYgMS4wNi44MSAxLjYyYy0uMTMuMjQtLjI0LjUtLjMyLjc3TDAgNS4yNXYxLjVsMS43Mi41N2MuMDguMjcuMTkuNTMuMzIuNzdsLS44MSAxLjYyIDEuMDYgMS4wNiAxLjYyLS44MWMuMjQuMTMuNS4yMy43Ny4zMkw1LjI1IDEyaDEuNWwuNTctMS43MmMuMjctLjA4LjUyLS4xOS43Ny0uMzJsMS42Mi44MSAxLjA2LTEuMDYtLjgxLTEuNjJjLjEzLS4yNC4yMy0uNS4zMi0uNzdMMTIgNi43NXpNNiA4LjVhMi41IDIuNSAwIDAxMC01IDIuNSAyLjUgMCAwMTAgNXoiIGZpbGw9IiMwNTBGMTkiLz48L3N2Zz4=";
  class c {
    constructor(v) {
      (this.items = new Map()),
        (this.nextItemKey = 0),
        (this.root = null),
        (this.darkMode = v.darkMode);
    }
    attach(v) {
      (this.root = document.createElement("div")),
        (this.root.className = "-cbwsdk-snackbar-root"),
        v.appendChild(this.root),
        this.render();
    }
    presentItem(v) {
      const E = this.nextItemKey++;
      return (
        this.items.set(E, v),
        this.render(),
        () => {
          this.items.delete(E), this.render();
        }
      );
    }
    clear() {
      this.items.clear(), this.render();
    }
    render() {
      this.root &&
        (0, n.render)(
          (0, n.h)(
            "div",
            null,
            (0, n.h)(
              t.SnackbarContainer,
              {
                darkMode: this.darkMode,
              },
              Array.from(this.items.entries()).map(([v, E]) =>
                (0, n.h)(
                  t.SnackbarInstance,
                  Object.assign({}, E, {
                    key: v,
                  })
                )
              )
            )
          ),
          this.root
        );
    }
  }
  t.Snackbar = c;
  const u = (m) =>
    (0, n.h)(
      "div",
      {
        class: (0, r.default)("-cbwsdk-snackbar-container"),
      },
      (0, n.h)("style", null, a.default),
      (0, n.h)(
        "div",
        {
          class: "-cbwsdk-snackbar",
        },
        m.children
      )
    );
  t.SnackbarContainer = u;
  const d = ({ autoExpand: m, message: v, menuItems: E }) => {
    const [A, I] = (0, i.useState)(!0),
      [b, w] = (0, i.useState)(m ?? !1);
    (0, i.useEffect)(() => {
      const k = [
        window.setTimeout(() => {
          I(!1);
        }, 1),
        window.setTimeout(() => {
          w(!0);
        }, 1e4),
      ];
      return () => {
        k.forEach(window.clearTimeout);
      };
    });
    const S = () => {
      w(!b);
    };
    return (0, n.h)(
      "div",
      {
        class: (0, r.default)(
          "-cbwsdk-snackbar-instance",
          A && "-cbwsdk-snackbar-instance-hidden",
          b && "-cbwsdk-snackbar-instance-expanded"
        ),
      },
      (0, n.h)(
        "div",
        {
          class: "-cbwsdk-snackbar-instance-header",
          onClick: S,
        },
        (0, n.h)("img", {
          src: s,
          class: "-cbwsdk-snackbar-instance-header-cblogo",
        }),
        " ",
        (0, n.h)(
          "div",
          {
            class: "-cbwsdk-snackbar-instance-header-message",
          },
          v
        ),
        (0, n.h)(
          "div",
          {
            class: "-gear-container",
          },
          !b &&
            (0, n.h)(
              "svg",
              {
                width: "24",
                height: "24",
                viewBox: "0 0 24 24",
                fill: "none",
                xmlns: "http://www.w3.org/2000/svg",
              },
              (0, n.h)("circle", {
                cx: "12",
                cy: "12",
                r: "12",
                fill: "#F5F7F8",
              })
            ),
          (0, n.h)("img", {
            src: o,
            class: "-gear-icon",
            title: "Expand",
          })
        )
      ),
      E &&
        E.length > 0 &&
        (0, n.h)(
          "div",
          {
            class: "-cbwsdk-snackbar-instance-menu",
          },
          E.map((k, N) =>
            (0, n.h)(
              "div",
              {
                class: (0, r.default)(
                  "-cbwsdk-snackbar-instance-menu-item",
                  k.isRed && "-cbwsdk-snackbar-instance-menu-item-is-red"
                ),
                onClick: k.onClick,
                key: N,
              },
              (0, n.h)(
                "svg",
                {
                  width: k.svgWidth,
                  height: k.svgHeight,
                  viewBox: "0 0 10 11",
                  fill: "none",
                  xmlns: "http://www.w3.org/2000/svg",
                },
                (0, n.h)("path", {
                  "fill-rule": k.defaultFillRule,
                  "clip-rule": k.defaultClipRule,
                  d: k.path,
                  fill: "#AAAAAA",
                })
              ),
              (0, n.h)(
                "span",
                {
                  class: (0, r.default)(
                    "-cbwsdk-snackbar-instance-menu-item-info",
                    k.isRed && "-cbwsdk-snackbar-instance-menu-item-info-is-red"
                  ),
                },
                k.info
              )
            )
          )
        )
    );
  };
  t.SnackbarInstance = d;
})(fT);
Object.defineProperty(r1, "__esModule", {
  value: !0,
});
r1.WalletLinkRelayUI = void 0;
const Kye = n1,
  Gye = Xv,
  Zye = fT;
class Jye {
  constructor(e) {
    (this.standalone = null),
      (this.attached = !1),
      (this.snackbar = new Zye.Snackbar({
        darkMode: e.darkMode,
      })),
      (this.linkFlow = new Gye.LinkFlow({
        darkMode: e.darkMode,
        version: e.version,
        sessionId: e.session.id,
        sessionSecret: e.session.secret,
        linkAPIUrl: e.linkAPIUrl,
        isParentConnection: !1,
      }));
  }
  attach() {
    if (this.attached)
      throw new Error("Coinbase Wallet SDK UI is already attached");
    const e = document.documentElement,
      r = document.createElement("div");
    (r.className = "-cbwsdk-css-reset"),
      e.appendChild(r),
      this.linkFlow.attach(r),
      this.snackbar.attach(r),
      (this.attached = !0),
      (0, Kye.injectCssReset)();
  }
  setConnected(e) {
    this.linkFlow.setConnected(e);
  }
  setChainId(e) {
    this.linkFlow.setChainId(e);
  }
  setConnectDisabled(e) {
    this.linkFlow.setConnectDisabled(e);
  }
  addEthereumChain() {}
  watchAsset() {}
  switchEthereumChain() {}
  requestEthereumAccounts(e) {
    this.linkFlow.open({
      onCancel: e.onCancel,
    });
  }
  hideRequestEthereumAccounts() {
    this.linkFlow.close();
  }
  signEthereumMessage() {}
  signEthereumTransaction() {}
  submitEthereumTransaction() {}
  ethereumAddressFromSignedMessage() {}
  showConnecting(e) {
    let r;
    return (
      e.isUnlinkedErrorState
        ? (r = {
            autoExpand: !0,
            message: "Connection lost",
            menuItems: [
              {
                isRed: !1,
                info: "Reset connection",
                svgWidth: "10",
                svgHeight: "11",
                path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
                defaultFillRule: "evenodd",
                defaultClipRule: "evenodd",
                onClick: e.onResetConnection,
              },
            ],
          })
        : (r = {
            message: "Confirm on phone",
            menuItems: [
              {
                isRed: !0,
                info: "Cancel transaction",
                svgWidth: "11",
                svgHeight: "11",
                path: "M10.3711 1.52346L9.21775 0.370117L5.37109 4.21022L1.52444 0.370117L0.371094 1.52346L4.2112 5.37012L0.371094 9.21677L1.52444 10.3701L5.37109 6.53001L9.21775 10.3701L10.3711 9.21677L6.53099 5.37012L10.3711 1.52346Z",
                defaultFillRule: "inherit",
                defaultClipRule: "inherit",
                onClick: e.onCancel,
              },
              {
                isRed: !1,
                info: "Reset connection",
                svgWidth: "10",
                svgHeight: "11",
                path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
                defaultFillRule: "evenodd",
                defaultClipRule: "evenodd",
                onClick: e.onResetConnection,
              },
            ],
          }),
      this.snackbar.presentItem(r)
    );
  }
  reloadUI() {
    document.location.reload();
  }
  inlineAccountsResponse() {
    return !1;
  }
  inlineAddEthereumChain() {
    return !1;
  }
  inlineWatchAsset() {
    return !1;
  }
  inlineSwitchEthereumChain() {
    return !1;
  }
  setStandalone(e) {
    this.standalone = e;
  }
  isStandalone() {
    var e;
    return (e = this.standalone) !== null && e !== void 0 ? e : !1;
  }
}
r1.WalletLinkRelayUI = Jye;
Object.defineProperty(Qm, "__esModule", {
  value: !0,
});
Qm.WalletLinkRelay = void 0;
const s0 = Vm,
  Qye = En,
  Ur = ot,
  Sl = Md,
  tM = La,
  cc = Id,
  Yye = Jv,
  Ml = kd,
  Xye = r1;
class No extends tM.RelayAbstract {
  constructor(e) {
    var r;
    super(),
      (this.accountsCallback = null),
      (this.chainCallbackParams = {
        chainId: "",
        jsonRpcUrl: "",
      }),
      (this.chainCallback = null),
      (this.dappDefaultChain = 1),
      (this.appName = ""),
      (this.appLogoUrl = null),
      (this.linkedUpdated = (s) => {
        var o;
        this.isLinked = s;
        const c = this.storage.getItem(tM.LOCAL_STORAGE_ADDRESSES_KEY);
        if (
          (s && (this.session.linked = s), (this.isUnlinkedErrorState = !1), c)
        ) {
          const u = c.split(" "),
            d = this.storage.getItem("IsStandaloneSigning") === "true";
          if (u[0] !== "" && !s && this.session.linked && !d) {
            this.isUnlinkedErrorState = !0;
            const m = this.getSessionIdHash();
            (o = this.diagnostic) === null ||
              o === void 0 ||
              o.log(Sl.EVENTS.UNLINKED_ERROR_STATE, {
                sessionIdHash: m,
              });
          }
        }
      }),
      (this.metadataUpdated = (s, o) => {
        this.storage.setItem(s, o);
      }),
      (this.chainUpdated = (s, o) => {
        (this.chainCallbackParams.chainId === s &&
          this.chainCallbackParams.jsonRpcUrl === o) ||
          ((this.chainCallbackParams = {
            chainId: s,
            jsonRpcUrl: o,
          }),
          this.chainCallback && this.chainCallback(s, o));
      }),
      (this.accountUpdated = (s) => {
        this.accountsCallback && this.accountsCallback([s]),
          No.accountRequestCallbackIds.size > 0 &&
            (Array.from(No.accountRequestCallbackIds.values()).forEach((o) => {
              const c = {
                type: "WEB3_RESPONSE",
                id: o,
                response: {
                  method: "requestEthereumAccounts",
                  result: [s],
                },
              };
              this.invokeCallback(
                Object.assign(Object.assign({}, c), {
                  id: o,
                })
              );
            }),
            No.accountRequestCallbackIds.clear());
      }),
      (this.connectedUpdated = (s) => {
        this.ui.setConnected(s);
      }),
      (this.resetAndReload = this.resetAndReload.bind(this)),
      (this.linkAPIUrl = e.linkAPIUrl),
      (this.storage = e.storage),
      (this.options = e);
    const { session: n, ui: i, connection: a } = this.subscribe();
    (this._session = n),
      (this.connection = a),
      (this.relayEventManager = e.relayEventManager),
      (this.diagnostic = e.diagnosticLogger),
      (this._reloadOnDisconnect =
        (r = e.reloadOnDisconnect) !== null && r !== void 0 ? r : !0),
      (this.ui = i);
  }
  subscribe() {
    const e =
        cc.Session.load(this.storage) || new cc.Session(this.storage).save(),
      { linkAPIUrl: r, diagnostic: n } = this,
      i = new Yye.WalletLinkConnection({
        session: e,
        linkAPIUrl: r,
        diagnostic: n,
        listener: this,
      }),
      { version: a, darkMode: s } = this.options,
      o = this.options.uiConstructor({
        linkAPIUrl: r,
        version: a,
        darkMode: s,
        session: e,
      });
    return (
      i.connect(),
      {
        session: e,
        ui: o,
        connection: i,
      }
    );
  }
  attachUI() {
    this.ui.attach();
  }
  resetAndReload() {
    Promise.race([
      this.connection.setSessionMetadata("__destroyed", "1"),
      new Promise((e) => setTimeout(() => e(null), 1e3)),
    ])
      .then(() => {
        var e, r;
        const n = this.ui.isStandalone();
        (e = this.diagnostic) === null ||
          e === void 0 ||
          e.log(Sl.EVENTS.SESSION_STATE_CHANGE, {
            method: "relay::resetAndReload",
            sessionMetadataChange: "__destroyed, 1",
            sessionIdHash: this.getSessionIdHash(),
          }),
          this.connection.destroy();
        const i = cc.Session.load(this.storage);
        if (
          ((i == null ? void 0 : i.id) === this._session.id
            ? this.storage.clear()
            : i &&
              ((r = this.diagnostic) === null ||
                r === void 0 ||
                r.log(Sl.EVENTS.SKIPPED_CLEARING_SESSION, {
                  sessionIdHash: this.getSessionIdHash(),
                  storedSessionIdHash: cc.Session.hash(i.id),
                })),
          this._reloadOnDisconnect)
        ) {
          this.ui.reloadUI();
          return;
        }
        this.accountsCallback && this.accountsCallback([], !0);
        const { session: a, ui: s, connection: o } = this.subscribe();
        (this._session = a),
          (this.connection = o),
          (this.ui = s),
          n && this.ui.setStandalone && this.ui.setStandalone(!0),
          this.options.headlessMode || this.attachUI();
      })
      .catch((e) => {
        var r;
        (r = this.diagnostic) === null ||
          r === void 0 ||
          r.log(Sl.EVENTS.FAILURE, {
            method: "relay::resetAndReload",
            message: `failed to reset and reload with ${e}`,
            sessionIdHash: this.getSessionIdHash(),
          });
      });
  }
  setAppInfo(e, r) {
    (this.appName = e), (this.appLogoUrl = r);
  }
  getStorageItem(e) {
    return this.storage.getItem(e);
  }
  get session() {
    return this._session;
  }
  setStorageItem(e, r) {
    this.storage.setItem(e, r);
  }
  signEthereumMessage(e, r, n, i) {
    return this.sendRequest({
      method: "signEthereumMessage",
      params: {
        message: (0, Ur.hexStringFromBuffer)(e, !0),
        address: r,
        addPrefix: n,
        typedDataJson: i || null,
      },
    });
  }
  ethereumAddressFromSignedMessage(e, r, n) {
    return this.sendRequest({
      method: "ethereumAddressFromSignedMessage",
      params: {
        message: (0, Ur.hexStringFromBuffer)(e, !0),
        signature: (0, Ur.hexStringFromBuffer)(r, !0),
        addPrefix: n,
      },
    });
  }
  signEthereumTransaction(e) {
    return this.sendRequest({
      method: "signEthereumTransaction",
      params: {
        fromAddress: e.fromAddress,
        toAddress: e.toAddress,
        weiValue: (0, Ur.bigIntStringFromBN)(e.weiValue),
        data: (0, Ur.hexStringFromBuffer)(e.data, !0),
        nonce: e.nonce,
        gasPriceInWei: e.gasPriceInWei
          ? (0, Ur.bigIntStringFromBN)(e.gasPriceInWei)
          : null,
        maxFeePerGas: e.gasPriceInWei
          ? (0, Ur.bigIntStringFromBN)(e.gasPriceInWei)
          : null,
        maxPriorityFeePerGas: e.gasPriceInWei
          ? (0, Ur.bigIntStringFromBN)(e.gasPriceInWei)
          : null,
        gasLimit: e.gasLimit ? (0, Ur.bigIntStringFromBN)(e.gasLimit) : null,
        chainId: e.chainId,
        shouldSubmit: !1,
      },
    });
  }
  signAndSubmitEthereumTransaction(e) {
    return this.sendRequest({
      method: "signEthereumTransaction",
      params: {
        fromAddress: e.fromAddress,
        toAddress: e.toAddress,
        weiValue: (0, Ur.bigIntStringFromBN)(e.weiValue),
        data: (0, Ur.hexStringFromBuffer)(e.data, !0),
        nonce: e.nonce,
        gasPriceInWei: e.gasPriceInWei
          ? (0, Ur.bigIntStringFromBN)(e.gasPriceInWei)
          : null,
        maxFeePerGas: e.maxFeePerGas
          ? (0, Ur.bigIntStringFromBN)(e.maxFeePerGas)
          : null,
        maxPriorityFeePerGas: e.maxPriorityFeePerGas
          ? (0, Ur.bigIntStringFromBN)(e.maxPriorityFeePerGas)
          : null,
        gasLimit: e.gasLimit ? (0, Ur.bigIntStringFromBN)(e.gasLimit) : null,
        chainId: e.chainId,
        shouldSubmit: !0,
      },
    });
  }
  submitEthereumTransaction(e, r) {
    return this.sendRequest({
      method: "submitEthereumTransaction",
      params: {
        signedTransaction: (0, Ur.hexStringFromBuffer)(e, !0),
        chainId: r,
      },
    });
  }
  scanQRCode(e) {
    return this.sendRequest({
      method: "scanQRCode",
      params: {
        regExp: e,
      },
    });
  }
  getQRCodeUrl() {
    return (0, Ur.createQrUrl)(
      this._session.id,
      this._session.secret,
      this.linkAPIUrl,
      !1,
      this.options.version,
      this.dappDefaultChain
    );
  }
  genericRequest(e, r) {
    return this.sendRequest({
      method: "generic",
      params: {
        action: r,
        data: e,
      },
    });
  }
  sendGenericMessage(e) {
    return this.sendRequest(e);
  }
  sendRequest(e) {
    let r = null;
    const n = (0, Ur.randomBytesHex)(8),
      i = (s) => {
        this.publishWeb3RequestCanceledEvent(n),
          this.handleErrorResponse(n, e.method, s),
          r == null || r();
      };
    return {
      promise: new Promise((s, o) => {
        this.ui.isStandalone() ||
          (r = this.ui.showConnecting({
            isUnlinkedErrorState: this.isUnlinkedErrorState,
            onCancel: i,
            onResetConnection: this.resetAndReload,
          })),
          this.relayEventManager.callbacks.set(n, (c) => {
            if ((r == null || r(), (0, Ml.isErrorResponse)(c)))
              return o(new Error(c.errorMessage));
            s(c);
          }),
          this.ui.isStandalone()
            ? this.sendRequestStandalone(n, e)
            : this.publishWeb3RequestEvent(n, e);
      }),
      cancel: i,
    };
  }
  setConnectDisabled(e) {
    this.ui.setConnectDisabled(e);
  }
  setAccountsCallback(e) {
    this.accountsCallback = e;
  }
  setChainCallback(e) {
    this.chainCallback = e;
  }
  setDappDefaultChainCallback(e) {
    (this.dappDefaultChain = e),
      this.ui instanceof Xye.WalletLinkRelayUI && this.ui.setChainId(e);
  }
  publishWeb3RequestEvent(e, r) {
    var n;
    const i = {
        type: "WEB3_REQUEST",
        id: e,
        request: r,
      },
      a = cc.Session.load(this.storage);
    (n = this.diagnostic) === null ||
      n === void 0 ||
      n.log(Sl.EVENTS.WEB3_REQUEST, {
        eventId: i.id,
        method: `relay::${r.method}`,
        sessionIdHash: this.getSessionIdHash(),
        storedSessionIdHash: a ? cc.Session.hash(a.id) : "",
        isSessionMismatched: (
          (a == null ? void 0 : a.id) !== this._session.id
        ).toString(),
      }),
      this.publishEvent("Web3Request", i, !0)
        .then((s) => {
          var o;
          (o = this.diagnostic) === null ||
            o === void 0 ||
            o.log(Sl.EVENTS.WEB3_REQUEST_PUBLISHED, {
              eventId: i.id,
              method: `relay::${r.method}`,
              sessionIdHash: this.getSessionIdHash(),
              storedSessionIdHash: a ? cc.Session.hash(a.id) : "",
              isSessionMismatched: (
                (a == null ? void 0 : a.id) !== this._session.id
              ).toString(),
            });
        })
        .catch((s) => {
          this.handleWeb3ResponseMessage({
            type: "WEB3_RESPONSE",
            id: i.id,
            response: {
              method: r.method,
              errorMessage: s.message,
            },
          });
        });
  }
  publishWeb3RequestCanceledEvent(e) {
    const r = {
      type: "WEB3_REQUEST_CANCELED",
      id: e,
    };
    this.publishEvent("Web3RequestCanceled", r, !1).then();
  }
  publishEvent(e, r, n) {
    return this.connection.publishEvent(e, r, n);
  }
  handleWeb3ResponseMessage(e) {
    var r;
    const { response: n } = e;
    if (
      ((r = this.diagnostic) === null ||
        r === void 0 ||
        r.log(Sl.EVENTS.WEB3_RESPONSE, {
          eventId: e.id,
          method: `relay::${n.method}`,
          sessionIdHash: this.getSessionIdHash(),
        }),
      n.method === "requestEthereumAccounts")
    ) {
      No.accountRequestCallbackIds.forEach((i) =>
        this.invokeCallback(
          Object.assign(Object.assign({}, e), {
            id: i,
          })
        )
      ),
        No.accountRequestCallbackIds.clear();
      return;
    }
    this.invokeCallback(e);
  }
  handleErrorResponse(e, r, n, i) {
    var a;
    const s =
      (a = n == null ? void 0 : n.message) !== null && a !== void 0
        ? a
        : (0, s0.getMessageFromCode)(i);
    this.handleWeb3ResponseMessage({
      type: "WEB3_RESPONSE",
      id: e,
      response: {
        method: r,
        errorMessage: s,
        errorCode: i,
      },
    });
  }
  invokeCallback(e) {
    const r = this.relayEventManager.callbacks.get(e.id);
    r && (r(e.response), this.relayEventManager.callbacks.delete(e.id));
  }
  requestEthereumAccounts() {
    const e = {
        method: "requestEthereumAccounts",
        params: {
          appName: this.appName,
          appLogoUrl: this.appLogoUrl || null,
        },
      },
      r = (0, Ur.randomBytesHex)(8),
      n = (a) => {
        this.publishWeb3RequestCanceledEvent(r),
          this.handleErrorResponse(r, e.method, a);
      };
    return {
      promise: new Promise((a, s) => {
        if (
          (this.relayEventManager.callbacks.set(r, (o) => {
            if (
              (this.ui.hideRequestEthereumAccounts(),
              (0, Ml.isErrorResponse)(o))
            )
              return s(new Error(o.errorMessage));
            a(o);
          }),
          this.ui.inlineAccountsResponse())
        ) {
          const o = (c) => {
            this.handleWeb3ResponseMessage({
              type: "WEB3_RESPONSE",
              id: r,
              response: {
                method: "requestEthereumAccounts",
                result: c,
              },
            });
          };
          this.ui.requestEthereumAccounts({
            onCancel: n,
            onAccounts: o,
          });
        } else {
          const o = s0.standardErrors.provider.userRejectedRequest(
            "User denied account authorization"
          );
          this.ui.requestEthereumAccounts({
            onCancel: () => n(o),
          });
        }
        No.accountRequestCallbackIds.add(r),
          !this.ui.inlineAccountsResponse() &&
            !this.ui.isStandalone() &&
            this.publishWeb3RequestEvent(r, e);
      }),
      cancel: n,
    };
  }
  selectProvider(e) {
    const r = {
        method: "selectProvider",
        params: {
          providerOptions: e,
        },
      },
      n = (0, Ur.randomBytesHex)(8),
      i = (s) => {
        this.publishWeb3RequestCanceledEvent(n),
          this.handleErrorResponse(n, r.method, s);
      },
      a = new Promise((s, o) => {
        this.relayEventManager.callbacks.set(n, (d) => {
          if ((0, Ml.isErrorResponse)(d)) return o(new Error(d.errorMessage));
          s(d);
        });
        const c = (d) => {
            this.handleWeb3ResponseMessage({
              type: "WEB3_RESPONSE",
              id: n,
              response: {
                method: "selectProvider",
                result: Qye.ProviderType.Unselected,
              },
            });
          },
          u = (d) => {
            this.handleWeb3ResponseMessage({
              type: "WEB3_RESPONSE",
              id: n,
              response: {
                method: "selectProvider",
                result: d,
              },
            });
          };
        this.ui.selectProvider &&
          this.ui.selectProvider({
            onApprove: u,
            onCancel: c,
            providerOptions: e,
          });
      });
    return {
      cancel: i,
      promise: a,
    };
  }
  watchAsset(e, r, n, i, a, s) {
    const o = {
      method: "watchAsset",
      params: {
        type: e,
        options: {
          address: r,
          symbol: n,
          decimals: i,
          image: a,
        },
        chainId: s,
      },
    };
    let c = null;
    const u = (0, Ur.randomBytesHex)(8),
      d = (v) => {
        this.publishWeb3RequestCanceledEvent(u),
          this.handleErrorResponse(u, o.method, v),
          c == null || c();
      };
    this.ui.inlineWatchAsset() ||
      (c = this.ui.showConnecting({
        isUnlinkedErrorState: this.isUnlinkedErrorState,
        onCancel: d,
        onResetConnection: this.resetAndReload,
      }));
    const m = new Promise((v, E) => {
      this.relayEventManager.callbacks.set(u, (b) => {
        if ((c == null || c(), (0, Ml.isErrorResponse)(b)))
          return E(new Error(b.errorMessage));
        v(b);
      });
      const A = (b) => {
          this.handleWeb3ResponseMessage({
            type: "WEB3_RESPONSE",
            id: u,
            response: {
              method: "watchAsset",
              result: !1,
            },
          });
        },
        I = () => {
          this.handleWeb3ResponseMessage({
            type: "WEB3_RESPONSE",
            id: u,
            response: {
              method: "watchAsset",
              result: !0,
            },
          });
        };
      this.ui.inlineWatchAsset() &&
        this.ui.watchAsset({
          onApprove: I,
          onCancel: A,
          type: e,
          address: r,
          symbol: n,
          decimals: i,
          image: a,
          chainId: s,
        }),
        !this.ui.inlineWatchAsset() &&
          !this.ui.isStandalone() &&
          this.publishWeb3RequestEvent(u, o);
    });
    return {
      cancel: d,
      promise: m,
    };
  }
  addEthereumChain(e, r, n, i, a, s) {
    const o = {
      method: "addEthereumChain",
      params: {
        chainId: e,
        rpcUrls: r,
        blockExplorerUrls: i,
        chainName: a,
        iconUrls: n,
        nativeCurrency: s,
      },
    };
    let c = null;
    const u = (0, Ur.randomBytesHex)(8),
      d = (v) => {
        this.publishWeb3RequestCanceledEvent(u),
          this.handleErrorResponse(u, o.method, v),
          c == null || c();
      };
    return (
      this.ui.inlineAddEthereumChain(e) ||
        (c = this.ui.showConnecting({
          isUnlinkedErrorState: this.isUnlinkedErrorState,
          onCancel: d,
          onResetConnection: this.resetAndReload,
        })),
      {
        promise: new Promise((v, E) => {
          this.relayEventManager.callbacks.set(u, (b) => {
            if ((c == null || c(), (0, Ml.isErrorResponse)(b)))
              return E(new Error(b.errorMessage));
            v(b);
          });
          const A = (b) => {
              this.handleWeb3ResponseMessage({
                type: "WEB3_RESPONSE",
                id: u,
                response: {
                  method: "addEthereumChain",
                  result: {
                    isApproved: !1,
                    rpcUrl: "",
                  },
                },
              });
            },
            I = (b) => {
              this.handleWeb3ResponseMessage({
                type: "WEB3_RESPONSE",
                id: u,
                response: {
                  method: "addEthereumChain",
                  result: {
                    isApproved: !0,
                    rpcUrl: b,
                  },
                },
              });
            };
          this.ui.inlineAddEthereumChain(e) &&
            this.ui.addEthereumChain({
              onCancel: A,
              onApprove: I,
              chainId: o.params.chainId,
              rpcUrls: o.params.rpcUrls,
              blockExplorerUrls: o.params.blockExplorerUrls,
              chainName: o.params.chainName,
              iconUrls: o.params.iconUrls,
              nativeCurrency: o.params.nativeCurrency,
            }),
            !this.ui.inlineAddEthereumChain(e) &&
              !this.ui.isStandalone() &&
              this.publishWeb3RequestEvent(u, o);
        }),
        cancel: d,
      }
    );
  }
  switchEthereumChain(e, r) {
    const n = {
        method: "switchEthereumChain",
        params: Object.assign(
          {
            chainId: e,
          },
          {
            address: r,
          }
        ),
      },
      i = (0, Ur.randomBytesHex)(8),
      a = (o) => {
        this.publishWeb3RequestCanceledEvent(i),
          this.handleErrorResponse(i, n.method, o);
      };
    return {
      promise: new Promise((o, c) => {
        this.relayEventManager.callbacks.set(i, (m) => {
          if ((0, Ml.isErrorResponse)(m) && m.errorCode)
            return c(
              s0.standardErrors.provider.custom({
                code: m.errorCode,
                message:
                  "Unrecognized chain ID. Try adding the chain using addEthereumChain first.",
              })
            );
          if ((0, Ml.isErrorResponse)(m)) return c(new Error(m.errorMessage));
          o(m);
        });
        const u = (m) => {
            var v;
            if (m) {
              const E =
                (v = (0, s0.getErrorCode)(m)) !== null && v !== void 0
                  ? v
                  : s0.standardErrorCodes.provider.unsupportedChain;
              this.handleErrorResponse(
                i,
                "switchEthereumChain",
                m instanceof Error
                  ? m
                  : s0.standardErrors.provider.unsupportedChain(e),
                E
              );
            } else
              this.handleWeb3ResponseMessage({
                type: "WEB3_RESPONSE",
                id: i,
                response: {
                  method: "switchEthereumChain",
                  result: {
                    isApproved: !1,
                    rpcUrl: "",
                  },
                },
              });
          },
          d = (m) => {
            this.handleWeb3ResponseMessage({
              type: "WEB3_RESPONSE",
              id: i,
              response: {
                method: "switchEthereumChain",
                result: {
                  isApproved: !0,
                  rpcUrl: m,
                },
              },
            });
          };
        this.ui.switchEthereumChain({
          onCancel: u,
          onApprove: d,
          chainId: n.params.chainId,
          address: n.params.address,
        }),
          !this.ui.inlineSwitchEthereumChain() &&
            !this.ui.isStandalone() &&
            this.publishWeb3RequestEvent(i, n);
      }),
      cancel: a,
    };
  }
  inlineAddEthereumChain(e) {
    return this.ui.inlineAddEthereumChain(e);
  }
  getSessionIdHash() {
    return cc.Session.hash(this._session.id);
  }
  sendRequestStandalone(e, r) {
    const n = (a) => {
        this.handleErrorResponse(e, r.method, a);
      },
      i = (a) => {
        this.handleWeb3ResponseMessage({
          type: "WEB3_RESPONSE",
          id: e,
          response: a,
        });
      };
    switch (r.method) {
      case "signEthereumMessage":
        this.ui.signEthereumMessage({
          request: r,
          onSuccess: i,
          onCancel: n,
        });
        break;
      case "signEthereumTransaction":
        this.ui.signEthereumTransaction({
          request: r,
          onSuccess: i,
          onCancel: n,
        });
        break;
      case "submitEthereumTransaction":
        this.ui.submitEthereumTransaction({
          request: r,
          onSuccess: i,
          onCancel: n,
        });
        break;
      case "ethereumAddressFromSignedMessage":
        this.ui.ethereumAddressFromSignedMessage({
          request: r,
          onSuccess: i,
        });
        break;
      default:
        n();
        break;
    }
  }
}
Qm.WalletLinkRelay = No;
No.accountRequestCallbackIds = new Set();
var o1 = {},
  dx = {},
  dU = {};
(function (t) {
  var e =
      (ke && ke.__createBinding) ||
      (Object.create
        ? function (n, i, a, s) {
            s === void 0 && (s = a);
            var o = Object.getOwnPropertyDescriptor(i, a);
            (!o ||
              ("get" in o ? !i.__esModule : o.writable || o.configurable)) &&
              (o = {
                enumerable: !0,
                get: function () {
                  return i[a];
                },
              }),
              Object.defineProperty(n, s, o);
          }
        : function (n, i, a, s) {
            s === void 0 && (s = a), (n[s] = i[a]);
          }),
    r =
      (ke && ke.__exportStar) ||
      function (n, i) {
        for (var a in n)
          a !== "default" &&
            !Object.prototype.hasOwnProperty.call(i, a) &&
            e(i, n, a);
      };
  Object.defineProperty(t, "__esModule", {
    value: !0,
  }),
    r(fT, t);
})(dU);
var hT = {};
Object.defineProperty(hT, "__esModule", {
  value: !0,
});
hT.default =
  ".-cbwsdk-css-reset .-cbwsdk-redirect-dialog-backdrop{position:fixed;top:0;left:0;right:0;bottom:0;transition:opacity .25s;background-color:rgba(10,11,13,.5)}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-backdrop-hidden{opacity:0}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box{display:block;position:fixed;top:50%;left:50%;transform:translate(-50%, -50%);padding:20px;border-radius:8px;background-color:#fff;color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box p{display:block;font-weight:400;font-size:14px;line-height:20px;padding-bottom:12px;color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box button{appearance:none;border:none;background:none;color:#0052ff;padding:0;text-decoration:none;display:block;font-weight:600;font-size:16px;line-height:24px}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.dark{background-color:#0a0b0d;color:#fff}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.dark button{color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.light{background-color:#fff;color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.light button{color:#0052ff}";
var hU =
  (ke && ke.__importDefault) ||
  function (t) {
    return t && t.__esModule
      ? t
      : {
          default: t,
        };
  };
Object.defineProperty(dx, "__esModule", {
  value: !0,
});
dx.RedirectDialog = void 0;
const ege = hU(s1),
  Os = Qi,
  tge = n1,
  rge = dU,
  nge = hU(hT);
class ige {
  constructor() {
    this.root = null;
  }
  attach() {
    const e = document.documentElement;
    (this.root = document.createElement("div")),
      (this.root.className = "-cbwsdk-css-reset"),
      e.appendChild(this.root),
      (0, tge.injectCssReset)();
  }
  present(e) {
    this.render(e);
  }
  clear() {
    this.render(null);
  }
  render(e) {
    this.root &&
      ((0, Os.render)(null, this.root),
      e &&
        (0, Os.render)(
          (0, Os.h)(
            age,
            Object.assign({}, e, {
              onDismiss: () => {
                this.clear();
              },
            })
          ),
          this.root
        ));
  }
}
dx.RedirectDialog = ige;
const age = ({
  title: t,
  buttonText: e,
  darkMode: r,
  onButtonClick: n,
  onDismiss: i,
}) => {
  const a = r ? "dark" : "light";
  return (0, Os.h)(
    rge.SnackbarContainer,
    {
      darkMode: r,
    },
    (0, Os.h)(
      "div",
      {
        class: "-cbwsdk-redirect-dialog",
      },
      (0, Os.h)("style", null, nge.default),
      (0, Os.h)("div", {
        class: "-cbwsdk-redirect-dialog-backdrop",
        onClick: i,
      }),
      (0, Os.h)(
        "div",
        {
          class: (0, ege.default)("-cbwsdk-redirect-dialog-box", a),
        },
        (0, Os.h)("p", null, t),
        (0, Os.h)(
          "button",
          {
            onClick: n,
          },
          e
        )
      )
    )
  );
};
Object.defineProperty(o1, "__esModule", {
  value: !0,
});
o1.MobileRelayUI = void 0;
const sge = dx;
class oge {
  constructor(e) {
    (this.attached = !1),
      (this.darkMode = !1),
      (this.redirectDialog = new sge.RedirectDialog()),
      (this.darkMode = e.darkMode);
  }
  attach() {
    if (this.attached)
      throw new Error("Coinbase Wallet SDK UI is already attached");
    this.redirectDialog.attach(), (this.attached = !0);
  }
  setConnected(e) {}
  redirectToCoinbaseWallet(e) {
    const r = new URL("https://go.cb-w.com/walletlink");
    r.searchParams.append("redirect_url", window.location.href),
      e && r.searchParams.append("wl_url", e);
    const n = document.createElement("a");
    (n.target = "cbw-opener"),
      (n.href = r.href),
      (n.rel = "noreferrer noopener"),
      n.click();
  }
  openCoinbaseWalletDeeplink(e) {
    this.redirectDialog.present({
      title: "Redirecting to Coinbase Wallet...",
      buttonText: "Open",
      darkMode: this.darkMode,
      onButtonClick: () => {
        this.redirectToCoinbaseWallet(e);
      },
    }),
      setTimeout(() => {
        this.redirectToCoinbaseWallet(e);
      }, 99);
  }
  showConnecting(e) {
    return () => {
      this.redirectDialog.clear();
    };
  }
  hideRequestEthereumAccounts() {
    this.redirectDialog.clear();
  }
  requestEthereumAccounts() {}
  addEthereumChain() {}
  watchAsset() {}
  selectProvider() {}
  switchEthereumChain() {}
  signEthereumMessage() {}
  signEthereumTransaction() {}
  submitEthereumTransaction() {}
  ethereumAddressFromSignedMessage() {}
  reloadUI() {}
  setStandalone() {}
  setConnectDisabled() {}
  inlineAccountsResponse() {
    return !1;
  }
  inlineAddEthereumChain() {
    return !1;
  }
  inlineWatchAsset() {
    return !1;
  }
  inlineSwitchEthereumChain() {
    return !1;
  }
  isStandalone() {
    return !1;
  }
}
o1.MobileRelayUI = oge;
Object.defineProperty(Jm, "__esModule", {
  value: !0,
});
Jm.MobileRelay = void 0;
const cge = ot,
  lge = Qm,
  uge = o1;
class fge extends lge.WalletLinkRelay {
  constructor(e) {
    var r;
    super(e),
      (this._enableMobileWalletLink =
        (r = e.enableMobileWalletLink) !== null && r !== void 0 ? r : !1);
  }
  requestEthereumAccounts() {
    return this._enableMobileWalletLink
      ? super.requestEthereumAccounts()
      : {
          promise: new Promise(() => {
            const e = (0, cge.getLocation)();
            e.href = `https://go.cb-w.com/dapp?cb_url=${encodeURIComponent(
              e.href
            )}`;
          }),
          cancel: () => {},
        };
  }
  publishWeb3RequestEvent(e, r) {
    if (
      (super.publishWeb3RequestEvent(e, r),
      !(this._enableMobileWalletLink && this.ui instanceof uge.MobileRelayUI))
    )
      return;
    let n = !1;
    switch (r.method) {
      case "requestEthereumAccounts":
      case "connectAndSignIn":
        (n = !0), this.ui.openCoinbaseWalletDeeplink(this.getQRCodeUrl());
        break;
      case "switchEthereumChain":
        return;
      default:
        (n = !0), this.ui.openCoinbaseWalletDeeplink();
        break;
    }
    n &&
      window.addEventListener(
        "blur",
        () => {
          window.addEventListener(
            "focus",
            () => {
              this.connection.checkUnseenEvents();
            },
            {
              once: !0,
            }
          );
        },
        {
          once: !0,
        }
      );
  }
  handleWeb3ResponseMessage(e) {
    super.handleWeb3ResponseMessage(e);
  }
  connectAndSignIn(e) {
    if (!this._enableMobileWalletLink)
      throw new Error(
        "connectAndSignIn is supported only when enableMobileWalletLink is on"
      );
    return this.sendRequest({
      method: "connectAndSignIn",
      params: {
        appName: this.appName,
        appLogoUrl: this.appLogoUrl,
        domain: window.location.hostname,
        aud: window.location.href,
        version: "1",
        type: "eip4361",
        nonce: e.nonce,
        iat: new Date().toISOString(),
        chainId: `eip155:${this.dappDefaultChain}`,
        statement: e.statement,
        resources: e.resources,
      },
    });
  }
}
Jm.MobileRelay = fge;
var f4 = {
    exports: {},
  },
  pU = Cd.EventEmitter,
  c5,
  rM;
function dge() {
  if (rM) return c5;
  rM = 1;
  function t(A, I) {
    var b = Object.keys(A);
    if (Object.getOwnPropertySymbols) {
      var w = Object.getOwnPropertySymbols(A);
      I &&
        (w = w.filter(function (S) {
          return Object.getOwnPropertyDescriptor(A, S).enumerable;
        })),
        b.push.apply(b, w);
    }
    return b;
  }
  function e(A) {
    for (var I = 1; I < arguments.length; I++) {
      var b = arguments[I] != null ? arguments[I] : {};
      I % 2
        ? t(Object(b), !0).forEach(function (w) {
            r(A, w, b[w]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(A, Object.getOwnPropertyDescriptors(b))
        : t(Object(b)).forEach(function (w) {
            Object.defineProperty(A, w, Object.getOwnPropertyDescriptor(b, w));
          });
    }
    return A;
  }
  function r(A, I, b) {
    return (
      (I = s(I)),
      I in A
        ? Object.defineProperty(A, I, {
            value: b,
            enumerable: !0,
            configurable: !0,
            writable: !0,
          })
        : (A[I] = b),
      A
    );
  }
  function n(A, I) {
    if (!(A instanceof I))
      throw new TypeError("Cannot call a class as a function");
  }
  function i(A, I) {
    for (var b = 0; b < I.length; b++) {
      var w = I[b];
      (w.enumerable = w.enumerable || !1),
        (w.configurable = !0),
        "value" in w && (w.writable = !0),
        Object.defineProperty(A, s(w.key), w);
    }
  }
  function a(A, I, b) {
    return (
      I && i(A.prototype, I),
      Object.defineProperty(A, "prototype", {
        writable: !1,
      }),
      A
    );
  }
  function s(A) {
    var I = o(A, "string");
    return typeof I == "symbol" ? I : String(I);
  }
  function o(A, I) {
    if (typeof A != "object" || A === null) return A;
    var b = A[Symbol.toPrimitive];
    if (b !== void 0) {
      var w = b.call(A, I || "default");
      if (typeof w != "object") return w;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (I === "string" ? String : Number)(A);
  }
  var c = vo,
    u = c.Buffer,
    d = Pu,
    m = d.inspect,
    v = (m && m.custom) || "inspect";
  function E(A, I, b) {
    u.prototype.copy.call(A, I, b);
  }
  return (
    (c5 = (function () {
      function A() {
        n(this, A), (this.head = null), (this.tail = null), (this.length = 0);
      }
      return (
        a(A, [
          {
            key: "push",
            value: function (b) {
              var w = {
                data: b,
                next: null,
              };
              this.length > 0 ? (this.tail.next = w) : (this.head = w),
                (this.tail = w),
                ++this.length;
            },
          },
          {
            key: "unshift",
            value: function (b) {
              var w = {
                data: b,
                next: this.head,
              };
              this.length === 0 && (this.tail = w),
                (this.head = w),
                ++this.length;
            },
          },
          {
            key: "shift",
            value: function () {
              if (this.length !== 0) {
                var b = this.head.data;
                return (
                  this.length === 1
                    ? (this.head = this.tail = null)
                    : (this.head = this.head.next),
                  --this.length,
                  b
                );
              }
            },
          },
          {
            key: "clear",
            value: function () {
              (this.head = this.tail = null), (this.length = 0);
            },
          },
          {
            key: "join",
            value: function (b) {
              if (this.length === 0) return "";
              for (var w = this.head, S = "" + w.data; (w = w.next); )
                S += b + w.data;
              return S;
            },
          },
          {
            key: "concat",
            value: function (b) {
              if (this.length === 0) return u.alloc(0);
              for (var w = u.allocUnsafe(b >>> 0), S = this.head, k = 0; S; )
                E(S.data, w, k), (k += S.data.length), (S = S.next);
              return w;
            },
          },
          {
            key: "consume",
            value: function (b, w) {
              var S;
              return (
                b < this.head.data.length
                  ? ((S = this.head.data.slice(0, b)),
                    (this.head.data = this.head.data.slice(b)))
                  : b === this.head.data.length
                  ? (S = this.shift())
                  : (S = w ? this._getString(b) : this._getBuffer(b)),
                S
              );
            },
          },
          {
            key: "first",
            value: function () {
              return this.head.data;
            },
          },
          {
            key: "_getString",
            value: function (b) {
              var w = this.head,
                S = 1,
                k = w.data;
              for (b -= k.length; (w = w.next); ) {
                var N = w.data,
                  O = b > N.length ? N.length : b;
                if (
                  (O === N.length ? (k += N) : (k += N.slice(0, b)),
                  (b -= O),
                  b === 0)
                ) {
                  O === N.length
                    ? (++S,
                      w.next
                        ? (this.head = w.next)
                        : (this.head = this.tail = null))
                    : ((this.head = w), (w.data = N.slice(O)));
                  break;
                }
                ++S;
              }
              return (this.length -= S), k;
            },
          },
          {
            key: "_getBuffer",
            value: function (b) {
              var w = u.allocUnsafe(b),
                S = this.head,
                k = 1;
              for (S.data.copy(w), b -= S.data.length; (S = S.next); ) {
                var N = S.data,
                  O = b > N.length ? N.length : b;
                if ((N.copy(w, w.length - b, 0, O), (b -= O), b === 0)) {
                  O === N.length
                    ? (++k,
                      S.next
                        ? (this.head = S.next)
                        : (this.head = this.tail = null))
                    : ((this.head = S), (S.data = N.slice(O)));
                  break;
                }
                ++k;
              }
              return (this.length -= k), w;
            },
          },
          {
            key: v,
            value: function (b, w) {
              return m(
                this,
                e(
                  e({}, w),
                  {},
                  {
                    depth: 0,
                    customInspect: !1,
                  }
                )
              );
            },
          },
        ]),
        A
      );
    })()),
    c5
  );
}
function hge(t, e) {
  var r = this,
    n = this._readableState && this._readableState.destroyed,
    i = this._writableState && this._writableState.destroyed;
  return n || i
    ? (e
        ? e(t)
        : t &&
          (this._writableState
            ? this._writableState.errorEmitted ||
              ((this._writableState.errorEmitted = !0),
              process.nextTick(d4, this, t))
            : process.nextTick(d4, this, t)),
      this)
    : (this._readableState && (this._readableState.destroyed = !0),
      this._writableState && (this._writableState.destroyed = !0),
      this._destroy(t || null, function (a) {
        !e && a
          ? r._writableState
            ? r._writableState.errorEmitted
              ? process.nextTick(rg, r)
              : ((r._writableState.errorEmitted = !0),
                process.nextTick(nM, r, a))
            : process.nextTick(nM, r, a)
          : e
          ? (process.nextTick(rg, r), e(a))
          : process.nextTick(rg, r);
      }),
      this);
}
function nM(t, e) {
  d4(t, e), rg(t);
}
function rg(t) {
  (t._writableState && !t._writableState.emitClose) ||
    (t._readableState && !t._readableState.emitClose) ||
    t.emit("close");
}
function pge() {
  this._readableState &&
    ((this._readableState.destroyed = !1),
    (this._readableState.reading = !1),
    (this._readableState.ended = !1),
    (this._readableState.endEmitted = !1)),
    this._writableState &&
      ((this._writableState.destroyed = !1),
      (this._writableState.ended = !1),
      (this._writableState.ending = !1),
      (this._writableState.finalCalled = !1),
      (this._writableState.prefinished = !1),
      (this._writableState.finished = !1),
      (this._writableState.errorEmitted = !1));
}
function d4(t, e) {
  t.emit("error", e);
}
function mge(t, e) {
  var r = t._readableState,
    n = t._writableState;
  (r && r.autoDestroy) || (n && n.autoDestroy)
    ? t.destroy(e)
    : t.emit("error", e);
}
var mU = {
    destroy: hge,
    undestroy: pge,
    errorOrDestroy: mge,
  },
  Hu = {};
function yge(t, e) {
  (t.prototype = Object.create(e.prototype)),
    (t.prototype.constructor = t),
    (t.__proto__ = e);
}
var yU = {};
function Qa(t, e, r) {
  r || (r = Error);
  function n(a, s, o) {
    return typeof e == "string" ? e : e(a, s, o);
  }
  var i = (function (a) {
    yge(s, a);
    function s(o, c, u) {
      return a.call(this, n(o, c, u)) || this;
    }
    return s;
  })(r);
  (i.prototype.name = r.name), (i.prototype.code = t), (yU[t] = i);
}
function iM(t, e) {
  if (Array.isArray(t)) {
    var r = t.length;
    return (
      (t = t.map(function (n) {
        return String(n);
      })),
      r > 2
        ? "one of "
            .concat(e, " ")
            .concat(t.slice(0, r - 1).join(", "), ", or ") + t[r - 1]
        : r === 2
        ? "one of ".concat(e, " ").concat(t[0], " or ").concat(t[1])
        : "of ".concat(e, " ").concat(t[0])
    );
  } else return "of ".concat(e, " ").concat(String(t));
}
function gge(t, e, r) {
  return t.substr(0, e.length) === e;
}
function bge(t, e, r) {
  return (
    (r === void 0 || r > t.length) && (r = t.length),
    t.substring(r - e.length, r) === e
  );
}
function vge(t, e, r) {
  return (
    typeof r != "number" && (r = 0),
    r + e.length > t.length ? !1 : t.indexOf(e, r) !== -1
  );
}
Qa(
  "ERR_INVALID_OPT_VALUE",
  function (t, e) {
    return 'The value "' + e + '" is invalid for option "' + t + '"';
  },
  TypeError
);
Qa(
  "ERR_INVALID_ARG_TYPE",
  function (t, e, r) {
    var n;
    typeof e == "string" && gge(e, "not ")
      ? ((n = "must not be"), (e = e.replace(/^not /, "")))
      : (n = "must be");
    var i;
    if (bge(t, " argument"))
      i = "The ".concat(t, " ").concat(n, " ").concat(iM(e, "type"));
    else {
      var a = vge(t, ".") ? "property" : "argument";
      i = 'The "'
        .concat(t, '" ')
        .concat(a, " ")
        .concat(n, " ")
        .concat(iM(e, "type"));
    }
    return (i += ". Received type ".concat(typeof r)), i;
  },
  TypeError
);
Qa("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
Qa("ERR_METHOD_NOT_IMPLEMENTED", function (t) {
  return "The " + t + " method is not implemented";
});
Qa("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
Qa("ERR_STREAM_DESTROYED", function (t) {
  return "Cannot call " + t + " after a stream was destroyed";
});
Qa("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
Qa("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
Qa("ERR_STREAM_WRITE_AFTER_END", "write after end");
Qa("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
Qa(
  "ERR_UNKNOWN_ENCODING",
  function (t) {
    return "Unknown encoding: " + t;
  },
  TypeError
);
Qa("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
Hu.codes = yU;
var xge = Hu.codes.ERR_INVALID_OPT_VALUE;
function wge(t, e, r) {
  return t.highWaterMark != null ? t.highWaterMark : e ? t[r] : null;
}
function _ge(t, e, r, n) {
  var i = wge(e, n, r);
  if (i != null) {
    if (!(isFinite(i) && Math.floor(i) === i) || i < 0) {
      var a = n ? r : "highWaterMark";
      throw new xge(a, i);
    }
    return Math.floor(i);
  }
  return t.objectMode ? 16 : 16 * 1024;
}
var gU = {
    getHighWaterMark: _ge,
  },
  Ege = Tge;
function Tge(t, e) {
  if (l5("noDeprecation")) return t;
  var r = !1;
  function n() {
    if (!r) {
      if (l5("throwDeprecation")) throw new Error(e);
      l5("traceDeprecation") ? console.trace(e) : console.warn(e), (r = !0);
    }
    return t.apply(this, arguments);
  }
  return n;
}
function l5(t) {
  try {
    if (!ke.localStorage) return !1;
  } catch {
    return !1;
  }
  var e = ke.localStorage[t];
  return e == null ? !1 : String(e).toLowerCase() === "true";
}
var u5, aM;
function bU() {
  if (aM) return u5;
  (aM = 1), (u5 = j);
  function t(H) {
    var Q = this;
    (this.next = null),
      (this.entry = null),
      (this.finish = function () {
        B(Q, H);
      });
  }
  var e;
  j.WritableState = F;
  var r = {
      deprecate: Ege,
    },
    n = pU,
    i = vo.Buffer,
    a =
      (typeof ke < "u"
        ? ke
        : typeof window < "u"
        ? window
        : typeof self < "u"
        ? self
        : {}
      ).Uint8Array || function () {};
  function s(H) {
    return i.from(H);
  }
  function o(H) {
    return i.isBuffer(H) || H instanceof a;
  }
  var c = mU,
    u = gU,
    d = u.getHighWaterMark,
    m = Hu.codes,
    v = m.ERR_INVALID_ARG_TYPE,
    E = m.ERR_METHOD_NOT_IMPLEMENTED,
    A = m.ERR_MULTIPLE_CALLBACK,
    I = m.ERR_STREAM_CANNOT_PIPE,
    b = m.ERR_STREAM_DESTROYED,
    w = m.ERR_STREAM_NULL_VALUES,
    S = m.ERR_STREAM_WRITE_AFTER_END,
    k = m.ERR_UNKNOWN_ENCODING,
    N = c.errorOrDestroy;
  Ka(j, n);
  function O() {}
  function F(H, Q, Z) {
    (e = e || Vf()),
      (H = H || {}),
      typeof Z != "boolean" && (Z = Q instanceof e),
      (this.objectMode = !!H.objectMode),
      Z && (this.objectMode = this.objectMode || !!H.writableObjectMode),
      (this.highWaterMark = d(this, H, "writableHighWaterMark", Z)),
      (this.finalCalled = !1),
      (this.needDrain = !1),
      (this.ending = !1),
      (this.ended = !1),
      (this.finished = !1),
      (this.destroyed = !1);
    var te = H.decodeStrings === !1;
    (this.decodeStrings = !te),
      (this.defaultEncoding = H.defaultEncoding || "utf8"),
      (this.length = 0),
      (this.writing = !1),
      (this.corked = 0),
      (this.sync = !0),
      (this.bufferProcessing = !1),
      (this.onwrite = function (Te) {
        T(Q, Te);
      }),
      (this.writecb = null),
      (this.writelen = 0),
      (this.bufferedRequest = null),
      (this.lastBufferedRequest = null),
      (this.pendingcb = 0),
      (this.prefinished = !1),
      (this.errorEmitted = !1),
      (this.emitClose = H.emitClose !== !1),
      (this.autoDestroy = !!H.autoDestroy),
      (this.bufferedRequestCount = 0),
      (this.corkedRequestsFree = new t(this));
  }
  (F.prototype.getBuffer = function () {
    for (var Q = this.bufferedRequest, Z = []; Q; ) Z.push(Q), (Q = Q.next);
    return Z;
  }),
    (function () {
      try {
        Object.defineProperty(F.prototype, "buffer", {
          get: r.deprecate(
            function () {
              return this.getBuffer();
            },
            "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.",
            "DEP0003"
          ),
        });
      } catch {}
    })();
  var V;
  typeof Symbol == "function" &&
  Symbol.hasInstance &&
  typeof Function.prototype[Symbol.hasInstance] == "function"
    ? ((V = Function.prototype[Symbol.hasInstance]),
      Object.defineProperty(j, Symbol.hasInstance, {
        value: function (Q) {
          return V.call(this, Q)
            ? !0
            : this !== j
            ? !1
            : Q && Q._writableState instanceof F;
        },
      }))
    : (V = function (Q) {
        return Q instanceof this;
      });
  function j(H) {
    e = e || Vf();
    var Q = this instanceof e;
    if (!Q && !V.call(j, this)) return new j(H);
    (this._writableState = new F(H, this, Q)),
      (this.writable = !0),
      H &&
        (typeof H.write == "function" && (this._write = H.write),
        typeof H.writev == "function" && (this._writev = H.writev),
        typeof H.destroy == "function" && (this._destroy = H.destroy),
        typeof H.final == "function" && (this._final = H.final)),
      n.call(this);
  }
  j.prototype.pipe = function () {
    N(this, new I());
  };
  function X(H, Q) {
    var Z = new S();
    N(H, Z), process.nextTick(Q, Z);
  }
  function C(H, Q, Z, te) {
    var Te;
    return (
      Z === null
        ? (Te = new w())
        : typeof Z != "string" &&
          !Q.objectMode &&
          (Te = new v("chunk", ["string", "Buffer"], Z)),
      Te ? (N(H, Te), process.nextTick(te, Te), !1) : !0
    );
  }
  (j.prototype.write = function (H, Q, Z) {
    var te = this._writableState,
      Te = !1,
      K = !te.objectMode && o(H);
    return (
      K && !i.isBuffer(H) && (H = s(H)),
      typeof Q == "function" && ((Z = Q), (Q = null)),
      K ? (Q = "buffer") : Q || (Q = te.defaultEncoding),
      typeof Z != "function" && (Z = O),
      te.ending
        ? X(this, Z)
        : (K || C(this, te, H, Z)) &&
          (te.pendingcb++, (Te = p(this, te, K, H, Q, Z))),
      Te
    );
  }),
    (j.prototype.cork = function () {
      this._writableState.corked++;
    }),
    (j.prototype.uncork = function () {
      var H = this._writableState;
      H.corked &&
        (H.corked--,
        !H.writing &&
          !H.corked &&
          !H.bufferProcessing &&
          H.bufferedRequest &&
          f(this, H));
    }),
    (j.prototype.setDefaultEncoding = function (Q) {
      if (
        (typeof Q == "string" && (Q = Q.toLowerCase()),
        !(
          [
            "hex",
            "utf8",
            "utf-8",
            "ascii",
            "binary",
            "base64",
            "ucs2",
            "ucs-2",
            "utf16le",
            "utf-16le",
            "raw",
          ].indexOf((Q + "").toLowerCase()) > -1
        ))
      )
        throw new k(Q);
      return (this._writableState.defaultEncoding = Q), this;
    }),
    Object.defineProperty(j.prototype, "writableBuffer", {
      enumerable: !1,
      get: function () {
        return this._writableState && this._writableState.getBuffer();
      },
    });
  function l(H, Q, Z) {
    return (
      !H.objectMode &&
        H.decodeStrings !== !1 &&
        typeof Q == "string" &&
        (Q = i.from(Q, Z)),
      Q
    );
  }
  Object.defineProperty(j.prototype, "writableHighWaterMark", {
    enumerable: !1,
    get: function () {
      return this._writableState.highWaterMark;
    },
  });
  function p(H, Q, Z, te, Te, K) {
    if (!Z) {
      var G = l(Q, te, Te);
      te !== G && ((Z = !0), (Te = "buffer"), (te = G));
    }
    var he = Q.objectMode ? 1 : te.length;
    Q.length += he;
    var se = Q.length < Q.highWaterMark;
    if ((se || (Q.needDrain = !0), Q.writing || Q.corked)) {
      var pe = Q.lastBufferedRequest;
      (Q.lastBufferedRequest = {
        chunk: te,
        encoding: Te,
        isBuf: Z,
        callback: K,
        next: null,
      }),
        pe
          ? (pe.next = Q.lastBufferedRequest)
          : (Q.bufferedRequest = Q.lastBufferedRequest),
        (Q.bufferedRequestCount += 1);
    } else y(H, Q, !1, he, te, Te, K);
    return se;
  }
  function y(H, Q, Z, te, Te, K, G) {
    (Q.writelen = te),
      (Q.writecb = G),
      (Q.writing = !0),
      (Q.sync = !0),
      Q.destroyed
        ? Q.onwrite(new b("write"))
        : Z
        ? H._writev(Te, Q.onwrite)
        : H._write(Te, K, Q.onwrite),
      (Q.sync = !1);
  }
  function h(H, Q, Z, te, Te) {
    --Q.pendingcb,
      Z
        ? (process.nextTick(Te, te),
          process.nextTick(D, H, Q),
          (H._writableState.errorEmitted = !0),
          N(H, te))
        : (Te(te), (H._writableState.errorEmitted = !0), N(H, te), D(H, Q));
  }
  function g(H) {
    (H.writing = !1),
      (H.writecb = null),
      (H.length -= H.writelen),
      (H.writelen = 0);
  }
  function T(H, Q) {
    var Z = H._writableState,
      te = Z.sync,
      Te = Z.writecb;
    if (typeof Te != "function") throw new A();
    if ((g(Z), Q)) h(H, Z, te, Q, Te);
    else {
      var K = _(Z) || H.destroyed;
      !K && !Z.corked && !Z.bufferProcessing && Z.bufferedRequest && f(H, Z),
        te ? process.nextTick(R, H, Z, K, Te) : R(H, Z, K, Te);
    }
  }
  function R(H, Q, Z, te) {
    Z || x(H, Q), Q.pendingcb--, te(), D(H, Q);
  }
  function x(H, Q) {
    Q.length === 0 && Q.needDrain && ((Q.needDrain = !1), H.emit("drain"));
  }
  function f(H, Q) {
    Q.bufferProcessing = !0;
    var Z = Q.bufferedRequest;
    if (H._writev && Z && Z.next) {
      var te = Q.bufferedRequestCount,
        Te = new Array(te),
        K = Q.corkedRequestsFree;
      K.entry = Z;
      for (var G = 0, he = !0; Z; )
        (Te[G] = Z), Z.isBuf || (he = !1), (Z = Z.next), (G += 1);
      (Te.allBuffers = he),
        y(H, Q, !0, Q.length, Te, "", K.finish),
        Q.pendingcb++,
        (Q.lastBufferedRequest = null),
        K.next
          ? ((Q.corkedRequestsFree = K.next), (K.next = null))
          : (Q.corkedRequestsFree = new t(Q)),
        (Q.bufferedRequestCount = 0);
    } else {
      for (; Z; ) {
        var se = Z.chunk,
          pe = Z.encoding,
          Y = Z.callback,
          $ = Q.objectMode ? 1 : se.length;
        if (
          (y(H, Q, !1, $, se, pe, Y),
          (Z = Z.next),
          Q.bufferedRequestCount--,
          Q.writing)
        )
          break;
      }
      Z === null && (Q.lastBufferedRequest = null);
    }
    (Q.bufferedRequest = Z), (Q.bufferProcessing = !1);
  }
  (j.prototype._write = function (H, Q, Z) {
    Z(new E("_write()"));
  }),
    (j.prototype._writev = null),
    (j.prototype.end = function (H, Q, Z) {
      var te = this._writableState;
      return (
        typeof H == "function"
          ? ((Z = H), (H = null), (Q = null))
          : typeof Q == "function" && ((Z = Q), (Q = null)),
        H != null && this.write(H, Q),
        te.corked && ((te.corked = 1), this.uncork()),
        te.ending || q(this, te, Z),
        this
      );
    }),
    Object.defineProperty(j.prototype, "writableLength", {
      enumerable: !1,
      get: function () {
        return this._writableState.length;
      },
    });
  function _(H) {
    return (
      H.ending &&
      H.length === 0 &&
      H.bufferedRequest === null &&
      !H.finished &&
      !H.writing
    );
  }
  function P(H, Q) {
    H._final(function (Z) {
      Q.pendingcb--,
        Z && N(H, Z),
        (Q.prefinished = !0),
        H.emit("prefinish"),
        D(H, Q);
    });
  }
  function M(H, Q) {
    !Q.prefinished &&
      !Q.finalCalled &&
      (typeof H._final == "function" && !Q.destroyed
        ? (Q.pendingcb++, (Q.finalCalled = !0), process.nextTick(P, H, Q))
        : ((Q.prefinished = !0), H.emit("prefinish")));
  }
  function D(H, Q) {
    var Z = _(Q);
    if (
      Z &&
      (M(H, Q),
      Q.pendingcb === 0 && ((Q.finished = !0), H.emit("finish"), Q.autoDestroy))
    ) {
      var te = H._readableState;
      (!te || (te.autoDestroy && te.endEmitted)) && H.destroy();
    }
    return Z;
  }
  function q(H, Q, Z) {
    (Q.ending = !0),
      D(H, Q),
      Z && (Q.finished ? process.nextTick(Z) : H.once("finish", Z)),
      (Q.ended = !0),
      (H.writable = !1);
  }
  function B(H, Q, Z) {
    var te = H.entry;
    for (H.entry = null; te; ) {
      var Te = te.callback;
      Q.pendingcb--, Te(Z), (te = te.next);
    }
    Q.corkedRequestsFree.next = H;
  }
  return (
    Object.defineProperty(j.prototype, "destroyed", {
      enumerable: !1,
      get: function () {
        return this._writableState === void 0
          ? !1
          : this._writableState.destroyed;
      },
      set: function (Q) {
        this._writableState && (this._writableState.destroyed = Q);
      },
    }),
    (j.prototype.destroy = c.destroy),
    (j.prototype._undestroy = c.undestroy),
    (j.prototype._destroy = function (H, Q) {
      Q(H);
    }),
    u5
  );
}
var f5, sM;
function Vf() {
  if (sM) return f5;
  sM = 1;
  var t =
    Object.keys ||
    function (u) {
      var d = [];
      for (var m in u) d.push(m);
      return d;
    };
  f5 = s;
  var e = xU(),
    r = bU();
  Ka(s, e);
  for (var n = t(r.prototype), i = 0; i < n.length; i++) {
    var a = n[i];
    s.prototype[a] || (s.prototype[a] = r.prototype[a]);
  }
  function s(u) {
    if (!(this instanceof s)) return new s(u);
    e.call(this, u),
      r.call(this, u),
      (this.allowHalfOpen = !0),
      u &&
        (u.readable === !1 && (this.readable = !1),
        u.writable === !1 && (this.writable = !1),
        u.allowHalfOpen === !1 &&
          ((this.allowHalfOpen = !1), this.once("end", o)));
  }
  Object.defineProperty(s.prototype, "writableHighWaterMark", {
    enumerable: !1,
    get: function () {
      return this._writableState.highWaterMark;
    },
  }),
    Object.defineProperty(s.prototype, "writableBuffer", {
      enumerable: !1,
      get: function () {
        return this._writableState && this._writableState.getBuffer();
      },
    }),
    Object.defineProperty(s.prototype, "writableLength", {
      enumerable: !1,
      get: function () {
        return this._writableState.length;
      },
    });
  function o() {
    this._writableState.ended || process.nextTick(c, this);
  }
  function c(u) {
    u.end();
  }
  return (
    Object.defineProperty(s.prototype, "destroyed", {
      enumerable: !1,
      get: function () {
        return this._readableState === void 0 || this._writableState === void 0
          ? !1
          : this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function (d) {
        this._readableState === void 0 ||
          this._writableState === void 0 ||
          ((this._readableState.destroyed = d),
          (this._writableState.destroyed = d));
      },
    }),
    f5
  );
}
var h4 = {},
  pT = wl.Buffer,
  oM =
    pT.isEncoding ||
    function (t) {
      switch (((t = "" + t), t && t.toLowerCase())) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return !0;
        default:
          return !1;
      }
    };
function Cge(t) {
  if (!t) return "utf8";
  for (var e; ; )
    switch (t) {
      case "utf8":
      case "utf-8":
        return "utf8";
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return "utf16le";
      case "latin1":
      case "binary":
        return "latin1";
      case "base64":
      case "ascii":
      case "hex":
        return t;
      default:
        if (e) return;
        (t = ("" + t).toLowerCase()), (e = !0);
    }
}
function Age(t) {
  var e = Cge(t);
  if (typeof e != "string" && (pT.isEncoding === oM || !oM(t)))
    throw new Error("Unknown encoding: " + t);
  return e || t;
}
h4.StringDecoder = c1;
function c1(t) {
  this.encoding = Age(t);
  var e;
  switch (this.encoding) {
    case "utf16le":
      (this.text = Pge), (this.end = Nge), (e = 4);
      break;
    case "utf8":
      (this.fillLast = Mge), (e = 4);
      break;
    case "base64":
      (this.text = Bge), (this.end = Dge), (e = 3);
      break;
    default:
      (this.write = Oge), (this.end = Fge);
      return;
  }
  (this.lastNeed = 0),
    (this.lastTotal = 0),
    (this.lastChar = pT.allocUnsafe(e));
}
c1.prototype.write = function (t) {
  if (t.length === 0) return "";
  var e, r;
  if (this.lastNeed) {
    if (((e = this.fillLast(t)), e === void 0)) return "";
    (r = this.lastNeed), (this.lastNeed = 0);
  } else r = 0;
  return r < t.length ? (e ? e + this.text(t, r) : this.text(t, r)) : e || "";
};
c1.prototype.end = Rge;
c1.prototype.text = Ige;
c1.prototype.fillLast = function (t) {
  if (this.lastNeed <= t.length)
    return (
      t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed),
      this.lastChar.toString(this.encoding, 0, this.lastTotal)
    );
  t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t.length),
    (this.lastNeed -= t.length);
};
function d5(t) {
  return t <= 127
    ? 0
    : t >> 5 === 6
    ? 2
    : t >> 4 === 14
    ? 3
    : t >> 3 === 30
    ? 4
    : t >> 6 === 2
    ? -1
    : -2;
}
function kge(t, e, r) {
  var n = e.length - 1;
  if (n < r) return 0;
  var i = d5(e[n]);
  return i >= 0
    ? (i > 0 && (t.lastNeed = i - 1), i)
    : --n < r || i === -2
    ? 0
    : ((i = d5(e[n])),
      i >= 0
        ? (i > 0 && (t.lastNeed = i - 2), i)
        : --n < r || i === -2
        ? 0
        : ((i = d5(e[n])),
          i >= 0
            ? (i > 0 && (i === 2 ? (i = 0) : (t.lastNeed = i - 3)), i)
            : 0));
}
function Sge(t, e, r) {
  if ((e[0] & 192) !== 128) return (t.lastNeed = 0), "�";
  if (t.lastNeed > 1 && e.length > 1) {
    if ((e[1] & 192) !== 128) return (t.lastNeed = 1), "�";
    if (t.lastNeed > 2 && e.length > 2 && (e[2] & 192) !== 128)
      return (t.lastNeed = 2), "�";
  }
}
function Mge(t) {
  var e = this.lastTotal - this.lastNeed,
    r = Sge(this, t);
  if (r !== void 0) return r;
  if (this.lastNeed <= t.length)
    return (
      t.copy(this.lastChar, e, 0, this.lastNeed),
      this.lastChar.toString(this.encoding, 0, this.lastTotal)
    );
  t.copy(this.lastChar, e, 0, t.length), (this.lastNeed -= t.length);
}
function Ige(t, e) {
  var r = kge(this, t, e);
  if (!this.lastNeed) return t.toString("utf8", e);
  this.lastTotal = r;
  var n = t.length - (r - this.lastNeed);
  return t.copy(this.lastChar, 0, n), t.toString("utf8", e, n);
}
function Rge(t) {
  var e = t && t.length ? this.write(t) : "";
  return this.lastNeed ? e + "�" : e;
}
function Pge(t, e) {
  if ((t.length - e) % 2 === 0) {
    var r = t.toString("utf16le", e);
    if (r) {
      var n = r.charCodeAt(r.length - 1);
      if (n >= 55296 && n <= 56319)
        return (
          (this.lastNeed = 2),
          (this.lastTotal = 4),
          (this.lastChar[0] = t[t.length - 2]),
          (this.lastChar[1] = t[t.length - 1]),
          r.slice(0, -1)
        );
    }
    return r;
  }
  return (
    (this.lastNeed = 1),
    (this.lastTotal = 2),
    (this.lastChar[0] = t[t.length - 1]),
    t.toString("utf16le", e, t.length - 1)
  );
}
function Nge(t) {
  var e = t && t.length ? this.write(t) : "";
  if (this.lastNeed) {
    var r = this.lastTotal - this.lastNeed;
    return e + this.lastChar.toString("utf16le", 0, r);
  }
  return e;
}
function Bge(t, e) {
  var r = (t.length - e) % 3;
  return r === 0
    ? t.toString("base64", e)
    : ((this.lastNeed = 3 - r),
      (this.lastTotal = 3),
      r === 1
        ? (this.lastChar[0] = t[t.length - 1])
        : ((this.lastChar[0] = t[t.length - 2]),
          (this.lastChar[1] = t[t.length - 1])),
      t.toString("base64", e, t.length - r));
}
function Dge(t) {
  var e = t && t.length ? this.write(t) : "";
  return this.lastNeed
    ? e + this.lastChar.toString("base64", 0, 3 - this.lastNeed)
    : e;
}
function Oge(t) {
  return t.toString(this.encoding);
}
function Fge(t) {
  return t && t.length ? this.write(t) : "";
}
var cM = Hu.codes.ERR_STREAM_PREMATURE_CLOSE;
function Lge(t) {
  var e = !1;
  return function () {
    if (!e) {
      e = !0;
      for (var r = arguments.length, n = new Array(r), i = 0; i < r; i++)
        n[i] = arguments[i];
      t.apply(this, n);
    }
  };
}
function $ge() {}
function Uge(t) {
  return t.setHeader && typeof t.abort == "function";
}
function vU(t, e, r) {
  if (typeof e == "function") return vU(t, null, e);
  e || (e = {}), (r = Lge(r || $ge));
  var n = e.readable || (e.readable !== !1 && t.readable),
    i = e.writable || (e.writable !== !1 && t.writable),
    a = function () {
      t.writable || o();
    },
    s = t._writableState && t._writableState.finished,
    o = function () {
      (i = !1), (s = !0), n || r.call(t);
    },
    c = t._readableState && t._readableState.endEmitted,
    u = function () {
      (n = !1), (c = !0), i || r.call(t);
    },
    d = function (A) {
      r.call(t, A);
    },
    m = function () {
      var A;
      if (n && !c)
        return (
          (!t._readableState || !t._readableState.ended) && (A = new cM()),
          r.call(t, A)
        );
      if (i && !s)
        return (
          (!t._writableState || !t._writableState.ended) && (A = new cM()),
          r.call(t, A)
        );
    },
    v = function () {
      t.req.on("finish", o);
    };
  return (
    Uge(t)
      ? (t.on("complete", o),
        t.on("abort", m),
        t.req ? v() : t.on("request", v))
      : i && !t._writableState && (t.on("end", a), t.on("close", a)),
    t.on("end", u),
    t.on("finish", o),
    e.error !== !1 && t.on("error", d),
    t.on("close", m),
    function () {
      t.removeListener("complete", o),
        t.removeListener("abort", m),
        t.removeListener("request", v),
        t.req && t.req.removeListener("finish", o),
        t.removeListener("end", a),
        t.removeListener("close", a),
        t.removeListener("finish", o),
        t.removeListener("end", u),
        t.removeListener("error", d),
        t.removeListener("close", m);
    }
  );
}
var mT = vU,
  h5,
  lM;
function Wge() {
  if (lM) return h5;
  lM = 1;
  var t;
  function e(k, N, O) {
    return (
      (N = r(N)),
      N in k
        ? Object.defineProperty(k, N, {
            value: O,
            enumerable: !0,
            configurable: !0,
            writable: !0,
          })
        : (k[N] = O),
      k
    );
  }
  function r(k) {
    var N = n(k, "string");
    return typeof N == "symbol" ? N : String(N);
  }
  function n(k, N) {
    if (typeof k != "object" || k === null) return k;
    var O = k[Symbol.toPrimitive];
    if (O !== void 0) {
      var F = O.call(k, N || "default");
      if (typeof F != "object") return F;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (N === "string" ? String : Number)(k);
  }
  var i = mT,
    a = Symbol("lastResolve"),
    s = Symbol("lastReject"),
    o = Symbol("error"),
    c = Symbol("ended"),
    u = Symbol("lastPromise"),
    d = Symbol("handlePromise"),
    m = Symbol("stream");
  function v(k, N) {
    return {
      value: k,
      done: N,
    };
  }
  function E(k) {
    var N = k[a];
    if (N !== null) {
      var O = k[m].read();
      O !== null && ((k[u] = null), (k[a] = null), (k[s] = null), N(v(O, !1)));
    }
  }
  function A(k) {
    process.nextTick(E, k);
  }
  function I(k, N) {
    return function (O, F) {
      k.then(function () {
        if (N[c]) {
          O(v(void 0, !0));
          return;
        }
        N[d](O, F);
      }, F);
    };
  }
  var b = Object.getPrototypeOf(function () {}),
    w = Object.setPrototypeOf(
      ((t = {
        get stream() {
          return this[m];
        },
        next: function () {
          var N = this,
            O = this[o];
          if (O !== null) return Promise.reject(O);
          if (this[c]) return Promise.resolve(v(void 0, !0));
          if (this[m].destroyed)
            return new Promise(function (X, C) {
              process.nextTick(function () {
                N[o] ? C(N[o]) : X(v(void 0, !0));
              });
            });
          var F = this[u],
            V;
          if (F) V = new Promise(I(F, this));
          else {
            var j = this[m].read();
            if (j !== null) return Promise.resolve(v(j, !1));
            V = new Promise(this[d]);
          }
          return (this[u] = V), V;
        },
      }),
      e(t, Symbol.asyncIterator, function () {
        return this;
      }),
      e(t, "return", function () {
        var N = this;
        return new Promise(function (O, F) {
          N[m].destroy(null, function (V) {
            if (V) {
              F(V);
              return;
            }
            O(v(void 0, !0));
          });
        });
      }),
      t),
      b
    ),
    S = function (N) {
      var O,
        F = Object.create(
          w,
          ((O = {}),
          e(O, m, {
            value: N,
            writable: !0,
          }),
          e(O, a, {
            value: null,
            writable: !0,
          }),
          e(O, s, {
            value: null,
            writable: !0,
          }),
          e(O, o, {
            value: null,
            writable: !0,
          }),
          e(O, c, {
            value: N._readableState.endEmitted,
            writable: !0,
          }),
          e(O, d, {
            value: function (j, X) {
              var C = F[m].read();
              C
                ? ((F[u] = null), (F[a] = null), (F[s] = null), j(v(C, !1)))
                : ((F[a] = j), (F[s] = X));
            },
            writable: !0,
          }),
          O)
        );
      return (
        (F[u] = null),
        i(N, function (V) {
          if (V && V.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            var j = F[s];
            j !== null && ((F[u] = null), (F[a] = null), (F[s] = null), j(V)),
              (F[o] = V);
            return;
          }
          var X = F[a];
          X !== null &&
            ((F[u] = null), (F[a] = null), (F[s] = null), X(v(void 0, !0))),
            (F[c] = !0);
        }),
        N.on("readable", A.bind(null, F)),
        F
      );
    };
  return (h5 = S), h5;
}
var p5, uM;
function jge() {
  return (
    uM ||
      ((uM = 1),
      (p5 = function () {
        throw new Error("Readable.from is not available in the browser");
      })),
    p5
  );
}
var m5, fM;
function xU() {
  if (fM) return m5;
  (fM = 1), (m5 = X);
  var t;
  (X.ReadableState = j), Cd.EventEmitter;
  var e = function (G, he) {
      return G.listeners(he).length;
    },
    r = pU,
    n = vo.Buffer,
    i =
      (typeof ke < "u"
        ? ke
        : typeof window < "u"
        ? window
        : typeof self < "u"
        ? self
        : {}
      ).Uint8Array || function () {};
  function a(K) {
    return n.from(K);
  }
  function s(K) {
    return n.isBuffer(K) || K instanceof i;
  }
  var o = Pu,
    c;
  o && o.debuglog ? (c = o.debuglog("stream")) : (c = function () {});
  var u = dge(),
    d = mU,
    m = gU,
    v = m.getHighWaterMark,
    E = Hu.codes,
    A = E.ERR_INVALID_ARG_TYPE,
    I = E.ERR_STREAM_PUSH_AFTER_EOF,
    b = E.ERR_METHOD_NOT_IMPLEMENTED,
    w = E.ERR_STREAM_UNSHIFT_AFTER_END_EVENT,
    S,
    k,
    N;
  Ka(X, r);
  var O = d.errorOrDestroy,
    F = ["error", "close", "destroy", "pause", "resume"];
  function V(K, G, he) {
    if (typeof K.prependListener == "function") return K.prependListener(G, he);
    !K._events || !K._events[G]
      ? K.on(G, he)
      : Array.isArray(K._events[G])
      ? K._events[G].unshift(he)
      : (K._events[G] = [he, K._events[G]]);
  }
  function j(K, G, he) {
    (t = t || Vf()),
      (K = K || {}),
      typeof he != "boolean" && (he = G instanceof t),
      (this.objectMode = !!K.objectMode),
      he && (this.objectMode = this.objectMode || !!K.readableObjectMode),
      (this.highWaterMark = v(this, K, "readableHighWaterMark", he)),
      (this.buffer = new u()),
      (this.length = 0),
      (this.pipes = null),
      (this.pipesCount = 0),
      (this.flowing = null),
      (this.ended = !1),
      (this.endEmitted = !1),
      (this.reading = !1),
      (this.sync = !0),
      (this.needReadable = !1),
      (this.emittedReadable = !1),
      (this.readableListening = !1),
      (this.resumeScheduled = !1),
      (this.paused = !0),
      (this.emitClose = K.emitClose !== !1),
      (this.autoDestroy = !!K.autoDestroy),
      (this.destroyed = !1),
      (this.defaultEncoding = K.defaultEncoding || "utf8"),
      (this.awaitDrain = 0),
      (this.readingMore = !1),
      (this.decoder = null),
      (this.encoding = null),
      K.encoding &&
        (S || (S = h4.StringDecoder),
        (this.decoder = new S(K.encoding)),
        (this.encoding = K.encoding));
  }
  function X(K) {
    if (((t = t || Vf()), !(this instanceof X))) return new X(K);
    var G = this instanceof t;
    (this._readableState = new j(K, this, G)),
      (this.readable = !0),
      K &&
        (typeof K.read == "function" && (this._read = K.read),
        typeof K.destroy == "function" && (this._destroy = K.destroy)),
      r.call(this);
  }
  Object.defineProperty(X.prototype, "destroyed", {
    enumerable: !1,
    get: function () {
      return this._readableState === void 0
        ? !1
        : this._readableState.destroyed;
    },
    set: function (G) {
      this._readableState && (this._readableState.destroyed = G);
    },
  }),
    (X.prototype.destroy = d.destroy),
    (X.prototype._undestroy = d.undestroy),
    (X.prototype._destroy = function (K, G) {
      G(K);
    }),
    (X.prototype.push = function (K, G) {
      var he = this._readableState,
        se;
      return (
        he.objectMode
          ? (se = !0)
          : typeof K == "string" &&
            ((G = G || he.defaultEncoding),
            G !== he.encoding && ((K = n.from(K, G)), (G = "")),
            (se = !0)),
        C(this, K, G, !1, se)
      );
    }),
    (X.prototype.unshift = function (K) {
      return C(this, K, null, !0, !1);
    });
  function C(K, G, he, se, pe) {
    c("readableAddChunk", G);
    var Y = K._readableState;
    if (G === null) (Y.reading = !1), T(K, Y);
    else {
      var $;
      if ((pe || ($ = p(Y, G)), $)) O(K, $);
      else if (Y.objectMode || (G && G.length > 0))
        if (
          (typeof G != "string" &&
            !Y.objectMode &&
            Object.getPrototypeOf(G) !== n.prototype &&
            (G = a(G)),
          se)
        )
          Y.endEmitted ? O(K, new w()) : l(K, Y, G, !0);
        else if (Y.ended) O(K, new I());
        else {
          if (Y.destroyed) return !1;
          (Y.reading = !1),
            Y.decoder && !he
              ? ((G = Y.decoder.write(G)),
                Y.objectMode || G.length !== 0 ? l(K, Y, G, !1) : f(K, Y))
              : l(K, Y, G, !1);
        }
      else se || ((Y.reading = !1), f(K, Y));
    }
    return !Y.ended && (Y.length < Y.highWaterMark || Y.length === 0);
  }
  function l(K, G, he, se) {
    G.flowing && G.length === 0 && !G.sync
      ? ((G.awaitDrain = 0), K.emit("data", he))
      : ((G.length += G.objectMode ? 1 : he.length),
        se ? G.buffer.unshift(he) : G.buffer.push(he),
        G.needReadable && R(K)),
      f(K, G);
  }
  function p(K, G) {
    var he;
    return (
      !s(G) &&
        typeof G != "string" &&
        G !== void 0 &&
        !K.objectMode &&
        (he = new A("chunk", ["string", "Buffer", "Uint8Array"], G)),
      he
    );
  }
  (X.prototype.isPaused = function () {
    return this._readableState.flowing === !1;
  }),
    (X.prototype.setEncoding = function (K) {
      S || (S = h4.StringDecoder);
      var G = new S(K);
      (this._readableState.decoder = G),
        (this._readableState.encoding = this._readableState.decoder.encoding);
      for (var he = this._readableState.buffer.head, se = ""; he !== null; )
        (se += G.write(he.data)), (he = he.next);
      return (
        this._readableState.buffer.clear(),
        se !== "" && this._readableState.buffer.push(se),
        (this._readableState.length = se.length),
        this
      );
    });
  var y = 1073741824;
  function h(K) {
    return (
      K >= y
        ? (K = y)
        : (K--,
          (K |= K >>> 1),
          (K |= K >>> 2),
          (K |= K >>> 4),
          (K |= K >>> 8),
          (K |= K >>> 16),
          K++),
      K
    );
  }
  function g(K, G) {
    return K <= 0 || (G.length === 0 && G.ended)
      ? 0
      : G.objectMode
      ? 1
      : K !== K
      ? G.flowing && G.length
        ? G.buffer.head.data.length
        : G.length
      : (K > G.highWaterMark && (G.highWaterMark = h(K)),
        K <= G.length ? K : G.ended ? G.length : ((G.needReadable = !0), 0));
  }
  X.prototype.read = function (K) {
    c("read", K), (K = parseInt(K, 10));
    var G = this._readableState,
      he = K;
    if (
      (K !== 0 && (G.emittedReadable = !1),
      K === 0 &&
        G.needReadable &&
        ((G.highWaterMark !== 0 ? G.length >= G.highWaterMark : G.length > 0) ||
          G.ended))
    )
      return (
        c("read: emitReadable", G.length, G.ended),
        G.length === 0 && G.ended ? Z(this) : R(this),
        null
      );
    if (((K = g(K, G)), K === 0 && G.ended))
      return G.length === 0 && Z(this), null;
    var se = G.needReadable;
    c("need readable", se),
      (G.length === 0 || G.length - K < G.highWaterMark) &&
        ((se = !0), c("length less than watermark", se)),
      G.ended || G.reading
        ? ((se = !1), c("reading or ended", se))
        : se &&
          (c("do read"),
          (G.reading = !0),
          (G.sync = !0),
          G.length === 0 && (G.needReadable = !0),
          this._read(G.highWaterMark),
          (G.sync = !1),
          G.reading || (K = g(he, G)));
    var pe;
    return (
      K > 0 ? (pe = Q(K, G)) : (pe = null),
      pe === null
        ? ((G.needReadable = G.length <= G.highWaterMark), (K = 0))
        : ((G.length -= K), (G.awaitDrain = 0)),
      G.length === 0 &&
        (G.ended || (G.needReadable = !0), he !== K && G.ended && Z(this)),
      pe !== null && this.emit("data", pe),
      pe
    );
  };
  function T(K, G) {
    if ((c("onEofChunk"), !G.ended)) {
      if (G.decoder) {
        var he = G.decoder.end();
        he &&
          he.length &&
          (G.buffer.push(he), (G.length += G.objectMode ? 1 : he.length));
      }
      (G.ended = !0),
        G.sync
          ? R(K)
          : ((G.needReadable = !1),
            G.emittedReadable || ((G.emittedReadable = !0), x(K)));
    }
  }
  function R(K) {
    var G = K._readableState;
    c("emitReadable", G.needReadable, G.emittedReadable),
      (G.needReadable = !1),
      G.emittedReadable ||
        (c("emitReadable", G.flowing),
        (G.emittedReadable = !0),
        process.nextTick(x, K));
  }
  function x(K) {
    var G = K._readableState;
    c("emitReadable_", G.destroyed, G.length, G.ended),
      !G.destroyed &&
        (G.length || G.ended) &&
        (K.emit("readable"), (G.emittedReadable = !1)),
      (G.needReadable = !G.flowing && !G.ended && G.length <= G.highWaterMark),
      H(K);
  }
  function f(K, G) {
    G.readingMore || ((G.readingMore = !0), process.nextTick(_, K, G));
  }
  function _(K, G) {
    for (
      ;
      !G.reading &&
      !G.ended &&
      (G.length < G.highWaterMark || (G.flowing && G.length === 0));

    ) {
      var he = G.length;
      if ((c("maybeReadMore read 0"), K.read(0), he === G.length)) break;
    }
    G.readingMore = !1;
  }
  (X.prototype._read = function (K) {
    O(this, new b("_read()"));
  }),
    (X.prototype.pipe = function (K, G) {
      var he = this,
        se = this._readableState;
      switch (se.pipesCount) {
        case 0:
          se.pipes = K;
          break;
        case 1:
          se.pipes = [se.pipes, K];
          break;
        default:
          se.pipes.push(K);
          break;
      }
      (se.pipesCount += 1), c("pipe count=%d opts=%j", se.pipesCount, G);
      var pe =
          (!G || G.end !== !1) && K !== process.stdout && K !== process.stderr,
        Y = pe ? W : ve;
      se.endEmitted ? process.nextTick(Y) : he.once("end", Y),
        K.on("unpipe", $);
      function $(z, U) {
        c("onunpipe"),
          z === he && U && U.hasUnpiped === !1 && ((U.hasUnpiped = !0), ce());
      }
      function W() {
        c("onend"), K.end();
      }
      var re = P(he);
      K.on("drain", re);
      var ee = !1;
      function ce() {
        c("cleanup"),
          K.removeListener("close", ge),
          K.removeListener("finish", it),
          K.removeListener("drain", re),
          K.removeListener("error", me),
          K.removeListener("unpipe", $),
          he.removeListener("end", W),
          he.removeListener("end", ve),
          he.removeListener("data", Ce),
          (ee = !0),
          se.awaitDrain &&
            (!K._writableState || K._writableState.needDrain) &&
            re();
      }
      he.on("data", Ce);
      function Ce(z) {
        c("ondata");
        var U = K.write(z);
        c("dest.write", U),
          U === !1 &&
            (((se.pipesCount === 1 && se.pipes === K) ||
              (se.pipesCount > 1 && Te(se.pipes, K) !== -1)) &&
              !ee &&
              (c("false write response, pause", se.awaitDrain),
              se.awaitDrain++),
            he.pause());
      }
      function me(z) {
        c("onerror", z),
          ve(),
          K.removeListener("error", me),
          e(K, "error") === 0 && O(K, z);
      }
      V(K, "error", me);
      function ge() {
        K.removeListener("finish", it), ve();
      }
      K.once("close", ge);
      function it() {
        c("onfinish"), K.removeListener("close", ge), ve();
      }
      K.once("finish", it);
      function ve() {
        c("unpipe"), he.unpipe(K);
      }
      return (
        K.emit("pipe", he), se.flowing || (c("pipe resume"), he.resume()), K
      );
    });
  function P(K) {
    return function () {
      var he = K._readableState;
      c("pipeOnDrain", he.awaitDrain),
        he.awaitDrain && he.awaitDrain--,
        he.awaitDrain === 0 && e(K, "data") && ((he.flowing = !0), H(K));
    };
  }
  (X.prototype.unpipe = function (K) {
    var G = this._readableState,
      he = {
        hasUnpiped: !1,
      };
    if (G.pipesCount === 0) return this;
    if (G.pipesCount === 1)
      return K && K !== G.pipes
        ? this
        : (K || (K = G.pipes),
          (G.pipes = null),
          (G.pipesCount = 0),
          (G.flowing = !1),
          K && K.emit("unpipe", this, he),
          this);
    if (!K) {
      var se = G.pipes,
        pe = G.pipesCount;
      (G.pipes = null), (G.pipesCount = 0), (G.flowing = !1);
      for (var Y = 0; Y < pe; Y++)
        se[Y].emit("unpipe", this, {
          hasUnpiped: !1,
        });
      return this;
    }
    var $ = Te(G.pipes, K);
    return $ === -1
      ? this
      : (G.pipes.splice($, 1),
        (G.pipesCount -= 1),
        G.pipesCount === 1 && (G.pipes = G.pipes[0]),
        K.emit("unpipe", this, he),
        this);
  }),
    (X.prototype.on = function (K, G) {
      var he = r.prototype.on.call(this, K, G),
        se = this._readableState;
      return (
        K === "data"
          ? ((se.readableListening = this.listenerCount("readable") > 0),
            se.flowing !== !1 && this.resume())
          : K === "readable" &&
            !se.endEmitted &&
            !se.readableListening &&
            ((se.readableListening = se.needReadable = !0),
            (se.flowing = !1),
            (se.emittedReadable = !1),
            c("on readable", se.length, se.reading),
            se.length ? R(this) : se.reading || process.nextTick(D, this)),
        he
      );
    }),
    (X.prototype.addListener = X.prototype.on),
    (X.prototype.removeListener = function (K, G) {
      var he = r.prototype.removeListener.call(this, K, G);
      return K === "readable" && process.nextTick(M, this), he;
    }),
    (X.prototype.removeAllListeners = function (K) {
      var G = r.prototype.removeAllListeners.apply(this, arguments);
      return (K === "readable" || K === void 0) && process.nextTick(M, this), G;
    });
  function M(K) {
    var G = K._readableState;
    (G.readableListening = K.listenerCount("readable") > 0),
      G.resumeScheduled && !G.paused
        ? (G.flowing = !0)
        : K.listenerCount("data") > 0 && K.resume();
  }
  function D(K) {
    c("readable nexttick read 0"), K.read(0);
  }
  X.prototype.resume = function () {
    var K = this._readableState;
    return (
      K.flowing ||
        (c("resume"), (K.flowing = !K.readableListening), q(this, K)),
      (K.paused = !1),
      this
    );
  };
  function q(K, G) {
    G.resumeScheduled || ((G.resumeScheduled = !0), process.nextTick(B, K, G));
  }
  function B(K, G) {
    c("resume", G.reading),
      G.reading || K.read(0),
      (G.resumeScheduled = !1),
      K.emit("resume"),
      H(K),
      G.flowing && !G.reading && K.read(0);
  }
  X.prototype.pause = function () {
    return (
      c("call pause flowing=%j", this._readableState.flowing),
      this._readableState.flowing !== !1 &&
        (c("pause"), (this._readableState.flowing = !1), this.emit("pause")),
      (this._readableState.paused = !0),
      this
    );
  };
  function H(K) {
    var G = K._readableState;
    for (c("flow", G.flowing); G.flowing && K.read() !== null; );
  }
  (X.prototype.wrap = function (K) {
    var G = this,
      he = this._readableState,
      se = !1;
    K.on("end", function () {
      if ((c("wrapped end"), he.decoder && !he.ended)) {
        var $ = he.decoder.end();
        $ && $.length && G.push($);
      }
      G.push(null);
    }),
      K.on("data", function ($) {
        if (
          (c("wrapped data"),
          he.decoder && ($ = he.decoder.write($)),
          !(he.objectMode && $ == null) &&
            !(!he.objectMode && (!$ || !$.length)))
        ) {
          var W = G.push($);
          W || ((se = !0), K.pause());
        }
      });
    for (var pe in K)
      this[pe] === void 0 &&
        typeof K[pe] == "function" &&
        (this[pe] = (function (W) {
          return function () {
            return K[W].apply(K, arguments);
          };
        })(pe));
    for (var Y = 0; Y < F.length; Y++) K.on(F[Y], this.emit.bind(this, F[Y]));
    return (
      (this._read = function ($) {
        c("wrapped _read", $), se && ((se = !1), K.resume());
      }),
      this
    );
  }),
    typeof Symbol == "function" &&
      (X.prototype[Symbol.asyncIterator] = function () {
        return k === void 0 && (k = Wge()), k(this);
      }),
    Object.defineProperty(X.prototype, "readableHighWaterMark", {
      enumerable: !1,
      get: function () {
        return this._readableState.highWaterMark;
      },
    }),
    Object.defineProperty(X.prototype, "readableBuffer", {
      enumerable: !1,
      get: function () {
        return this._readableState && this._readableState.buffer;
      },
    }),
    Object.defineProperty(X.prototype, "readableFlowing", {
      enumerable: !1,
      get: function () {
        return this._readableState.flowing;
      },
      set: function (G) {
        this._readableState && (this._readableState.flowing = G);
      },
    }),
    (X._fromList = Q),
    Object.defineProperty(X.prototype, "readableLength", {
      enumerable: !1,
      get: function () {
        return this._readableState.length;
      },
    });
  function Q(K, G) {
    if (G.length === 0) return null;
    var he;
    return (
      G.objectMode
        ? (he = G.buffer.shift())
        : !K || K >= G.length
        ? (G.decoder
            ? (he = G.buffer.join(""))
            : G.buffer.length === 1
            ? (he = G.buffer.first())
            : (he = G.buffer.concat(G.length)),
          G.buffer.clear())
        : (he = G.buffer.consume(K, G.decoder)),
      he
    );
  }
  function Z(K) {
    var G = K._readableState;
    c("endReadable", G.endEmitted),
      G.endEmitted || ((G.ended = !0), process.nextTick(te, G, K));
  }
  function te(K, G) {
    if (
      (c("endReadableNT", K.endEmitted, K.length),
      !K.endEmitted &&
        K.length === 0 &&
        ((K.endEmitted = !0), (G.readable = !1), G.emit("end"), K.autoDestroy))
    ) {
      var he = G._writableState;
      (!he || (he.autoDestroy && he.finished)) && G.destroy();
    }
  }
  typeof Symbol == "function" &&
    (X.from = function (K, G) {
      return N === void 0 && (N = jge()), N(X, K, G);
    });
  function Te(K, G) {
    for (var he = 0, se = K.length; he < se; he++) if (K[he] === G) return he;
    return -1;
  }
  return m5;
}
var wU = Yo,
  hx = Hu.codes,
  Hge = hx.ERR_METHOD_NOT_IMPLEMENTED,
  zge = hx.ERR_MULTIPLE_CALLBACK,
  qge = hx.ERR_TRANSFORM_ALREADY_TRANSFORMING,
  Vge = hx.ERR_TRANSFORM_WITH_LENGTH_0,
  px = Vf();
Ka(Yo, px);
function Kge(t, e) {
  var r = this._transformState;
  r.transforming = !1;
  var n = r.writecb;
  if (n === null) return this.emit("error", new zge());
  (r.writechunk = null), (r.writecb = null), e != null && this.push(e), n(t);
  var i = this._readableState;
  (i.reading = !1),
    (i.needReadable || i.length < i.highWaterMark) &&
      this._read(i.highWaterMark);
}
function Yo(t) {
  if (!(this instanceof Yo)) return new Yo(t);
  px.call(this, t),
    (this._transformState = {
      afterTransform: Kge.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null,
    }),
    (this._readableState.needReadable = !0),
    (this._readableState.sync = !1),
    t &&
      (typeof t.transform == "function" && (this._transform = t.transform),
      typeof t.flush == "function" && (this._flush = t.flush)),
    this.on("prefinish", Gge);
}
function Gge() {
  var t = this;
  typeof this._flush == "function" && !this._readableState.destroyed
    ? this._flush(function (e, r) {
        dM(t, e, r);
      })
    : dM(this, null, null);
}
Yo.prototype.push = function (t, e) {
  return (
    (this._transformState.needTransform = !1),
    px.prototype.push.call(this, t, e)
  );
};
Yo.prototype._transform = function (t, e, r) {
  r(new Hge("_transform()"));
};
Yo.prototype._write = function (t, e, r) {
  var n = this._transformState;
  if (
    ((n.writecb = r),
    (n.writechunk = t),
    (n.writeencoding = e),
    !n.transforming)
  ) {
    var i = this._readableState;
    (n.needTransform || i.needReadable || i.length < i.highWaterMark) &&
      this._read(i.highWaterMark);
  }
};
Yo.prototype._read = function (t) {
  var e = this._transformState;
  e.writechunk !== null && !e.transforming
    ? ((e.transforming = !0),
      this._transform(e.writechunk, e.writeencoding, e.afterTransform))
    : (e.needTransform = !0);
};
Yo.prototype._destroy = function (t, e) {
  px.prototype._destroy.call(this, t, function (r) {
    e(r);
  });
};
function dM(t, e, r) {
  if (e) return t.emit("error", e);
  if ((r != null && t.push(r), t._writableState.length)) throw new Vge();
  if (t._transformState.transforming) throw new qge();
  return t.push(null);
}
var Zge = fm,
  _U = wU;
Ka(fm, _U);
function fm(t) {
  if (!(this instanceof fm)) return new fm(t);
  _U.call(this, t);
}
fm.prototype._transform = function (t, e, r) {
  r(null, t);
};
var y5;
function Jge(t) {
  var e = !1;
  return function () {
    e || ((e = !0), t.apply(void 0, arguments));
  };
}
var EU = Hu.codes,
  Qge = EU.ERR_MISSING_ARGS,
  Yge = EU.ERR_STREAM_DESTROYED;
function hM(t) {
  if (t) throw t;
}
function Xge(t) {
  return t.setHeader && typeof t.abort == "function";
}
function e2e(t, e, r, n) {
  n = Jge(n);
  var i = !1;
  t.on("close", function () {
    i = !0;
  }),
    y5 === void 0 && (y5 = mT),
    y5(
      t,
      {
        readable: e,
        writable: r,
      },
      function (s) {
        if (s) return n(s);
        (i = !0), n();
      }
    );
  var a = !1;
  return function (s) {
    if (!i && !a) {
      if (((a = !0), Xge(t))) return t.abort();
      if (typeof t.destroy == "function") return t.destroy();
      n(s || new Yge("pipe"));
    }
  };
}
function pM(t) {
  t();
}
function t2e(t, e) {
  return t.pipe(e);
}
function r2e(t) {
  return !t.length || typeof t[t.length - 1] != "function" ? hM : t.pop();
}
function n2e() {
  for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)
    e[r] = arguments[r];
  var n = r2e(e);
  if ((Array.isArray(e[0]) && (e = e[0]), e.length < 2))
    throw new Qge("streams");
  var i,
    a = e.map(function (s, o) {
      var c = o < e.length - 1,
        u = o > 0;
      return e2e(s, c, u, function (d) {
        i || (i = d), d && a.forEach(pM), !c && (a.forEach(pM), n(i));
      });
    });
  return e.reduce(t2e);
}
var i2e = n2e;
(function (t, e) {
  (e = t.exports = xU()),
    (e.Stream = e),
    (e.Readable = e),
    (e.Writable = bU()),
    (e.Duplex = Vf()),
    (e.Transform = wU),
    (e.PassThrough = Zge),
    (e.finished = mT),
    (e.pipeline = i2e);
})(f4, f4.exports);
var TU = f4.exports;
const { Transform: a2e } = TU;
var s2e = (t) =>
  class CU extends a2e {
    constructor(r, n, i, a, s) {
      super(s),
        (this._rate = r),
        (this._capacity = n),
        (this._delimitedSuffix = i),
        (this._hashBitLength = a),
        (this._options = s),
        (this._state = new t()),
        this._state.initialize(r, n),
        (this._finalized = !1);
    }
    _transform(r, n, i) {
      let a = null;
      try {
        this.update(r, n);
      } catch (s) {
        a = s;
      }
      i(a);
    }
    _flush(r) {
      let n = null;
      try {
        this.push(this.digest());
      } catch (i) {
        n = i;
      }
      r(n);
    }
    update(r, n) {
      if (!Buffer.isBuffer(r) && typeof r != "string")
        throw new TypeError("Data must be a string or a buffer");
      if (this._finalized) throw new Error("Digest already called");
      return (
        Buffer.isBuffer(r) || (r = Buffer.from(r, n)),
        this._state.absorb(r),
        this
      );
    }
    digest(r) {
      if (this._finalized) throw new Error("Digest already called");
      (this._finalized = !0),
        this._delimitedSuffix &&
          this._state.absorbLastFewBits(this._delimitedSuffix);
      let n = this._state.squeeze(this._hashBitLength / 8);
      return r !== void 0 && (n = n.toString(r)), this._resetState(), n;
    }
    _resetState() {
      return this._state.initialize(this._rate, this._capacity), this;
    }
    _clone() {
      const r = new CU(
        this._rate,
        this._capacity,
        this._delimitedSuffix,
        this._hashBitLength,
        this._options
      );
      return this._state.copy(r._state), (r._finalized = this._finalized), r;
    }
  };
const { Transform: o2e } = TU;
var c2e = (t) =>
  class AU extends o2e {
    constructor(r, n, i, a) {
      super(a),
        (this._rate = r),
        (this._capacity = n),
        (this._delimitedSuffix = i),
        (this._options = a),
        (this._state = new t()),
        this._state.initialize(r, n),
        (this._finalized = !1);
    }
    _transform(r, n, i) {
      let a = null;
      try {
        this.update(r, n);
      } catch (s) {
        a = s;
      }
      i(a);
    }
    _flush() {}
    _read(r) {
      this.push(this.squeeze(r));
    }
    update(r, n) {
      if (!Buffer.isBuffer(r) && typeof r != "string")
        throw new TypeError("Data must be a string or a buffer");
      if (this._finalized) throw new Error("Squeeze already called");
      return (
        Buffer.isBuffer(r) || (r = Buffer.from(r, n)),
        this._state.absorb(r),
        this
      );
    }
    squeeze(r, n) {
      this._finalized ||
        ((this._finalized = !0),
        this._state.absorbLastFewBits(this._delimitedSuffix));
      let i = this._state.squeeze(r);
      return n !== void 0 && (i = i.toString(n)), i;
    }
    _resetState() {
      return this._state.initialize(this._rate, this._capacity), this;
    }
    _clone() {
      const r = new AU(
        this._rate,
        this._capacity,
        this._delimitedSuffix,
        this._options
      );
      return this._state.copy(r._state), (r._finalized = this._finalized), r;
    }
  };
const l2e = s2e,
  u2e = c2e;
var f2e = function (t) {
    const e = l2e(t),
      r = u2e(t);
    return function (n, i) {
      switch (typeof n == "string" ? n.toLowerCase() : n) {
        case "keccak224":
          return new e(1152, 448, null, 224, i);
        case "keccak256":
          return new e(1088, 512, null, 256, i);
        case "keccak384":
          return new e(832, 768, null, 384, i);
        case "keccak512":
          return new e(576, 1024, null, 512, i);
        case "sha3-224":
          return new e(1152, 448, 6, 224, i);
        case "sha3-256":
          return new e(1088, 512, 6, 256, i);
        case "sha3-384":
          return new e(832, 768, 6, 384, i);
        case "sha3-512":
          return new e(576, 1024, 6, 512, i);
        case "shake128":
          return new r(1344, 256, 31, i);
        case "shake256":
          return new r(1088, 512, 31, i);
        default:
          throw new Error("Invald algorithm: " + n);
      }
    };
  },
  kU = {};
const mM = [
  1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0,
  2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0,
  2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905,
  2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0,
  2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649,
  0, 2147516424, 2147483648,
];
kU.p1600 = function (t) {
  for (let e = 0; e < 24; ++e) {
    const r = t[0] ^ t[10] ^ t[20] ^ t[30] ^ t[40],
      n = t[1] ^ t[11] ^ t[21] ^ t[31] ^ t[41],
      i = t[2] ^ t[12] ^ t[22] ^ t[32] ^ t[42],
      a = t[3] ^ t[13] ^ t[23] ^ t[33] ^ t[43],
      s = t[4] ^ t[14] ^ t[24] ^ t[34] ^ t[44],
      o = t[5] ^ t[15] ^ t[25] ^ t[35] ^ t[45],
      c = t[6] ^ t[16] ^ t[26] ^ t[36] ^ t[46],
      u = t[7] ^ t[17] ^ t[27] ^ t[37] ^ t[47],
      d = t[8] ^ t[18] ^ t[28] ^ t[38] ^ t[48],
      m = t[9] ^ t[19] ^ t[29] ^ t[39] ^ t[49];
    let v = d ^ ((i << 1) | (a >>> 31)),
      E = m ^ ((a << 1) | (i >>> 31));
    const A = t[0] ^ v,
      I = t[1] ^ E,
      b = t[10] ^ v,
      w = t[11] ^ E,
      S = t[20] ^ v,
      k = t[21] ^ E,
      N = t[30] ^ v,
      O = t[31] ^ E,
      F = t[40] ^ v,
      V = t[41] ^ E;
    (v = r ^ ((s << 1) | (o >>> 31))), (E = n ^ ((o << 1) | (s >>> 31)));
    const j = t[2] ^ v,
      X = t[3] ^ E,
      C = t[12] ^ v,
      l = t[13] ^ E,
      p = t[22] ^ v,
      y = t[23] ^ E,
      h = t[32] ^ v,
      g = t[33] ^ E,
      T = t[42] ^ v,
      R = t[43] ^ E;
    (v = i ^ ((c << 1) | (u >>> 31))), (E = a ^ ((u << 1) | (c >>> 31)));
    const x = t[4] ^ v,
      f = t[5] ^ E,
      _ = t[14] ^ v,
      P = t[15] ^ E,
      M = t[24] ^ v,
      D = t[25] ^ E,
      q = t[34] ^ v,
      B = t[35] ^ E,
      H = t[44] ^ v,
      Q = t[45] ^ E;
    (v = s ^ ((d << 1) | (m >>> 31))), (E = o ^ ((m << 1) | (d >>> 31)));
    const Z = t[6] ^ v,
      te = t[7] ^ E,
      Te = t[16] ^ v,
      K = t[17] ^ E,
      G = t[26] ^ v,
      he = t[27] ^ E,
      se = t[36] ^ v,
      pe = t[37] ^ E,
      Y = t[46] ^ v,
      $ = t[47] ^ E;
    (v = c ^ ((r << 1) | (n >>> 31))), (E = u ^ ((n << 1) | (r >>> 31)));
    const W = t[8] ^ v,
      re = t[9] ^ E,
      ee = t[18] ^ v,
      ce = t[19] ^ E,
      Ce = t[28] ^ v,
      me = t[29] ^ E,
      ge = t[38] ^ v,
      it = t[39] ^ E,
      ve = t[48] ^ v,
      z = t[49] ^ E,
      U = A,
      L = I,
      J = (w << 4) | (b >>> 28),
      fe = (b << 4) | (w >>> 28),
      ie = (S << 3) | (k >>> 29),
      le = (k << 3) | (S >>> 29),
      nt = (O << 9) | (N >>> 23),
      Ee = (N << 9) | (O >>> 23),
      we = (F << 18) | (V >>> 14),
      ft = (V << 18) | (F >>> 14),
      xe = (j << 1) | (X >>> 31),
      Pe = (X << 1) | (j >>> 31),
      hr = (l << 12) | (C >>> 20),
      Ne = (C << 12) | (l >>> 20),
      Me = (p << 10) | (y >>> 22),
      _r = (y << 10) | (p >>> 22),
      Be = (g << 13) | (h >>> 19),
      De = (h << 13) | (g >>> 19),
      pr = (T << 2) | (R >>> 30),
      Oe = (R << 2) | (T >>> 30),
      Fe = (f << 30) | (x >>> 2),
      mr = (x << 30) | (f >>> 2),
      Le = (_ << 6) | (P >>> 26),
      Ie = (P << 6) | (_ >>> 26),
      At = (D << 11) | (M >>> 21),
      Ae = (M << 11) | (D >>> 21),
      Re = (q << 15) | (B >>> 17),
      Er = (B << 15) | (q >>> 17),
      $e = (Q << 29) | (H >>> 3),
      Ue = (H << 29) | (Q >>> 3),
      Mr = (Z << 28) | (te >>> 4),
      We = (te << 28) | (Z >>> 4),
      je = (K << 23) | (Te >>> 9),
      ur = (Te << 23) | (K >>> 9),
      mt = (G << 25) | (he >>> 7),
      yt = (he << 25) | (G >>> 7),
      rr = (se << 21) | (pe >>> 11),
      nr = (pe << 21) | (se >>> 11),
      ir = ($ << 24) | (Y >>> 8),
      ar = (Y << 24) | ($ >>> 8),
      sr = (W << 27) | (re >>> 5),
      Ir = (re << 27) | (W >>> 5),
      Rr = (ee << 20) | (ce >>> 12),
      Pr = (ce << 20) | (ee >>> 12),
      Nr = (me << 7) | (Ce >>> 25),
      Br = (Ce << 7) | (me >>> 25),
      Dr = (ge << 8) | (it >>> 24),
      Or = (it << 8) | (ge >>> 24),
      Fr = (ve << 14) | (z >>> 18),
      Lr = (z << 14) | (ve >>> 18);
    (t[0] = U ^ (~hr & At)),
      (t[1] = L ^ (~Ne & Ae)),
      (t[10] = Mr ^ (~Rr & ie)),
      (t[11] = We ^ (~Pr & le)),
      (t[20] = xe ^ (~Le & mt)),
      (t[21] = Pe ^ (~Ie & yt)),
      (t[30] = sr ^ (~J & Me)),
      (t[31] = Ir ^ (~fe & _r)),
      (t[40] = Fe ^ (~je & Nr)),
      (t[41] = mr ^ (~ur & Br)),
      (t[2] = hr ^ (~At & rr)),
      (t[3] = Ne ^ (~Ae & nr)),
      (t[12] = Rr ^ (~ie & Be)),
      (t[13] = Pr ^ (~le & De)),
      (t[22] = Le ^ (~mt & Dr)),
      (t[23] = Ie ^ (~yt & Or)),
      (t[32] = J ^ (~Me & Re)),
      (t[33] = fe ^ (~_r & Er)),
      (t[42] = je ^ (~Nr & nt)),
      (t[43] = ur ^ (~Br & Ee)),
      (t[4] = At ^ (~rr & Fr)),
      (t[5] = Ae ^ (~nr & Lr)),
      (t[14] = ie ^ (~Be & $e)),
      (t[15] = le ^ (~De & Ue)),
      (t[24] = mt ^ (~Dr & we)),
      (t[25] = yt ^ (~Or & ft)),
      (t[34] = Me ^ (~Re & ir)),
      (t[35] = _r ^ (~Er & ar)),
      (t[44] = Nr ^ (~nt & pr)),
      (t[45] = Br ^ (~Ee & Oe)),
      (t[6] = rr ^ (~Fr & U)),
      (t[7] = nr ^ (~Lr & L)),
      (t[16] = Be ^ (~$e & Mr)),
      (t[17] = De ^ (~Ue & We)),
      (t[26] = Dr ^ (~we & xe)),
      (t[27] = Or ^ (~ft & Pe)),
      (t[36] = Re ^ (~ir & sr)),
      (t[37] = Er ^ (~ar & Ir)),
      (t[46] = nt ^ (~pr & Fe)),
      (t[47] = Ee ^ (~Oe & mr)),
      (t[8] = Fr ^ (~U & hr)),
      (t[9] = Lr ^ (~L & Ne)),
      (t[18] = $e ^ (~Mr & Rr)),
      (t[19] = Ue ^ (~We & Pr)),
      (t[28] = we ^ (~xe & Le)),
      (t[29] = ft ^ (~Pe & Ie)),
      (t[38] = ir ^ (~sr & J)),
      (t[39] = ar ^ (~Ir & fe)),
      (t[48] = pr ^ (~Fe & je)),
      (t[49] = Oe ^ (~mr & ur)),
      (t[0] ^= mM[e * 2]),
      (t[1] ^= mM[e * 2 + 1]);
  }
};
const ub = kU;
function Pd() {
  (this.state = [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  ]),
    (this.blockSize = null),
    (this.count = 0),
    (this.squeezing = !1);
}
Pd.prototype.initialize = function (t, e) {
  for (let r = 0; r < 50; ++r) this.state[r] = 0;
  (this.blockSize = t / 8), (this.count = 0), (this.squeezing = !1);
};
Pd.prototype.absorb = function (t) {
  for (let e = 0; e < t.length; ++e)
    (this.state[~~(this.count / 4)] ^= t[e] << (8 * (this.count % 4))),
      (this.count += 1),
      this.count === this.blockSize && (ub.p1600(this.state), (this.count = 0));
};
Pd.prototype.absorbLastFewBits = function (t) {
  (this.state[~~(this.count / 4)] ^= t << (8 * (this.count % 4))),
    t & 128 && this.count === this.blockSize - 1 && ub.p1600(this.state),
    (this.state[~~((this.blockSize - 1) / 4)] ^=
      128 << (8 * ((this.blockSize - 1) % 4))),
    ub.p1600(this.state),
    (this.count = 0),
    (this.squeezing = !0);
};
Pd.prototype.squeeze = function (t) {
  this.squeezing || this.absorbLastFewBits(1);
  const e = Buffer.alloc(t);
  for (let r = 0; r < t; ++r)
    (e[r] = (this.state[~~(this.count / 4)] >>> (8 * (this.count % 4))) & 255),
      (this.count += 1),
      this.count === this.blockSize && (ub.p1600(this.state), (this.count = 0));
  return e;
};
Pd.prototype.copy = function (t) {
  for (let e = 0; e < 50; ++e) t.state[e] = this.state[e];
  (t.blockSize = this.blockSize),
    (t.count = this.count),
    (t.squeezing = this.squeezing);
};
var d2e = Pd,
  h2e = f2e(d2e);
const p2e = h2e,
  m2e = Nm;
function SU(t) {
  return Buffer.allocUnsafe(t).fill(0);
}
function MU(t, e, r) {
  const n = SU(e);
  return (
    (t = mx(t)),
    r
      ? t.length < e
        ? (t.copy(n), n)
        : t.slice(0, e)
      : t.length < e
      ? (t.copy(n, e - t.length), n)
      : t.slice(-e)
  );
}
function y2e(t, e) {
  return MU(t, e, !0);
}
function mx(t) {
  if (!Buffer.isBuffer(t))
    if (Array.isArray(t)) t = Buffer.from(t);
    else if (typeof t == "string")
      IU(t) ? (t = Buffer.from(v2e(RU(t)), "hex")) : (t = Buffer.from(t));
    else if (typeof t == "number") t = intToBuffer(t);
    else if (t == null) t = Buffer.allocUnsafe(0);
    else if (m2e.isBN(t)) t = t.toArrayLike(Buffer);
    else if (t.toArray) t = Buffer.from(t.toArray());
    else throw new Error("invalid type");
  return t;
}
function g2e(t) {
  return (t = mx(t)), "0x" + t.toString("hex");
}
function b2e(t, e) {
  return (
    (t = mx(t)),
    e || (e = 256),
    p2e("keccak" + e)
      .update(t)
      .digest()
  );
}
function v2e(t) {
  return t.length % 2 ? "0" + t : t;
}
function IU(t) {
  return typeof t == "string" && t.match(/^0x[0-9A-Fa-f]*$/);
}
function RU(t) {
  return typeof t == "string" && t.startsWith("0x") ? t.slice(2) : t;
}
var PU = {
  zeros: SU,
  setLength: MU,
  setLengthRight: y2e,
  isHexString: IU,
  stripHexPrefix: RU,
  toBuffer: mx,
  bufferToHex: g2e,
  keccak: b2e,
};
const Tu = PU,
  Jl = Nm;
function NU(t) {
  return t.startsWith("int[")
    ? "int256" + t.slice(3)
    : t === "int"
    ? "int256"
    : t.startsWith("uint[")
    ? "uint256" + t.slice(4)
    : t === "uint"
    ? "uint256"
    : t.startsWith("fixed[")
    ? "fixed128x128" + t.slice(5)
    : t === "fixed"
    ? "fixed128x128"
    : t.startsWith("ufixed[")
    ? "ufixed128x128" + t.slice(6)
    : t === "ufixed"
    ? "ufixed128x128"
    : t;
}
function rf(t) {
  return parseInt(/^\D+(\d+)$/.exec(t)[1], 10);
}
function yM(t) {
  var e = /^\D+(\d+)x(\d+)$/.exec(t);
  return [parseInt(e[1], 10), parseInt(e[2], 10)];
}
function BU(t) {
  var e = t.match(/(.*)\[(.*?)\]$/);
  return e ? (e[2] === "" ? "dynamic" : parseInt(e[2], 10)) : null;
}
function $l(t) {
  var e = typeof t;
  if (e === "string")
    return Tu.isHexString(t) ? new Jl(Tu.stripHexPrefix(t), 16) : new Jl(t, 10);
  if (e === "number") return new Jl(t);
  if (t.toArray) return t;
  throw new Error("Argument is not a number");
}
function Bs(t, e) {
  var r, n, i, a;
  if (t === "address") return Bs("uint160", $l(e));
  if (t === "bool") return Bs("uint8", e ? 1 : 0);
  if (t === "string") return Bs("bytes", new Buffer(e, "utf8"));
  if (w2e(t)) {
    if (typeof e.length > "u") throw new Error("Not an array?");
    if (((r = BU(t)), r !== "dynamic" && r !== 0 && e.length > r))
      throw new Error("Elements exceed array size: " + r);
    (i = []),
      (t = t.slice(0, t.lastIndexOf("["))),
      typeof e == "string" && (e = JSON.parse(e));
    for (a in e) i.push(Bs(t, e[a]));
    if (r === "dynamic") {
      var s = Bs("uint256", e.length);
      i.unshift(s);
    }
    return Buffer.concat(i);
  } else {
    if (t === "bytes")
      return (
        (e = new Buffer(e)),
        (i = Buffer.concat([Bs("uint256", e.length), e])),
        e.length % 32 !== 0 &&
          (i = Buffer.concat([i, Tu.zeros(32 - (e.length % 32))])),
        i
      );
    if (t.startsWith("bytes")) {
      if (((r = rf(t)), r < 1 || r > 32))
        throw new Error("Invalid bytes<N> width: " + r);
      return Tu.setLengthRight(e, 32);
    } else if (t.startsWith("uint")) {
      if (((r = rf(t)), r % 8 || r < 8 || r > 256))
        throw new Error("Invalid uint<N> width: " + r);
      if (((n = $l(e)), n.bitLength() > r))
        throw new Error(
          "Supplied uint exceeds width: " + r + " vs " + n.bitLength()
        );
      if (n < 0) throw new Error("Supplied uint is negative");
      return n.toArrayLike(Buffer, "be", 32);
    } else if (t.startsWith("int")) {
      if (((r = rf(t)), r % 8 || r < 8 || r > 256))
        throw new Error("Invalid int<N> width: " + r);
      if (((n = $l(e)), n.bitLength() > r))
        throw new Error(
          "Supplied int exceeds width: " + r + " vs " + n.bitLength()
        );
      return n.toTwos(256).toArrayLike(Buffer, "be", 32);
    } else if (t.startsWith("ufixed")) {
      if (((r = yM(t)), (n = $l(e)), n < 0))
        throw new Error("Supplied ufixed is negative");
      return Bs("uint256", n.mul(new Jl(2).pow(new Jl(r[1]))));
    } else if (t.startsWith("fixed"))
      return (r = yM(t)), Bs("int256", $l(e).mul(new Jl(2).pow(new Jl(r[1]))));
  }
  throw new Error("Unsupported or invalid type: " + t);
}
function x2e(t) {
  return t === "string" || t === "bytes" || BU(t) === "dynamic";
}
function w2e(t) {
  return t.lastIndexOf("]") === t.length - 1;
}
function _2e(t, e) {
  var r = [],
    n = [],
    i = 32 * t.length;
  for (var a in t) {
    var s = NU(t[a]),
      o = e[a],
      c = Bs(s, o);
    x2e(s) ? (r.push(Bs("uint256", i)), n.push(c), (i += c.length)) : r.push(c);
  }
  return Buffer.concat(r.concat(n));
}
function DU(t, e) {
  if (t.length !== e.length)
    throw new Error("Number of types are not matching the values");
  for (var r, n, i = [], a = 0; a < t.length; a++) {
    var s = NU(t[a]),
      o = e[a];
    if (s === "bytes") i.push(o);
    else if (s === "string") i.push(new Buffer(o, "utf8"));
    else if (s === "bool") i.push(new Buffer(o ? "01" : "00", "hex"));
    else if (s === "address") i.push(Tu.setLength(o, 20));
    else if (s.startsWith("bytes")) {
      if (((r = rf(s)), r < 1 || r > 32))
        throw new Error("Invalid bytes<N> width: " + r);
      i.push(Tu.setLengthRight(o, r));
    } else if (s.startsWith("uint")) {
      if (((r = rf(s)), r % 8 || r < 8 || r > 256))
        throw new Error("Invalid uint<N> width: " + r);
      if (((n = $l(o)), n.bitLength() > r))
        throw new Error(
          "Supplied uint exceeds width: " + r + " vs " + n.bitLength()
        );
      i.push(n.toArrayLike(Buffer, "be", r / 8));
    } else if (s.startsWith("int")) {
      if (((r = rf(s)), r % 8 || r < 8 || r > 256))
        throw new Error("Invalid int<N> width: " + r);
      if (((n = $l(o)), n.bitLength() > r))
        throw new Error(
          "Supplied int exceeds width: " + r + " vs " + n.bitLength()
        );
      i.push(n.toTwos(r).toArrayLike(Buffer, "be", r / 8));
    } else throw new Error("Unsupported or invalid type: " + s);
  }
  return Buffer.concat(i);
}
function E2e(t, e) {
  return Tu.keccak(DU(t, e));
}
var T2e = {
  rawEncode: _2e,
  solidityPack: DU,
  soliditySHA3: E2e,
};
const ns = PU,
  Zh = T2e,
  OU = {
    type: "object",
    properties: {
      types: {
        type: "object",
        additionalProperties: {
          type: "array",
          items: {
            type: "object",
            properties: {
              name: {
                type: "string",
              },
              type: {
                type: "string",
              },
            },
            required: ["name", "type"],
          },
        },
      },
      primaryType: {
        type: "string",
      },
      domain: {
        type: "object",
      },
      message: {
        type: "object",
      },
    },
    required: ["types", "primaryType", "domain", "message"],
  },
  g5 = {
    encodeData(t, e, r, n = !0) {
      const i = ["bytes32"],
        a = [this.hashType(t, r)];
      if (n) {
        const s = (o, c, u) => {
          if (r[c] !== void 0)
            return [
              "bytes32",
              u == null
                ? "0x0000000000000000000000000000000000000000000000000000000000000000"
                : ns.keccak(this.encodeData(c, u, r, n)),
            ];
          if (u === void 0)
            throw new Error(`missing value for field ${o} of type ${c}`);
          if (c === "bytes") return ["bytes32", ns.keccak(u)];
          if (c === "string")
            return (
              typeof u == "string" && (u = Buffer.from(u, "utf8")),
              ["bytes32", ns.keccak(u)]
            );
          if (c.lastIndexOf("]") === c.length - 1) {
            const d = c.slice(0, c.lastIndexOf("[")),
              m = u.map((v) => s(o, d, v));
            return [
              "bytes32",
              ns.keccak(
                Zh.rawEncode(
                  m.map(([v]) => v),
                  m.map(([, v]) => v)
                )
              ),
            ];
          }
          return [c, u];
        };
        for (const o of r[t]) {
          const [c, u] = s(o.name, o.type, e[o.name]);
          i.push(c), a.push(u);
        }
      } else
        for (const s of r[t]) {
          let o = e[s.name];
          if (o !== void 0)
            if (s.type === "bytes")
              i.push("bytes32"), (o = ns.keccak(o)), a.push(o);
            else if (s.type === "string")
              i.push("bytes32"),
                typeof o == "string" && (o = Buffer.from(o, "utf8")),
                (o = ns.keccak(o)),
                a.push(o);
            else if (r[s.type] !== void 0)
              i.push("bytes32"),
                (o = ns.keccak(this.encodeData(s.type, o, r, n))),
                a.push(o);
            else {
              if (s.type.lastIndexOf("]") === s.type.length - 1)
                throw new Error("Arrays currently unimplemented in encodeData");
              i.push(s.type), a.push(o);
            }
        }
      return Zh.rawEncode(i, a);
    },
    encodeType(t, e) {
      let r = "",
        n = this.findTypeDependencies(t, e).filter((i) => i !== t);
      n = [t].concat(n.sort());
      for (const i of n) {
        if (!e[i]) throw new Error("No type definition specified: " + i);
        r +=
          i +
          "(" +
          e[i].map(({ name: s, type: o }) => o + " " + s).join(",") +
          ")";
      }
      return r;
    },
    findTypeDependencies(t, e, r = []) {
      if (((t = t.match(/^\w*/)[0]), r.includes(t) || e[t] === void 0))
        return r;
      r.push(t);
      for (const n of e[t])
        for (const i of this.findTypeDependencies(n.type, e, r))
          !r.includes(i) && r.push(i);
      return r;
    },
    hashStruct(t, e, r, n = !0) {
      return ns.keccak(this.encodeData(t, e, r, n));
    },
    hashType(t, e) {
      return ns.keccak(this.encodeType(t, e));
    },
    sanitizeData(t) {
      const e = {};
      for (const r in OU.properties) t[r] && (e[r] = t[r]);
      return (
        e.types &&
          (e.types = Object.assign(
            {
              EIP712Domain: [],
            },
            e.types
          )),
        e
      );
    },
    hash(t, e = !0) {
      const r = this.sanitizeData(t),
        n = [Buffer.from("1901", "hex")];
      return (
        n.push(this.hashStruct("EIP712Domain", r.domain, r.types, e)),
        r.primaryType !== "EIP712Domain" &&
          n.push(this.hashStruct(r.primaryType, r.message, r.types, e)),
        ns.keccak(Buffer.concat(n))
      );
    },
  };
var C2e = {
  TYPED_MESSAGE_SCHEMA: OU,
  TypedDataUtils: g5,
  hashForSignTypedDataLegacy: function (t) {
    return A2e(t.data);
  },
  hashForSignTypedData_v3: function (t) {
    return g5.hash(t.data, !1);
  },
  hashForSignTypedData_v4: function (t) {
    return g5.hash(t.data);
  },
};
function A2e(t) {
  const e = new Error("Expect argument to be non-empty array");
  if (typeof t != "object" || !t.length) throw e;
  const r = t.map(function (a) {
      return a.type === "bytes" ? ns.toBuffer(a.value) : a.value;
    }),
    n = t.map(function (a) {
      return a.type;
    }),
    i = t.map(function (a) {
      if (!a.name) throw e;
      return a.type + " " + a.name;
    });
  return Zh.soliditySHA3(
    ["bytes32", "bytes32"],
    [
      Zh.soliditySHA3(new Array(t.length).fill("string"), i),
      Zh.soliditySHA3(n, r),
    ]
  );
}
var Kf = {};
Object.defineProperty(Kf, "__esModule", {
  value: !0,
});
Kf.filterFromParam = Kf.FilterPolyfill = void 0;
const m0 = En,
  vi = ot,
  k2e = 5 * 60 * 1e3,
  Ul = {
    jsonrpc: "2.0",
    id: 0,
  };
class S2e {
  constructor(e) {
    (this.logFilters = new Map()),
      (this.blockFilters = new Set()),
      (this.pendingTransactionFilters = new Set()),
      (this.cursors = new Map()),
      (this.timeouts = new Map()),
      (this.nextFilterId = (0, m0.IntNumber)(1)),
      (this.REQUEST_THROTTLE_INTERVAL = 1e3),
      (this.lastFetchTimestamp = new Date(0)),
      (this.resolvers = []),
      (this.provider = e);
  }
  async newFilter(e) {
    const r = FU(e),
      n = this.makeFilterId(),
      i = await this.setInitialCursorPosition(n, r.fromBlock);
    return (
      console.info(
        `Installing new log filter(${n}):`,
        r,
        "initial cursor position:",
        i
      ),
      this.logFilters.set(n, r),
      this.setFilterTimeout(n),
      (0, vi.hexStringFromIntNumber)(n)
    );
  }
  async newBlockFilter() {
    const e = this.makeFilterId(),
      r = await this.setInitialCursorPosition(e, "latest");
    return (
      console.info(
        `Installing new block filter (${e}) with initial cursor position:`,
        r
      ),
      this.blockFilters.add(e),
      this.setFilterTimeout(e),
      (0, vi.hexStringFromIntNumber)(e)
    );
  }
  async newPendingTransactionFilter() {
    const e = this.makeFilterId(),
      r = await this.setInitialCursorPosition(e, "latest");
    return (
      console.info(
        `Installing new block filter (${e}) with initial cursor position:`,
        r
      ),
      this.pendingTransactionFilters.add(e),
      this.setFilterTimeout(e),
      (0, vi.hexStringFromIntNumber)(e)
    );
  }
  uninstallFilter(e) {
    const r = (0, vi.intNumberFromHexString)(e);
    return console.info(`Uninstalling filter (${r})`), this.deleteFilter(r), !0;
  }
  getFilterChanges(e) {
    const r = (0, vi.intNumberFromHexString)(e);
    return (
      this.timeouts.has(r) && this.setFilterTimeout(r),
      this.logFilters.has(r)
        ? this.getLogFilterChanges(r)
        : this.blockFilters.has(r)
        ? this.getBlockFilterChanges(r)
        : this.pendingTransactionFilters.has(r)
        ? this.getPendingTransactionFilterChanges(r)
        : Promise.resolve(yy())
    );
  }
  async getFilterLogs(e) {
    const r = (0, vi.intNumberFromHexString)(e),
      n = this.logFilters.get(r);
    return n
      ? this.sendAsyncPromise(
          Object.assign(Object.assign({}, Ul), {
            method: "eth_getLogs",
            params: [gM(n)],
          })
        )
      : yy();
  }
  makeFilterId() {
    return (0, m0.IntNumber)(++this.nextFilterId);
  }
  sendAsyncPromise(e) {
    return new Promise((r, n) => {
      this.provider.sendAsync(e, (i, a) => {
        if (i) return n(i);
        if (Array.isArray(a) || a == null)
          return n(
            new Error(`unexpected response received: ${JSON.stringify(a)}`)
          );
        r(a);
      });
    });
  }
  deleteFilter(e) {
    console.info(`Deleting filter (${e})`),
      this.logFilters.delete(e),
      this.blockFilters.delete(e),
      this.pendingTransactionFilters.delete(e),
      this.cursors.delete(e),
      this.timeouts.delete(e);
  }
  async getLogFilterChanges(e) {
    const r = this.logFilters.get(e),
      n = this.cursors.get(e);
    if (!n || !r) return yy();
    const i = await this.getCurrentBlockHeight(),
      a = r.toBlock === "latest" ? i : r.toBlock;
    if (n > i || n > Number(r.toBlock)) return gy();
    console.info(`Fetching logs from ${n} to ${a} for filter ${e}`);
    const s = await this.sendAsyncPromise(
      Object.assign(Object.assign({}, Ul), {
        method: "eth_getLogs",
        params: [
          gM(
            Object.assign(Object.assign({}, r), {
              fromBlock: n,
              toBlock: a,
            })
          ),
        ],
      })
    );
    if (Array.isArray(s.result)) {
      const o = s.result.map((u) =>
          (0, vi.intNumberFromHexString)(u.blockNumber || "0x0")
        ),
        c = Math.max(...o);
      if (c && c > n) {
        const u = (0, m0.IntNumber)(c + 1);
        console.info(
          `Moving cursor position for filter (${e}) from ${n} to ${u}`
        ),
          this.cursors.set(e, u);
      }
    }
    return s;
  }
  async getBlockFilterChanges(e) {
    const r = this.cursors.get(e);
    if (!r) return yy();
    const n = await this.getCurrentBlockHeight();
    if (r > n) return gy();
    console.info(`Fetching blocks from ${r} to ${n} for filter (${e})`);
    const i = (
        await Promise.all(
          (0, vi.range)(r, n + 1).map((s) =>
            this.getBlockHashByNumber((0, m0.IntNumber)(s))
          )
        )
      ).filter((s) => !!s),
      a = (0, m0.IntNumber)(r + i.length);
    return (
      console.info(
        `Moving cursor position for filter (${e}) from ${r} to ${a}`
      ),
      this.cursors.set(e, a),
      Object.assign(Object.assign({}, Ul), {
        result: i,
      })
    );
  }
  async getPendingTransactionFilterChanges(e) {
    return Promise.resolve(gy());
  }
  async setInitialCursorPosition(e, r) {
    const n = await this.getCurrentBlockHeight(),
      i = typeof r == "number" && r > n ? r : n;
    return this.cursors.set(e, i), i;
  }
  setFilterTimeout(e) {
    const r = this.timeouts.get(e);
    r && window.clearTimeout(r);
    const n = window.setTimeout(() => {
      console.info(`Filter (${e}) timed out`), this.deleteFilter(e);
    }, k2e);
    this.timeouts.set(e, n);
  }
  async getCurrentBlockHeight() {
    const e = new Date();
    if (
      e.getTime() - this.lastFetchTimestamp.getTime() >
      this.REQUEST_THROTTLE_INTERVAL
    ) {
      this.lastFetchTimestamp = e;
      const r = await this._getCurrentBlockHeight();
      (this.currentBlockHeight = r),
        this.resolvers.forEach((n) => n(r)),
        (this.resolvers = []);
    }
    return this.currentBlockHeight
      ? this.currentBlockHeight
      : new Promise((r) => this.resolvers.push(r));
  }
  async _getCurrentBlockHeight() {
    const { result: e } = await this.sendAsyncPromise(
      Object.assign(Object.assign({}, Ul), {
        method: "eth_blockNumber",
        params: [],
      })
    );
    return (0, vi.intNumberFromHexString)((0, vi.ensureHexString)(e));
  }
  async getBlockHashByNumber(e) {
    const r = await this.sendAsyncPromise(
      Object.assign(Object.assign({}, Ul), {
        method: "eth_getBlockByNumber",
        params: [(0, vi.hexStringFromIntNumber)(e), !1],
      })
    );
    return r.result && typeof r.result.hash == "string"
      ? (0, vi.ensureHexString)(r.result.hash)
      : null;
  }
}
Kf.FilterPolyfill = S2e;
function FU(t) {
  return {
    fromBlock: bM(t.fromBlock),
    toBlock: bM(t.toBlock),
    addresses:
      t.address === void 0
        ? null
        : Array.isArray(t.address)
        ? t.address
        : [t.address],
    topics: t.topics || [],
  };
}
Kf.filterFromParam = FU;
function gM(t) {
  const e = {
    fromBlock: vM(t.fromBlock),
    toBlock: vM(t.toBlock),
    topics: t.topics,
  };
  return t.addresses !== null && (e.address = t.addresses), e;
}
function bM(t) {
  if (t === void 0 || t === "latest" || t === "pending") return "latest";
  if (t === "earliest") return (0, m0.IntNumber)(0);
  if ((0, vi.isHexString)(t)) return (0, vi.intNumberFromHexString)(t);
  throw new Error(`Invalid block option: ${String(t)}`);
}
function vM(t) {
  return t === "latest" ? t : (0, vi.hexStringFromIntNumber)(t);
}
function yy() {
  return Object.assign(Object.assign({}, Ul), {
    error: {
      code: -32e3,
      message: "filter not found",
    },
  });
}
function gy() {
  return Object.assign(Object.assign({}, Ul), {
    result: [],
  });
}
var yx = {},
  LU = {},
  gx = {},
  yT = M2e;
function M2e(t) {
  t = t || {};
  var e = t.max || Number.MAX_SAFE_INTEGER,
    r = typeof t.start < "u" ? t.start : Math.floor(Math.random() * e);
  return function () {
    return (r = r % e), r++;
  };
}
const xM = (t, e) =>
  function () {
    const r = e.promiseModule,
      n = new Array(arguments.length);
    for (let i = 0; i < arguments.length; i++) n[i] = arguments[i];
    return new r((i, a) => {
      e.errorFirst
        ? n.push(function (s, o) {
            if (e.multiArgs) {
              const c = new Array(arguments.length - 1);
              for (let u = 1; u < arguments.length; u++)
                c[u - 1] = arguments[u];
              s ? (c.unshift(s), a(c)) : i(c);
            } else s ? a(s) : i(o);
          })
        : n.push(function (s) {
            if (e.multiArgs) {
              const o = new Array(arguments.length - 1);
              for (let c = 0; c < arguments.length; c++) o[c] = arguments[c];
              i(o);
            } else i(s);
          }),
        t.apply(this, n);
    });
  };
var I2e = (t, e) => {
    e = Object.assign(
      {
        exclude: [/.+(Sync|Stream)$/],
        errorFirst: !0,
        promiseModule: Promise,
      },
      e
    );
    const r = (i) => {
      const a = (s) => (typeof s == "string" ? i === s : s.test(i));
      return e.include ? e.include.some(a) : !e.exclude.some(a);
    };
    let n;
    typeof t == "function"
      ? (n = function () {
          return e.excludeMain
            ? t.apply(this, arguments)
            : xM(t, e).apply(this, arguments);
        })
      : (n = Object.create(Object.getPrototypeOf(t)));
    for (const i in t) {
      const a = t[i];
      n[i] = typeof a == "function" && r(i) ? xM(a, e) : a;
    }
    return n;
  },
  l1 = {},
  u1 = {};
Object.defineProperty(u1, "__esModule", {
  value: !0,
});
const R2e = Cd;
function wM(t, e, r) {
  try {
    Reflect.apply(t, e, r);
  } catch (n) {
    setTimeout(() => {
      throw n;
    });
  }
}
function P2e(t) {
  const e = t.length,
    r = new Array(e);
  for (let n = 0; n < e; n += 1) r[n] = t[n];
  return r;
}
let N2e = class extends R2e.EventEmitter {
  emit(e, ...r) {
    let n = e === "error";
    const i = this._events;
    if (i !== void 0) n = n && i.error === void 0;
    else if (!n) return !1;
    if (n) {
      let s;
      if ((r.length > 0 && ([s] = r), s instanceof Error)) throw s;
      const o = new Error(`Unhandled error.${s ? ` (${s.message})` : ""}`);
      throw ((o.context = s), o);
    }
    const a = i[e];
    if (a === void 0) return !1;
    if (typeof a == "function") wM(a, this, r);
    else {
      const s = a.length,
        o = P2e(a);
      for (let c = 0; c < s; c += 1) wM(o[c], this, r);
    }
    return !0;
  }
};
u1.default = N2e;
var B2e =
  (ke && ke.__importDefault) ||
  function (t) {
    return t && t.__esModule
      ? t
      : {
          default: t,
        };
  };
Object.defineProperty(l1, "__esModule", {
  value: !0,
});
l1.BaseBlockTracker = void 0;
const D2e = B2e(u1),
  O2e = 1e3,
  F2e = (t, e) => t + e,
  _M = ["sync", "latest"];
class L2e extends D2e.default {
  constructor(e) {
    super(),
      (this._blockResetDuration = e.blockResetDuration || 20 * O2e),
      (this._usePastBlocks = e.usePastBlocks || !1),
      (this._currentBlock = null),
      (this._isRunning = !1),
      (this._onNewListener = this._onNewListener.bind(this)),
      (this._onRemoveListener = this._onRemoveListener.bind(this)),
      (this._resetCurrentBlock = this._resetCurrentBlock.bind(this)),
      this._setupInternalEvents();
  }
  async destroy() {
    this._cancelBlockResetTimeout(),
      await this._maybeEnd(),
      super.removeAllListeners();
  }
  isRunning() {
    return this._isRunning;
  }
  getCurrentBlock() {
    return this._currentBlock;
  }
  async getLatestBlock() {
    return this._currentBlock
      ? this._currentBlock
      : await new Promise((r) => this.once("latest", r));
  }
  removeAllListeners(e) {
    return (
      e ? super.removeAllListeners(e) : super.removeAllListeners(),
      this._setupInternalEvents(),
      this._onRemoveListener(),
      this
    );
  }
  _setupInternalEvents() {
    this.removeListener("newListener", this._onNewListener),
      this.removeListener("removeListener", this._onRemoveListener),
      this.on("newListener", this._onNewListener),
      this.on("removeListener", this._onRemoveListener);
  }
  _onNewListener(e) {
    _M.includes(e) && this._maybeStart();
  }
  _onRemoveListener() {
    this._getBlockTrackerEventCount() > 0 || this._maybeEnd();
  }
  async _maybeStart() {
    this._isRunning ||
      ((this._isRunning = !0),
      this._cancelBlockResetTimeout(),
      await this._start(),
      this.emit("_started"));
  }
  async _maybeEnd() {
    this._isRunning &&
      ((this._isRunning = !1),
      this._setupBlockResetTimeout(),
      await this._end(),
      this.emit("_ended"));
  }
  _getBlockTrackerEventCount() {
    return _M.map((e) => this.listenerCount(e)).reduce(F2e);
  }
  _shouldUseNewBlock(e) {
    const r = this._currentBlock;
    if (!r) return !0;
    const n = EM(e),
      i = EM(r);
    return (this._usePastBlocks && n < i) || n > i;
  }
  _newPotentialLatest(e) {
    this._shouldUseNewBlock(e) && this._setCurrentBlock(e);
  }
  _setCurrentBlock(e) {
    const r = this._currentBlock;
    (this._currentBlock = e),
      this.emit("latest", e),
      this.emit("sync", {
        oldBlock: r,
        newBlock: e,
      });
  }
  _setupBlockResetTimeout() {
    this._cancelBlockResetTimeout(),
      (this._blockResetTimeout = setTimeout(
        this._resetCurrentBlock,
        this._blockResetDuration
      )),
      this._blockResetTimeout.unref && this._blockResetTimeout.unref();
  }
  _cancelBlockResetTimeout() {
    this._blockResetTimeout && clearTimeout(this._blockResetTimeout);
  }
  _resetCurrentBlock() {
    this._currentBlock = null;
  }
}
l1.BaseBlockTracker = L2e;
function EM(t) {
  return Number.parseInt(t, 16);
}
var $U = {},
  UU = {},
  Vn = {};
class WU extends TypeError {
  constructor(e, r) {
    let n;
    const { message: i, explanation: a, ...s } = e,
      { path: o } = e,
      c = o.length === 0 ? i : `At path: ${o.join(".")} -- ${i}`;
    super(a ?? c),
      a != null && (this.cause = c),
      Object.assign(this, s),
      (this.name = this.constructor.name),
      (this.failures = () => n ?? (n = [e, ...r()]));
  }
}
function $2e(t) {
  return Wa(t) && typeof t[Symbol.iterator] == "function";
}
function Wa(t) {
  return typeof t == "object" && t != null;
}
function TM(t) {
  if (Object.prototype.toString.call(t) !== "[object Object]") return !1;
  const e = Object.getPrototypeOf(t);
  return e === null || e === Object.prototype;
}
function kn(t) {
  return typeof t == "symbol"
    ? t.toString()
    : typeof t == "string"
    ? JSON.stringify(t)
    : `${t}`;
}
function U2e(t) {
  const { done: e, value: r } = t.next();
  return e ? void 0 : r;
}
function W2e(t, e, r, n) {
  if (t === !0) return;
  t === !1
    ? (t = {})
    : typeof t == "string" &&
      (t = {
        message: t,
      });
  const { path: i, branch: a } = e,
    { type: s } = r,
    {
      refinement: o,
      message: c = `Expected a value of type \`${s}\`${
        o ? ` with refinement \`${o}\`` : ""
      }, but received: \`${kn(n)}\``,
    } = t;
  return {
    value: n,
    type: s,
    refinement: o,
    key: i[i.length - 1],
    path: i,
    branch: a,
    ...t,
    message: c,
  };
}
function* p4(t, e, r, n) {
  $2e(t) || (t = [t]);
  for (const i of t) {
    const a = W2e(i, e, r, n);
    a && (yield a);
  }
}
function* gT(t, e, r = {}) {
  const { path: n = [], branch: i = [t], coerce: a = !1, mask: s = !1 } = r,
    o = {
      path: n,
      branch: i,
    };
  if (
    a &&
    ((t = e.coercer(t, o)),
    s && e.type !== "type" && Wa(e.schema) && Wa(t) && !Array.isArray(t))
  )
    for (const u in t) e.schema[u] === void 0 && delete t[u];
  let c = "valid";
  for (const u of e.validator(t, o))
    (u.explanation = r.message), (c = "not_valid"), yield [u, void 0];
  for (let [u, d, m] of e.entries(t, o)) {
    const v = gT(d, m, {
      path: u === void 0 ? n : [...n, u],
      branch: u === void 0 ? i : [...i, d],
      coerce: a,
      mask: s,
      message: r.message,
    });
    for (const E of v)
      E[0]
        ? ((c = E[0].refinement != null ? "not_refined" : "not_valid"),
          yield [E[0], void 0])
        : a &&
          ((d = E[1]),
          u === void 0
            ? (t = d)
            : t instanceof Map
            ? t.set(u, d)
            : t instanceof Set
            ? t.add(d)
            : Wa(t) && (d !== void 0 || u in t) && (t[u] = d));
  }
  if (c !== "not_valid")
    for (const u of e.refiner(t, o))
      (u.explanation = r.message), (c = "not_refined"), yield [u, void 0];
  c === "valid" && (yield [void 0, t]);
}
class cn {
  constructor(e) {
    const {
      type: r,
      schema: n,
      validator: i,
      refiner: a,
      coercer: s = (c) => c,
      entries: o = function* () {},
    } = e;
    (this.type = r),
      (this.schema = n),
      (this.entries = o),
      (this.coercer = s),
      i
        ? (this.validator = (c, u) => {
            const d = i(c, u);
            return p4(d, u, this, c);
          })
        : (this.validator = () => []),
      a
        ? (this.refiner = (c, u) => {
            const d = a(c, u);
            return p4(d, u, this, c);
          })
        : (this.refiner = () => []);
  }
  assert(e, r) {
    return jU(e, this, r);
  }
  create(e, r) {
    return HU(e, this, r);
  }
  is(e) {
    return bT(e, this);
  }
  mask(e, r) {
    return zU(e, this, r);
  }
  validate(e, r = {}) {
    return Nd(e, this, r);
  }
}
function jU(t, e, r) {
  const n = Nd(t, e, {
    message: r,
  });
  if (n[0]) throw n[0];
}
function HU(t, e, r) {
  const n = Nd(t, e, {
    coerce: !0,
    message: r,
  });
  if (n[0]) throw n[0];
  return n[1];
}
function zU(t, e, r) {
  const n = Nd(t, e, {
    coerce: !0,
    mask: !0,
    message: r,
  });
  if (n[0]) throw n[0];
  return n[1];
}
function bT(t, e) {
  return !Nd(t, e)[0];
}
function Nd(t, e, r = {}) {
  const n = gT(t, e, r),
    i = U2e(n);
  return i[0]
    ? [
        new WU(i[0], function* () {
          for (const s of n) s[0] && (yield s[0]);
        }),
        void 0,
      ]
    : [void 0, i[1]];
}
function j2e(...t) {
  const e = t[0].type === "type",
    r = t.map((i) => i.schema),
    n = Object.assign({}, ...r);
  return e ? d1(n) : f1(n);
}
function Yi(t, e) {
  return new cn({
    type: t,
    schema: null,
    validator: e,
  });
}
function H2e(t, e) {
  return new cn({
    ...t,
    refiner: (r, n) => r === void 0 || t.refiner(r, n),
    validator(r, n) {
      return r === void 0 ? !0 : (e(r, n), t.validator(r, n));
    },
  });
}
function z2e(t) {
  return new cn({
    type: "dynamic",
    schema: null,
    *entries(e, r) {
      yield* t(e, r).entries(e, r);
    },
    validator(e, r) {
      return t(e, r).validator(e, r);
    },
    coercer(e, r) {
      return t(e, r).coercer(e, r);
    },
    refiner(e, r) {
      return t(e, r).refiner(e, r);
    },
  });
}
function q2e(t) {
  let e;
  return new cn({
    type: "lazy",
    schema: null,
    *entries(r, n) {
      e ?? (e = t()), yield* e.entries(r, n);
    },
    validator(r, n) {
      return e ?? (e = t()), e.validator(r, n);
    },
    coercer(r, n) {
      return e ?? (e = t()), e.coercer(r, n);
    },
    refiner(r, n) {
      return e ?? (e = t()), e.refiner(r, n);
    },
  });
}
function V2e(t, e) {
  const { schema: r } = t,
    n = {
      ...r,
    };
  for (const i of e) delete n[i];
  switch (t.type) {
    case "type":
      return d1(n);
    default:
      return f1(n);
  }
}
function K2e(t) {
  const e = t instanceof cn,
    r = e
      ? {
          ...t.schema,
        }
      : {
          ...t,
        };
  for (const n in r) r[n] = qU(r[n]);
  return e && t.type === "type" ? d1(r) : f1(r);
}
function G2e(t, e) {
  const { schema: r } = t,
    n = {};
  for (const i of e) n[i] = r[i];
  switch (t.type) {
    case "type":
      return d1(n);
    default:
      return f1(n);
  }
}
function Z2e(t, e) {
  return (
    console.warn(
      "superstruct@0.11 - The `struct` helper has been renamed to `define`."
    ),
    Yi(t, e)
  );
}
function J2e() {
  return Yi("any", () => !0);
}
function Q2e(t) {
  return new cn({
    type: "array",
    schema: t,
    *entries(e) {
      if (t && Array.isArray(e))
        for (const [r, n] of e.entries()) yield [r, n, t];
    },
    coercer(e) {
      return Array.isArray(e) ? e.slice() : e;
    },
    validator(e) {
      return (
        Array.isArray(e) || `Expected an array value, but received: ${kn(e)}`
      );
    },
  });
}
function Y2e() {
  return Yi("bigint", (t) => typeof t == "bigint");
}
function X2e() {
  return Yi("boolean", (t) => typeof t == "boolean");
}
function ebe() {
  return Yi(
    "date",
    (t) =>
      (t instanceof Date && !isNaN(t.getTime())) ||
      `Expected a valid \`Date\` object, but received: ${kn(t)}`
  );
}
function tbe(t) {
  const e = {},
    r = t.map((n) => kn(n)).join();
  for (const n of t) e[n] = n;
  return new cn({
    type: "enums",
    schema: e,
    validator(n) {
      return (
        t.includes(n) || `Expected one of \`${r}\`, but received: ${kn(n)}`
      );
    },
  });
}
function rbe() {
  return Yi(
    "func",
    (t) =>
      typeof t == "function" || `Expected a function, but received: ${kn(t)}`
  );
}
function nbe(t) {
  return Yi(
    "instance",
    (e) =>
      e instanceof t ||
      `Expected a \`${t.name}\` instance, but received: ${kn(e)}`
  );
}
function ibe() {
  return Yi(
    "integer",
    (t) =>
      (typeof t == "number" && !isNaN(t) && Number.isInteger(t)) ||
      `Expected an integer, but received: ${kn(t)}`
  );
}
function abe(t) {
  return new cn({
    type: "intersection",
    schema: null,
    *entries(e, r) {
      for (const n of t) yield* n.entries(e, r);
    },
    *validator(e, r) {
      for (const n of t) yield* n.validator(e, r);
    },
    *refiner(e, r) {
      for (const n of t) yield* n.refiner(e, r);
    },
  });
}
function sbe(t) {
  const e = kn(t),
    r = typeof t;
  return new cn({
    type: "literal",
    schema: r === "string" || r === "number" || r === "boolean" ? t : null,
    validator(n) {
      return n === t || `Expected the literal \`${e}\`, but received: ${kn(n)}`;
    },
  });
}
function obe(t, e) {
  return new cn({
    type: "map",
    schema: null,
    *entries(r) {
      if (t && e && r instanceof Map)
        for (const [n, i] of r.entries()) yield [n, n, t], yield [n, i, e];
    },
    coercer(r) {
      return r instanceof Map ? new Map(r) : r;
    },
    validator(r) {
      return (
        r instanceof Map || `Expected a \`Map\` object, but received: ${kn(r)}`
      );
    },
  });
}
function vT() {
  return Yi("never", () => !1);
}
function cbe(t) {
  return new cn({
    ...t,
    validator: (e, r) => e === null || t.validator(e, r),
    refiner: (e, r) => e === null || t.refiner(e, r),
  });
}
function lbe() {
  return Yi(
    "number",
    (t) =>
      (typeof t == "number" && !isNaN(t)) ||
      `Expected a number, but received: ${kn(t)}`
  );
}
function f1(t) {
  const e = t ? Object.keys(t) : [],
    r = vT();
  return new cn({
    type: "object",
    schema: t || null,
    *entries(n) {
      if (t && Wa(n)) {
        const i = new Set(Object.keys(n));
        for (const a of e) i.delete(a), yield [a, n[a], t[a]];
        for (const a of i) yield [a, n[a], r];
      }
    },
    validator(n) {
      return Wa(n) || `Expected an object, but received: ${kn(n)}`;
    },
    coercer(n) {
      return Wa(n)
        ? {
            ...n,
          }
        : n;
    },
  });
}
function qU(t) {
  return new cn({
    ...t,
    validator: (e, r) => e === void 0 || t.validator(e, r),
    refiner: (e, r) => e === void 0 || t.refiner(e, r),
  });
}
function ube(t, e) {
  return new cn({
    type: "record",
    schema: null,
    *entries(r) {
      if (Wa(r))
        for (const n in r) {
          const i = r[n];
          yield [n, n, t], yield [n, i, e];
        }
    },
    validator(r) {
      return Wa(r) || `Expected an object, but received: ${kn(r)}`;
    },
  });
}
function fbe() {
  return Yi("regexp", (t) => t instanceof RegExp);
}
function dbe(t) {
  return new cn({
    type: "set",
    schema: null,
    *entries(e) {
      if (t && e instanceof Set) for (const r of e) yield [r, r, t];
    },
    coercer(e) {
      return e instanceof Set ? new Set(e) : e;
    },
    validator(e) {
      return (
        e instanceof Set || `Expected a \`Set\` object, but received: ${kn(e)}`
      );
    },
  });
}
function VU() {
  return Yi(
    "string",
    (t) => typeof t == "string" || `Expected a string, but received: ${kn(t)}`
  );
}
function hbe(t) {
  const e = vT();
  return new cn({
    type: "tuple",
    schema: null,
    *entries(r) {
      if (Array.isArray(r)) {
        const n = Math.max(t.length, r.length);
        for (let i = 0; i < n; i++) yield [i, r[i], t[i] || e];
      }
    },
    validator(r) {
      return Array.isArray(r) || `Expected an array, but received: ${kn(r)}`;
    },
  });
}
function d1(t) {
  const e = Object.keys(t);
  return new cn({
    type: "type",
    schema: t,
    *entries(r) {
      if (Wa(r)) for (const n of e) yield [n, r[n], t[n]];
    },
    validator(r) {
      return Wa(r) || `Expected an object, but received: ${kn(r)}`;
    },
    coercer(r) {
      return Wa(r)
        ? {
            ...r,
          }
        : r;
    },
  });
}
function pbe(t) {
  const e = t.map((r) => r.type).join(" | ");
  return new cn({
    type: "union",
    schema: null,
    coercer(r) {
      for (const n of t) {
        const [i, a] = n.validate(r, {
          coerce: !0,
        });
        if (!i) return a;
      }
      return r;
    },
    validator(r, n) {
      const i = [];
      for (const a of t) {
        const [...s] = gT(r, a, n),
          [o] = s;
        if (o[0]) for (const [c] of s) c && i.push(c);
        else return [];
      }
      return [
        `Expected the value to satisfy a union of \`${e}\`, but received: ${kn(
          r
        )}`,
        ...i,
      ];
    },
  });
}
function KU() {
  return Yi("unknown", () => !0);
}
function xT(t, e, r) {
  return new cn({
    ...t,
    coercer: (n, i) => (bT(n, e) ? t.coercer(r(n, i), i) : t.coercer(n, i)),
  });
}
function mbe(t, e, r = {}) {
  return xT(t, KU(), (n) => {
    const i = typeof e == "function" ? e() : e;
    if (n === void 0) return i;
    if (!r.strict && TM(n) && TM(i)) {
      const a = {
        ...n,
      };
      let s = !1;
      for (const o in i) a[o] === void 0 && ((a[o] = i[o]), (s = !0));
      if (s) return a;
    }
    return n;
  });
}
function ybe(t) {
  return xT(t, VU(), (e) => e.trim());
}
function gbe(t) {
  return zu(t, "empty", (e) => {
    const r = GU(e);
    return (
      r === 0 ||
      `Expected an empty ${t.type} but received one with a size of \`${r}\``
    );
  });
}
function GU(t) {
  return t instanceof Map || t instanceof Set ? t.size : t.length;
}
function bbe(t, e, r = {}) {
  const { exclusive: n } = r;
  return zu(t, "max", (i) =>
    n
      ? i < e
      : i <= e ||
        `Expected a ${t.type} less than ${
          n ? "" : "or equal to "
        }${e} but received \`${i}\``
  );
}
function vbe(t, e, r = {}) {
  const { exclusive: n } = r;
  return zu(t, "min", (i) =>
    n
      ? i > e
      : i >= e ||
        `Expected a ${t.type} greater than ${
          n ? "" : "or equal to "
        }${e} but received \`${i}\``
  );
}
function xbe(t) {
  return zu(
    t,
    "nonempty",
    (e) =>
      GU(e) > 0 || `Expected a nonempty ${t.type} but received an empty one`
  );
}
function wbe(t, e) {
  return zu(
    t,
    "pattern",
    (r) =>
      e.test(r) ||
      `Expected a ${t.type} matching \`/${e.source}/\` but received "${r}"`
  );
}
function _be(t, e, r = e) {
  const n = `Expected a ${t.type}`,
    i = e === r ? `of \`${e}\`` : `between \`${e}\` and \`${r}\``;
  return zu(t, "size", (a) => {
    if (typeof a == "number" || a instanceof Date)
      return (e <= a && a <= r) || `${n} ${i} but received \`${a}\``;
    if (a instanceof Map || a instanceof Set) {
      const { size: s } = a;
      return (
        (e <= s && s <= r) ||
        `${n} with a size ${i} but received one with a size of \`${s}\``
      );
    } else {
      const { length: s } = a;
      return (
        (e <= s && s <= r) ||
        `${n} with a length ${i} but received one with a length of \`${s}\``
      );
    }
  });
}
function zu(t, e, r) {
  return new cn({
    ...t,
    *refiner(n, i) {
      yield* t.refiner(n, i);
      const a = r(n, i),
        s = p4(a, i, t, n);
      for (const o of s)
        yield {
          ...o,
          refinement: e,
        };
    },
  });
}
const Ebe = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        Struct: cn,
        StructError: WU,
        any: J2e,
        array: Q2e,
        assert: jU,
        assign: j2e,
        bigint: Y2e,
        boolean: X2e,
        coerce: xT,
        create: HU,
        date: ebe,
        defaulted: mbe,
        define: Yi,
        deprecated: H2e,
        dynamic: z2e,
        empty: gbe,
        enums: tbe,
        func: rbe,
        instance: nbe,
        integer: ibe,
        intersection: abe,
        is: bT,
        lazy: q2e,
        literal: sbe,
        map: obe,
        mask: zU,
        max: bbe,
        min: vbe,
        never: vT,
        nonempty: xbe,
        nullable: cbe,
        number: lbe,
        object: f1,
        omit: V2e,
        optional: qU,
        partial: K2e,
        pattern: wbe,
        pick: G2e,
        record: ube,
        refine: zu,
        regexp: fbe,
        set: dbe,
        size: _be,
        string: VU,
        struct: Z2e,
        trimmed: ybe,
        tuple: hbe,
        type: d1,
        union: pbe,
        unknown: KU,
        validate: Nd,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  qu = Pt(Ebe);
Object.defineProperty(Vn, "__esModule", {
  value: !0,
});
Vn.assertExhaustive = Vn.assertStruct = Vn.assert = Vn.AssertionError = void 0;
const Tbe = qu;
function Cbe(t) {
  return typeof t == "object" && t !== null && "message" in t;
}
function Abe(t) {
  var e, r;
  return (
    typeof ((r =
      (e = t == null ? void 0 : t.prototype) === null || e === void 0
        ? void 0
        : e.constructor) === null || r === void 0
      ? void 0
      : r.name) == "string"
  );
}
function kbe(t) {
  const e = Cbe(t) ? t.message : String(t);
  return e.endsWith(".") ? e.slice(0, -1) : e;
}
function ZU(t, e) {
  return Abe(t)
    ? new t({
        message: e,
      })
    : t({
        message: e,
      });
}
class wT extends Error {
  constructor(e) {
    super(e.message), (this.code = "ERR_ASSERTION");
  }
}
Vn.AssertionError = wT;
function Sbe(t, e = "Assertion failed.", r = wT) {
  if (!t) throw e instanceof Error ? e : ZU(r, e);
}
Vn.assert = Sbe;
function Mbe(t, e, r = "Assertion failed", n = wT) {
  try {
    (0, Tbe.assert)(t, e);
  } catch (i) {
    throw ZU(n, `${r}: ${kbe(i)}.`);
  }
}
Vn.assertStruct = Mbe;
function Ibe(t) {
  throw new Error(
    "Invalid branch reached. Should be detected during compilation."
  );
}
Vn.assertExhaustive = Ibe;
var h1 = {};
Object.defineProperty(h1, "__esModule", {
  value: !0,
});
h1.base64 = void 0;
const Rbe = qu,
  Pbe = Vn,
  Nbe = (t, e = {}) => {
    var r, n;
    const i = (r = e.paddingRequired) !== null && r !== void 0 ? r : !1,
      a = (n = e.characterSet) !== null && n !== void 0 ? n : "base64";
    let s;
    a === "base64"
      ? (s = String.raw`[A-Za-z0-9+\/]`)
      : ((0, Pbe.assert)(a === "base64url"), (s = String.raw`[-_A-Za-z0-9]`));
    let o;
    return (
      i
        ? (o = new RegExp(`^(?:${s}{4})*(?:${s}{3}=|${s}{2}==)?$`, "u"))
        : (o = new RegExp(
            `^(?:${s}{4})*(?:${s}{2,3}|${s}{3}=|${s}{2}==)?$`,
            "u"
          )),
      (0, Rbe.pattern)(t, o)
    );
  };
h1.base64 = Nbe;
var Ht = {},
  p1 = {};
(function (t) {
  Object.defineProperty(t, "__esModule", {
    value: !0,
  }),
    (t.remove0x =
      t.add0x =
      t.assertIsStrictHexString =
      t.assertIsHexString =
      t.isStrictHexString =
      t.isHexString =
      t.StrictHexStruct =
      t.HexStruct =
        void 0);
  const e = qu,
    r = Vn;
  (t.HexStruct = (0, e.pattern)((0, e.string)(), /^(?:0x)?[0-9a-f]+$/iu)),
    (t.StrictHexStruct = (0, e.pattern)((0, e.string)(), /^0x[0-9a-f]+$/iu));
  function n(u) {
    return (0, e.is)(u, t.HexStruct);
  }
  t.isHexString = n;
  function i(u) {
    return (0, e.is)(u, t.StrictHexStruct);
  }
  t.isStrictHexString = i;
  function a(u) {
    (0, r.assert)(n(u), "Value must be a hexadecimal string.");
  }
  t.assertIsHexString = a;
  function s(u) {
    (0, r.assert)(
      i(u),
      'Value must be a hexadecimal string, starting with "0x".'
    );
  }
  t.assertIsStrictHexString = s;
  function o(u) {
    return u.startsWith("0x")
      ? u
      : u.startsWith("0X")
      ? `0x${u.substring(2)}`
      : `0x${u}`;
  }
  t.add0x = o;
  function c(u) {
    return u.startsWith("0x") || u.startsWith("0X") ? u.substring(2) : u;
  }
  t.remove0x = c;
})(p1);
Object.defineProperty(Ht, "__esModule", {
  value: !0,
});
Ht.createDataView =
  Ht.concatBytes =
  Ht.valueToBytes =
  Ht.stringToBytes =
  Ht.numberToBytes =
  Ht.signedBigIntToBytes =
  Ht.bigIntToBytes =
  Ht.hexToBytes =
  Ht.bytesToString =
  Ht.bytesToNumber =
  Ht.bytesToSignedBigInt =
  Ht.bytesToBigInt =
  Ht.bytesToHex =
  Ht.assertIsBytes =
  Ht.isBytes =
    void 0;
const ca = Vn,
  m4 = p1,
  CM = 48,
  AM = 58,
  kM = 87;
function Bbe() {
  const t = [];
  return () => {
    if (t.length === 0)
      for (let e = 0; e < 256; e++) t.push(e.toString(16).padStart(2, "0"));
    return t;
  };
}
const Dbe = Bbe();
function _T(t) {
  return t instanceof Uint8Array;
}
Ht.isBytes = _T;
function Bd(t) {
  (0, ca.assert)(_T(t), "Value must be a Uint8Array.");
}
Ht.assertIsBytes = Bd;
function JU(t) {
  if ((Bd(t), t.length === 0)) return "0x";
  const e = Dbe(),
    r = new Array(t.length);
  for (let n = 0; n < t.length; n++) r[n] = e[t[n]];
  return (0, m4.add0x)(r.join(""));
}
Ht.bytesToHex = JU;
function QU(t) {
  Bd(t);
  const e = JU(t);
  return BigInt(e);
}
Ht.bytesToBigInt = QU;
function Obe(t) {
  Bd(t);
  let e = BigInt(0);
  for (const r of t) e = (e << BigInt(8)) + BigInt(r);
  return BigInt.asIntN(t.length * 8, e);
}
Ht.bytesToSignedBigInt = Obe;
function Fbe(t) {
  Bd(t);
  const e = QU(t);
  return (
    (0, ca.assert)(
      e <= BigInt(Number.MAX_SAFE_INTEGER),
      "Number is not a safe integer. Use `bytesToBigInt` instead."
    ),
    Number(e)
  );
}
Ht.bytesToNumber = Fbe;
function Lbe(t) {
  return Bd(t), new TextDecoder().decode(t);
}
Ht.bytesToString = Lbe;
function bx(t) {
  var e;
  if (
    ((e = t == null ? void 0 : t.toLowerCase) === null || e === void 0
      ? void 0
      : e.call(t)) === "0x"
  )
    return new Uint8Array();
  (0, m4.assertIsHexString)(t);
  const r = (0, m4.remove0x)(t).toLowerCase(),
    n = r.length % 2 === 0 ? r : `0${r}`,
    i = new Uint8Array(n.length / 2);
  for (let a = 0; a < i.length; a++) {
    const s = n.charCodeAt(a * 2),
      o = n.charCodeAt(a * 2 + 1),
      c = s - (s < AM ? CM : kM),
      u = o - (o < AM ? CM : kM);
    i[a] = c * 16 + u;
  }
  return i;
}
Ht.hexToBytes = bx;
function YU(t) {
  (0, ca.assert)(typeof t == "bigint", "Value must be a bigint."),
    (0, ca.assert)(t >= BigInt(0), "Value must be a non-negative bigint.");
  const e = t.toString(16);
  return bx(e);
}
Ht.bigIntToBytes = YU;
function $be(t, e) {
  (0, ca.assert)(e > 0);
  const r = t >> BigInt(31);
  return !(((~t & r) + (t & ~r)) >> BigInt(e * 8 + -1));
}
function Ube(t, e) {
  (0, ca.assert)(typeof t == "bigint", "Value must be a bigint."),
    (0, ca.assert)(typeof e == "number", "Byte length must be a number."),
    (0, ca.assert)(e > 0, "Byte length must be greater than 0."),
    (0, ca.assert)(
      $be(t, e),
      "Byte length is too small to represent the given value."
    );
  let r = t;
  const n = new Uint8Array(e);
  for (let i = 0; i < n.length; i++)
    (n[i] = Number(BigInt.asUintN(8, r))), (r >>= BigInt(8));
  return n.reverse();
}
Ht.signedBigIntToBytes = Ube;
function XU(t) {
  (0, ca.assert)(typeof t == "number", "Value must be a number."),
    (0, ca.assert)(t >= 0, "Value must be a non-negative number."),
    (0, ca.assert)(
      Number.isSafeInteger(t),
      "Value is not a safe integer. Use `bigIntToBytes` instead."
    );
  const e = t.toString(16);
  return bx(e);
}
Ht.numberToBytes = XU;
function eW(t) {
  return (
    (0, ca.assert)(typeof t == "string", "Value must be a string."),
    new TextEncoder().encode(t)
  );
}
Ht.stringToBytes = eW;
function tW(t) {
  if (typeof t == "bigint") return YU(t);
  if (typeof t == "number") return XU(t);
  if (typeof t == "string") return t.startsWith("0x") ? bx(t) : eW(t);
  if (_T(t)) return t;
  throw new TypeError(`Unsupported value type: "${typeof t}".`);
}
Ht.valueToBytes = tW;
function Wbe(t) {
  const e = new Array(t.length);
  let r = 0;
  for (let i = 0; i < t.length; i++) {
    const a = tW(t[i]);
    (e[i] = a), (r += a.length);
  }
  const n = new Uint8Array(r);
  for (let i = 0, a = 0; i < e.length; i++) n.set(e[i], a), (a += e[i].length);
  return n;
}
Ht.concatBytes = Wbe;
function jbe(t) {
  if (typeof Buffer < "u" && t instanceof Buffer) {
    const e = t.buffer.slice(t.byteOffset, t.byteOffset + t.byteLength);
    return new DataView(e);
  }
  return new DataView(t.buffer, t.byteOffset, t.byteLength);
}
Ht.createDataView = jbe;
var vx = {};
Object.defineProperty(vx, "__esModule", {
  value: !0,
});
vx.ChecksumStruct = void 0;
const SM = qu,
  Hbe = h1;
vx.ChecksumStruct = (0, SM.size)(
  (0, Hbe.base64)((0, SM.string)(), {
    paddingRequired: !0,
  }),
  44,
  44
);
var Js = {};
Object.defineProperty(Js, "__esModule", {
  value: !0,
});
Js.createHex = Js.createBytes = Js.createBigInt = Js.createNumber = void 0;
const Gr = qu,
  zbe = Vn,
  rW = Ht,
  xx = p1,
  nW = (0, Gr.union)([
    (0, Gr.number)(),
    (0, Gr.bigint)(),
    (0, Gr.string)(),
    xx.StrictHexStruct,
  ]),
  qbe = (0, Gr.coerce)((0, Gr.number)(), nW, Number),
  Vbe = (0, Gr.coerce)((0, Gr.bigint)(), nW, BigInt);
(0, Gr.union)([xx.StrictHexStruct, (0, Gr.instance)(Uint8Array)]);
const Kbe = (0, Gr.coerce)(
    (0, Gr.instance)(Uint8Array),
    (0, Gr.union)([xx.StrictHexStruct]),
    rW.hexToBytes
  ),
  Gbe = (0, Gr.coerce)(
    xx.StrictHexStruct,
    (0, Gr.instance)(Uint8Array),
    rW.bytesToHex
  );
function Zbe(t) {
  try {
    const e = (0, Gr.create)(t, qbe);
    return (
      (0, zbe.assert)(
        Number.isFinite(e),
        `Expected a number-like value, got "${t}".`
      ),
      e
    );
  } catch (e) {
    throw e instanceof Gr.StructError
      ? new Error(`Expected a number-like value, got "${t}".`)
      : e;
  }
}
Js.createNumber = Zbe;
function Jbe(t) {
  try {
    return (0, Gr.create)(t, Vbe);
  } catch (e) {
    throw e instanceof Gr.StructError
      ? new Error(`Expected a number-like value, got "${String(e.value)}".`)
      : e;
  }
}
Js.createBigInt = Jbe;
function Qbe(t) {
  if (typeof t == "string" && t.toLowerCase() === "0x") return new Uint8Array();
  try {
    return (0, Gr.create)(t, Kbe);
  } catch (e) {
    throw e instanceof Gr.StructError
      ? new Error(`Expected a bytes-like value, got "${String(e.value)}".`)
      : e;
  }
}
Js.createBytes = Qbe;
function Ybe(t) {
  if (
    (t instanceof Uint8Array && t.length === 0) ||
    (typeof t == "string" && t.toLowerCase() === "0x")
  )
    return "0x";
  try {
    return (0, Gr.create)(t, Gbe);
  } catch (e) {
    throw e instanceof Gr.StructError
      ? new Error(`Expected a bytes-like value, got "${String(e.value)}".`)
      : e;
  }
}
Js.createHex = Ybe;
var Gf = {},
  iW =
    (ke && ke.__classPrivateFieldSet) ||
    function (t, e, r, n, i) {
      if (n === "m") throw new TypeError("Private method is not writable");
      if (n === "a" && !i)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof e == "function" ? t !== e || !i : !e.has(t))
        throw new TypeError(
          "Cannot write private member to an object whose class did not declare it"
        );
      return n === "a" ? i.call(t, r) : i ? (i.value = r) : e.set(t, r), r;
    },
  _i =
    (ke && ke.__classPrivateFieldGet) ||
    function (t, e, r, n) {
      if (r === "a" && !n)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof e == "function" ? t !== e || !n : !e.has(t))
        throw new TypeError(
          "Cannot read private member from an object whose class did not declare it"
        );
      return r === "m" ? n : r === "a" ? n.call(t) : n ? n.value : e.get(t);
    },
  ts,
  Ms;
Object.defineProperty(Gf, "__esModule", {
  value: !0,
});
Gf.FrozenSet = Gf.FrozenMap = void 0;
class ET {
  constructor(e) {
    ts.set(this, void 0), iW(this, ts, new Map(e), "f"), Object.freeze(this);
  }
  get size() {
    return _i(this, ts, "f").size;
  }
  [((ts = new WeakMap()), Symbol.iterator)]() {
    return _i(this, ts, "f")[Symbol.iterator]();
  }
  entries() {
    return _i(this, ts, "f").entries();
  }
  forEach(e, r) {
    return _i(this, ts, "f").forEach((n, i, a) => e.call(r, n, i, this));
  }
  get(e) {
    return _i(this, ts, "f").get(e);
  }
  has(e) {
    return _i(this, ts, "f").has(e);
  }
  keys() {
    return _i(this, ts, "f").keys();
  }
  values() {
    return _i(this, ts, "f").values();
  }
  toString() {
    return `FrozenMap(${this.size}) {${
      this.size > 0
        ? ` ${[...this.entries()]
            .map(([e, r]) => `${String(e)} => ${String(r)}`)
            .join(", ")} `
        : ""
    }}`;
  }
}
Gf.FrozenMap = ET;
class TT {
  constructor(e) {
    Ms.set(this, void 0), iW(this, Ms, new Set(e), "f"), Object.freeze(this);
  }
  get size() {
    return _i(this, Ms, "f").size;
  }
  [((Ms = new WeakMap()), Symbol.iterator)]() {
    return _i(this, Ms, "f")[Symbol.iterator]();
  }
  entries() {
    return _i(this, Ms, "f").entries();
  }
  forEach(e, r) {
    return _i(this, Ms, "f").forEach((n, i, a) => e.call(r, n, i, this));
  }
  has(e) {
    return _i(this, Ms, "f").has(e);
  }
  keys() {
    return _i(this, Ms, "f").keys();
  }
  values() {
    return _i(this, Ms, "f").values();
  }
  toString() {
    return `FrozenSet(${this.size}) {${
      this.size > 0
        ? ` ${[...this.values()].map((e) => String(e)).join(", ")} `
        : ""
    }}`;
  }
}
Gf.FrozenSet = TT;
Object.freeze(ET);
Object.freeze(ET.prototype);
Object.freeze(TT);
Object.freeze(TT.prototype);
var aW = {};
Object.defineProperty(aW, "__esModule", {
  value: !0,
});
var sW = {};
(function (t) {
  Object.defineProperty(t, "__esModule", {
    value: !0,
  }),
    (t.getJsonRpcIdValidator =
      t.assertIsJsonRpcError =
      t.isJsonRpcError =
      t.assertIsJsonRpcFailure =
      t.isJsonRpcFailure =
      t.assertIsJsonRpcSuccess =
      t.isJsonRpcSuccess =
      t.assertIsJsonRpcResponse =
      t.isJsonRpcResponse =
      t.assertIsPendingJsonRpcResponse =
      t.isPendingJsonRpcResponse =
      t.JsonRpcResponseStruct =
      t.JsonRpcFailureStruct =
      t.JsonRpcSuccessStruct =
      t.PendingJsonRpcResponseStruct =
      t.assertIsJsonRpcRequest =
      t.isJsonRpcRequest =
      t.assertIsJsonRpcNotification =
      t.isJsonRpcNotification =
      t.JsonRpcNotificationStruct =
      t.JsonRpcRequestStruct =
      t.JsonRpcParamsStruct =
      t.JsonRpcErrorStruct =
      t.JsonRpcIdStruct =
      t.JsonRpcVersionStruct =
      t.jsonrpc2 =
      t.getJsonSize =
      t.isValidJson =
      t.JsonStruct =
      t.UnsafeJsonStruct =
        void 0);
  const e = qu,
    r = Vn,
    n = () =>
      (0, e.define)(
        "finite number",
        (O) => (0, e.is)(O, (0, e.number)()) && Number.isFinite(O)
      );
  (t.UnsafeJsonStruct = (0, e.union)([
    (0, e.literal)(null),
    (0, e.boolean)(),
    n(),
    (0, e.string)(),
    (0, e.array)((0, e.lazy)(() => t.UnsafeJsonStruct)),
    (0, e.record)(
      (0, e.string)(),
      (0, e.lazy)(() => t.UnsafeJsonStruct)
    ),
  ])),
    (t.JsonStruct = (0, e.define)("Json", (O, F) => {
      function V(j, X) {
        const l = [...X.validator(j, F)];
        return l.length > 0 ? l : !0;
      }
      try {
        const j = V(O, t.UnsafeJsonStruct);
        return j !== !0
          ? j
          : V(JSON.parse(JSON.stringify(O)), t.UnsafeJsonStruct);
      } catch (j) {
        return j instanceof RangeError ? "Circular reference detected" : !1;
      }
    }));
  function i(O) {
    return (0, e.is)(O, t.JsonStruct);
  }
  t.isValidJson = i;
  function a(O) {
    (0, r.assertStruct)(O, t.JsonStruct, "Invalid JSON value");
    const F = JSON.stringify(O);
    return new TextEncoder().encode(F).byteLength;
  }
  (t.getJsonSize = a),
    (t.jsonrpc2 = "2.0"),
    (t.JsonRpcVersionStruct = (0, e.literal)(t.jsonrpc2)),
    (t.JsonRpcIdStruct = (0, e.nullable)(
      (0, e.union)([(0, e.number)(), (0, e.string)()])
    )),
    (t.JsonRpcErrorStruct = (0, e.object)({
      code: (0, e.integer)(),
      message: (0, e.string)(),
      data: (0, e.optional)(t.JsonStruct),
      stack: (0, e.optional)((0, e.string)()),
    })),
    (t.JsonRpcParamsStruct = (0, e.optional)(
      (0, e.union)([
        (0, e.record)((0, e.string)(), t.JsonStruct),
        (0, e.array)(t.JsonStruct),
      ])
    )),
    (t.JsonRpcRequestStruct = (0, e.object)({
      id: t.JsonRpcIdStruct,
      jsonrpc: t.JsonRpcVersionStruct,
      method: (0, e.string)(),
      params: t.JsonRpcParamsStruct,
    })),
    (t.JsonRpcNotificationStruct = (0, e.omit)(t.JsonRpcRequestStruct, ["id"]));
  function s(O) {
    return (0, e.is)(O, t.JsonRpcNotificationStruct);
  }
  t.isJsonRpcNotification = s;
  function o(O, F) {
    (0, r.assertStruct)(
      O,
      t.JsonRpcNotificationStruct,
      "Invalid JSON-RPC notification",
      F
    );
  }
  t.assertIsJsonRpcNotification = o;
  function c(O) {
    return (0, e.is)(O, t.JsonRpcRequestStruct);
  }
  t.isJsonRpcRequest = c;
  function u(O, F) {
    (0, r.assertStruct)(
      O,
      t.JsonRpcRequestStruct,
      "Invalid JSON-RPC request",
      F
    );
  }
  (t.assertIsJsonRpcRequest = u),
    (t.PendingJsonRpcResponseStruct = (0, e.object)({
      id: t.JsonRpcIdStruct,
      jsonrpc: t.JsonRpcVersionStruct,
      result: (0, e.optional)((0, e.unknown)()),
      error: (0, e.optional)(t.JsonRpcErrorStruct),
    })),
    (t.JsonRpcSuccessStruct = (0, e.object)({
      id: t.JsonRpcIdStruct,
      jsonrpc: t.JsonRpcVersionStruct,
      result: t.JsonStruct,
    })),
    (t.JsonRpcFailureStruct = (0, e.object)({
      id: t.JsonRpcIdStruct,
      jsonrpc: t.JsonRpcVersionStruct,
      error: t.JsonRpcErrorStruct,
    })),
    (t.JsonRpcResponseStruct = (0, e.union)([
      t.JsonRpcSuccessStruct,
      t.JsonRpcFailureStruct,
    ]));
  function d(O) {
    return (0, e.is)(O, t.PendingJsonRpcResponseStruct);
  }
  t.isPendingJsonRpcResponse = d;
  function m(O, F) {
    (0, r.assertStruct)(
      O,
      t.PendingJsonRpcResponseStruct,
      "Invalid pending JSON-RPC response",
      F
    );
  }
  t.assertIsPendingJsonRpcResponse = m;
  function v(O) {
    return (0, e.is)(O, t.JsonRpcResponseStruct);
  }
  t.isJsonRpcResponse = v;
  function E(O, F) {
    (0, r.assertStruct)(
      O,
      t.JsonRpcResponseStruct,
      "Invalid JSON-RPC response",
      F
    );
  }
  t.assertIsJsonRpcResponse = E;
  function A(O) {
    return (0, e.is)(O, t.JsonRpcSuccessStruct);
  }
  t.isJsonRpcSuccess = A;
  function I(O, F) {
    (0, r.assertStruct)(
      O,
      t.JsonRpcSuccessStruct,
      "Invalid JSON-RPC success response",
      F
    );
  }
  t.assertIsJsonRpcSuccess = I;
  function b(O) {
    return (0, e.is)(O, t.JsonRpcFailureStruct);
  }
  t.isJsonRpcFailure = b;
  function w(O, F) {
    (0, r.assertStruct)(
      O,
      t.JsonRpcFailureStruct,
      "Invalid JSON-RPC failure response",
      F
    );
  }
  t.assertIsJsonRpcFailure = w;
  function S(O) {
    return (0, e.is)(O, t.JsonRpcErrorStruct);
  }
  t.isJsonRpcError = S;
  function k(O, F) {
    (0, r.assertStruct)(O, t.JsonRpcErrorStruct, "Invalid JSON-RPC error", F);
  }
  t.assertIsJsonRpcError = k;
  function N(O) {
    const {
      permitEmptyString: F,
      permitFractions: V,
      permitNull: j,
    } = Object.assign(
      {
        permitEmptyString: !0,
        permitFractions: !1,
        permitNull: !0,
      },
      O
    );
    return (C) =>
      !!(
        (typeof C == "number" && (V || Number.isInteger(C))) ||
        (typeof C == "string" && (F || C.length > 0)) ||
        (j && C === null)
      );
  }
  t.getJsonRpcIdValidator = N;
})(sW);
var oW = {};
Object.defineProperty(oW, "__esModule", {
  value: !0,
});
var Zf = {},
  y4 = {
    exports: {},
  },
  b5,
  MM;
function Xbe() {
  if (MM) return b5;
  MM = 1;
  var t = 1e3,
    e = t * 60,
    r = e * 60,
    n = r * 24,
    i = n * 7,
    a = n * 365.25;
  b5 = function (d, m) {
    m = m || {};
    var v = typeof d;
    if (v === "string" && d.length > 0) return s(d);
    if (v === "number" && isFinite(d)) return m.long ? c(d) : o(d);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" +
        JSON.stringify(d)
    );
  };
  function s(d) {
    if (((d = String(d)), !(d.length > 100))) {
      var m =
        /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          d
        );
      if (m) {
        var v = parseFloat(m[1]),
          E = (m[2] || "ms").toLowerCase();
        switch (E) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return v * a;
          case "weeks":
          case "week":
          case "w":
            return v * i;
          case "days":
          case "day":
          case "d":
            return v * n;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return v * r;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return v * e;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return v * t;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return v;
          default:
            return;
        }
      }
    }
  }
  function o(d) {
    var m = Math.abs(d);
    return m >= n
      ? Math.round(d / n) + "d"
      : m >= r
      ? Math.round(d / r) + "h"
      : m >= e
      ? Math.round(d / e) + "m"
      : m >= t
      ? Math.round(d / t) + "s"
      : d + "ms";
  }
  function c(d) {
    var m = Math.abs(d);
    return m >= n
      ? u(d, m, n, "day")
      : m >= r
      ? u(d, m, r, "hour")
      : m >= e
      ? u(d, m, e, "minute")
      : m >= t
      ? u(d, m, t, "second")
      : d + " ms";
  }
  function u(d, m, v, E) {
    var A = m >= v * 1.5;
    return Math.round(d / v) + " " + E + (A ? "s" : "");
  }
  return b5;
}
function eve(t) {
  (r.debug = r),
    (r.default = r),
    (r.coerce = c),
    (r.disable = a),
    (r.enable = i),
    (r.enabled = s),
    (r.humanize = Xbe()),
    (r.destroy = u),
    Object.keys(t).forEach((d) => {
      r[d] = t[d];
    }),
    (r.names = []),
    (r.skips = []),
    (r.formatters = {});
  function e(d) {
    let m = 0;
    for (let v = 0; v < d.length; v++)
      (m = (m << 5) - m + d.charCodeAt(v)), (m |= 0);
    return r.colors[Math.abs(m) % r.colors.length];
  }
  r.selectColor = e;
  function r(d) {
    let m,
      v = null,
      E,
      A;
    function I(...b) {
      if (!I.enabled) return;
      const w = I,
        S = Number(new Date()),
        k = S - (m || S);
      (w.diff = k),
        (w.prev = m),
        (w.curr = S),
        (m = S),
        (b[0] = r.coerce(b[0])),
        typeof b[0] != "string" && b.unshift("%O");
      let N = 0;
      (b[0] = b[0].replace(/%([a-zA-Z%])/g, (F, V) => {
        if (F === "%%") return "%";
        N++;
        const j = r.formatters[V];
        if (typeof j == "function") {
          const X = b[N];
          (F = j.call(w, X)), b.splice(N, 1), N--;
        }
        return F;
      })),
        r.formatArgs.call(w, b),
        (w.log || r.log).apply(w, b);
    }
    return (
      (I.namespace = d),
      (I.useColors = r.useColors()),
      (I.color = r.selectColor(d)),
      (I.extend = n),
      (I.destroy = r.destroy),
      Object.defineProperty(I, "enabled", {
        enumerable: !0,
        configurable: !1,
        get: () =>
          v !== null
            ? v
            : (E !== r.namespaces && ((E = r.namespaces), (A = r.enabled(d))),
              A),
        set: (b) => {
          v = b;
        },
      }),
      typeof r.init == "function" && r.init(I),
      I
    );
  }
  function n(d, m) {
    const v = r(this.namespace + (typeof m > "u" ? ":" : m) + d);
    return (v.log = this.log), v;
  }
  function i(d) {
    r.save(d), (r.namespaces = d), (r.names = []), (r.skips = []);
    let m;
    const v = (typeof d == "string" ? d : "").split(/[\s,]+/),
      E = v.length;
    for (m = 0; m < E; m++)
      v[m] &&
        ((d = v[m].replace(/\*/g, ".*?")),
        d[0] === "-"
          ? r.skips.push(new RegExp("^" + d.slice(1) + "$"))
          : r.names.push(new RegExp("^" + d + "$")));
  }
  function a() {
    const d = [...r.names.map(o), ...r.skips.map(o).map((m) => "-" + m)].join(
      ","
    );
    return r.enable(""), d;
  }
  function s(d) {
    if (d[d.length - 1] === "*") return !0;
    let m, v;
    for (m = 0, v = r.skips.length; m < v; m++)
      if (r.skips[m].test(d)) return !1;
    for (m = 0, v = r.names.length; m < v; m++)
      if (r.names[m].test(d)) return !0;
    return !1;
  }
  function o(d) {
    return d
      .toString()
      .substring(2, d.toString().length - 2)
      .replace(/\.\*\?$/, "*");
  }
  function c(d) {
    return d instanceof Error ? d.stack || d.message : d;
  }
  function u() {
    console.warn(
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
  }
  return r.enable(r.load()), r;
}
var tve = eve;
(function (t, e) {
  var r = {};
  (e.formatArgs = i),
    (e.save = a),
    (e.load = s),
    (e.useColors = n),
    (e.storage = o()),
    (e.destroy = (() => {
      let u = !1;
      return () => {
        u ||
          ((u = !0),
          console.warn(
            "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
          ));
      };
    })()),
    (e.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33",
    ]);
  function n() {
    if (
      typeof window < "u" &&
      window.process &&
      (window.process.type === "renderer" || window.process.__nwjs)
    )
      return !0;
    if (
      typeof navigator < "u" &&
      navigator.userAgent &&
      navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
    )
      return !1;
    let u;
    return (
      (typeof document < "u" &&
        document.documentElement &&
        document.documentElement.style &&
        document.documentElement.style.WebkitAppearance) ||
      (typeof window < "u" &&
        window.console &&
        (window.console.firebug ||
          (window.console.exception && window.console.table))) ||
      (typeof navigator < "u" &&
        navigator.userAgent &&
        (u = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) &&
        parseInt(u[1], 10) >= 31) ||
      (typeof navigator < "u" &&
        navigator.userAgent &&
        navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
    );
  }
  function i(u) {
    if (
      ((u[0] =
        (this.useColors ? "%c" : "") +
        this.namespace +
        (this.useColors ? " %c" : " ") +
        u[0] +
        (this.useColors ? "%c " : " ") +
        "+" +
        t.exports.humanize(this.diff)),
      !this.useColors)
    )
      return;
    const d = "color: " + this.color;
    u.splice(1, 0, d, "color: inherit");
    let m = 0,
      v = 0;
    u[0].replace(/%[a-zA-Z%]/g, (E) => {
      E !== "%%" && (m++, E === "%c" && (v = m));
    }),
      u.splice(v, 0, d);
  }
  e.log = console.debug || console.log || (() => {});
  function a(u) {
    try {
      u ? e.storage.setItem("debug", u) : e.storage.removeItem("debug");
    } catch {}
  }
  function s() {
    let u;
    try {
      u = e.storage.getItem("debug");
    } catch {}
    return !u && typeof process < "u" && "env" in process && (u = r.DEBUG), u;
  }
  function o() {
    try {
      return localStorage;
    } catch {}
  }
  t.exports = tve(e);
  const { formatters: c } = t.exports;
  c.j = function (u) {
    try {
      return JSON.stringify(u);
    } catch (d) {
      return "[UnexpectedJSONParseError]: " + d.message;
    }
  };
})(y4, y4.exports);
var rve = y4.exports,
  nve =
    (ke && ke.__importDefault) ||
    function (t) {
      return t && t.__esModule
        ? t
        : {
            default: t,
          };
    };
Object.defineProperty(Zf, "__esModule", {
  value: !0,
});
Zf.createModuleLogger = Zf.createProjectLogger = void 0;
const ive = nve(rve),
  ave = (0, ive.default)("metamask");
function sve(t) {
  return ave.extend(t);
}
Zf.createProjectLogger = sve;
function ove(t, e) {
  return t.extend(e);
}
Zf.createModuleLogger = ove;
var cW = {};
(function (t) {
  Object.defineProperty(t, "__esModule", {
    value: !0,
  }),
    (t.calculateNumberSize =
      t.calculateStringSize =
      t.isASCII =
      t.isPlainObject =
      t.ESCAPE_CHARACTERS_REGEXP =
      t.JsonSize =
      t.hasProperty =
      t.isObject =
      t.isNullOrUndefined =
      t.isNonEmptyArray =
        void 0);
  function e(u) {
    return Array.isArray(u) && u.length > 0;
  }
  t.isNonEmptyArray = e;
  function r(u) {
    return u == null;
  }
  t.isNullOrUndefined = r;
  function n(u) {
    return !!u && typeof u == "object" && !Array.isArray(u);
  }
  t.isObject = n;
  const i = (u, d) => Object.hasOwnProperty.call(u, d);
  (t.hasProperty = i),
    (function (u) {
      (u[(u.Null = 4)] = "Null"),
        (u[(u.Comma = 1)] = "Comma"),
        (u[(u.Wrapper = 1)] = "Wrapper"),
        (u[(u.True = 4)] = "True"),
        (u[(u.False = 5)] = "False"),
        (u[(u.Quote = 1)] = "Quote"),
        (u[(u.Colon = 1)] = "Colon"),
        (u[(u.Date = 24)] = "Date");
    })(t.JsonSize || (t.JsonSize = {})),
    (t.ESCAPE_CHARACTERS_REGEXP = /"|\\|\n|\r|\t/gu);
  function a(u) {
    if (typeof u != "object" || u === null) return !1;
    try {
      let d = u;
      for (; Object.getPrototypeOf(d) !== null; ) d = Object.getPrototypeOf(d);
      return Object.getPrototypeOf(u) === d;
    } catch {
      return !1;
    }
  }
  t.isPlainObject = a;
  function s(u) {
    return u.charCodeAt(0) <= 127;
  }
  t.isASCII = s;
  function o(u) {
    var d;
    return (
      u.split("").reduce((v, E) => (s(E) ? v + 1 : v + 2), 0) +
      ((d = u.match(t.ESCAPE_CHARACTERS_REGEXP)) !== null && d !== void 0
        ? d
        : []
      ).length
    );
  }
  t.calculateStringSize = o;
  function c(u) {
    return u.toString().length;
  }
  t.calculateNumberSize = c;
})(cW);
var Qs = {};
Object.defineProperty(Qs, "__esModule", {
  value: !0,
});
Qs.hexToBigInt = Qs.hexToNumber = Qs.bigIntToHex = Qs.numberToHex = void 0;
const nf = Vn,
  dm = p1,
  cve = (t) => (
    (0, nf.assert)(typeof t == "number", "Value must be a number."),
    (0, nf.assert)(t >= 0, "Value must be a non-negative number."),
    (0, nf.assert)(
      Number.isSafeInteger(t),
      "Value is not a safe integer. Use `bigIntToHex` instead."
    ),
    (0, dm.add0x)(t.toString(16))
  );
Qs.numberToHex = cve;
const lve = (t) => (
  (0, nf.assert)(typeof t == "bigint", "Value must be a bigint."),
  (0, nf.assert)(t >= 0, "Value must be a non-negative bigint."),
  (0, dm.add0x)(t.toString(16))
);
Qs.bigIntToHex = lve;
const uve = (t) => {
  (0, dm.assertIsHexString)(t);
  const e = parseInt(t, 16);
  return (
    (0, nf.assert)(
      Number.isSafeInteger(e),
      "Value is not a safe integer. Use `hexToBigInt` instead."
    ),
    e
  );
};
Qs.hexToNumber = uve;
const fve = (t) => ((0, dm.assertIsHexString)(t), BigInt((0, dm.add0x)(t)));
Qs.hexToBigInt = fve;
var lW = {};
Object.defineProperty(lW, "__esModule", {
  value: !0,
});
var uW = {};
(function (t) {
  Object.defineProperty(t, "__esModule", {
    value: !0,
  }),
    (t.timeSince = t.inMilliseconds = t.Duration = void 0),
    (function (a) {
      (a[(a.Millisecond = 1)] = "Millisecond"),
        (a[(a.Second = 1e3)] = "Second"),
        (a[(a.Minute = 6e4)] = "Minute"),
        (a[(a.Hour = 36e5)] = "Hour"),
        (a[(a.Day = 864e5)] = "Day"),
        (a[(a.Week = 6048e5)] = "Week"),
        (a[(a.Year = 31536e6)] = "Year");
    })(t.Duration || (t.Duration = {}));
  const e = (a) => Number.isInteger(a) && a >= 0,
    r = (a, s) => {
      if (!e(a))
        throw new Error(
          `"${s}" must be a non-negative integer. Received: "${a}".`
        );
    };
  function n(a, s) {
    return r(a, "count"), a * s;
  }
  t.inMilliseconds = n;
  function i(a) {
    return r(a, "timestamp"), Date.now() - a;
  }
  t.timeSince = i;
})(uW);
var fW = {};
Object.defineProperty(fW, "__esModule", {
  value: !0,
});
var dW = {},
  g4 = {
    exports: {},
  };
const dve = "2.0.0",
  hW = 256,
  hve = Number.MAX_SAFE_INTEGER || 9007199254740991,
  pve = 16,
  mve = hW - 6,
  yve = [
    "major",
    "premajor",
    "minor",
    "preminor",
    "patch",
    "prepatch",
    "prerelease",
  ];
var wx = {
    MAX_LENGTH: hW,
    MAX_SAFE_COMPONENT_LENGTH: pve,
    MAX_SAFE_BUILD_LENGTH: mve,
    MAX_SAFE_INTEGER: hve,
    RELEASE_TYPES: yve,
    SEMVER_SPEC_VERSION: dve,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2,
  },
  v5 = {};
const gve =
  typeof process == "object" &&
  v5 &&
  v5.NODE_DEBUG &&
  /\bsemver\b/i.test(v5.NODE_DEBUG)
    ? (...t) => console.error("SEMVER", ...t)
    : () => {};
var _x = gve;
(function (t, e) {
  const {
      MAX_SAFE_COMPONENT_LENGTH: r,
      MAX_SAFE_BUILD_LENGTH: n,
      MAX_LENGTH: i,
    } = wx,
    a = _x;
  e = t.exports = {};
  const s = (e.re = []),
    o = (e.safeRe = []),
    c = (e.src = []),
    u = (e.t = {});
  let d = 0;
  const m = "[a-zA-Z0-9-]",
    v = [
      ["\\s", 1],
      ["\\d", i],
      [m, n],
    ],
    E = (I) => {
      for (const [b, w] of v)
        I = I.split(`${b}*`)
          .join(`${b}{0,${w}}`)
          .split(`${b}+`)
          .join(`${b}{1,${w}}`);
      return I;
    },
    A = (I, b, w) => {
      const S = E(b),
        k = d++;
      a(I, k, b),
        (u[I] = k),
        (c[k] = b),
        (s[k] = new RegExp(b, w ? "g" : void 0)),
        (o[k] = new RegExp(S, w ? "g" : void 0));
    };
  A("NUMERICIDENTIFIER", "0|[1-9]\\d*"),
    A("NUMERICIDENTIFIERLOOSE", "\\d+"),
    A("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${m}*`),
    A(
      "MAINVERSION",
      `(${c[u.NUMERICIDENTIFIER]})\\.(${c[u.NUMERICIDENTIFIER]})\\.(${
        c[u.NUMERICIDENTIFIER]
      })`
    ),
    A(
      "MAINVERSIONLOOSE",
      `(${c[u.NUMERICIDENTIFIERLOOSE]})\\.(${c[u.NUMERICIDENTIFIERLOOSE]})\\.(${
        c[u.NUMERICIDENTIFIERLOOSE]
      })`
    ),
    A(
      "PRERELEASEIDENTIFIER",
      `(?:${c[u.NUMERICIDENTIFIER]}|${c[u.NONNUMERICIDENTIFIER]})`
    ),
    A(
      "PRERELEASEIDENTIFIERLOOSE",
      `(?:${c[u.NUMERICIDENTIFIERLOOSE]}|${c[u.NONNUMERICIDENTIFIER]})`
    ),
    A(
      "PRERELEASE",
      `(?:-(${c[u.PRERELEASEIDENTIFIER]}(?:\\.${c[u.PRERELEASEIDENTIFIER]})*))`
    ),
    A(
      "PRERELEASELOOSE",
      `(?:-?(${c[u.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${
        c[u.PRERELEASEIDENTIFIERLOOSE]
      })*))`
    ),
    A("BUILDIDENTIFIER", `${m}+`),
    A(
      "BUILD",
      `(?:\\+(${c[u.BUILDIDENTIFIER]}(?:\\.${c[u.BUILDIDENTIFIER]})*))`
    ),
    A("FULLPLAIN", `v?${c[u.MAINVERSION]}${c[u.PRERELEASE]}?${c[u.BUILD]}?`),
    A("FULL", `^${c[u.FULLPLAIN]}$`),
    A(
      "LOOSEPLAIN",
      `[v=\\s]*${c[u.MAINVERSIONLOOSE]}${c[u.PRERELEASELOOSE]}?${c[u.BUILD]}?`
    ),
    A("LOOSE", `^${c[u.LOOSEPLAIN]}$`),
    A("GTLT", "((?:<|>)?=?)"),
    A("XRANGEIDENTIFIERLOOSE", `${c[u.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`),
    A("XRANGEIDENTIFIER", `${c[u.NUMERICIDENTIFIER]}|x|X|\\*`),
    A(
      "XRANGEPLAIN",
      `[v=\\s]*(${c[u.XRANGEIDENTIFIER]})(?:\\.(${
        c[u.XRANGEIDENTIFIER]
      })(?:\\.(${c[u.XRANGEIDENTIFIER]})(?:${c[u.PRERELEASE]})?${
        c[u.BUILD]
      }?)?)?`
    ),
    A(
      "XRANGEPLAINLOOSE",
      `[v=\\s]*(${c[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${
        c[u.XRANGEIDENTIFIERLOOSE]
      })(?:\\.(${c[u.XRANGEIDENTIFIERLOOSE]})(?:${c[u.PRERELEASELOOSE]})?${
        c[u.BUILD]
      }?)?)?`
    ),
    A("XRANGE", `^${c[u.GTLT]}\\s*${c[u.XRANGEPLAIN]}$`),
    A("XRANGELOOSE", `^${c[u.GTLT]}\\s*${c[u.XRANGEPLAINLOOSE]}$`),
    A(
      "COERCEPLAIN",
      `(^|[^\\d])(\\d{1,${r}})(?:\\.(\\d{1,${r}}))?(?:\\.(\\d{1,${r}}))?`
    ),
    A("COERCE", `${c[u.COERCEPLAIN]}(?:$|[^\\d])`),
    A(
      "COERCEFULL",
      c[u.COERCEPLAIN] + `(?:${c[u.PRERELEASE]})?(?:${c[u.BUILD]})?(?:$|[^\\d])`
    ),
    A("COERCERTL", c[u.COERCE], !0),
    A("COERCERTLFULL", c[u.COERCEFULL], !0),
    A("LONETILDE", "(?:~>?)"),
    A("TILDETRIM", `(\\s*)${c[u.LONETILDE]}\\s+`, !0),
    (e.tildeTrimReplace = "$1~"),
    A("TILDE", `^${c[u.LONETILDE]}${c[u.XRANGEPLAIN]}$`),
    A("TILDELOOSE", `^${c[u.LONETILDE]}${c[u.XRANGEPLAINLOOSE]}$`),
    A("LONECARET", "(?:\\^)"),
    A("CARETTRIM", `(\\s*)${c[u.LONECARET]}\\s+`, !0),
    (e.caretTrimReplace = "$1^"),
    A("CARET", `^${c[u.LONECARET]}${c[u.XRANGEPLAIN]}$`),
    A("CARETLOOSE", `^${c[u.LONECARET]}${c[u.XRANGEPLAINLOOSE]}$`),
    A("COMPARATORLOOSE", `^${c[u.GTLT]}\\s*(${c[u.LOOSEPLAIN]})$|^$`),
    A("COMPARATOR", `^${c[u.GTLT]}\\s*(${c[u.FULLPLAIN]})$|^$`),
    A(
      "COMPARATORTRIM",
      `(\\s*)${c[u.GTLT]}\\s*(${c[u.LOOSEPLAIN]}|${c[u.XRANGEPLAIN]})`,
      !0
    ),
    (e.comparatorTrimReplace = "$1$2$3"),
    A(
      "HYPHENRANGE",
      `^\\s*(${c[u.XRANGEPLAIN]})\\s+-\\s+(${c[u.XRANGEPLAIN]})\\s*$`
    ),
    A(
      "HYPHENRANGELOOSE",
      `^\\s*(${c[u.XRANGEPLAINLOOSE]})\\s+-\\s+(${c[u.XRANGEPLAINLOOSE]})\\s*$`
    ),
    A("STAR", "(<|>)?=?\\s*\\*"),
    A("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"),
    A("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(g4, g4.exports);
var m1 = g4.exports;
const bve = Object.freeze({
    loose: !0,
  }),
  vve = Object.freeze({}),
  xve = (t) => (t ? (typeof t != "object" ? bve : t) : vve);
var CT = xve;
const IM = /^[0-9]+$/,
  pW = (t, e) => {
    const r = IM.test(t),
      n = IM.test(e);
    return (
      r && n && ((t = +t), (e = +e)),
      t === e ? 0 : r && !n ? -1 : n && !r ? 1 : t < e ? -1 : 1
    );
  },
  wve = (t, e) => pW(e, t);
var mW = {
  compareIdentifiers: pW,
  rcompareIdentifiers: wve,
};
const by = _x,
  { MAX_LENGTH: RM, MAX_SAFE_INTEGER: vy } = wx,
  { safeRe: PM, t: NM } = m1,
  _ve = CT,
  { compareIdentifiers: o0 } = mW;
let Eve = class Ps {
  constructor(e, r) {
    if (((r = _ve(r)), e instanceof Ps)) {
      if (
        e.loose === !!r.loose &&
        e.includePrerelease === !!r.includePrerelease
      )
        return e;
      e = e.version;
    } else if (typeof e != "string")
      throw new TypeError(
        `Invalid version. Must be a string. Got type "${typeof e}".`
      );
    if (e.length > RM)
      throw new TypeError(`version is longer than ${RM} characters`);
    by("SemVer", e, r),
      (this.options = r),
      (this.loose = !!r.loose),
      (this.includePrerelease = !!r.includePrerelease);
    const n = e.trim().match(r.loose ? PM[NM.LOOSE] : PM[NM.FULL]);
    if (!n) throw new TypeError(`Invalid Version: ${e}`);
    if (
      ((this.raw = e),
      (this.major = +n[1]),
      (this.minor = +n[2]),
      (this.patch = +n[3]),
      this.major > vy || this.major < 0)
    )
      throw new TypeError("Invalid major version");
    if (this.minor > vy || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > vy || this.patch < 0)
      throw new TypeError("Invalid patch version");
    n[4]
      ? (this.prerelease = n[4].split(".").map((i) => {
          if (/^[0-9]+$/.test(i)) {
            const a = +i;
            if (a >= 0 && a < vy) return a;
          }
          return i;
        }))
      : (this.prerelease = []),
      (this.build = n[5] ? n[5].split(".") : []),
      this.format();
  }
  format() {
    return (
      (this.version = `${this.major}.${this.minor}.${this.patch}`),
      this.prerelease.length &&
        (this.version += `-${this.prerelease.join(".")}`),
      this.version
    );
  }
  toString() {
    return this.version;
  }
  compare(e) {
    if (
      (by("SemVer.compare", this.version, this.options, e), !(e instanceof Ps))
    ) {
      if (typeof e == "string" && e === this.version) return 0;
      e = new Ps(e, this.options);
    }
    return e.version === this.version
      ? 0
      : this.compareMain(e) || this.comparePre(e);
  }
  compareMain(e) {
    return (
      e instanceof Ps || (e = new Ps(e, this.options)),
      o0(this.major, e.major) ||
        o0(this.minor, e.minor) ||
        o0(this.patch, e.patch)
    );
  }
  comparePre(e) {
    if (
      (e instanceof Ps || (e = new Ps(e, this.options)),
      this.prerelease.length && !e.prerelease.length)
    )
      return -1;
    if (!this.prerelease.length && e.prerelease.length) return 1;
    if (!this.prerelease.length && !e.prerelease.length) return 0;
    let r = 0;
    do {
      const n = this.prerelease[r],
        i = e.prerelease[r];
      if ((by("prerelease compare", r, n, i), n === void 0 && i === void 0))
        return 0;
      if (i === void 0) return 1;
      if (n === void 0) return -1;
      if (n === i) continue;
      return o0(n, i);
    } while (++r);
  }
  compareBuild(e) {
    e instanceof Ps || (e = new Ps(e, this.options));
    let r = 0;
    do {
      const n = this.build[r],
        i = e.build[r];
      if ((by("build compare", r, n, i), n === void 0 && i === void 0))
        return 0;
      if (i === void 0) return 1;
      if (n === void 0) return -1;
      if (n === i) continue;
      return o0(n, i);
    } while (++r);
  }
  inc(e, r, n) {
    switch (e) {
      case "premajor":
        (this.prerelease.length = 0),
          (this.patch = 0),
          (this.minor = 0),
          this.major++,
          this.inc("pre", r, n);
        break;
      case "preminor":
        (this.prerelease.length = 0),
          (this.patch = 0),
          this.minor++,
          this.inc("pre", r, n);
        break;
      case "prepatch":
        (this.prerelease.length = 0),
          this.inc("patch", r, n),
          this.inc("pre", r, n);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", r, n),
          this.inc("pre", r, n);
        break;
      case "major":
        (this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0) &&
          this.major++,
          (this.minor = 0),
          (this.patch = 0),
          (this.prerelease = []);
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++,
          (this.patch = 0),
          (this.prerelease = []);
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, (this.prerelease = []);
        break;
      case "pre": {
        const i = Number(n) ? 1 : 0;
        if (!r && n === !1)
          throw new Error("invalid increment argument: identifier is empty");
        if (this.prerelease.length === 0) this.prerelease = [i];
        else {
          let a = this.prerelease.length;
          for (; --a >= 0; )
            typeof this.prerelease[a] == "number" &&
              (this.prerelease[a]++, (a = -2));
          if (a === -1) {
            if (r === this.prerelease.join(".") && n === !1)
              throw new Error(
                "invalid increment argument: identifier already exists"
              );
            this.prerelease.push(i);
          }
        }
        if (r) {
          let a = [r, i];
          n === !1 && (a = [r]),
            o0(this.prerelease[0], r) === 0
              ? isNaN(this.prerelease[1]) && (this.prerelease = a)
              : (this.prerelease = a);
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${e}`);
    }
    return (
      (this.raw = this.format()),
      this.build.length && (this.raw += `+${this.build.join(".")}`),
      this
    );
  }
};
var Pi = Eve;
const BM = Pi,
  Tve = (t, e, r = !1) => {
    if (t instanceof BM) return t;
    try {
      return new BM(t, e);
    } catch (n) {
      if (!r) return null;
      throw n;
    }
  };
var Dd = Tve;
const Cve = Dd,
  Ave = (t, e) => {
    const r = Cve(t, e);
    return r ? r.version : null;
  };
var kve = Ave;
const Sve = Dd,
  Mve = (t, e) => {
    const r = Sve(t.trim().replace(/^[=v]+/, ""), e);
    return r ? r.version : null;
  };
var Ive = Mve;
const DM = Pi,
  Rve = (t, e, r, n, i) => {
    typeof r == "string" && ((i = n), (n = r), (r = void 0));
    try {
      return new DM(t instanceof DM ? t.version : t, r).inc(e, n, i).version;
    } catch {
      return null;
    }
  };
var Pve = Rve;
const OM = Dd,
  Nve = (t, e) => {
    const r = OM(t, null, !0),
      n = OM(e, null, !0),
      i = r.compare(n);
    if (i === 0) return null;
    const a = i > 0,
      s = a ? r : n,
      o = a ? n : r,
      c = !!s.prerelease.length;
    if (!!o.prerelease.length && !c)
      return !o.patch && !o.minor
        ? "major"
        : s.patch
        ? "patch"
        : s.minor
        ? "minor"
        : "major";
    const d = c ? "pre" : "";
    return r.major !== n.major
      ? d + "major"
      : r.minor !== n.minor
      ? d + "minor"
      : r.patch !== n.patch
      ? d + "patch"
      : "prerelease";
  };
var Bve = Nve;
const Dve = Pi,
  Ove = (t, e) => new Dve(t, e).major;
var Fve = Ove;
const Lve = Pi,
  $ve = (t, e) => new Lve(t, e).minor;
var Uve = $ve;
const Wve = Pi,
  jve = (t, e) => new Wve(t, e).patch;
var Hve = jve;
const zve = Dd,
  qve = (t, e) => {
    const r = zve(t, e);
    return r && r.prerelease.length ? r.prerelease : null;
  };
var Vve = qve;
const FM = Pi,
  Kve = (t, e, r) => new FM(t, r).compare(new FM(e, r));
var Cs = Kve;
const Gve = Cs,
  Zve = (t, e, r) => Gve(e, t, r);
var Jve = Zve;
const Qve = Cs,
  Yve = (t, e) => Qve(t, e, !0);
var Xve = Yve;
const LM = Pi,
  exe = (t, e, r) => {
    const n = new LM(t, r),
      i = new LM(e, r);
    return n.compare(i) || n.compareBuild(i);
  };
var AT = exe;
const txe = AT,
  rxe = (t, e) => t.sort((r, n) => txe(r, n, e));
var nxe = rxe;
const ixe = AT,
  axe = (t, e) => t.sort((r, n) => ixe(n, r, e));
var sxe = axe;
const oxe = Cs,
  cxe = (t, e, r) => oxe(t, e, r) > 0;
var Ex = cxe;
const lxe = Cs,
  uxe = (t, e, r) => lxe(t, e, r) < 0;
var kT = uxe;
const fxe = Cs,
  dxe = (t, e, r) => fxe(t, e, r) === 0;
var yW = dxe;
const hxe = Cs,
  pxe = (t, e, r) => hxe(t, e, r) !== 0;
var gW = pxe;
const mxe = Cs,
  yxe = (t, e, r) => mxe(t, e, r) >= 0;
var ST = yxe;
const gxe = Cs,
  bxe = (t, e, r) => gxe(t, e, r) <= 0;
var MT = bxe;
const vxe = yW,
  xxe = gW,
  wxe = Ex,
  _xe = ST,
  Exe = kT,
  Txe = MT,
  Cxe = (t, e, r, n) => {
    switch (e) {
      case "===":
        return (
          typeof t == "object" && (t = t.version),
          typeof r == "object" && (r = r.version),
          t === r
        );
      case "!==":
        return (
          typeof t == "object" && (t = t.version),
          typeof r == "object" && (r = r.version),
          t !== r
        );
      case "":
      case "=":
      case "==":
        return vxe(t, r, n);
      case "!=":
        return xxe(t, r, n);
      case ">":
        return wxe(t, r, n);
      case ">=":
        return _xe(t, r, n);
      case "<":
        return Exe(t, r, n);
      case "<=":
        return Txe(t, r, n);
      default:
        throw new TypeError(`Invalid operator: ${e}`);
    }
  };
var bW = Cxe;
const Axe = Pi,
  kxe = Dd,
  { safeRe: xy, t: wy } = m1,
  Sxe = (t, e) => {
    if (t instanceof Axe) return t;
    if ((typeof t == "number" && (t = String(t)), typeof t != "string"))
      return null;
    e = e || {};
    let r = null;
    if (!e.rtl)
      r = t.match(e.includePrerelease ? xy[wy.COERCEFULL] : xy[wy.COERCE]);
    else {
      const c = e.includePrerelease ? xy[wy.COERCERTLFULL] : xy[wy.COERCERTL];
      let u;
      for (; (u = c.exec(t)) && (!r || r.index + r[0].length !== t.length); )
        (!r || u.index + u[0].length !== r.index + r[0].length) && (r = u),
          (c.lastIndex = u.index + u[1].length + u[2].length);
      c.lastIndex = -1;
    }
    if (r === null) return null;
    const n = r[2],
      i = r[3] || "0",
      a = r[4] || "0",
      s = e.includePrerelease && r[5] ? `-${r[5]}` : "",
      o = e.includePrerelease && r[6] ? `+${r[6]}` : "";
    return kxe(`${n}.${i}.${a}${s}${o}`, e);
  };
var Mxe = Sxe;
class Ixe {
  constructor() {
    (this.max = 1e3), (this.map = new Map());
  }
  get(e) {
    const r = this.map.get(e);
    if (r !== void 0) return this.map.delete(e), this.map.set(e, r), r;
  }
  delete(e) {
    return this.map.delete(e);
  }
  set(e, r) {
    if (!this.delete(e) && r !== void 0) {
      if (this.map.size >= this.max) {
        const i = this.map.keys().next().value;
        this.delete(i);
      }
      this.map.set(e, r);
    }
    return this;
  }
}
var Rxe = Ixe,
  x5,
  $M;
function As() {
  if ($M) return x5;
  $M = 1;
  const t = /\s+/g;
  class e {
    constructor(g, T) {
      if (((T = i(T)), g instanceof e))
        return g.loose === !!T.loose &&
          g.includePrerelease === !!T.includePrerelease
          ? g
          : new e(g.raw, T);
      if (g instanceof a)
        return (
          (this.raw = g.value),
          (this.set = [[g]]),
          (this.formatted = void 0),
          this
        );
      if (
        ((this.options = T),
        (this.loose = !!T.loose),
        (this.includePrerelease = !!T.includePrerelease),
        (this.raw = g.trim().replace(t, " ")),
        (this.set = this.raw
          .split("||")
          .map((R) => this.parseRange(R.trim()))
          .filter((R) => R.length)),
        !this.set.length)
      )
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        const R = this.set[0];
        if (
          ((this.set = this.set.filter((x) => !I(x[0]))), this.set.length === 0)
        )
          this.set = [R];
        else if (this.set.length > 1) {
          for (const x of this.set)
            if (x.length === 1 && b(x[0])) {
              this.set = [x];
              break;
            }
        }
      }
      this.formatted = void 0;
    }
    get range() {
      if (this.formatted === void 0) {
        this.formatted = "";
        for (let g = 0; g < this.set.length; g++) {
          g > 0 && (this.formatted += "||");
          const T = this.set[g];
          for (let R = 0; R < T.length; R++)
            R > 0 && (this.formatted += " "),
              (this.formatted += T[R].toString().trim());
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(g) {
      const R =
          ((this.options.includePrerelease && E) | (this.options.loose && A)) +
          ":" +
          g,
        x = n.get(R);
      if (x) return x;
      const f = this.options.loose,
        _ = f ? c[u.HYPHENRANGELOOSE] : c[u.HYPHENRANGE];
      (g = g.replace(_, p(this.options.includePrerelease))),
        s("hyphen replace", g),
        (g = g.replace(c[u.COMPARATORTRIM], d)),
        s("comparator trim", g),
        (g = g.replace(c[u.TILDETRIM], m)),
        s("tilde trim", g),
        (g = g.replace(c[u.CARETTRIM], v)),
        s("caret trim", g);
      let P = g
        .split(" ")
        .map((B) => S(B, this.options))
        .join(" ")
        .split(/\s+/)
        .map((B) => l(B, this.options));
      f &&
        (P = P.filter(
          (B) => (
            s("loose invalid filter", B, this.options),
            !!B.match(c[u.COMPARATORLOOSE])
          )
        )),
        s("range list", P);
      const M = new Map(),
        D = P.map((B) => new a(B, this.options));
      for (const B of D) {
        if (I(B)) return [B];
        M.set(B.value, B);
      }
      M.size > 1 && M.has("") && M.delete("");
      const q = [...M.values()];
      return n.set(R, q), q;
    }
    intersects(g, T) {
      if (!(g instanceof e)) throw new TypeError("a Range is required");
      return this.set.some(
        (R) =>
          w(R, T) &&
          g.set.some(
            (x) => w(x, T) && R.every((f) => x.every((_) => f.intersects(_, T)))
          )
      );
    }
    test(g) {
      if (!g) return !1;
      if (typeof g == "string")
        try {
          g = new o(g, this.options);
        } catch {
          return !1;
        }
      for (let T = 0; T < this.set.length; T++)
        if (y(this.set[T], g, this.options)) return !0;
      return !1;
    }
  }
  x5 = e;
  const r = Rxe,
    n = new r(),
    i = CT,
    a = Tx(),
    s = _x,
    o = Pi,
    {
      safeRe: c,
      t: u,
      comparatorTrimReplace: d,
      tildeTrimReplace: m,
      caretTrimReplace: v,
    } = m1,
    { FLAG_INCLUDE_PRERELEASE: E, FLAG_LOOSE: A } = wx,
    I = (h) => h.value === "<0.0.0-0",
    b = (h) => h.value === "",
    w = (h, g) => {
      let T = !0;
      const R = h.slice();
      let x = R.pop();
      for (; T && R.length; )
        (T = R.every((f) => x.intersects(f, g))), (x = R.pop());
      return T;
    },
    S = (h, g) => (
      s("comp", h, g),
      (h = F(h, g)),
      s("caret", h),
      (h = N(h, g)),
      s("tildes", h),
      (h = j(h, g)),
      s("xrange", h),
      (h = C(h, g)),
      s("stars", h),
      h
    ),
    k = (h) => !h || h.toLowerCase() === "x" || h === "*",
    N = (h, g) =>
      h
        .trim()
        .split(/\s+/)
        .map((T) => O(T, g))
        .join(" "),
    O = (h, g) => {
      const T = g.loose ? c[u.TILDELOOSE] : c[u.TILDE];
      return h.replace(T, (R, x, f, _, P) => {
        s("tilde", h, R, x, f, _, P);
        let M;
        return (
          k(x)
            ? (M = "")
            : k(f)
            ? (M = `>=${x}.0.0 <${+x + 1}.0.0-0`)
            : k(_)
            ? (M = `>=${x}.${f}.0 <${x}.${+f + 1}.0-0`)
            : P
            ? (s("replaceTilde pr", P),
              (M = `>=${x}.${f}.${_}-${P} <${x}.${+f + 1}.0-0`))
            : (M = `>=${x}.${f}.${_} <${x}.${+f + 1}.0-0`),
          s("tilde return", M),
          M
        );
      });
    },
    F = (h, g) =>
      h
        .trim()
        .split(/\s+/)
        .map((T) => V(T, g))
        .join(" "),
    V = (h, g) => {
      s("caret", h, g);
      const T = g.loose ? c[u.CARETLOOSE] : c[u.CARET],
        R = g.includePrerelease ? "-0" : "";
      return h.replace(T, (x, f, _, P, M) => {
        s("caret", h, x, f, _, P, M);
        let D;
        return (
          k(f)
            ? (D = "")
            : k(_)
            ? (D = `>=${f}.0.0${R} <${+f + 1}.0.0-0`)
            : k(P)
            ? f === "0"
              ? (D = `>=${f}.${_}.0${R} <${f}.${+_ + 1}.0-0`)
              : (D = `>=${f}.${_}.0${R} <${+f + 1}.0.0-0`)
            : M
            ? (s("replaceCaret pr", M),
              f === "0"
                ? _ === "0"
                  ? (D = `>=${f}.${_}.${P}-${M} <${f}.${_}.${+P + 1}-0`)
                  : (D = `>=${f}.${_}.${P}-${M} <${f}.${+_ + 1}.0-0`)
                : (D = `>=${f}.${_}.${P}-${M} <${+f + 1}.0.0-0`))
            : (s("no pr"),
              f === "0"
                ? _ === "0"
                  ? (D = `>=${f}.${_}.${P}${R} <${f}.${_}.${+P + 1}-0`)
                  : (D = `>=${f}.${_}.${P}${R} <${f}.${+_ + 1}.0-0`)
                : (D = `>=${f}.${_}.${P} <${+f + 1}.0.0-0`)),
          s("caret return", D),
          D
        );
      });
    },
    j = (h, g) => (
      s("replaceXRanges", h, g),
      h
        .split(/\s+/)
        .map((T) => X(T, g))
        .join(" ")
    ),
    X = (h, g) => {
      h = h.trim();
      const T = g.loose ? c[u.XRANGELOOSE] : c[u.XRANGE];
      return h.replace(T, (R, x, f, _, P, M) => {
        s("xRange", h, R, x, f, _, P, M);
        const D = k(f),
          q = D || k(_),
          B = q || k(P),
          H = B;
        return (
          x === "=" && H && (x = ""),
          (M = g.includePrerelease ? "-0" : ""),
          D
            ? x === ">" || x === "<"
              ? (R = "<0.0.0-0")
              : (R = "*")
            : x && H
            ? (q && (_ = 0),
              (P = 0),
              x === ">"
                ? ((x = ">="),
                  q
                    ? ((f = +f + 1), (_ = 0), (P = 0))
                    : ((_ = +_ + 1), (P = 0)))
                : x === "<=" && ((x = "<"), q ? (f = +f + 1) : (_ = +_ + 1)),
              x === "<" && (M = "-0"),
              (R = `${x + f}.${_}.${P}${M}`))
            : q
            ? (R = `>=${f}.0.0${M} <${+f + 1}.0.0-0`)
            : B && (R = `>=${f}.${_}.0${M} <${f}.${+_ + 1}.0-0`),
          s("xRange return", R),
          R
        );
      });
    },
    C = (h, g) => (s("replaceStars", h, g), h.trim().replace(c[u.STAR], "")),
    l = (h, g) => (
      s("replaceGTE0", h, g),
      h.trim().replace(c[g.includePrerelease ? u.GTE0PRE : u.GTE0], "")
    ),
    p = (h) => (g, T, R, x, f, _, P, M, D, q, B, H) => (
      k(R)
        ? (T = "")
        : k(x)
        ? (T = `>=${R}.0.0${h ? "-0" : ""}`)
        : k(f)
        ? (T = `>=${R}.${x}.0${h ? "-0" : ""}`)
        : _
        ? (T = `>=${T}`)
        : (T = `>=${T}${h ? "-0" : ""}`),
      k(D)
        ? (M = "")
        : k(q)
        ? (M = `<${+D + 1}.0.0-0`)
        : k(B)
        ? (M = `<${D}.${+q + 1}.0-0`)
        : H
        ? (M = `<=${D}.${q}.${B}-${H}`)
        : h
        ? (M = `<${D}.${q}.${+B + 1}-0`)
        : (M = `<=${M}`),
      `${T} ${M}`.trim()
    ),
    y = (h, g, T) => {
      for (let R = 0; R < h.length; R++) if (!h[R].test(g)) return !1;
      if (g.prerelease.length && !T.includePrerelease) {
        for (let R = 0; R < h.length; R++)
          if (
            (s(h[R].semver),
            h[R].semver !== a.ANY && h[R].semver.prerelease.length > 0)
          ) {
            const x = h[R].semver;
            if (
              x.major === g.major &&
              x.minor === g.minor &&
              x.patch === g.patch
            )
              return !0;
          }
        return !1;
      }
      return !0;
    };
  return x5;
}
var w5, UM;
function Tx() {
  if (UM) return w5;
  UM = 1;
  const t = Symbol("SemVer ANY");
  class e {
    static get ANY() {
      return t;
    }
    constructor(d, m) {
      if (((m = r(m)), d instanceof e)) {
        if (d.loose === !!m.loose) return d;
        d = d.value;
      }
      (d = d.trim().split(/\s+/).join(" ")),
        s("comparator", d, m),
        (this.options = m),
        (this.loose = !!m.loose),
        this.parse(d),
        this.semver === t
          ? (this.value = "")
          : (this.value = this.operator + this.semver.version),
        s("comp", this);
    }
    parse(d) {
      const m = this.options.loose ? n[i.COMPARATORLOOSE] : n[i.COMPARATOR],
        v = d.match(m);
      if (!v) throw new TypeError(`Invalid comparator: ${d}`);
      (this.operator = v[1] !== void 0 ? v[1] : ""),
        this.operator === "=" && (this.operator = ""),
        v[2]
          ? (this.semver = new o(v[2], this.options.loose))
          : (this.semver = t);
    }
    toString() {
      return this.value;
    }
    test(d) {
      if (
        (s("Comparator.test", d, this.options.loose),
        this.semver === t || d === t)
      )
        return !0;
      if (typeof d == "string")
        try {
          d = new o(d, this.options);
        } catch {
          return !1;
        }
      return a(d, this.operator, this.semver, this.options);
    }
    intersects(d, m) {
      if (!(d instanceof e)) throw new TypeError("a Comparator is required");
      return this.operator === ""
        ? this.value === ""
          ? !0
          : new c(d.value, m).test(this.value)
        : d.operator === ""
        ? d.value === ""
          ? !0
          : new c(this.value, m).test(d.semver)
        : ((m = r(m)),
          (m.includePrerelease &&
            (this.value === "<0.0.0-0" || d.value === "<0.0.0-0")) ||
          (!m.includePrerelease &&
            (this.value.startsWith("<0.0.0") || d.value.startsWith("<0.0.0")))
            ? !1
            : !!(
                (this.operator.startsWith(">") && d.operator.startsWith(">")) ||
                (this.operator.startsWith("<") && d.operator.startsWith("<")) ||
                (this.semver.version === d.semver.version &&
                  this.operator.includes("=") &&
                  d.operator.includes("=")) ||
                (a(this.semver, "<", d.semver, m) &&
                  this.operator.startsWith(">") &&
                  d.operator.startsWith("<")) ||
                (a(this.semver, ">", d.semver, m) &&
                  this.operator.startsWith("<") &&
                  d.operator.startsWith(">"))
              ));
    }
  }
  w5 = e;
  const r = CT,
    { safeRe: n, t: i } = m1,
    a = bW,
    s = _x,
    o = Pi,
    c = As();
  return w5;
}
const Pxe = As(),
  Nxe = (t, e, r) => {
    try {
      e = new Pxe(e, r);
    } catch {
      return !1;
    }
    return e.test(t);
  };
var Cx = Nxe;
const Bxe = As(),
  Dxe = (t, e) =>
    new Bxe(t, e).set.map((r) =>
      r
        .map((n) => n.value)
        .join(" ")
        .trim()
        .split(" ")
    );
var Oxe = Dxe;
const Fxe = Pi,
  Lxe = As(),
  $xe = (t, e, r) => {
    let n = null,
      i = null,
      a = null;
    try {
      a = new Lxe(e, r);
    } catch {
      return null;
    }
    return (
      t.forEach((s) => {
        a.test(s) &&
          (!n || i.compare(s) === -1) &&
          ((n = s), (i = new Fxe(n, r)));
      }),
      n
    );
  };
var Uxe = $xe;
const Wxe = Pi,
  jxe = As(),
  Hxe = (t, e, r) => {
    let n = null,
      i = null,
      a = null;
    try {
      a = new jxe(e, r);
    } catch {
      return null;
    }
    return (
      t.forEach((s) => {
        a.test(s) &&
          (!n || i.compare(s) === 1) &&
          ((n = s), (i = new Wxe(n, r)));
      }),
      n
    );
  };
var zxe = Hxe;
const _5 = Pi,
  qxe = As(),
  WM = Ex,
  Vxe = (t, e) => {
    t = new qxe(t, e);
    let r = new _5("0.0.0");
    if (t.test(r) || ((r = new _5("0.0.0-0")), t.test(r))) return r;
    r = null;
    for (let n = 0; n < t.set.length; ++n) {
      const i = t.set[n];
      let a = null;
      i.forEach((s) => {
        const o = new _5(s.semver.version);
        switch (s.operator) {
          case ">":
            o.prerelease.length === 0 ? o.patch++ : o.prerelease.push(0),
              (o.raw = o.format());
          case "":
          case ">=":
            (!a || WM(o, a)) && (a = o);
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error(`Unexpected operation: ${s.operator}`);
        }
      }),
        a && (!r || WM(r, a)) && (r = a);
    }
    return r && t.test(r) ? r : null;
  };
var Kxe = Vxe;
const Gxe = As(),
  Zxe = (t, e) => {
    try {
      return new Gxe(t, e).range || "*";
    } catch {
      return null;
    }
  };
var Jxe = Zxe;
const Qxe = Pi,
  vW = Tx(),
  { ANY: Yxe } = vW,
  Xxe = As(),
  ewe = Cx,
  jM = Ex,
  HM = kT,
  twe = MT,
  rwe = ST,
  nwe = (t, e, r, n) => {
    (t = new Qxe(t, n)), (e = new Xxe(e, n));
    let i, a, s, o, c;
    switch (r) {
      case ">":
        (i = jM), (a = twe), (s = HM), (o = ">"), (c = ">=");
        break;
      case "<":
        (i = HM), (a = rwe), (s = jM), (o = "<"), (c = "<=");
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (ewe(t, e, n)) return !1;
    for (let u = 0; u < e.set.length; ++u) {
      const d = e.set[u];
      let m = null,
        v = null;
      if (
        (d.forEach((E) => {
          E.semver === Yxe && (E = new vW(">=0.0.0")),
            (m = m || E),
            (v = v || E),
            i(E.semver, m.semver, n)
              ? (m = E)
              : s(E.semver, v.semver, n) && (v = E);
        }),
        m.operator === o ||
          m.operator === c ||
          ((!v.operator || v.operator === o) && a(t, v.semver)))
      )
        return !1;
      if (v.operator === c && s(t, v.semver)) return !1;
    }
    return !0;
  };
var IT = nwe;
const iwe = IT,
  awe = (t, e, r) => iwe(t, e, ">", r);
var swe = awe;
const owe = IT,
  cwe = (t, e, r) => owe(t, e, "<", r);
var lwe = cwe;
const zM = As(),
  uwe = (t, e, r) => (
    (t = new zM(t, r)), (e = new zM(e, r)), t.intersects(e, r)
  );
var fwe = uwe;
const dwe = Cx,
  hwe = Cs;
var pwe = (t, e, r) => {
  const n = [];
  let i = null,
    a = null;
  const s = t.sort((d, m) => hwe(d, m, r));
  for (const d of s)
    dwe(d, e, r)
      ? ((a = d), i || (i = d))
      : (a && n.push([i, a]), (a = null), (i = null));
  i && n.push([i, null]);
  const o = [];
  for (const [d, m] of n)
    d === m
      ? o.push(d)
      : !m && d === s[0]
      ? o.push("*")
      : m
      ? d === s[0]
        ? o.push(`<=${m}`)
        : o.push(`${d} - ${m}`)
      : o.push(`>=${d}`);
  const c = o.join(" || "),
    u = typeof e.raw == "string" ? e.raw : String(e);
  return c.length < u.length ? c : e;
};
const qM = As(),
  RT = Tx(),
  { ANY: E5 } = RT,
  oh = Cx,
  PT = Cs,
  mwe = (t, e, r = {}) => {
    if (t === e) return !0;
    (t = new qM(t, r)), (e = new qM(e, r));
    let n = !1;
    e: for (const i of t.set) {
      for (const a of e.set) {
        const s = gwe(i, a, r);
        if (((n = n || s !== null), s)) continue e;
      }
      if (n) return !1;
    }
    return !0;
  },
  ywe = [new RT(">=0.0.0-0")],
  VM = [new RT(">=0.0.0")],
  gwe = (t, e, r) => {
    if (t === e) return !0;
    if (t.length === 1 && t[0].semver === E5) {
      if (e.length === 1 && e[0].semver === E5) return !0;
      r.includePrerelease ? (t = ywe) : (t = VM);
    }
    if (e.length === 1 && e[0].semver === E5) {
      if (r.includePrerelease) return !0;
      e = VM;
    }
    const n = new Set();
    let i, a;
    for (const E of t)
      E.operator === ">" || E.operator === ">="
        ? (i = KM(i, E, r))
        : E.operator === "<" || E.operator === "<="
        ? (a = GM(a, E, r))
        : n.add(E.semver);
    if (n.size > 1) return null;
    let s;
    if (i && a) {
      if (((s = PT(i.semver, a.semver, r)), s > 0)) return null;
      if (s === 0 && (i.operator !== ">=" || a.operator !== "<=")) return null;
    }
    for (const E of n) {
      if ((i && !oh(E, String(i), r)) || (a && !oh(E, String(a), r)))
        return null;
      for (const A of e) if (!oh(E, String(A), r)) return !1;
      return !0;
    }
    let o,
      c,
      u,
      d,
      m =
        a && !r.includePrerelease && a.semver.prerelease.length ? a.semver : !1,
      v =
        i && !r.includePrerelease && i.semver.prerelease.length ? i.semver : !1;
    m &&
      m.prerelease.length === 1 &&
      a.operator === "<" &&
      m.prerelease[0] === 0 &&
      (m = !1);
    for (const E of e) {
      if (
        ((d = d || E.operator === ">" || E.operator === ">="),
        (u = u || E.operator === "<" || E.operator === "<="),
        i)
      ) {
        if (
          (v &&
            E.semver.prerelease &&
            E.semver.prerelease.length &&
            E.semver.major === v.major &&
            E.semver.minor === v.minor &&
            E.semver.patch === v.patch &&
            (v = !1),
          E.operator === ">" || E.operator === ">=")
        ) {
          if (((o = KM(i, E, r)), o === E && o !== i)) return !1;
        } else if (i.operator === ">=" && !oh(i.semver, String(E), r))
          return !1;
      }
      if (a) {
        if (
          (m &&
            E.semver.prerelease &&
            E.semver.prerelease.length &&
            E.semver.major === m.major &&
            E.semver.minor === m.minor &&
            E.semver.patch === m.patch &&
            (m = !1),
          E.operator === "<" || E.operator === "<=")
        ) {
          if (((c = GM(a, E, r)), c === E && c !== a)) return !1;
        } else if (a.operator === "<=" && !oh(a.semver, String(E), r))
          return !1;
      }
      if (!E.operator && (a || i) && s !== 0) return !1;
    }
    return !((i && u && !a && s !== 0) || (a && d && !i && s !== 0) || v || m);
  },
  KM = (t, e, r) => {
    if (!t) return e;
    const n = PT(t.semver, e.semver, r);
    return n > 0
      ? t
      : n < 0 || (e.operator === ">" && t.operator === ">=")
      ? e
      : t;
  },
  GM = (t, e, r) => {
    if (!t) return e;
    const n = PT(t.semver, e.semver, r);
    return n < 0
      ? t
      : n > 0 || (e.operator === "<" && t.operator === "<=")
      ? e
      : t;
  };
var bwe = mwe;
const T5 = m1,
  ZM = wx,
  vwe = Pi,
  JM = mW,
  xwe = Dd,
  wwe = kve,
  _we = Ive,
  Ewe = Pve,
  Twe = Bve,
  Cwe = Fve,
  Awe = Uve,
  kwe = Hve,
  Swe = Vve,
  Mwe = Cs,
  Iwe = Jve,
  Rwe = Xve,
  Pwe = AT,
  Nwe = nxe,
  Bwe = sxe,
  Dwe = Ex,
  Owe = kT,
  Fwe = yW,
  Lwe = gW,
  $we = ST,
  Uwe = MT,
  Wwe = bW,
  jwe = Mxe,
  Hwe = Tx(),
  zwe = As(),
  qwe = Cx,
  Vwe = Oxe,
  Kwe = Uxe,
  Gwe = zxe,
  Zwe = Kxe,
  Jwe = Jxe,
  Qwe = IT,
  Ywe = swe,
  Xwe = lwe,
  e3e = fwe,
  t3e = pwe,
  r3e = bwe;
var n3e = {
  parse: xwe,
  valid: wwe,
  clean: _we,
  inc: Ewe,
  diff: Twe,
  major: Cwe,
  minor: Awe,
  patch: kwe,
  prerelease: Swe,
  compare: Mwe,
  rcompare: Iwe,
  compareLoose: Rwe,
  compareBuild: Pwe,
  sort: Nwe,
  rsort: Bwe,
  gt: Dwe,
  lt: Owe,
  eq: Fwe,
  neq: Lwe,
  gte: $we,
  lte: Uwe,
  cmp: Wwe,
  coerce: jwe,
  Comparator: Hwe,
  Range: zwe,
  satisfies: qwe,
  toComparators: Vwe,
  maxSatisfying: Kwe,
  minSatisfying: Gwe,
  minVersion: Zwe,
  validRange: Jwe,
  outside: Qwe,
  gtr: Ywe,
  ltr: Xwe,
  intersects: e3e,
  simplifyRange: t3e,
  subset: r3e,
  SemVer: vwe,
  re: T5.re,
  src: T5.src,
  tokens: T5.t,
  SEMVER_SPEC_VERSION: ZM.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: ZM.RELEASE_TYPES,
  compareIdentifiers: JM.compareIdentifiers,
  rcompareIdentifiers: JM.rcompareIdentifiers,
};
(function (t) {
  Object.defineProperty(t, "__esModule", {
    value: !0,
  }),
    (t.satisfiesVersionRange =
      t.gtRange =
      t.gtVersion =
      t.assertIsSemVerRange =
      t.assertIsSemVerVersion =
      t.isValidSemVerRange =
      t.isValidSemVerVersion =
      t.VersionRangeStruct =
      t.VersionStruct =
        void 0);
  const e = n3e,
    r = qu,
    n = Vn;
  (t.VersionStruct = (0, r.refine)((0, r.string)(), "Version", (m) =>
    (0, e.valid)(m) === null ? `Expected SemVer version, got "${m}"` : !0
  )),
    (t.VersionRangeStruct = (0, r.refine)(
      (0, r.string)(),
      "Version range",
      (m) =>
        (0, e.validRange)(m) === null ? `Expected SemVer range, got "${m}"` : !0
    ));
  function i(m) {
    return (0, r.is)(m, t.VersionStruct);
  }
  t.isValidSemVerVersion = i;
  function a(m) {
    return (0, r.is)(m, t.VersionRangeStruct);
  }
  t.isValidSemVerRange = a;
  function s(m) {
    (0, n.assertStruct)(m, t.VersionStruct);
  }
  t.assertIsSemVerVersion = s;
  function o(m) {
    (0, n.assertStruct)(m, t.VersionRangeStruct);
  }
  t.assertIsSemVerRange = o;
  function c(m, v) {
    return (0, e.gt)(m, v);
  }
  t.gtVersion = c;
  function u(m, v) {
    return (0, e.gtr)(m, v);
  }
  t.gtRange = u;
  function d(m, v) {
    return (0, e.satisfies)(m, v, {
      includePrerelease: !0,
    });
  }
  t.satisfiesVersionRange = d;
})(dW);
(function (t) {
  var e =
      (ke && ke.__createBinding) ||
      (Object.create
        ? function (n, i, a, s) {
            s === void 0 && (s = a);
            var o = Object.getOwnPropertyDescriptor(i, a);
            (!o ||
              ("get" in o ? !i.__esModule : o.writable || o.configurable)) &&
              (o = {
                enumerable: !0,
                get: function () {
                  return i[a];
                },
              }),
              Object.defineProperty(n, s, o);
          }
        : function (n, i, a, s) {
            s === void 0 && (s = a), (n[s] = i[a]);
          }),
    r =
      (ke && ke.__exportStar) ||
      function (n, i) {
        for (var a in n)
          a !== "default" &&
            !Object.prototype.hasOwnProperty.call(i, a) &&
            e(i, n, a);
      };
  Object.defineProperty(t, "__esModule", {
    value: !0,
  }),
    r(Vn, t),
    r(h1, t),
    r(Ht, t),
    r(vx, t),
    r(Js, t),
    r(Gf, t),
    r(aW, t),
    r(p1, t),
    r(sW, t),
    r(oW, t),
    r(Zf, t),
    r(cW, t),
    r(Qs, t),
    r(lW, t),
    r(uW, t),
    r(fW, t),
    r(dW, t);
})(UU);
(function (t) {
  Object.defineProperty(t, "__esModule", {
    value: !0,
  }),
    (t.createModuleLogger = t.projectLogger = void 0);
  const e = UU;
  Object.defineProperty(t, "createModuleLogger", {
    enumerable: !0,
    get: function () {
      return e.createModuleLogger;
    },
  }),
    (t.projectLogger = (0, e.createProjectLogger)("eth-block-tracker"));
})($U);
var xW =
  (ke && ke.__importDefault) ||
  function (t) {
    return t && t.__esModule
      ? t
      : {
          default: t,
        };
  };
Object.defineProperty(gx, "__esModule", {
  value: !0,
});
gx.PollingBlockTracker = void 0;
const i3e = xW(yT),
  a3e = xW(I2e),
  s3e = l1,
  QM = $U,
  YM = (0, QM.createModuleLogger)(QM.projectLogger, "polling-block-tracker"),
  o3e = (0, i3e.default)(),
  c3e = 1e3;
class l3e extends s3e.BaseBlockTracker {
  constructor(e = {}) {
    var r;
    if (!e.provider)
      throw new Error("PollingBlockTracker - no provider specified.");
    super(
      Object.assign(Object.assign({}, e), {
        blockResetDuration:
          (r = e.blockResetDuration) !== null && r !== void 0
            ? r
            : e.pollingInterval,
      })
    ),
      (this._provider = e.provider),
      (this._pollingInterval = e.pollingInterval || 20 * c3e),
      (this._retryTimeout = e.retryTimeout || this._pollingInterval / 10),
      (this._keepEventLoopActive =
        e.keepEventLoopActive === void 0 ? !0 : e.keepEventLoopActive),
      (this._setSkipCacheFlag = e.setSkipCacheFlag || !1);
  }
  async checkForLatestBlock() {
    return await this._updateLatestBlock(), await this.getLatestBlock();
  }
  async _start() {
    this._synchronize();
  }
  async _end() {}
  async _synchronize() {
    for (var e; this._isRunning; )
      try {
        await this._updateLatestBlock();
        const r = XM(this._pollingInterval, !this._keepEventLoopActive);
        this.emit("_waitingForNextIteration"), await r;
      } catch (r) {
        const n =
          new Error(`PollingBlockTracker - encountered an error while attempting to update latest block:
${(e = r.stack) !== null && e !== void 0 ? e : r}`);
        try {
          this.emit("error", n);
        } catch {
          console.error(n);
        }
        const i = XM(this._retryTimeout, !this._keepEventLoopActive);
        this.emit("_waitingForNextIteration"), await i;
      }
  }
  async _updateLatestBlock() {
    const e = await this._fetchLatestBlock();
    this._newPotentialLatest(e);
  }
  async _fetchLatestBlock() {
    const e = {
      jsonrpc: "2.0",
      id: o3e(),
      method: "eth_blockNumber",
      params: [],
    };
    this._setSkipCacheFlag && (e.skipCache = !0), YM("Making request", e);
    const r = await (0, a3e.default)((n) => this._provider.sendAsync(e, n))();
    if ((YM("Got response", r), r.error))
      throw new Error(`PollingBlockTracker - encountered error fetching block:
${r.error.message}`);
    return r.result;
  }
}
gx.PollingBlockTracker = l3e;
function XM(t, e) {
  return new Promise((r) => {
    const n = setTimeout(r, t);
    n.unref && e && n.unref();
  });
}
var Ax = {},
  u3e =
    (ke && ke.__importDefault) ||
    function (t) {
      return t && t.__esModule
        ? t
        : {
            default: t,
          };
    };
Object.defineProperty(Ax, "__esModule", {
  value: !0,
});
Ax.SubscribeBlockTracker = void 0;
const f3e = u3e(yT),
  d3e = l1,
  h3e = (0, f3e.default)();
class p3e extends d3e.BaseBlockTracker {
  constructor(e = {}) {
    if (!e.provider)
      throw new Error("SubscribeBlockTracker - no provider specified.");
    super(e), (this._provider = e.provider), (this._subscriptionId = null);
  }
  async checkForLatestBlock() {
    return await this.getLatestBlock();
  }
  async _start() {
    if (this._subscriptionId === void 0 || this._subscriptionId === null)
      try {
        const e = await this._call("eth_blockNumber");
        (this._subscriptionId = await this._call("eth_subscribe", "newHeads")),
          this._provider.on("data", this._handleSubData.bind(this)),
          this._newPotentialLatest(e);
      } catch (e) {
        this.emit("error", e);
      }
  }
  async _end() {
    if (this._subscriptionId !== null && this._subscriptionId !== void 0)
      try {
        await this._call("eth_unsubscribe", this._subscriptionId),
          (this._subscriptionId = null);
      } catch (e) {
        this.emit("error", e);
      }
  }
  _call(e, ...r) {
    return new Promise((n, i) => {
      this._provider.sendAsync(
        {
          id: h3e(),
          method: e,
          params: r,
          jsonrpc: "2.0",
        },
        (a, s) => {
          a ? i(a) : n(s.result);
        }
      );
    });
  }
  _handleSubData(e, r) {
    var n;
    r.method === "eth_subscription" &&
      ((n = r.params) === null || n === void 0 ? void 0 : n.subscription) ===
        this._subscriptionId &&
      this._newPotentialLatest(r.params.result.number);
  }
}
Ax.SubscribeBlockTracker = p3e;
(function (t) {
  var e =
      (ke && ke.__createBinding) ||
      (Object.create
        ? function (n, i, a, s) {
            s === void 0 && (s = a),
              Object.defineProperty(n, s, {
                enumerable: !0,
                get: function () {
                  return i[a];
                },
              });
          }
        : function (n, i, a, s) {
            s === void 0 && (s = a), (n[s] = i[a]);
          }),
    r =
      (ke && ke.__exportStar) ||
      function (n, i) {
        for (var a in n)
          a !== "default" &&
            !Object.prototype.hasOwnProperty.call(i, a) &&
            e(i, n, a);
      };
  Object.defineProperty(t, "__esModule", {
    value: !0,
  }),
    r(gx, t),
    r(Ax, t);
})(LU);
var NT = {},
  kx = {},
  y1 = {};
Object.defineProperty(y1, "__esModule", {
  value: !0,
});
y1.getUniqueId = void 0;
const wW = 4294967295;
let C5 = Math.floor(Math.random() * wW);
function m3e() {
  return (C5 = (C5 + 1) % wW), C5;
}
y1.getUniqueId = m3e;
Object.defineProperty(kx, "__esModule", {
  value: !0,
});
kx.createIdRemapMiddleware = void 0;
const y3e = y1;
function g3e() {
  return (t, e, r, n) => {
    const i = t.id,
      a = y3e.getUniqueId();
    (t.id = a),
      (e.id = a),
      r((s) => {
        (t.id = i), (e.id = i), s();
      });
  };
}
kx.createIdRemapMiddleware = g3e;
var Sx = {};
Object.defineProperty(Sx, "__esModule", {
  value: !0,
});
Sx.createAsyncMiddleware = void 0;
function b3e(t) {
  return async (e, r, n, i) => {
    let a;
    const s = new Promise((d) => {
      a = d;
    });
    let o = null,
      c = !1;
    const u = async () => {
      (c = !0),
        n((d) => {
          (o = d), a();
        }),
        await s;
    };
    try {
      await t(e, r, u), c ? (await s, o(null)) : i(null);
    } catch (d) {
      o ? o(d) : i(d);
    }
  };
}
Sx.createAsyncMiddleware = b3e;
var Mx = {};
Object.defineProperty(Mx, "__esModule", {
  value: !0,
});
Mx.createScaffoldMiddleware = void 0;
function v3e(t) {
  return (e, r, n, i) => {
    const a = t[e.method];
    return a === void 0
      ? n()
      : typeof a == "function"
      ? a(e, r, n, i)
      : ((r.result = a), i());
  };
}
Mx.createScaffoldMiddleware = v3e;
var g1 = {},
  BT = {};
Object.defineProperty(BT, "__esModule", {
  value: !0,
});
const x3e = Cd;
function eI(t, e, r) {
  try {
    Reflect.apply(t, e, r);
  } catch (n) {
    setTimeout(() => {
      throw n;
    });
  }
}
function w3e(t) {
  const e = t.length,
    r = new Array(e);
  for (let n = 0; n < e; n += 1) r[n] = t[n];
  return r;
}
let _3e = class extends x3e.EventEmitter {
  emit(e, ...r) {
    let n = e === "error";
    const i = this._events;
    if (i !== void 0) n = n && i.error === void 0;
    else if (!n) return !1;
    if (n) {
      let s;
      if ((r.length > 0 && ([s] = r), s instanceof Error)) throw s;
      const o = new Error(`Unhandled error.${s ? ` (${s.message})` : ""}`);
      throw ((o.context = s), o);
    }
    const a = i[e];
    if (a === void 0) return !1;
    if (typeof a == "function") eI(a, this, r);
    else {
      const s = a.length,
        o = w3e(a);
      for (let c = 0; c < s; c += 1) eI(o[c], this, r);
    }
    return !0;
  }
};
BT.default = _3e;
var _W = {},
  sl = {},
  E3e = hm;
hm.default = hm;
hm.stable = CW;
hm.stableStringify = CW;
var fb = "[...]",
  EW = "[Circular]",
  Cu = [],
  Ql = [];
function TW() {
  return {
    depthLimit: Number.MAX_SAFE_INTEGER,
    edgesLimit: Number.MAX_SAFE_INTEGER,
  };
}
function hm(t, e, r, n) {
  typeof n > "u" && (n = TW()), b4(t, "", 0, [], void 0, 0, n);
  var i;
  try {
    Ql.length === 0
      ? (i = JSON.stringify(t, e, r))
      : (i = JSON.stringify(t, AW(e), r));
  } catch {
    return JSON.stringify(
      "[unable to serialize, circular reference is too complex to analyze]"
    );
  } finally {
    for (; Cu.length !== 0; ) {
      var a = Cu.pop();
      a.length === 4
        ? Object.defineProperty(a[0], a[1], a[3])
        : (a[0][a[1]] = a[2]);
    }
  }
  return i;
}
function af(t, e, r, n) {
  var i = Object.getOwnPropertyDescriptor(n, r);
  i.get !== void 0
    ? i.configurable
      ? (Object.defineProperty(n, r, {
          value: t,
        }),
        Cu.push([n, r, e, i]))
      : Ql.push([e, r, t])
    : ((n[r] = t), Cu.push([n, r, e]));
}
function b4(t, e, r, n, i, a, s) {
  a += 1;
  var o;
  if (typeof t == "object" && t !== null) {
    for (o = 0; o < n.length; o++)
      if (n[o] === t) {
        af(EW, t, e, i);
        return;
      }
    if (typeof s.depthLimit < "u" && a > s.depthLimit) {
      af(fb, t, e, i);
      return;
    }
    if (typeof s.edgesLimit < "u" && r + 1 > s.edgesLimit) {
      af(fb, t, e, i);
      return;
    }
    if ((n.push(t), Array.isArray(t)))
      for (o = 0; o < t.length; o++) b4(t[o], o, o, n, t, a, s);
    else {
      var c = Object.keys(t);
      for (o = 0; o < c.length; o++) {
        var u = c[o];
        b4(t[u], u, o, n, t, a, s);
      }
    }
    n.pop();
  }
}
function T3e(t, e) {
  return t < e ? -1 : t > e ? 1 : 0;
}
function CW(t, e, r, n) {
  typeof n > "u" && (n = TW());
  var i = v4(t, "", 0, [], void 0, 0, n) || t,
    a;
  try {
    Ql.length === 0
      ? (a = JSON.stringify(i, e, r))
      : (a = JSON.stringify(i, AW(e), r));
  } catch {
    return JSON.stringify(
      "[unable to serialize, circular reference is too complex to analyze]"
    );
  } finally {
    for (; Cu.length !== 0; ) {
      var s = Cu.pop();
      s.length === 4
        ? Object.defineProperty(s[0], s[1], s[3])
        : (s[0][s[1]] = s[2]);
    }
  }
  return a;
}
function v4(t, e, r, n, i, a, s) {
  a += 1;
  var o;
  if (typeof t == "object" && t !== null) {
    for (o = 0; o < n.length; o++)
      if (n[o] === t) {
        af(EW, t, e, i);
        return;
      }
    try {
      if (typeof t.toJSON == "function") return;
    } catch {
      return;
    }
    if (typeof s.depthLimit < "u" && a > s.depthLimit) {
      af(fb, t, e, i);
      return;
    }
    if (typeof s.edgesLimit < "u" && r + 1 > s.edgesLimit) {
      af(fb, t, e, i);
      return;
    }
    if ((n.push(t), Array.isArray(t)))
      for (o = 0; o < t.length; o++) v4(t[o], o, o, n, t, a, s);
    else {
      var c = {},
        u = Object.keys(t).sort(T3e);
      for (o = 0; o < u.length; o++) {
        var d = u[o];
        v4(t[d], d, o, n, t, a, s), (c[d] = t[d]);
      }
      if (typeof i < "u") Cu.push([i, e, t]), (i[e] = c);
      else return c;
    }
    n.pop();
  }
}
function AW(t) {
  return (
    (t =
      typeof t < "u"
        ? t
        : function (e, r) {
            return r;
          }),
    function (e, r) {
      if (Ql.length > 0)
        for (var n = 0; n < Ql.length; n++) {
          var i = Ql[n];
          if (i[1] === e && i[0] === r) {
            (r = i[2]), Ql.splice(n, 1);
            break;
          }
        }
      return t.call(this, e, r);
    }
  );
}
Object.defineProperty(sl, "__esModule", {
  value: !0,
});
sl.EthereumProviderError = sl.EthereumRpcError = void 0;
const C3e = E3e;
class kW extends Error {
  constructor(e, r, n) {
    if (!Number.isInteger(e)) throw new Error('"code" must be an integer.');
    if (!r || typeof r != "string")
      throw new Error('"message" must be a nonempty string.');
    super(r), (this.code = e), n !== void 0 && (this.data = n);
  }
  serialize() {
    const e = {
      code: this.code,
      message: this.message,
    };
    return (
      this.data !== void 0 && (e.data = this.data),
      this.stack && (e.stack = this.stack),
      e
    );
  }
  toString() {
    return C3e.default(this.serialize(), S3e, 2);
  }
}
sl.EthereumRpcError = kW;
class A3e extends kW {
  constructor(e, r, n) {
    if (!k3e(e))
      throw new Error(
        '"code" must be an integer such that: 1000 <= code <= 4999'
      );
    super(e, r, n);
  }
}
sl.EthereumProviderError = A3e;
function k3e(t) {
  return Number.isInteger(t) && t >= 1e3 && t <= 4999;
}
function S3e(t, e) {
  if (e !== "[Circular]") return e;
}
var DT = {},
  ol = {};
Object.defineProperty(ol, "__esModule", {
  value: !0,
});
ol.errorValues = ol.errorCodes = void 0;
ol.errorCodes = {
  rpc: {
    invalidInput: -32e3,
    resourceNotFound: -32001,
    resourceUnavailable: -32002,
    transactionRejected: -32003,
    methodNotSupported: -32004,
    limitExceeded: -32005,
    parse: -32700,
    invalidRequest: -32600,
    methodNotFound: -32601,
    invalidParams: -32602,
    internal: -32603,
  },
  provider: {
    userRejectedRequest: 4001,
    unauthorized: 4100,
    unsupportedMethod: 4200,
    disconnected: 4900,
    chainDisconnected: 4901,
  },
};
ol.errorValues = {
  "-32700": {
    standard: "JSON RPC 2.0",
    message:
      "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.",
  },
  "-32600": {
    standard: "JSON RPC 2.0",
    message: "The JSON sent is not a valid Request object.",
  },
  "-32601": {
    standard: "JSON RPC 2.0",
    message: "The method does not exist / is not available.",
  },
  "-32602": {
    standard: "JSON RPC 2.0",
    message: "Invalid method parameter(s).",
  },
  "-32603": {
    standard: "JSON RPC 2.0",
    message: "Internal JSON-RPC error.",
  },
  "-32000": {
    standard: "EIP-1474",
    message: "Invalid input.",
  },
  "-32001": {
    standard: "EIP-1474",
    message: "Resource not found.",
  },
  "-32002": {
    standard: "EIP-1474",
    message: "Resource unavailable.",
  },
  "-32003": {
    standard: "EIP-1474",
    message: "Transaction rejected.",
  },
  "-32004": {
    standard: "EIP-1474",
    message: "Method not supported.",
  },
  "-32005": {
    standard: "EIP-1474",
    message: "Request limit exceeded.",
  },
  4001: {
    standard: "EIP-1193",
    message: "User rejected the request.",
  },
  4100: {
    standard: "EIP-1193",
    message:
      "The requested account and/or method has not been authorized by the user.",
  },
  4200: {
    standard: "EIP-1193",
    message: "The requested method is not supported by this Ethereum provider.",
  },
  4900: {
    standard: "EIP-1193",
    message: "The provider is disconnected from all chains.",
  },
  4901: {
    standard: "EIP-1193",
    message: "The provider is disconnected from the specified chain.",
  },
};
(function (t) {
  Object.defineProperty(t, "__esModule", {
    value: !0,
  }),
    (t.serializeError =
      t.isValidCode =
      t.getMessageFromCode =
      t.JSON_RPC_SERVER_ERROR_MESSAGE =
        void 0);
  const e = ol,
    r = sl,
    n = e.errorCodes.rpc.internal,
    i = "Unspecified error message. This is a bug, please report it.",
    a = {
      code: n,
      message: s(n),
    };
  t.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
  function s(v, E = i) {
    if (Number.isInteger(v)) {
      const A = v.toString();
      if (m(e.errorValues, A)) return e.errorValues[A].message;
      if (u(v)) return t.JSON_RPC_SERVER_ERROR_MESSAGE;
    }
    return E;
  }
  t.getMessageFromCode = s;
  function o(v) {
    if (!Number.isInteger(v)) return !1;
    const E = v.toString();
    return !!(e.errorValues[E] || u(v));
  }
  t.isValidCode = o;
  function c(v, { fallbackError: E = a, shouldIncludeStack: A = !1 } = {}) {
    var I, b;
    if (!E || !Number.isInteger(E.code) || typeof E.message != "string")
      throw new Error(
        "Must provide fallback error with integer number code and string message."
      );
    if (v instanceof r.EthereumRpcError) return v.serialize();
    const w = {};
    if (
      v &&
      typeof v == "object" &&
      !Array.isArray(v) &&
      m(v, "code") &&
      o(v.code)
    ) {
      const k = v;
      (w.code = k.code),
        k.message && typeof k.message == "string"
          ? ((w.message = k.message), m(k, "data") && (w.data = k.data))
          : ((w.message = s(w.code)),
            (w.data = {
              originalError: d(v),
            }));
    } else {
      w.code = E.code;
      const k = (I = v) === null || I === void 0 ? void 0 : I.message;
      (w.message = k && typeof k == "string" ? k : E.message),
        (w.data = {
          originalError: d(v),
        });
    }
    const S = (b = v) === null || b === void 0 ? void 0 : b.stack;
    return A && v && S && typeof S == "string" && (w.stack = S), w;
  }
  t.serializeError = c;
  function u(v) {
    return v >= -32099 && v <= -32e3;
  }
  function d(v) {
    return v && typeof v == "object" && !Array.isArray(v)
      ? Object.assign({}, v)
      : v;
  }
  function m(v, E) {
    return Object.prototype.hasOwnProperty.call(v, E);
  }
})(DT);
var Ix = {};
Object.defineProperty(Ix, "__esModule", {
  value: !0,
});
Ix.ethErrors = void 0;
const OT = sl,
  SW = DT,
  ii = ol;
Ix.ethErrors = {
  rpc: {
    parse: (t) => Aa(ii.errorCodes.rpc.parse, t),
    invalidRequest: (t) => Aa(ii.errorCodes.rpc.invalidRequest, t),
    invalidParams: (t) => Aa(ii.errorCodes.rpc.invalidParams, t),
    methodNotFound: (t) => Aa(ii.errorCodes.rpc.methodNotFound, t),
    internal: (t) => Aa(ii.errorCodes.rpc.internal, t),
    server: (t) => {
      if (!t || typeof t != "object" || Array.isArray(t))
        throw new Error(
          "Ethereum RPC Server errors must provide single object argument."
        );
      const { code: e } = t;
      if (!Number.isInteger(e) || e > -32005 || e < -32099)
        throw new Error(
          '"code" must be an integer such that: -32099 <= code <= -32005'
        );
      return Aa(e, t);
    },
    invalidInput: (t) => Aa(ii.errorCodes.rpc.invalidInput, t),
    resourceNotFound: (t) => Aa(ii.errorCodes.rpc.resourceNotFound, t),
    resourceUnavailable: (t) => Aa(ii.errorCodes.rpc.resourceUnavailable, t),
    transactionRejected: (t) => Aa(ii.errorCodes.rpc.transactionRejected, t),
    methodNotSupported: (t) => Aa(ii.errorCodes.rpc.methodNotSupported, t),
    limitExceeded: (t) => Aa(ii.errorCodes.rpc.limitExceeded, t),
  },
  provider: {
    userRejectedRequest: (t) =>
      ch(ii.errorCodes.provider.userRejectedRequest, t),
    unauthorized: (t) => ch(ii.errorCodes.provider.unauthorized, t),
    unsupportedMethod: (t) => ch(ii.errorCodes.provider.unsupportedMethod, t),
    disconnected: (t) => ch(ii.errorCodes.provider.disconnected, t),
    chainDisconnected: (t) => ch(ii.errorCodes.provider.chainDisconnected, t),
    custom: (t) => {
      if (!t || typeof t != "object" || Array.isArray(t))
        throw new Error(
          "Ethereum Provider custom errors must provide single object argument."
        );
      const { code: e, message: r, data: n } = t;
      if (!r || typeof r != "string")
        throw new Error('"message" must be a nonempty string');
      return new OT.EthereumProviderError(e, r, n);
    },
  },
};
function Aa(t, e) {
  const [r, n] = MW(e);
  return new OT.EthereumRpcError(t, r || SW.getMessageFromCode(t), n);
}
function ch(t, e) {
  const [r, n] = MW(e);
  return new OT.EthereumProviderError(t, r || SW.getMessageFromCode(t), n);
}
function MW(t) {
  if (t) {
    if (typeof t == "string") return [t];
    if (typeof t == "object" && !Array.isArray(t)) {
      const { message: e, data: r } = t;
      if (e && typeof e != "string")
        throw new Error("Must specify string message.");
      return [e || void 0, r];
    }
  }
  return [];
}
(function (t) {
  Object.defineProperty(t, "__esModule", {
    value: !0,
  }),
    (t.getMessageFromCode =
      t.serializeError =
      t.EthereumProviderError =
      t.EthereumRpcError =
      t.ethErrors =
      t.errorCodes =
        void 0);
  const e = sl;
  Object.defineProperty(t, "EthereumRpcError", {
    enumerable: !0,
    get: function () {
      return e.EthereumRpcError;
    },
  }),
    Object.defineProperty(t, "EthereumProviderError", {
      enumerable: !0,
      get: function () {
        return e.EthereumProviderError;
      },
    });
  const r = DT;
  Object.defineProperty(t, "serializeError", {
    enumerable: !0,
    get: function () {
      return r.serializeError;
    },
  }),
    Object.defineProperty(t, "getMessageFromCode", {
      enumerable: !0,
      get: function () {
        return r.getMessageFromCode;
      },
    });
  const n = Ix;
  Object.defineProperty(t, "ethErrors", {
    enumerable: !0,
    get: function () {
      return n.ethErrors;
    },
  });
  const i = ol;
  Object.defineProperty(t, "errorCodes", {
    enumerable: !0,
    get: function () {
      return i.errorCodes;
    },
  });
})(_W);
var M3e =
  (ke && ke.__importDefault) ||
  function (t) {
    return t && t.__esModule
      ? t
      : {
          default: t,
        };
  };
Object.defineProperty(g1, "__esModule", {
  value: !0,
});
g1.JsonRpcEngine = void 0;
const I3e = M3e(BT),
  ka = _W;
class Mo extends I3e.default {
  constructor() {
    super(), (this._middleware = []);
  }
  push(e) {
    this._middleware.push(e);
  }
  handle(e, r) {
    if (r && typeof r != "function")
      throw new Error('"callback" must be a function if provided.');
    return Array.isArray(e)
      ? r
        ? this._handleBatch(e, r)
        : this._handleBatch(e)
      : r
      ? this._handle(e, r)
      : this._promiseHandle(e);
  }
  asMiddleware() {
    return async (e, r, n, i) => {
      try {
        const [a, s, o] = await Mo._runAllMiddleware(e, r, this._middleware);
        return s
          ? (await Mo._runReturnHandlers(o), i(a))
          : n(async (c) => {
              try {
                await Mo._runReturnHandlers(o);
              } catch (u) {
                return c(u);
              }
              return c();
            });
      } catch (a) {
        return i(a);
      }
    };
  }
  async _handleBatch(e, r) {
    try {
      const n = await Promise.all(e.map(this._promiseHandle.bind(this)));
      return r ? r(null, n) : n;
    } catch (n) {
      if (r) return r(n);
      throw n;
    }
  }
  _promiseHandle(e) {
    return new Promise((r) => {
      this._handle(e, (n, i) => {
        r(i);
      });
    });
  }
  async _handle(e, r) {
    if (!e || Array.isArray(e) || typeof e != "object") {
      const s = new ka.EthereumRpcError(
        ka.errorCodes.rpc.invalidRequest,
        `Requests must be plain objects. Received: ${typeof e}`,
        {
          request: e,
        }
      );
      return r(s, {
        id: void 0,
        jsonrpc: "2.0",
        error: s,
      });
    }
    if (typeof e.method != "string") {
      const s = new ka.EthereumRpcError(
        ka.errorCodes.rpc.invalidRequest,
        `Must specify a string method. Received: ${typeof e.method}`,
        {
          request: e,
        }
      );
      return r(s, {
        id: e.id,
        jsonrpc: "2.0",
        error: s,
      });
    }
    const n = Object.assign({}, e),
      i = {
        id: n.id,
        jsonrpc: n.jsonrpc,
      };
    let a = null;
    try {
      await this._processRequest(n, i);
    } catch (s) {
      a = s;
    }
    return (
      a && (delete i.result, i.error || (i.error = ka.serializeError(a))),
      r(a, i)
    );
  }
  async _processRequest(e, r) {
    const [n, i, a] = await Mo._runAllMiddleware(e, r, this._middleware);
    if ((Mo._checkForCompletion(e, r, i), await Mo._runReturnHandlers(a), n))
      throw n;
  }
  static async _runAllMiddleware(e, r, n) {
    const i = [];
    let a = null,
      s = !1;
    for (const o of n)
      if ((([a, s] = await Mo._runMiddleware(e, r, o, i)), s)) break;
    return [a, s, i.reverse()];
  }
  static _runMiddleware(e, r, n, i) {
    return new Promise((a) => {
      const s = (c) => {
          const u = c || r.error;
          u && (r.error = ka.serializeError(u)), a([u, !0]);
        },
        o = (c) => {
          r.error
            ? s(r.error)
            : (c &&
                (typeof c != "function" &&
                  s(
                    new ka.EthereumRpcError(
                      ka.errorCodes.rpc.internal,
                      `JsonRpcEngine: "next" return handlers must be functions. Received "${typeof c}" for request:
${A5(e)}`,
                      {
                        request: e,
                      }
                    )
                  ),
                i.push(c)),
              a([null, !1]));
        };
      try {
        n(e, r, o, s);
      } catch (c) {
        s(c);
      }
    });
  }
  static async _runReturnHandlers(e) {
    for (const r of e)
      await new Promise((n, i) => {
        r((a) => (a ? i(a) : n()));
      });
  }
  static _checkForCompletion(e, r, n) {
    if (!("result" in r) && !("error" in r))
      throw new ka.EthereumRpcError(
        ka.errorCodes.rpc.internal,
        `JsonRpcEngine: Response has no error or result for request:
${A5(e)}`,
        {
          request: e,
        }
      );
    if (!n)
      throw new ka.EthereumRpcError(
        ka.errorCodes.rpc.internal,
        `JsonRpcEngine: Nothing ended request:
${A5(e)}`,
        {
          request: e,
        }
      );
  }
}
g1.JsonRpcEngine = Mo;
function A5(t) {
  return JSON.stringify(t, null, 2);
}
var Rx = {};
Object.defineProperty(Rx, "__esModule", {
  value: !0,
});
Rx.mergeMiddleware = void 0;
const R3e = g1;
function P3e(t) {
  const e = new R3e.JsonRpcEngine();
  return t.forEach((r) => e.push(r)), e.asMiddleware();
}
Rx.mergeMiddleware = P3e;
(function (t) {
  var e =
      (ke && ke.__createBinding) ||
      (Object.create
        ? function (n, i, a, s) {
            s === void 0 && (s = a),
              Object.defineProperty(n, s, {
                enumerable: !0,
                get: function () {
                  return i[a];
                },
              });
          }
        : function (n, i, a, s) {
            s === void 0 && (s = a), (n[s] = i[a]);
          }),
    r =
      (ke && ke.__exportStar) ||
      function (n, i) {
        for (var a in n)
          a !== "default" &&
            !Object.prototype.hasOwnProperty.call(i, a) &&
            e(i, n, a);
      };
  Object.defineProperty(t, "__esModule", {
    value: !0,
  }),
    r(kx, t),
    r(Sx, t),
    r(Mx, t),
    r(y1, t),
    r(g1, t),
    r(Rx, t);
})(NT);
var IW = {},
  FT = {},
  x4 = function (t, e) {
    return (
      (x4 =
        Object.setPrototypeOf ||
        ({
          __proto__: [],
        } instanceof Array &&
          function (r, n) {
            r.__proto__ = n;
          }) ||
        function (r, n) {
          for (var i in n)
            Object.prototype.hasOwnProperty.call(n, i) && (r[i] = n[i]);
        }),
      x4(t, e)
    );
  };
function RW(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError(
      "Class extends value " + String(e) + " is not a constructor or null"
    );
  x4(t, e);
  function r() {
    this.constructor = t;
  }
  t.prototype =
    e === null ? Object.create(e) : ((r.prototype = e.prototype), new r());
}
var db = function () {
  return (
    (db =
      Object.assign ||
      function (e) {
        for (var r, n = 1, i = arguments.length; n < i; n++) {
          r = arguments[n];
          for (var a in r)
            Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
        }
        return e;
      }),
    db.apply(this, arguments)
  );
};
function PW(t, e) {
  var r = {};
  for (var n in t)
    Object.prototype.hasOwnProperty.call(t, n) &&
      e.indexOf(n) < 0 &&
      (r[n] = t[n]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(t); i < n.length; i++)
      e.indexOf(n[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, n[i]) &&
        (r[n[i]] = t[n[i]]);
  return r;
}
function NW(t, e, r, n) {
  var i = arguments.length,
    a =
      i < 3 ? e : n === null ? (n = Object.getOwnPropertyDescriptor(e, r)) : n,
    s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    a = Reflect.decorate(t, e, r, n);
  else
    for (var o = t.length - 1; o >= 0; o--)
      (s = t[o]) && (a = (i < 3 ? s(a) : i > 3 ? s(e, r, a) : s(e, r)) || a);
  return i > 3 && a && Object.defineProperty(e, r, a), a;
}
function BW(t, e) {
  return function (r, n) {
    e(r, n, t);
  };
}
function N3e(t, e, r, n, i, a) {
  function s(w) {
    if (w !== void 0 && typeof w != "function")
      throw new TypeError("Function expected");
    return w;
  }
  for (
    var o = n.kind,
      c = o === "getter" ? "get" : o === "setter" ? "set" : "value",
      u = !e && t ? (n.static ? t : t.prototype) : null,
      d = e || (u ? Object.getOwnPropertyDescriptor(u, n.name) : {}),
      m,
      v = !1,
      E = r.length - 1;
    E >= 0;
    E--
  ) {
    var A = {};
    for (var I in n) A[I] = I === "access" ? {} : n[I];
    for (var I in n.access) A.access[I] = n.access[I];
    A.addInitializer = function (w) {
      if (v)
        throw new TypeError(
          "Cannot add initializers after decoration has completed"
        );
      a.push(s(w || null));
    };
    var b = (0, r[E])(
      o === "accessor"
        ? {
            get: d.get,
            set: d.set,
          }
        : d[c],
      A
    );
    if (o === "accessor") {
      if (b === void 0) continue;
      if (b === null || typeof b != "object")
        throw new TypeError("Object expected");
      (m = s(b.get)) && (d.get = m),
        (m = s(b.set)) && (d.set = m),
        (m = s(b.init)) && i.unshift(m);
    } else (m = s(b)) && (o === "field" ? i.unshift(m) : (d[c] = m));
  }
  u && Object.defineProperty(u, n.name, d), (v = !0);
}
function B3e(t, e, r) {
  for (var n = arguments.length > 2, i = 0; i < e.length; i++)
    r = n ? e[i].call(t, r) : e[i].call(t);
  return n ? r : void 0;
}
function D3e(t) {
  return typeof t == "symbol" ? t : "".concat(t);
}
function O3e(t, e, r) {
  return (
    typeof e == "symbol" &&
      (e = e.description ? "[".concat(e.description, "]") : ""),
    Object.defineProperty(t, "name", {
      configurable: !0,
      value: r ? "".concat(r, " ", e) : e,
    })
  );
}
function DW(t, e) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata(t, e);
}
function OW(t, e, r, n) {
  function i(a) {
    return a instanceof r
      ? a
      : new r(function (s) {
          s(a);
        });
  }
  return new (r || (r = Promise))(function (a, s) {
    function o(d) {
      try {
        u(n.next(d));
      } catch (m) {
        s(m);
      }
    }
    function c(d) {
      try {
        u(n.throw(d));
      } catch (m) {
        s(m);
      }
    }
    function u(d) {
      d.done ? a(d.value) : i(d.value).then(o, c);
    }
    u((n = n.apply(t, e || [])).next());
  });
}
function FW(t, e) {
  var r = {
      label: 0,
      sent: function () {
        if (a[0] & 1) throw a[1];
        return a[1];
      },
      trys: [],
      ops: [],
    },
    n,
    i,
    a,
    s = Object.create(
      (typeof Iterator == "function" ? Iterator : Object).prototype
    );
  return (
    (s.next = o(0)),
    (s.throw = o(1)),
    (s.return = o(2)),
    typeof Symbol == "function" &&
      (s[Symbol.iterator] = function () {
        return this;
      }),
    s
  );
  function o(u) {
    return function (d) {
      return c([u, d]);
    };
  }
  function c(u) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; s && ((s = 0), u[0] && (r = 0)), r; )
      try {
        if (
          ((n = 1),
          i &&
            (a =
              u[0] & 2
                ? i.return
                : u[0]
                ? i.throw || ((a = i.return) && a.call(i), 0)
                : i.next) &&
            !(a = a.call(i, u[1])).done)
        )
          return a;
        switch (((i = 0), a && (u = [u[0] & 2, a.value]), u[0])) {
          case 0:
          case 1:
            a = u;
            break;
          case 4:
            return (
              r.label++,
              {
                value: u[1],
                done: !1,
              }
            );
          case 5:
            r.label++, (i = u[1]), (u = [0]);
            continue;
          case 7:
            (u = r.ops.pop()), r.trys.pop();
            continue;
          default:
            if (
              ((a = r.trys),
              !(a = a.length > 0 && a[a.length - 1]) &&
                (u[0] === 6 || u[0] === 2))
            ) {
              r = 0;
              continue;
            }
            if (u[0] === 3 && (!a || (u[1] > a[0] && u[1] < a[3]))) {
              r.label = u[1];
              break;
            }
            if (u[0] === 6 && r.label < a[1]) {
              (r.label = a[1]), (a = u);
              break;
            }
            if (a && r.label < a[2]) {
              (r.label = a[2]), r.ops.push(u);
              break;
            }
            a[2] && r.ops.pop(), r.trys.pop();
            continue;
        }
        u = e.call(t, r);
      } catch (d) {
        (u = [6, d]), (i = 0);
      } finally {
        n = a = 0;
      }
    if (u[0] & 5) throw u[1];
    return {
      value: u[0] ? u[1] : void 0,
      done: !0,
    };
  }
}
var Px = Object.create
  ? function (t, e, r, n) {
      n === void 0 && (n = r);
      var i = Object.getOwnPropertyDescriptor(e, r);
      (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) &&
        (i = {
          enumerable: !0,
          get: function () {
            return e[r];
          },
        }),
        Object.defineProperty(t, n, i);
    }
  : function (t, e, r, n) {
      n === void 0 && (n = r), (t[n] = e[r]);
    };
function LW(t, e) {
  for (var r in t)
    r !== "default" &&
      !Object.prototype.hasOwnProperty.call(e, r) &&
      Px(e, t, r);
}
function hb(t) {
  var e = typeof Symbol == "function" && Symbol.iterator,
    r = e && t[e],
    n = 0;
  if (r) return r.call(t);
  if (t && typeof t.length == "number")
    return {
      next: function () {
        return (
          t && n >= t.length && (t = void 0),
          {
            value: t && t[n++],
            done: !t,
          }
        );
      },
    };
  throw new TypeError(
    e ? "Object is not iterable." : "Symbol.iterator is not defined."
  );
}
function LT(t, e) {
  var r = typeof Symbol == "function" && t[Symbol.iterator];
  if (!r) return t;
  var n = r.call(t),
    i,
    a = [],
    s;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; ) a.push(i.value);
  } catch (o) {
    s = {
      error: o,
    };
  } finally {
    try {
      i && !i.done && (r = n.return) && r.call(n);
    } finally {
      if (s) throw s.error;
    }
  }
  return a;
}
function $W() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t = t.concat(LT(arguments[e]));
  return t;
}
function UW() {
  for (var t = 0, e = 0, r = arguments.length; e < r; e++)
    t += arguments[e].length;
  for (var n = Array(t), i = 0, e = 0; e < r; e++)
    for (var a = arguments[e], s = 0, o = a.length; s < o; s++, i++)
      n[i] = a[s];
  return n;
}
function WW(t, e, r) {
  if (r || arguments.length === 2)
    for (var n = 0, i = e.length, a; n < i; n++)
      (a || !(n in e)) &&
        (a || (a = Array.prototype.slice.call(e, 0, n)), (a[n] = e[n]));
  return t.concat(a || Array.prototype.slice.call(e));
}
function Jf(t) {
  return this instanceof Jf ? ((this.v = t), this) : new Jf(t);
}
function jW(t, e, r) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var n = r.apply(t, e || []),
    i,
    a = [];
  return (
    (i = Object.create(
      (typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype
    )),
    o("next"),
    o("throw"),
    o("return", s),
    (i[Symbol.asyncIterator] = function () {
      return this;
    }),
    i
  );
  function s(E) {
    return function (A) {
      return Promise.resolve(A).then(E, m);
    };
  }
  function o(E, A) {
    n[E] &&
      ((i[E] = function (I) {
        return new Promise(function (b, w) {
          a.push([E, I, b, w]) > 1 || c(E, I);
        });
      }),
      A && (i[E] = A(i[E])));
  }
  function c(E, A) {
    try {
      u(n[E](A));
    } catch (I) {
      v(a[0][3], I);
    }
  }
  function u(E) {
    E.value instanceof Jf
      ? Promise.resolve(E.value.v).then(d, m)
      : v(a[0][2], E);
  }
  function d(E) {
    c("next", E);
  }
  function m(E) {
    c("throw", E);
  }
  function v(E, A) {
    E(A), a.shift(), a.length && c(a[0][0], a[0][1]);
  }
}
function HW(t) {
  var e, r;
  return (
    (e = {}),
    n("next"),
    n("throw", function (i) {
      throw i;
    }),
    n("return"),
    (e[Symbol.iterator] = function () {
      return this;
    }),
    e
  );
  function n(i, a) {
    e[i] = t[i]
      ? function (s) {
          return (r = !r)
            ? {
                value: Jf(t[i](s)),
                done: !1,
              }
            : a
            ? a(s)
            : s;
        }
      : a;
  }
}
function zW(t) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = t[Symbol.asyncIterator],
    r;
  return e
    ? e.call(t)
    : ((t = typeof hb == "function" ? hb(t) : t[Symbol.iterator]()),
      (r = {}),
      n("next"),
      n("throw"),
      n("return"),
      (r[Symbol.asyncIterator] = function () {
        return this;
      }),
      r);
  function n(a) {
    r[a] =
      t[a] &&
      function (s) {
        return new Promise(function (o, c) {
          (s = t[a](s)), i(o, c, s.done, s.value);
        });
      };
  }
  function i(a, s, o, c) {
    Promise.resolve(c).then(function (u) {
      a({
        value: u,
        done: o,
      });
    }, s);
  }
}
function qW(t, e) {
  return (
    Object.defineProperty
      ? Object.defineProperty(t, "raw", {
          value: e,
        })
      : (t.raw = e),
    t
  );
}
var F3e = Object.create
  ? function (t, e) {
      Object.defineProperty(t, "default", {
        enumerable: !0,
        value: e,
      });
    }
  : function (t, e) {
      t.default = e;
    };
function VW(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null)
    for (var r in t)
      r !== "default" &&
        Object.prototype.hasOwnProperty.call(t, r) &&
        Px(e, t, r);
  return F3e(e, t), e;
}
function KW(t) {
  return t && t.__esModule
    ? t
    : {
        default: t,
      };
}
function GW(t, e, r, n) {
  if (r === "a" && !n)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? t !== e || !n : !e.has(t))
    throw new TypeError(
      "Cannot read private member from an object whose class did not declare it"
    );
  return r === "m" ? n : r === "a" ? n.call(t) : n ? n.value : e.get(t);
}
function ZW(t, e, r, n, i) {
  if (n === "m") throw new TypeError("Private method is not writable");
  if (n === "a" && !i)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? t !== e || !i : !e.has(t))
    throw new TypeError(
      "Cannot write private member to an object whose class did not declare it"
    );
  return n === "a" ? i.call(t, r) : i ? (i.value = r) : e.set(t, r), r;
}
function JW(t, e) {
  if (e === null || (typeof e != "object" && typeof e != "function"))
    throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof t == "function" ? e === t : t.has(e);
}
function QW(t, e, r) {
  if (e != null) {
    if (typeof e != "object" && typeof e != "function")
      throw new TypeError("Object expected.");
    var n, i;
    if (r) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      n = e[Symbol.asyncDispose];
    }
    if (n === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      (n = e[Symbol.dispose]), r && (i = n);
    }
    if (typeof n != "function") throw new TypeError("Object not disposable.");
    i &&
      (n = function () {
        try {
          i.call(this);
        } catch (a) {
          return Promise.reject(a);
        }
      }),
      t.stack.push({
        value: e,
        dispose: n,
        async: r,
      });
  } else
    r &&
      t.stack.push({
        async: !0,
      });
  return e;
}
var L3e =
  typeof SuppressedError == "function"
    ? SuppressedError
    : function (t, e, r) {
        var n = new Error(r);
        return (
          (n.name = "SuppressedError"), (n.error = t), (n.suppressed = e), n
        );
      };
function YW(t) {
  function e(a) {
    (t.error = t.hasError
      ? new L3e(a, t.error, "An error was suppressed during disposal.")
      : a),
      (t.hasError = !0);
  }
  var r,
    n = 0;
  function i() {
    for (; (r = t.stack.pop()); )
      try {
        if (!r.async && n === 1)
          return (n = 0), t.stack.push(r), Promise.resolve().then(i);
        if (r.dispose) {
          var a = r.dispose.call(r.value);
          if (r.async)
            return (
              (n |= 2),
              Promise.resolve(a).then(i, function (s) {
                return e(s), i();
              })
            );
        } else n |= 1;
      } catch (s) {
        e(s);
      }
    if (n === 1)
      return t.hasError ? Promise.reject(t.error) : Promise.resolve();
    if (t.hasError) throw t.error;
  }
  return i();
}
const $3e = {
    __extends: RW,
    __assign: db,
    __rest: PW,
    __decorate: NW,
    __param: BW,
    __metadata: DW,
    __awaiter: OW,
    __generator: FW,
    __createBinding: Px,
    __exportStar: LW,
    __values: hb,
    __read: LT,
    __spread: $W,
    __spreadArrays: UW,
    __spreadArray: WW,
    __await: Jf,
    __asyncGenerator: jW,
    __asyncDelegator: HW,
    __asyncValues: zW,
    __makeTemplateObject: qW,
    __importStar: VW,
    __importDefault: KW,
    __classPrivateFieldGet: GW,
    __classPrivateFieldSet: ZW,
    __classPrivateFieldIn: JW,
    __addDisposableResource: QW,
    __disposeResources: YW,
  },
  U3e = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        __addDisposableResource: QW,
        get __assign() {
          return db;
        },
        __asyncDelegator: HW,
        __asyncGenerator: jW,
        __asyncValues: zW,
        __await: Jf,
        __awaiter: OW,
        __classPrivateFieldGet: GW,
        __classPrivateFieldIn: JW,
        __classPrivateFieldSet: ZW,
        __createBinding: Px,
        __decorate: NW,
        __disposeResources: YW,
        __esDecorate: N3e,
        __exportStar: LW,
        __extends: RW,
        __generator: FW,
        __importDefault: KW,
        __importStar: VW,
        __makeTemplateObject: qW,
        __metadata: DW,
        __param: BW,
        __propKey: D3e,
        __read: LT,
        __rest: PW,
        __runInitializers: B3e,
        __setFunctionName: O3e,
        __spread: $W,
        __spreadArray: WW,
        __spreadArrays: UW,
        __values: hb,
        default: $3e,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  $T = Pt(U3e);
var Nx = {};
Object.defineProperty(Nx, "__esModule", {
  value: !0,
});
var tI = $T,
  W3e = (function () {
    function t(e) {
      if (((this._maxConcurrency = e), (this._queue = []), e <= 0))
        throw new Error("semaphore must be initialized to a positive value");
      this._value = e;
    }
    return (
      (t.prototype.acquire = function () {
        var e = this,
          r = this.isLocked(),
          n = new Promise(function (i) {
            return e._queue.push(i);
          });
        return r || this._dispatch(), n;
      }),
      (t.prototype.runExclusive = function (e) {
        return tI.__awaiter(this, void 0, void 0, function () {
          var r, n, i;
          return tI.__generator(this, function (a) {
            switch (a.label) {
              case 0:
                return [4, this.acquire()];
              case 1:
                (r = a.sent()), (n = r[0]), (i = r[1]), (a.label = 2);
              case 2:
                return a.trys.push([2, , 4, 5]), [4, e(n)];
              case 3:
                return [2, a.sent()];
              case 4:
                return i(), [7];
              case 5:
                return [2];
            }
          });
        });
      }),
      (t.prototype.isLocked = function () {
        return this._value <= 0;
      }),
      (t.prototype.release = function () {
        if (this._maxConcurrency > 1)
          throw new Error(
            "this method is unavailabel on semaphores with concurrency > 1; use the scoped release returned by acquire instead"
          );
        if (this._currentReleaser) {
          var e = this._currentReleaser;
          (this._currentReleaser = void 0), e();
        }
      }),
      (t.prototype._dispatch = function () {
        var e = this,
          r = this._queue.shift();
        if (r) {
          var n = !1;
          (this._currentReleaser = function () {
            n || ((n = !0), e._value++, e._dispatch());
          }),
            r([this._value--, this._currentReleaser]);
        }
      }),
      t
    );
  })();
Nx.default = W3e;
Object.defineProperty(FT, "__esModule", {
  value: !0,
});
var rI = $T,
  j3e = Nx,
  H3e = (function () {
    function t() {
      this._semaphore = new j3e.default(1);
    }
    return (
      (t.prototype.acquire = function () {
        return rI.__awaiter(this, void 0, void 0, function () {
          var e, r;
          return rI.__generator(this, function (n) {
            switch (n.label) {
              case 0:
                return [4, this._semaphore.acquire()];
              case 1:
                return (e = n.sent()), (r = e[1]), [2, r];
            }
          });
        });
      }),
      (t.prototype.runExclusive = function (e) {
        return this._semaphore.runExclusive(function () {
          return e();
        });
      }),
      (t.prototype.isLocked = function () {
        return this._semaphore.isLocked();
      }),
      (t.prototype.release = function () {
        this._semaphore.release();
      }),
      t
    );
  })();
FT.default = H3e;
var Bx = {};
Object.defineProperty(Bx, "__esModule", {
  value: !0,
});
Bx.withTimeout = void 0;
var _y = $T;
function z3e(t, e, r) {
  var n = this;
  return (
    r === void 0 && (r = new Error("timeout")),
    {
      acquire: function () {
        return new Promise(function (i, a) {
          return _y.__awaiter(n, void 0, void 0, function () {
            var s, o, c;
            return _y.__generator(this, function (u) {
              switch (u.label) {
                case 0:
                  return (
                    (s = !1),
                    setTimeout(function () {
                      (s = !0), a(r);
                    }, e),
                    [4, t.acquire()]
                  );
                case 1:
                  return (
                    (o = u.sent()),
                    s ? ((c = Array.isArray(o) ? o[1] : o), c()) : i(o),
                    [2]
                  );
              }
            });
          });
        });
      },
      runExclusive: function (i) {
        return _y.__awaiter(this, void 0, void 0, function () {
          var a, s;
          return _y.__generator(this, function (o) {
            switch (o.label) {
              case 0:
                (a = function () {}), (o.label = 1);
              case 1:
                return o.trys.push([1, , 7, 8]), [4, this.acquire()];
              case 2:
                return (
                  (s = o.sent()),
                  Array.isArray(s) ? ((a = s[1]), [4, i(s[0])]) : [3, 4]
                );
              case 3:
                return [2, o.sent()];
              case 4:
                return (a = s), [4, i()];
              case 5:
                return [2, o.sent()];
              case 6:
                return [3, 8];
              case 7:
                return a(), [7];
              case 8:
                return [2];
            }
          });
        });
      },
      release: function () {
        t.release();
      },
      isLocked: function () {
        return t.isLocked();
      },
    }
  );
}
Bx.withTimeout = z3e;
(function (t) {
  Object.defineProperty(t, "__esModule", {
    value: !0,
  }),
    (t.withTimeout = t.Semaphore = t.Mutex = void 0);
  var e = FT;
  Object.defineProperty(t, "Mutex", {
    enumerable: !0,
    get: function () {
      return e.default;
    },
  });
  var r = Nx;
  Object.defineProperty(t, "Semaphore", {
    enumerable: !0,
    get: function () {
      return r.default;
    },
  });
  var n = Bx;
  Object.defineProperty(t, "withTimeout", {
    enumerable: !0,
    get: function () {
      return n.withTimeout;
    },
  });
})(IW);
var q3e = K3e,
  V3e = Object.prototype.hasOwnProperty;
function K3e() {
  for (var t = {}, e = 0; e < arguments.length; e++) {
    var r = arguments[e];
    for (var n in r) V3e.call(r, n) && (t[n] = r[n]);
  }
  return t;
}
const G3e = q3e,
  Z3e = yT();
var J3e = bt;
function bt(t) {
  const e = this;
  e.currentProvider = t;
}
bt.prototype.getBalance = b1(2, "eth_getBalance");
bt.prototype.getCode = b1(2, "eth_getCode");
bt.prototype.getTransactionCount = b1(2, "eth_getTransactionCount");
bt.prototype.getStorageAt = b1(3, "eth_getStorageAt");
bt.prototype.call = b1(2, "eth_call");
bt.prototype.protocolVersion = Ct("eth_protocolVersion");
bt.prototype.syncing = Ct("eth_syncing");
bt.prototype.coinbase = Ct("eth_coinbase");
bt.prototype.mining = Ct("eth_mining");
bt.prototype.hashrate = Ct("eth_hashrate");
bt.prototype.gasPrice = Ct("eth_gasPrice");
bt.prototype.accounts = Ct("eth_accounts");
bt.prototype.blockNumber = Ct("eth_blockNumber");
bt.prototype.getBlockTransactionCountByHash = Ct(
  "eth_getBlockTransactionCountByHash"
);
bt.prototype.getBlockTransactionCountByNumber = Ct(
  "eth_getBlockTransactionCountByNumber"
);
bt.prototype.getUncleCountByBlockHash = Ct("eth_getUncleCountByBlockHash");
bt.prototype.getUncleCountByBlockNumber = Ct("eth_getUncleCountByBlockNumber");
bt.prototype.sign = Ct("eth_sign");
bt.prototype.sendTransaction = Ct("eth_sendTransaction");
bt.prototype.sendRawTransaction = Ct("eth_sendRawTransaction");
bt.prototype.estimateGas = Ct("eth_estimateGas");
bt.prototype.getBlockByHash = Ct("eth_getBlockByHash");
bt.prototype.getBlockByNumber = Ct("eth_getBlockByNumber");
bt.prototype.getTransactionByHash = Ct("eth_getTransactionByHash");
bt.prototype.getTransactionByBlockHashAndIndex = Ct(
  "eth_getTransactionByBlockHashAndIndex"
);
bt.prototype.getTransactionByBlockNumberAndIndex = Ct(
  "eth_getTransactionByBlockNumberAndIndex"
);
bt.prototype.getTransactionReceipt = Ct("eth_getTransactionReceipt");
bt.prototype.getUncleByBlockHashAndIndex = Ct(
  "eth_getUncleByBlockHashAndIndex"
);
bt.prototype.getUncleByBlockNumberAndIndex = Ct(
  "eth_getUncleByBlockNumberAndIndex"
);
bt.prototype.getCompilers = Ct("eth_getCompilers");
bt.prototype.compileLLL = Ct("eth_compileLLL");
bt.prototype.compileSolidity = Ct("eth_compileSolidity");
bt.prototype.compileSerpent = Ct("eth_compileSerpent");
bt.prototype.newFilter = Ct("eth_newFilter");
bt.prototype.newBlockFilter = Ct("eth_newBlockFilter");
bt.prototype.newPendingTransactionFilter = Ct(
  "eth_newPendingTransactionFilter"
);
bt.prototype.uninstallFilter = Ct("eth_uninstallFilter");
bt.prototype.getFilterChanges = Ct("eth_getFilterChanges");
bt.prototype.getFilterLogs = Ct("eth_getFilterLogs");
bt.prototype.getLogs = Ct("eth_getLogs");
bt.prototype.getWork = Ct("eth_getWork");
bt.prototype.submitWork = Ct("eth_submitWork");
bt.prototype.submitHashrate = Ct("eth_submitHashrate");
bt.prototype.sendAsync = function (t, e) {
  this.currentProvider.sendAsync(Q3e(t), function (n, i) {
    if (
      (!n &&
        i.error &&
        (n = new Error("EthQuery - RPC Error - " + i.error.message)),
      n)
    )
      return e(n);
    e(null, i.result);
  });
};
function Ct(t) {
  return function () {
    const e = this;
    var r = [].slice.call(arguments),
      n = r.pop();
    e.sendAsync(
      {
        method: t,
        params: r,
      },
      n
    );
  };
}
function b1(t, e) {
  return function () {
    const r = this;
    var n = [].slice.call(arguments),
      i = n.pop();
    n.length < t && n.push("latest"),
      r.sendAsync(
        {
          method: e,
          params: n,
        },
        i
      );
  };
}
function Q3e(t) {
  return G3e(
    {
      id: Z3e(),
      jsonrpc: "2.0",
      params: [],
    },
    t
  );
}
const nI = (t, e, r, n) =>
    function (...i) {
      const a = e.promiseModule;
      return new a((s, o) => {
        e.multiArgs
          ? i.push((...u) => {
              e.errorFirst ? (u[0] ? o(u) : (u.shift(), s(u))) : s(u);
            })
          : e.errorFirst
          ? i.push((u, d) => {
              u ? o(u) : s(d);
            })
          : i.push(s),
          Reflect.apply(t, this === r ? n : this, i);
      });
    },
  iI = new WeakMap();
var Y3e = (t, e) => {
  e = {
    exclude: [/.+(?:Sync|Stream)$/],
    errorFirst: !0,
    promiseModule: Promise,
    ...e,
  };
  const r = typeof t;
  if (!(t !== null && (r === "object" || r === "function")))
    throw new TypeError(
      `Expected \`input\` to be a \`Function\` or \`Object\`, got \`${
        t === null ? "null" : r
      }\``
    );
  const n = (s, o) => {
      let c = iI.get(s);
      if ((c || ((c = {}), iI.set(s, c)), o in c)) return c[o];
      const u = (A) =>
          typeof A == "string" || typeof o == "symbol" ? o === A : A.test(o),
        d = Reflect.getOwnPropertyDescriptor(s, o),
        m = d === void 0 || d.writable || d.configurable,
        E = (e.include ? e.include.some(u) : !e.exclude.some(u)) && m;
      return (c[o] = E), E;
    },
    i = new WeakMap(),
    a = new Proxy(t, {
      apply(s, o, c) {
        const u = i.get(s);
        if (u) return Reflect.apply(u, o, c);
        const d = e.excludeMain ? s : nI(s, e, a, s);
        return i.set(s, d), Reflect.apply(d, o, c);
      },
      get(s, o) {
        const c = s[o];
        if (!n(s, o) || c === Function.prototype[o]) return c;
        const u = i.get(c);
        if (u) return u;
        if (typeof c == "function") {
          const d = nI(c, e, a, s);
          return i.set(c, d), d;
        }
        return c;
      },
    });
  return a;
};
const X3e = u1.default;
let e5e = class extends X3e {
  constructor() {
    super(), (this.updates = []);
  }
  async initialize() {}
  async update() {
    throw new Error("BaseFilter - no update method specified");
  }
  addResults(e) {
    (this.updates = this.updates.concat(e)),
      e.forEach((r) => this.emit("update", r));
  }
  addInitialResults(e) {}
  getChangesAndClear() {
    const e = this.updates;
    return (this.updates = []), e;
  }
};
var UT = e5e;
const t5e = UT;
let r5e = class extends t5e {
  constructor() {
    super(), (this.allResults = []);
  }
  async update() {
    throw new Error("BaseFilterWithHistory - no update method specified");
  }
  addResults(e) {
    (this.allResults = this.allResults.concat(e)), super.addResults(e);
  }
  addInitialResults(e) {
    (this.allResults = this.allResults.concat(e)), super.addInitialResults(e);
  }
  getAllResults() {
    return this.allResults;
  }
};
var n5e = r5e,
  v1 = {
    minBlockRef: i5e,
    maxBlockRef: a5e,
    sortBlockRefs: WT,
    bnToHex: s5e,
    blockRefIsNumber: o5e,
    hexToInt: pb,
    incrementHexInt: c5e,
    intToHex: XW,
    unsafeRandomBytes: l5e,
  };
function i5e(...t) {
  return WT(t)[0];
}
function a5e(...t) {
  const e = WT(t);
  return e[e.length - 1];
}
function WT(t) {
  return t.sort((e, r) =>
    e === "latest" || r === "earliest"
      ? 1
      : r === "latest" || e === "earliest"
      ? -1
      : pb(e) - pb(r)
  );
}
function s5e(t) {
  return "0x" + t.toString(16);
}
function o5e(t) {
  return t && !["earliest", "latest", "pending"].includes(t);
}
function pb(t) {
  return t == null ? t : Number.parseInt(t, 16);
}
function c5e(t) {
  if (t == null) return t;
  const e = pb(t);
  return XW(e + 1);
}
function XW(t) {
  if (t == null) return t;
  let e = t.toString(16);
  return e.length % 2 && (e = "0" + e), "0x" + e;
}
function l5e(t) {
  let e = "0x";
  for (let r = 0; r < t; r++) (e += aI()), (e += aI());
  return e;
}
function aI() {
  return Math.floor(Math.random() * 16).toString(16);
}
const u5e = J3e,
  f5e = Y3e,
  d5e = n5e,
  {
    bnToHex: Bke,
    hexToInt: Ey,
    incrementHexInt: h5e,
    minBlockRef: p5e,
    blockRefIsNumber: m5e,
  } = v1;
let y5e = class extends d5e {
  constructor({ provider: e, params: r }) {
    super(),
      (this.type = "log"),
      (this.ethQuery = new u5e(e)),
      (this.params = Object.assign(
        {
          fromBlock: "latest",
          toBlock: "latest",
          address: void 0,
          topics: [],
        },
        r
      )),
      this.params.address &&
        (Array.isArray(this.params.address) ||
          (this.params.address = [this.params.address]),
        (this.params.address = this.params.address.map((n) =>
          n.toLowerCase()
        )));
  }
  async initialize({ currentBlock: e }) {
    let r = this.params.fromBlock;
    ["latest", "pending"].includes(r) && (r = e),
      r === "earliest" && (r = "0x0"),
      (this.params.fromBlock = r);
    const n = p5e(this.params.toBlock, e),
      i = Object.assign({}, this.params, {
        toBlock: n,
      }),
      a = await this._fetchLogs(i);
    this.addInitialResults(a);
  }
  async update({ oldBlock: e, newBlock: r }) {
    const n = r;
    let i;
    e ? (i = h5e(e)) : (i = r);
    const a = Object.assign({}, this.params, {
        fromBlock: i,
        toBlock: n,
      }),
      o = (await this._fetchLogs(a)).filter((c) => this.matchLog(c));
    this.addResults(o);
  }
  async _fetchLogs(e) {
    return await f5e((n) => this.ethQuery.getLogs(e, n))();
  }
  matchLog(e) {
    if (
      Ey(this.params.fromBlock) >= Ey(e.blockNumber) ||
      (m5e(this.params.toBlock) && Ey(this.params.toBlock) <= Ey(e.blockNumber))
    )
      return !1;
    const r = e.address && e.address.toLowerCase();
    return this.params.address && r && !this.params.address.includes(r)
      ? !1
      : this.params.topics.every((i, a) => {
          let s = e.topics[a];
          if (!s) return !1;
          s = s.toLowerCase();
          let o = Array.isArray(i) ? i : [i];
          return o.includes(null)
            ? !0
            : ((o = o.map((d) => d.toLowerCase())), o.includes(s));
        });
  }
};
var g5e = y5e,
  jT = b5e;
async function b5e({ provider: t, fromBlock: e, toBlock: r }) {
  e || (e = r);
  const n = sI(e),
    a = sI(r) - n + 1,
    s = Array(a)
      .fill()
      .map((c, u) => n + u)
      .map(v5e);
  let o = await Promise.all(
    s.map((c) => w5e(t, "eth_getBlockByNumber", [c, !1]))
  );
  return (o = o.filter((c) => c !== null)), o;
}
function sI(t) {
  return t == null ? t : Number.parseInt(t, 16);
}
function v5e(t) {
  return t == null ? t : "0x" + t.toString(16);
}
function x5e(t, e) {
  return new Promise((r, n) => {
    t.sendAsync(e, (i, a) => {
      i
        ? n(i)
        : a.error
        ? n(a.error)
        : a.result
        ? r(a.result)
        : n(new Error("Result was empty"));
    });
  });
}
async function w5e(t, e, r) {
  for (let n = 0; n < 3; n++)
    try {
      return await x5e(t, {
        id: 1,
        jsonrpc: "2.0",
        method: e,
        params: r,
      });
    } catch (i) {
      console.error(`provider.sendAsync failed: ${i.stack || i.message || i}`);
    }
  return null;
}
const _5e = UT,
  E5e = jT,
  { incrementHexInt: T5e } = v1;
let C5e = class extends _5e {
  constructor({ provider: e, params: r }) {
    super(), (this.type = "block"), (this.provider = e);
  }
  async update({ oldBlock: e, newBlock: r }) {
    const n = r,
      i = T5e(e),
      s = (
        await E5e({
          provider: this.provider,
          fromBlock: i,
          toBlock: n,
        })
      ).map((o) => o.hash);
    this.addResults(s);
  }
};
var A5e = C5e;
const k5e = UT,
  S5e = jT,
  { incrementHexInt: M5e } = v1;
let I5e = class extends k5e {
  constructor({ provider: e }) {
    super(), (this.type = "tx"), (this.provider = e);
  }
  async update({ oldBlock: e }) {
    const r = e,
      n = M5e(e),
      i = await S5e({
        provider: this.provider,
        fromBlock: n,
        toBlock: r,
      }),
      a = [];
    for (const s of i) a.push(...s.transactions);
    this.addResults(a);
  }
};
var R5e = I5e;
const P5e = IW.Mutex,
  { createAsyncMiddleware: N5e, createScaffoldMiddleware: B5e } = NT,
  D5e = g5e,
  O5e = A5e,
  F5e = R5e,
  { intToHex: ej, hexToInt: k5 } = v1;
var L5e = $5e;
function $5e({ blockTracker: t, provider: e }) {
  let r = 0,
    n = {};
  const i = new P5e(),
    a = U5e({
      mutex: i,
    }),
    s = B5e({
      eth_newFilter: a(S5(c)),
      eth_newBlockFilter: a(S5(u)),
      eth_newPendingTransactionFilter: a(S5(d)),
      eth_uninstallFilter: a(ng(E)),
      eth_getFilterChanges: a(ng(m)),
      eth_getFilterLogs: a(ng(v)),
    }),
    o = async ({ oldBlock: S, newBlock: k }) => {
      if (n.length === 0) return;
      const N = await i.acquire();
      try {
        await Promise.all(
          c0(n).map(async (O) => {
            try {
              await O.update({
                oldBlock: S,
                newBlock: k,
              });
            } catch (F) {
              console.error(F);
            }
          })
        );
      } catch (O) {
        console.error(O);
      }
      N();
    };
  return (
    (s.newLogFilter = c),
    (s.newBlockFilter = u),
    (s.newPendingTransactionFilter = d),
    (s.uninstallFilter = E),
    (s.getFilterChanges = m),
    (s.getFilterLogs = v),
    (s.destroy = () => {
      b();
    }),
    s
  );
  async function c(S) {
    const k = new D5e({
      provider: e,
      params: S,
    });
    return await A(k), k;
  }
  async function u() {
    const S = new O5e({
      provider: e,
    });
    return await A(S), S;
  }
  async function d() {
    const S = new F5e({
      provider: e,
    });
    return await A(S), S;
  }
  async function m(S) {
    const k = k5(S),
      N = n[k];
    if (!N) throw new Error(`No filter for index "${k}"`);
    return N.getChangesAndClear();
  }
  async function v(S) {
    const k = k5(S),
      N = n[k];
    if (!N) throw new Error(`No filter for index "${k}"`);
    let O = [];
    return N.type === "log" && (O = N.getAllResults()), O;
  }
  async function E(S) {
    const k = k5(S),
      O = !!n[k];
    return O && (await I(k)), O;
  }
  async function A(S) {
    const k = c0(n).length,
      N = await t.getLatestBlock();
    await S.initialize({
      currentBlock: N,
    }),
      r++,
      (n[r] = S),
      (S.id = r),
      (S.idHex = ej(r));
    const O = c0(n).length;
    return (
      w({
        prevFilterCount: k,
        newFilterCount: O,
      }),
      r
    );
  }
  async function I(S) {
    const k = c0(n).length;
    delete n[S];
    const N = c0(n).length;
    w({
      prevFilterCount: k,
      newFilterCount: N,
    });
  }
  async function b() {
    const S = c0(n).length;
    (n = {}),
      w({
        prevFilterCount: S,
        newFilterCount: 0,
      });
  }
  function w({ prevFilterCount: S, newFilterCount: k }) {
    if (S === 0 && k > 0) {
      t.on("sync", o);
      return;
    }
    if (S > 0 && k === 0) {
      t.removeListener("sync", o);
      return;
    }
  }
}
function S5(t) {
  return ng(async (...e) => {
    const r = await t(...e);
    return ej(r.id);
  });
}
function ng(t) {
  return N5e(async (e, r) => {
    const n = await t.apply(null, e.params);
    r.result = n;
  });
}
function U5e({ mutex: t }) {
  return (e) => async (r, n, i, a) => {
    (await t.acquire())(), e(r, n, i, a);
  };
}
function c0(t, e) {
  const r = [];
  for (let n in t) r.push(t[n]);
  return r;
}
const W5e = u1.default,
  { createAsyncMiddleware: oI, createScaffoldMiddleware: j5e } = NT,
  H5e = L5e,
  { unsafeRandomBytes: z5e, incrementHexInt: q5e } = v1,
  V5e = jT;
var K5e = G5e;
function G5e({ blockTracker: t, provider: e }) {
  const r = {},
    n = H5e({
      blockTracker: t,
      provider: e,
    });
  let i = !1;
  const a = new W5e(),
    s = j5e({
      eth_subscribe: oI(o),
      eth_unsubscribe: oI(c),
    });
  return (
    (s.destroy = d),
    {
      events: a,
      middleware: s,
    }
  );
  async function o(m, v) {
    if (i)
      throw new Error(
        "SubscriptionManager - attempting to use after destroying"
      );
    const E = m.params[0],
      A = z5e(16);
    let I;
    switch (E) {
      case "newHeads":
        I = b({
          subId: A,
        });
        break;
      case "logs":
        const S = m.params[1],
          k = await n.newLogFilter(S);
        I = w({
          subId: A,
          filter: k,
        });
        break;
      default:
        throw new Error(
          `SubscriptionManager - unsupported subscription type "${E}"`
        );
    }
    (r[A] = I), (v.result = A);
    return;
    function b({ subId: S }) {
      const k = {
        type: E,
        destroy: async () => {
          t.removeListener("sync", k.update);
        },
        update: async ({ oldBlock: N, newBlock: O }) => {
          const F = O,
            V = q5e(N);
          (
            await V5e({
              provider: e,
              fromBlock: V,
              toBlock: F,
            })
          )
            .map(Z5e)
            .filter((C) => C !== null)
            .forEach((C) => {
              u(S, C);
            });
        },
      };
      return t.on("sync", k.update), k;
    }
    function w({ subId: S, filter: k }) {
      return (
        k.on("update", (O) => u(S, O)),
        {
          type: E,
          destroy: async () => await n.uninstallFilter(k.idHex),
        }
      );
    }
  }
  async function c(m, v) {
    if (i)
      throw new Error(
        "SubscriptionManager - attempting to use after destroying"
      );
    const E = m.params[0],
      A = r[E];
    if (!A) {
      v.result = !1;
      return;
    }
    delete r[E], await A.destroy(), (v.result = !0);
  }
  function u(m, v) {
    a.emit("notification", {
      jsonrpc: "2.0",
      method: "eth_subscription",
      params: {
        subscription: m,
        result: v,
      },
    });
  }
  function d() {
    a.removeAllListeners();
    for (const m in r) r[m].destroy(), delete r[m];
    i = !0;
  }
}
function Z5e(t) {
  return t == null
    ? null
    : {
        hash: t.hash,
        parentHash: t.parentHash,
        sha3Uncles: t.sha3Uncles,
        miner: t.miner,
        stateRoot: t.stateRoot,
        transactionsRoot: t.transactionsRoot,
        receiptsRoot: t.receiptsRoot,
        logsBloom: t.logsBloom,
        difficulty: t.difficulty,
        number: t.number,
        gasLimit: t.gasLimit,
        gasUsed: t.gasUsed,
        nonce: t.nonce,
        mixHash: t.mixHash,
        timestamp: t.timestamp,
        extraData: t.extraData,
      };
}
Object.defineProperty(yx, "__esModule", {
  value: !0,
});
yx.SubscriptionManager = void 0;
const J5e = LU,
  Q5e = K5e,
  cI = () => {};
class Y5e {
  constructor(e) {
    const r = new J5e.PollingBlockTracker({
        provider: e,
        pollingInterval: 15e3,
        setSkipCacheFlag: !0,
      }),
      { events: n, middleware: i } = Q5e({
        blockTracker: r,
        provider: e,
      });
    (this.events = n), (this.subscriptionMiddleware = i);
  }
  async handleRequest(e) {
    const r = {};
    return await this.subscriptionMiddleware(e, r, cI, cI), r;
  }
  destroy() {
    this.subscriptionMiddleware.destroy();
  }
}
yx.SubscriptionManager = Y5e;
var tj =
  (ke && ke.__importDefault) ||
  function (t) {
    return t && t.__esModule
      ? t
      : {
          default: t,
        };
  };
Object.defineProperty(Wf, "__esModule", {
  value: !0,
});
Wf.CoinbaseWalletProvider = void 0;
const X5e = tj(Nm),
  e6e = $me,
  Wt = Vm,
  wt = ot,
  t6e = Jm,
  lI = La,
  Ty = Id,
  Xi = kd,
  M5 = tj(C2e),
  lh = Md,
  r6e = Kf,
  n6e = yx,
  uI = "DefaultChainId",
  fI = "DefaultJsonRpcUrl";
class i6e extends e6e.EventEmitter {
  constructor(e) {
    var r, n;
    super(),
      (this._filterPolyfill = new r6e.FilterPolyfill(this)),
      (this._subscriptionManager = new n6e.SubscriptionManager(this)),
      (this._relay = null),
      (this._addresses = []),
      (this.hasMadeFirstChainChangedEmission = !1),
      (this.setProviderInfo = this.setProviderInfo.bind(this)),
      (this.updateProviderInfo = this.updateProviderInfo.bind(this)),
      (this.getChainId = this.getChainId.bind(this)),
      (this.setAppInfo = this.setAppInfo.bind(this)),
      (this.enable = this.enable.bind(this)),
      (this.close = this.close.bind(this)),
      (this.send = this.send.bind(this)),
      (this.sendAsync = this.sendAsync.bind(this)),
      (this.request = this.request.bind(this)),
      (this._setAddresses = this._setAddresses.bind(this)),
      (this.scanQRCode = this.scanQRCode.bind(this)),
      (this.genericRequest = this.genericRequest.bind(this)),
      (this._chainIdFromOpts = e.chainId),
      (this._jsonRpcUrlFromOpts = e.jsonRpcUrl),
      (this._overrideIsMetaMask = e.overrideIsMetaMask),
      (this._relayProvider = e.relayProvider),
      (this._storage = e.storage),
      (this._relayEventManager = e.relayEventManager),
      (this.diagnostic = e.diagnosticLogger),
      (this.reloadOnDisconnect = !0),
      (this.isCoinbaseWallet =
        (r = e.overrideIsCoinbaseWallet) !== null && r !== void 0 ? r : !0),
      (this.isCoinbaseBrowser =
        (n = e.overrideIsCoinbaseBrowser) !== null && n !== void 0 ? n : !1),
      (this.qrUrl = e.qrUrl);
    const i = this.getChainId(),
      a = (0, wt.prepend0x)(i.toString(16));
    this.emit("connect", {
      chainIdStr: a,
    });
    const s = this._storage.getItem(lI.LOCAL_STORAGE_ADDRESSES_KEY);
    if (s) {
      const o = s.split(" ");
      o[0] !== "" &&
        ((this._addresses = o.map((c) => (0, wt.ensureAddressString)(c))),
        this.emit("accountsChanged", o));
    }
    this._subscriptionManager.events.on("notification", (o) => {
      this.emit("message", {
        type: o.method,
        data: o.params,
      });
    }),
      this._isAuthorized() && this.initializeRelay(),
      window.addEventListener("message", (o) => {
        var c;
        if (
          !(o.origin !== location.origin || o.source !== window) &&
          o.data.type === "walletLinkMessage" &&
          o.data.data.action === "dappChainSwitched"
        ) {
          const u = o.data.data.chainId,
            d =
              (c = o.data.data.jsonRpcUrl) !== null && c !== void 0
                ? c
                : this.jsonRpcUrl;
          this.updateProviderInfo(d, Number(u));
        }
      });
  }
  get selectedAddress() {
    return this._addresses[0] || void 0;
  }
  get networkVersion() {
    return this.getChainId().toString(10);
  }
  get chainId() {
    return (0, wt.prepend0x)(this.getChainId().toString(16));
  }
  get isWalletLink() {
    return !0;
  }
  get isMetaMask() {
    return this._overrideIsMetaMask;
  }
  get host() {
    return this.jsonRpcUrl;
  }
  get connected() {
    return !0;
  }
  isConnected() {
    return !0;
  }
  get jsonRpcUrl() {
    var e;
    return (e = this._storage.getItem(fI)) !== null && e !== void 0
      ? e
      : this._jsonRpcUrlFromOpts;
  }
  set jsonRpcUrl(e) {
    this._storage.setItem(fI, e);
  }
  disableReloadOnDisconnect() {
    this.reloadOnDisconnect = !1;
  }
  setProviderInfo(e, r) {
    this.isCoinbaseBrowser ||
      ((this._chainIdFromOpts = r), (this._jsonRpcUrlFromOpts = e)),
      this.updateProviderInfo(this.jsonRpcUrl, this.getChainId());
  }
  updateProviderInfo(e, r) {
    this.jsonRpcUrl = e;
    const n = this.getChainId();
    this._storage.setItem(uI, r.toString(10)),
      ((0, wt.ensureIntNumber)(r) !== n ||
        !this.hasMadeFirstChainChangedEmission) &&
        (this.emit("chainChanged", this.getChainId()),
        (this.hasMadeFirstChainChangedEmission = !0));
  }
  async watchAsset(e, r, n, i, a, s) {
    const c = await (
      await this.initializeRelay()
    ).watchAsset(e, r, n, i, a, s == null ? void 0 : s.toString()).promise;
    return (0, Xi.isErrorResponse)(c) ? !1 : !!c.result;
  }
  async addEthereumChain(e, r, n, i, a, s) {
    var o, c;
    if ((0, wt.ensureIntNumber)(e) === this.getChainId()) return !1;
    const u = await this.initializeRelay(),
      d = u.inlineAddEthereumChain(e.toString());
    !this._isAuthorized() && !d && (await u.requestEthereumAccounts().promise);
    const m = await u.addEthereumChain(e.toString(), r, a, n, i, s).promise;
    return (0, Xi.isErrorResponse)(m)
      ? !1
      : (((o = m.result) === null || o === void 0 ? void 0 : o.isApproved) ===
          !0 && this.updateProviderInfo(r[0], e),
        ((c = m.result) === null || c === void 0 ? void 0 : c.isApproved) ===
          !0);
  }
  async switchEthereumChain(e) {
    const n = await (
      await this.initializeRelay()
    ).switchEthereumChain(e.toString(10), this.selectedAddress || void 0)
      .promise;
    if ((0, Xi.isErrorResponse)(n)) {
      if (!n.errorCode) return;
      throw n.errorCode === Wt.standardErrorCodes.provider.unsupportedChain
        ? Wt.standardErrors.provider.unsupportedChain()
        : Wt.standardErrors.provider.custom({
            message: n.errorMessage,
            code: n.errorCode,
          });
    }
    const i = n.result;
    i.isApproved && i.rpcUrl.length > 0 && this.updateProviderInfo(i.rpcUrl, e);
  }
  setAppInfo(e, r) {
    this.initializeRelay().then((n) => n.setAppInfo(e, r));
  }
  async enable() {
    var e;
    return (
      (e = this.diagnostic) === null ||
        e === void 0 ||
        e.log(lh.EVENTS.ETH_ACCOUNTS_STATE, {
          method: "provider::enable",
          addresses_length: this._addresses.length,
          sessionIdHash: this._relay
            ? Ty.Session.hash(this._relay.session.id)
            : void 0,
        }),
      this._isAuthorized()
        ? [...this._addresses]
        : await this.send("eth_requestAccounts")
    );
  }
  async close() {
    (await this.initializeRelay()).resetAndReload();
  }
  send(e, r) {
    try {
      const n = this._send(e, r);
      if (n instanceof Promise)
        return n.catch((i) => {
          throw (0, Wt.serializeError)(i, e);
        });
    } catch (n) {
      throw (0, Wt.serializeError)(n, e);
    }
  }
  _send(e, r) {
    if (typeof e == "string") {
      const i = e,
        a = Array.isArray(r) ? r : r !== void 0 ? [r] : [],
        s = {
          jsonrpc: "2.0",
          id: 0,
          method: i,
          params: a,
        };
      return this._sendRequestAsync(s).then((o) => o.result);
    }
    if (typeof r == "function") {
      const i = e,
        a = r;
      return this._sendAsync(i, a);
    }
    if (Array.isArray(e)) return e.map((a) => this._sendRequest(a));
    const n = e;
    return this._sendRequest(n);
  }
  async sendAsync(e, r) {
    try {
      return this._sendAsync(e, r).catch((n) => {
        throw (0, Wt.serializeError)(n, e);
      });
    } catch (n) {
      return Promise.reject((0, Wt.serializeError)(n, e));
    }
  }
  async _sendAsync(e, r) {
    if (typeof r != "function") throw new Error("callback is required");
    if (Array.isArray(e)) {
      const i = r;
      this._sendMultipleRequestsAsync(e)
        .then((a) => i(null, a))
        .catch((a) => i(a, null));
      return;
    }
    const n = r;
    return this._sendRequestAsync(e)
      .then((i) => n(null, i))
      .catch((i) => n(i, null));
  }
  async request(e) {
    try {
      return this._request(e).catch((r) => {
        throw (0, Wt.serializeError)(r, e.method);
      });
    } catch (r) {
      return Promise.reject((0, Wt.serializeError)(r, e.method));
    }
  }
  async _request(e) {
    if (!e || typeof e != "object" || Array.isArray(e))
      throw Wt.standardErrors.rpc.invalidRequest({
        message: "Expected a single, non-array, object argument.",
        data: e,
      });
    const { method: r, params: n } = e;
    if (typeof r != "string" || r.length === 0)
      throw Wt.standardErrors.rpc.invalidRequest({
        message: "'args.method' must be a non-empty string.",
        data: e,
      });
    if (
      n !== void 0 &&
      !Array.isArray(n) &&
      (typeof n != "object" || n === null)
    )
      throw Wt.standardErrors.rpc.invalidRequest({
        message: "'args.params' must be an object or array if provided.",
        data: e,
      });
    const i = n === void 0 ? [] : n,
      a = this._relayEventManager.makeRequestId();
    return (
      await this._sendRequestAsync({
        method: r,
        params: i,
        jsonrpc: "2.0",
        id: a,
      })
    ).result;
  }
  async scanQRCode(e) {
    const n = await (
      await this.initializeRelay()
    ).scanQRCode((0, wt.ensureRegExpString)(e)).promise;
    if ((0, Xi.isErrorResponse)(n))
      throw (0, Wt.serializeError)(n.errorMessage, "scanQRCode");
    if (typeof n.result != "string")
      throw (0, Wt.serializeError)("result was not a string", "scanQRCode");
    return n.result;
  }
  async genericRequest(e, r) {
    const i = await (await this.initializeRelay()).genericRequest(e, r).promise;
    if ((0, Xi.isErrorResponse)(i))
      throw (0, Wt.serializeError)(i.errorMessage, "generic");
    if (typeof i.result != "string")
      throw (0, Wt.serializeError)("result was not a string", "generic");
    return i.result;
  }
  async connectAndSignIn(e) {
    var r;
    (r = this.diagnostic) === null ||
      r === void 0 ||
      r.log(lh.EVENTS.ETH_ACCOUNTS_STATE, {
        method: "provider::connectAndSignIn",
        sessionIdHash: this._relay
          ? Ty.Session.hash(this._relay.session.id)
          : void 0,
      });
    let n;
    try {
      const a = await this.initializeRelay();
      if (!(a instanceof t6e.MobileRelay))
        throw new Error("connectAndSignIn is only supported on mobile");
      if (
        ((n = await a.connectAndSignIn(e).promise), (0, Xi.isErrorResponse)(n))
      )
        throw new Error(n.errorMessage);
    } catch (a) {
      throw typeof a.message == "string" &&
        a.message.match(/(denied|rejected)/i)
        ? Wt.standardErrors.provider.userRejectedRequest(
            "User denied account authorization"
          )
        : a;
    }
    if (!n.result) throw new Error("accounts received is empty");
    const { accounts: i } = n.result;
    return (
      this._setAddresses(i),
      this.isCoinbaseBrowser ||
        (await this.switchEthereumChain(this.getChainId())),
      n.result
    );
  }
  async selectProvider(e) {
    const n = await (await this.initializeRelay()).selectProvider(e).promise;
    if ((0, Xi.isErrorResponse)(n))
      throw (0, Wt.serializeError)(n.errorMessage, "selectProvider");
    if (typeof n.result != "string")
      throw (0, Wt.serializeError)("result was not a string", "selectProvider");
    return n.result;
  }
  supportsSubscriptions() {
    return !1;
  }
  subscribe() {
    throw new Error("Subscriptions are not supported");
  }
  unsubscribe() {
    throw new Error("Subscriptions are not supported");
  }
  disconnect() {
    return !0;
  }
  _sendRequest(e) {
    const r = {
        jsonrpc: "2.0",
        id: e.id,
      },
      { method: n } = e;
    if (((r.result = this._handleSynchronousMethods(e)), r.result === void 0))
      throw new Error(
        `Coinbase Wallet does not support calling ${n} synchronously without a callback. Please provide a callback parameter to call ${n} asynchronously.`
      );
    return r;
  }
  _setAddresses(e, r) {
    if (!Array.isArray(e)) throw new Error("addresses is not an array");
    const n = e.map((i) => (0, wt.ensureAddressString)(i));
    JSON.stringify(n) !== JSON.stringify(this._addresses) &&
      ((this._addresses = n),
      this.emit("accountsChanged", this._addresses),
      this._storage.setItem(lI.LOCAL_STORAGE_ADDRESSES_KEY, n.join(" ")));
  }
  _sendRequestAsync(e) {
    return new Promise((r, n) => {
      try {
        const i = this._handleSynchronousMethods(e);
        if (i !== void 0)
          return r({
            jsonrpc: "2.0",
            id: e.id,
            result: i,
          });
        const a = this._handleAsynchronousFilterMethods(e);
        if (a !== void 0) {
          a.then((o) =>
            r(
              Object.assign(Object.assign({}, o), {
                id: e.id,
              })
            )
          ).catch((o) => n(o));
          return;
        }
        const s = this._handleSubscriptionMethods(e);
        if (s !== void 0) {
          s.then((o) =>
            r({
              jsonrpc: "2.0",
              id: e.id,
              result: o.result,
            })
          ).catch((o) => n(o));
          return;
        }
      } catch (i) {
        return n(i);
      }
      this._handleAsynchronousMethods(e)
        .then(
          (i) =>
            i &&
            r(
              Object.assign(Object.assign({}, i), {
                id: e.id,
              })
            )
        )
        .catch((i) => n(i));
    });
  }
  _sendMultipleRequestsAsync(e) {
    return Promise.all(e.map((r) => this._sendRequestAsync(r)));
  }
  _handleSynchronousMethods(e) {
    const { method: r } = e,
      n = e.params || [];
    switch (r) {
      case "eth_accounts":
        return this._eth_accounts();
      case "eth_coinbase":
        return this._eth_coinbase();
      case "eth_uninstallFilter":
        return this._eth_uninstallFilter(n);
      case "net_version":
        return this._net_version();
      case "eth_chainId":
        return this._eth_chainId();
      default:
        return;
    }
  }
  async _handleAsynchronousMethods(e) {
    const { method: r } = e,
      n = e.params || [];
    switch (r) {
      case "eth_requestAccounts":
        return this._eth_requestAccounts();
      case "eth_sign":
        return this._eth_sign(n);
      case "eth_ecRecover":
        return this._eth_ecRecover(n);
      case "personal_sign":
        return this._personal_sign(n);
      case "personal_ecRecover":
        return this._personal_ecRecover(n);
      case "eth_signTransaction":
        return this._eth_signTransaction(n);
      case "eth_sendRawTransaction":
        return this._eth_sendRawTransaction(n);
      case "eth_sendTransaction":
        return this._eth_sendTransaction(n);
      case "eth_signTypedData_v1":
        return this._eth_signTypedData_v1(n);
      case "eth_signTypedData_v2":
        return this._throwUnsupportedMethodError();
      case "eth_signTypedData_v3":
        return this._eth_signTypedData_v3(n);
      case "eth_signTypedData_v4":
      case "eth_signTypedData":
        return this._eth_signTypedData_v4(n);
      case "cbWallet_arbitrary":
        return this._cbwallet_arbitrary(n);
      case "wallet_addEthereumChain":
        return this._wallet_addEthereumChain(n);
      case "wallet_switchEthereumChain":
        return this._wallet_switchEthereumChain(n);
      case "wallet_watchAsset":
        return this._wallet_watchAsset(n);
    }
    return (await this.initializeRelay())
      .makeEthereumJSONRPCRequest(e, this.jsonRpcUrl)
      .catch((a) => {
        var s;
        throw (
          ((a.code === Wt.standardErrorCodes.rpc.methodNotFound ||
            a.code === Wt.standardErrorCodes.rpc.methodNotSupported) &&
            ((s = this.diagnostic) === null ||
              s === void 0 ||
              s.log(lh.EVENTS.METHOD_NOT_IMPLEMENTED, {
                method: e.method,
                sessionIdHash: this._relay
                  ? Ty.Session.hash(this._relay.session.id)
                  : void 0,
              })),
          a)
        );
      });
  }
  _handleAsynchronousFilterMethods(e) {
    const { method: r } = e,
      n = e.params || [];
    switch (r) {
      case "eth_newFilter":
        return this._eth_newFilter(n);
      case "eth_newBlockFilter":
        return this._eth_newBlockFilter();
      case "eth_newPendingTransactionFilter":
        return this._eth_newPendingTransactionFilter();
      case "eth_getFilterChanges":
        return this._eth_getFilterChanges(n);
      case "eth_getFilterLogs":
        return this._eth_getFilterLogs(n);
    }
  }
  _handleSubscriptionMethods(e) {
    switch (e.method) {
      case "eth_subscribe":
      case "eth_unsubscribe":
        return this._subscriptionManager.handleRequest(e);
    }
  }
  _isKnownAddress(e) {
    try {
      const r = (0, wt.ensureAddressString)(e);
      return this._addresses
        .map((i) => (0, wt.ensureAddressString)(i))
        .includes(r);
    } catch {}
    return !1;
  }
  _ensureKnownAddress(e) {
    var r;
    if (!this._isKnownAddress(e))
      throw (
        ((r = this.diagnostic) === null ||
          r === void 0 ||
          r.log(lh.EVENTS.UNKNOWN_ADDRESS_ENCOUNTERED),
        new Error("Unknown Ethereum address"))
      );
  }
  _prepareTransactionParams(e) {
    const r = e.from
      ? (0, wt.ensureAddressString)(e.from)
      : this.selectedAddress;
    if (!r) throw new Error("Ethereum address is unavailable");
    this._ensureKnownAddress(r);
    const n = e.to ? (0, wt.ensureAddressString)(e.to) : null,
      i = e.value != null ? (0, wt.ensureBN)(e.value) : new X5e.default(0),
      a = e.data ? (0, wt.ensureBuffer)(e.data) : Buffer.alloc(0),
      s = e.nonce != null ? (0, wt.ensureIntNumber)(e.nonce) : null,
      o = e.gasPrice != null ? (0, wt.ensureBN)(e.gasPrice) : null,
      c = e.maxFeePerGas != null ? (0, wt.ensureBN)(e.maxFeePerGas) : null,
      u =
        e.maxPriorityFeePerGas != null
          ? (0, wt.ensureBN)(e.maxPriorityFeePerGas)
          : null,
      d = e.gas != null ? (0, wt.ensureBN)(e.gas) : null,
      m = e.chainId ? (0, wt.ensureIntNumber)(e.chainId) : this.getChainId();
    return {
      fromAddress: r,
      toAddress: n,
      weiValue: i,
      data: a,
      nonce: s,
      gasPriceInWei: o,
      maxFeePerGas: c,
      maxPriorityFeePerGas: u,
      gasLimit: d,
      chainId: m,
    };
  }
  _isAuthorized() {
    return this._addresses.length > 0;
  }
  _requireAuthorization() {
    if (!this._isAuthorized())
      throw Wt.standardErrors.provider.unauthorized({});
  }
  _throwUnsupportedMethodError() {
    throw Wt.standardErrors.provider.unsupportedMethod({});
  }
  async _signEthereumMessage(e, r, n, i) {
    this._ensureKnownAddress(r);
    try {
      const s = await (
        await this.initializeRelay()
      ).signEthereumMessage(e, r, n, i).promise;
      if ((0, Xi.isErrorResponse)(s)) throw new Error(s.errorMessage);
      return {
        jsonrpc: "2.0",
        id: 0,
        result: s.result,
      };
    } catch (a) {
      throw typeof a.message == "string" &&
        a.message.match(/(denied|rejected)/i)
        ? Wt.standardErrors.provider.userRejectedRequest(
            "User denied message signature"
          )
        : a;
    }
  }
  async _ethereumAddressFromSignedMessage(e, r, n) {
    const a = await (
      await this.initializeRelay()
    ).ethereumAddressFromSignedMessage(e, r, n).promise;
    if ((0, Xi.isErrorResponse)(a)) throw new Error(a.errorMessage);
    return {
      jsonrpc: "2.0",
      id: 0,
      result: a.result,
    };
  }
  _eth_accounts() {
    return [...this._addresses];
  }
  _eth_coinbase() {
    return this.selectedAddress || null;
  }
  _net_version() {
    return this.getChainId().toString(10);
  }
  _eth_chainId() {
    return (0, wt.hexStringFromIntNumber)(this.getChainId());
  }
  getChainId() {
    const e = this._storage.getItem(uI);
    if (!e) return (0, wt.ensureIntNumber)(this._chainIdFromOpts);
    const r = parseInt(e, 10);
    return (0, wt.ensureIntNumber)(r);
  }
  async _eth_requestAccounts() {
    var e;
    if (
      ((e = this.diagnostic) === null ||
        e === void 0 ||
        e.log(lh.EVENTS.ETH_ACCOUNTS_STATE, {
          method: "provider::_eth_requestAccounts",
          addresses_length: this._addresses.length,
          sessionIdHash: this._relay
            ? Ty.Session.hash(this._relay.session.id)
            : void 0,
        }),
      this._isAuthorized())
    )
      return Promise.resolve({
        jsonrpc: "2.0",
        id: 0,
        result: this._addresses,
      });
    let r;
    try {
      if (
        ((r = await (await this.initializeRelay()).requestEthereumAccounts()
          .promise),
        (0, Xi.isErrorResponse)(r))
      )
        throw new Error(r.errorMessage);
    } catch (n) {
      throw typeof n.message == "string" &&
        n.message.match(/(denied|rejected)/i)
        ? Wt.standardErrors.provider.userRejectedRequest(
            "User denied account authorization"
          )
        : n;
    }
    if (!r.result) throw new Error("accounts received is empty");
    return (
      this._setAddresses(r.result),
      this.isCoinbaseBrowser ||
        (await this.switchEthereumChain(this.getChainId())),
      {
        jsonrpc: "2.0",
        id: 0,
        result: this._addresses,
      }
    );
  }
  _eth_sign(e) {
    this._requireAuthorization();
    const r = (0, wt.ensureAddressString)(e[0]),
      n = (0, wt.ensureBuffer)(e[1]);
    return this._signEthereumMessage(n, r, !1);
  }
  _eth_ecRecover(e) {
    const r = (0, wt.ensureBuffer)(e[0]),
      n = (0, wt.ensureBuffer)(e[1]);
    return this._ethereumAddressFromSignedMessage(r, n, !1);
  }
  _personal_sign(e) {
    this._requireAuthorization();
    const r = (0, wt.ensureBuffer)(e[0]),
      n = (0, wt.ensureAddressString)(e[1]);
    return this._signEthereumMessage(r, n, !0);
  }
  _personal_ecRecover(e) {
    const r = (0, wt.ensureBuffer)(e[0]),
      n = (0, wt.ensureBuffer)(e[1]);
    return this._ethereumAddressFromSignedMessage(r, n, !0);
  }
  async _eth_signTransaction(e) {
    this._requireAuthorization();
    const r = this._prepareTransactionParams(e[0] || {});
    try {
      const i = await (await this.initializeRelay()).signEthereumTransaction(r)
        .promise;
      if ((0, Xi.isErrorResponse)(i)) throw new Error(i.errorMessage);
      return {
        jsonrpc: "2.0",
        id: 0,
        result: i.result,
      };
    } catch (n) {
      throw typeof n.message == "string" &&
        n.message.match(/(denied|rejected)/i)
        ? Wt.standardErrors.provider.userRejectedRequest(
            "User denied transaction signature"
          )
        : n;
    }
  }
  async _eth_sendRawTransaction(e) {
    const r = (0, wt.ensureBuffer)(e[0]),
      i = await (
        await this.initializeRelay()
      ).submitEthereumTransaction(r, this.getChainId()).promise;
    if ((0, Xi.isErrorResponse)(i)) throw new Error(i.errorMessage);
    return {
      jsonrpc: "2.0",
      id: 0,
      result: i.result,
    };
  }
  async _eth_sendTransaction(e) {
    this._requireAuthorization();
    const r = this._prepareTransactionParams(e[0] || {});
    try {
      const i = await (
        await this.initializeRelay()
      ).signAndSubmitEthereumTransaction(r).promise;
      if ((0, Xi.isErrorResponse)(i)) throw new Error(i.errorMessage);
      return {
        jsonrpc: "2.0",
        id: 0,
        result: i.result,
      };
    } catch (n) {
      throw typeof n.message == "string" &&
        n.message.match(/(denied|rejected)/i)
        ? Wt.standardErrors.provider.userRejectedRequest(
            "User denied transaction signature"
          )
        : n;
    }
  }
  async _eth_signTypedData_v1(e) {
    this._requireAuthorization();
    const r = (0, wt.ensureParsedJSONObject)(e[0]),
      n = (0, wt.ensureAddressString)(e[1]);
    this._ensureKnownAddress(n);
    const i = M5.default.hashForSignTypedDataLegacy({
        data: r,
      }),
      a = JSON.stringify(r, null, 2);
    return this._signEthereumMessage(i, n, !1, a);
  }
  async _eth_signTypedData_v3(e) {
    this._requireAuthorization();
    const r = (0, wt.ensureAddressString)(e[0]),
      n = (0, wt.ensureParsedJSONObject)(e[1]);
    this._ensureKnownAddress(r);
    const i = M5.default.hashForSignTypedData_v3({
        data: n,
      }),
      a = JSON.stringify(n, null, 2);
    return this._signEthereumMessage(i, r, !1, a);
  }
  async _eth_signTypedData_v4(e) {
    this._requireAuthorization();
    const r = (0, wt.ensureAddressString)(e[0]),
      n = (0, wt.ensureParsedJSONObject)(e[1]);
    this._ensureKnownAddress(r);
    const i = M5.default.hashForSignTypedData_v4({
        data: n,
      }),
      a = JSON.stringify(n, null, 2);
    return this._signEthereumMessage(i, r, !1, a);
  }
  async _cbwallet_arbitrary(e) {
    const r = e[0],
      n = e[1];
    if (typeof n != "string") throw new Error("parameter must be a string");
    if (typeof r != "object" || r === null)
      throw new Error("parameter must be an object");
    return {
      jsonrpc: "2.0",
      id: 0,
      result: await this.genericRequest(r, n),
    };
  }
  async _wallet_addEthereumChain(e) {
    var r, n, i, a;
    const s = e[0];
    if (((r = s.rpcUrls) === null || r === void 0 ? void 0 : r.length) === 0)
      return {
        jsonrpc: "2.0",
        id: 0,
        error: {
          code: 2,
          message: "please pass in at least 1 rpcUrl",
        },
      };
    if (!s.chainName || s.chainName.trim() === "")
      throw Wt.standardErrors.rpc.invalidParams(
        "chainName is a required field"
      );
    if (!s.nativeCurrency)
      throw Wt.standardErrors.rpc.invalidParams(
        "nativeCurrency is a required field"
      );
    const o = parseInt(s.chainId, 16);
    return (await this.addEthereumChain(
      o,
      (n = s.rpcUrls) !== null && n !== void 0 ? n : [],
      (i = s.blockExplorerUrls) !== null && i !== void 0 ? i : [],
      s.chainName,
      (a = s.iconUrls) !== null && a !== void 0 ? a : [],
      s.nativeCurrency
    ))
      ? {
          jsonrpc: "2.0",
          id: 0,
          result: null,
        }
      : {
          jsonrpc: "2.0",
          id: 0,
          error: {
            code: 2,
            message: "unable to add ethereum chain",
          },
        };
  }
  async _wallet_switchEthereumChain(e) {
    const r = e[0];
    return (
      await this.switchEthereumChain(parseInt(r.chainId, 16)),
      {
        jsonrpc: "2.0",
        id: 0,
        result: null,
      }
    );
  }
  async _wallet_watchAsset(e) {
    const r = Array.isArray(e) ? e[0] : e;
    if (!r.type) throw Wt.standardErrors.rpc.invalidParams("Type is required");
    if ((r == null ? void 0 : r.type) !== "ERC20")
      throw Wt.standardErrors.rpc.invalidParams(
        `Asset of type '${r.type}' is not supported`
      );
    if (!(r != null && r.options))
      throw Wt.standardErrors.rpc.invalidParams("Options are required");
    if (!(r != null && r.options.address))
      throw Wt.standardErrors.rpc.invalidParams("Address is required");
    const n = this.getChainId(),
      { address: i, symbol: a, image: s, decimals: o } = r.options;
    return {
      jsonrpc: "2.0",
      id: 0,
      result: await this.watchAsset(r.type, i, a, o, s, n),
    };
  }
  _eth_uninstallFilter(e) {
    const r = (0, wt.ensureHexString)(e[0]);
    return this._filterPolyfill.uninstallFilter(r);
  }
  async _eth_newFilter(e) {
    const r = e[0];
    return {
      jsonrpc: "2.0",
      id: 0,
      result: await this._filterPolyfill.newFilter(r),
    };
  }
  async _eth_newBlockFilter() {
    return {
      jsonrpc: "2.0",
      id: 0,
      result: await this._filterPolyfill.newBlockFilter(),
    };
  }
  async _eth_newPendingTransactionFilter() {
    return {
      jsonrpc: "2.0",
      id: 0,
      result: await this._filterPolyfill.newPendingTransactionFilter(),
    };
  }
  _eth_getFilterChanges(e) {
    const r = (0, wt.ensureHexString)(e[0]);
    return this._filterPolyfill.getFilterChanges(r);
  }
  _eth_getFilterLogs(e) {
    const r = (0, wt.ensureHexString)(e[0]);
    return this._filterPolyfill.getFilterLogs(r);
  }
  initializeRelay() {
    return this._relay
      ? Promise.resolve(this._relay)
      : this._relayProvider().then(
          (e) => (
            e.setAccountsCallback((r, n) => this._setAddresses(r, n)),
            e.setChainCallback((r, n) => {
              this.updateProviderInfo(n, parseInt(r, 10));
            }),
            e.setDappDefaultChainCallback(this._chainIdFromOpts),
            (this._relay = e),
            e
          )
        );
  }
}
Wf.CoinbaseWalletProvider = i6e;
var Dx = {};
Object.defineProperty(Dx, "__esModule", {
  value: !0,
});
Dx.RelayEventManager = void 0;
const a6e = ot;
class s6e {
  constructor() {
    (this._nextRequestId = 0), (this.callbacks = new Map());
  }
  makeRequestId() {
    this._nextRequestId = (this._nextRequestId + 1) % 2147483647;
    const e = this._nextRequestId,
      r = (0, a6e.prepend0x)(e.toString(16));
    return this.callbacks.get(r) && this.callbacks.delete(r), e;
  }
}
Dx.RelayEventManager = s6e;
Object.defineProperty(lm, "__esModule", {
  value: !0,
});
lm.CoinbaseWalletSDK = void 0;
const o6e = Uv,
  c6e = Wv,
  dI = ot,
  l6e = Vv,
  u6e = Wf,
  f6e = Jm,
  d6e = o1,
  h6e = Dx,
  p6e = r1,
  m6e = Qm,
  rj = Sd;
class Ox {
  constructor(e) {
    var r, n, i;
    (this._appName = ""),
      (this._appLogoUrl = null),
      (this._relay = null),
      (this._relayEventManager = null);
    const a = e.linkAPIUrl || c6e.LINK_API_URL;
    typeof e.overrideIsMetaMask > "u"
      ? (this._overrideIsMetaMask = !1)
      : (this._overrideIsMetaMask = e.overrideIsMetaMask),
      (this._overrideIsCoinbaseWallet =
        (r = e.overrideIsCoinbaseWallet) !== null && r !== void 0 ? r : !0),
      (this._overrideIsCoinbaseBrowser =
        (n = e.overrideIsCoinbaseBrowser) !== null && n !== void 0 ? n : !1),
      (this._diagnosticLogger = e.diagnosticLogger),
      (this._reloadOnDisconnect =
        (i = e.reloadOnDisconnect) !== null && i !== void 0 ? i : !0);
    const s = new URL(a),
      o = `${s.protocol}//${s.host}`;
    if (
      ((this._storage = new l6e.ScopedLocalStorage(`-walletlink:${o}`)),
      this._storage.setItem("version", Ox.VERSION),
      this.walletExtension || this.coinbaseBrowser)
    )
      return;
    this._relayEventManager = new h6e.RelayEventManager();
    const c = (0, dI.isMobileWeb)(),
      u =
        e.uiConstructor ||
        ((m) => (c ? new d6e.MobileRelayUI(m) : new p6e.WalletLinkRelayUI(m))),
      d = {
        linkAPIUrl: a,
        version: rj.LIB_VERSION,
        darkMode: !!e.darkMode,
        headlessMode: !!e.headlessMode,
        uiConstructor: u,
        storage: this._storage,
        relayEventManager: this._relayEventManager,
        diagnosticLogger: this._diagnosticLogger,
        reloadOnDisconnect: this._reloadOnDisconnect,
        enableMobileWalletLink: e.enableMobileWalletLink,
      };
    (this._relay = c ? new f6e.MobileRelay(d) : new m6e.WalletLinkRelay(d)),
      this.setAppInfo(e.appName, e.appLogoUrl),
      !e.headlessMode && this._relay.attachUI();
  }
  makeWeb3Provider(e = "", r = 1) {
    const n = this.walletExtension;
    if (n)
      return (
        this.isCipherProvider(n) || n.setProviderInfo(e, r),
        this._reloadOnDisconnect === !1 &&
          typeof n.disableReloadOnDisconnect == "function" &&
          n.disableReloadOnDisconnect(),
        n
      );
    const i = this.coinbaseBrowser;
    if (i) return i;
    const a = this._relay;
    if (!a || !this._relayEventManager || !this._storage)
      throw new Error("Relay not initialized, should never happen");
    return (
      e || a.setConnectDisabled(!0),
      new u6e.CoinbaseWalletProvider({
        relayProvider: () => Promise.resolve(a),
        relayEventManager: this._relayEventManager,
        storage: this._storage,
        jsonRpcUrl: e,
        chainId: r,
        qrUrl: this.getQrUrl(),
        diagnosticLogger: this._diagnosticLogger,
        overrideIsMetaMask: this._overrideIsMetaMask,
        overrideIsCoinbaseWallet: this._overrideIsCoinbaseWallet,
        overrideIsCoinbaseBrowser: this._overrideIsCoinbaseBrowser,
      })
    );
  }
  setAppInfo(e, r) {
    var n;
    (this._appName = e || "DApp"),
      (this._appLogoUrl = r || (0, dI.getFavicon)());
    const i = this.walletExtension;
    i
      ? this.isCipherProvider(i) ||
        i.setAppInfo(this._appName, this._appLogoUrl)
      : (n = this._relay) === null ||
        n === void 0 ||
        n.setAppInfo(this._appName, this._appLogoUrl);
  }
  disconnect() {
    var e;
    const r = this === null || this === void 0 ? void 0 : this.walletExtension;
    r
      ? r.close()
      : (e = this._relay) === null || e === void 0 || e.resetAndReload();
  }
  getQrUrl() {
    var e, r;
    return (r =
      (e = this._relay) === null || e === void 0
        ? void 0
        : e.getQRCodeUrl()) !== null && r !== void 0
      ? r
      : null;
  }
  getCoinbaseWalletLogo(e, r = 240) {
    return (0, o6e.walletLogo)(e, r);
  }
  get walletExtension() {
    var e;
    return (e = window.coinbaseWalletExtension) !== null && e !== void 0
      ? e
      : window.walletLinkExtension;
  }
  get coinbaseBrowser() {
    var e, r;
    try {
      const n =
        (e = window.ethereum) !== null && e !== void 0
          ? e
          : (r = window.top) === null || r === void 0
          ? void 0
          : r.ethereum;
      return n && "isCoinbaseBrowser" in n && n.isCoinbaseBrowser ? n : void 0;
    } catch {
      return;
    }
  }
  isCipherProvider(e) {
    return typeof e.isCipher == "boolean" && e.isCipher;
  }
}
lm.CoinbaseWalletSDK = Ox;
Ox.VERSION = rj.LIB_VERSION;
(function (t) {
  Object.defineProperty(t, "__esModule", {
    value: !0,
  }),
    (t.CoinbaseWalletProvider = t.CoinbaseWalletSDK = void 0);
  const e = lm,
    r = Wf;
  var n = lm;
  Object.defineProperty(t, "CoinbaseWalletSDK", {
    enumerable: !0,
    get: function () {
      return n.CoinbaseWalletSDK;
    },
  });
  var i = Wf;
  Object.defineProperty(t, "CoinbaseWalletProvider", {
    enumerable: !0,
    get: function () {
      return i.CoinbaseWalletProvider;
    },
  }),
    (t.default = e.CoinbaseWalletSDK),
    typeof window < "u" &&
      ((window.CoinbaseWalletSDK = e.CoinbaseWalletSDK),
      (window.CoinbaseWalletProvider = r.CoinbaseWalletProvider),
      (window.WalletLink = e.CoinbaseWalletSDK),
      (window.WalletLinkProvider = r.CoinbaseWalletProvider));
})(b$);
var I5 = new WeakMap(),
  uh = new WeakMap();
class y6e extends $v {
  constructor(e) {
    var r;
    super(e),
      Dt(this, "id", "coinbasewallet"),
      Dt(this, "name", "Coinbase Wallet"),
      Dt(
        this,
        "ready",
        typeof window < "u" &&
          !(
            (r = window.ethereum) !== null &&
            r !== void 0 &&
            r.isCoinbaseWallet
          )
      ),
      ob(this, I5, {
        writable: !0,
        value: void 0,
      }),
      ob(this, uh, {
        writable: !0,
        value: void 0,
      }),
      Dt(this, "onAccountsChanged", (n) => {
        n.length === 0
          ? this.emit("disconnect")
          : this.emit("change", {
              account: oa.getAddress(n[0]),
            });
      }),
      Dt(this, "onChainChanged", (n) => {
        const i = $f(n),
          a = this.isChainUnsupported(i);
        this.emit("change", {
          chain: {
            id: i,
            unsupported: a,
          },
        });
      }),
      Dt(this, "onDisconnect", () => {
        this.emit("disconnect");
      });
  }
  async connect() {
    try {
      const e = this.getProvider();
      e.on("accountsChanged", this.onAccountsChanged),
        e.on("chainChanged", this.onChainChanged),
        e.on("disconnect", this.onDisconnect);
      const r = await e.enable(),
        n = oa.getAddress(r[0]),
        i = await this.getChainId(),
        a = this.isChainUnsupported(i);
      return {
        account: n,
        chain: {
          id: i,
          unsupported: a,
        },
        provider: new kf(e),
      };
    } catch (e) {
      throw /user closed modal/i.test(e.message) ? new Uf() : e;
    }
  }
  async disconnect() {
    if (!Zl(this, uh)) return;
    const e = this.getProvider();
    if (
      (e.removeListener("accountsChanged", this.onAccountsChanged),
      e.removeListener("chainChanged", this.onChainChanged),
      e.removeListener("disconnect", this.onDisconnect),
      e.disconnect(),
      e.close(),
      typeof localStorage < "u")
    ) {
      let r = localStorage.length;
      for (; r--; ) {
        const n = localStorage.key(r);
        n && /-walletlink/.test(n) && localStorage.removeItem(n);
      }
    }
  }
  async getAccount() {
    const r = await this.getProvider().request({
      method: "eth_accounts",
    });
    return oa.getAddress(r[0]);
  }
  async getChainId() {
    const e = this.getProvider();
    return $f(e.chainId);
  }
  getProvider() {
    return (
      Zl(this, uh) ||
        (cb(this, I5, new b$.CoinbaseWalletSDK(this.options)),
        cb(this, uh, Zl(this, I5).makeWeb3Provider(this.options.jsonRpcUrl))),
      Zl(this, uh)
    );
  }
  async getSigner() {
    const e = this.getProvider(),
      r = await this.getAccount();
    return new kf(e).getSigner(r);
  }
  async isAuthorized() {
    try {
      return !!(await this.getAccount());
    } catch {
      return !1;
    }
  }
  async switchChain(e) {
    const r = this.getProvider(),
      n = oa.hexValue(e);
    try {
      return (
        await r.request({
          method: "wallet_switchEthereumChain",
          params: [
            {
              chainId: n,
            },
          ],
        }),
        [...this.chains, ...QE].find((a) => a.id === e)
      );
    } catch (i) {
      throw /user rejected signature request/i.test(i.message)
        ? new Uf()
        : new YE();
    }
  }
}
var g6e = Object.defineProperty,
  b6e = Object.defineProperties,
  v6e = Object.getOwnPropertyDescriptors,
  hI = Object.getOwnPropertySymbols,
  x6e = Object.prototype.hasOwnProperty,
  w6e = Object.prototype.propertyIsEnumerable,
  pI = (t, e, r) =>
    e in t
      ? g6e(t, e, {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: r,
        })
      : (t[e] = r),
  mI = (t, e) => {
    for (var r in e || (e = {})) x6e.call(e, r) && pI(t, r, e[r]);
    if (hI) for (var r of hI(e)) w6e.call(e, r) && pI(t, r, e[r]);
    return t;
  },
  yI = (t, e) => b6e(t, v6e(e));
const _6e = {
    Accept: "application/json",
    "Content-Type": "application/json",
  },
  E6e = "POST",
  gI = {
    headers: _6e,
    method: E6e,
  },
  bI = 10;
let T6e = class {
  constructor(e, r = !1) {
    if (
      ((this.url = e),
      (this.disableProviderPing = r),
      (this.events = new Cd.EventEmitter()),
      (this.isAvailable = !1),
      (this.registering = !1),
      !_9(e))
    )
      throw new Error(
        `Provided URL is not compatible with HTTP connection: ${e}`
      );
    (this.url = e), (this.disableProviderPing = r);
  }
  get connected() {
    return this.isAvailable;
  }
  get connecting() {
    return this.registering;
  }
  on(e, r) {
    this.events.on(e, r);
  }
  once(e, r) {
    this.events.once(e, r);
  }
  off(e, r) {
    this.events.off(e, r);
  }
  removeListener(e, r) {
    this.events.removeListener(e, r);
  }
  async open(e = this.url) {
    await this.register(e);
  }
  async close() {
    if (!this.isAvailable) throw new Error("Connection already closed");
    this.onClose();
  }
  async send(e) {
    this.isAvailable || (await this.register());
    try {
      const r = h9(e),
        n = await (
          await _s(
            this.url,
            yI(mI({}, gI), {
              body: r,
            })
          )
        ).json();
      this.onPayload({
        data: n,
      });
    } catch (r) {
      this.onError(e.id, r);
    }
  }
  async register(e = this.url) {
    if (!_9(e))
      throw new Error(
        `Provided URL is not compatible with HTTP connection: ${e}`
      );
    if (this.registering) {
      const r = this.events.getMaxListeners();
      return (
        (this.events.listenerCount("register_error") >= r ||
          this.events.listenerCount("open") >= r) &&
          this.events.setMaxListeners(r + 1),
        new Promise((n, i) => {
          this.events.once("register_error", (a) => {
            this.resetMaxListeners(), i(a);
          }),
            this.events.once("open", () => {
              if ((this.resetMaxListeners(), typeof this.isAvailable > "u"))
                return i(new Error("HTTP connection is missing or invalid"));
              n();
            });
        })
      );
    }
    (this.url = e), (this.registering = !0);
    try {
      if (!this.disableProviderPing) {
        const r = h9({
          id: 1,
          jsonrpc: "2.0",
          method: "test",
          params: [],
        });
        await _s(
          e,
          yI(mI({}, gI), {
            body: r,
          })
        );
      }
      this.onOpen();
    } catch (r) {
      const n = this.parseError(r);
      throw (this.events.emit("register_error", n), this.onClose(), n);
    }
  }
  onOpen() {
    (this.isAvailable = !0), (this.registering = !1), this.events.emit("open");
  }
  onClose() {
    (this.isAvailable = !1), (this.registering = !1), this.events.emit("close");
  }
  onPayload(e) {
    if (typeof e.data > "u") return;
    const r = typeof e.data == "string" ? tpe(e.data) : e.data;
    this.events.emit("payload", r);
  }
  onError(e, r) {
    const n = this.parseError(r),
      i = n.message || n.toString(),
      a = n4(e, i);
    this.events.emit("payload", a);
  }
  parseError(e, r = this.url) {
    return Cpe(e, r, "HTTP");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > bI && this.events.setMaxListeners(bI);
  }
};
var HT = {},
  gr = {};
Object.defineProperty(gr, "__esModule", {
  value: !0,
});
var nj =
  (gr.getLocalStorage =
  pj =
  gr.getLocalStorageOrThrow =
  hj =
  gr.getCrypto =
  dj =
  gr.getCryptoOrThrow =
  fj =
  gr.getLocation =
  uj =
  gr.getLocationOrThrow =
  lj =
  gr.getNavigator =
  cj =
  gr.getNavigatorOrThrow =
  oj =
  gr.getDocument =
  sj =
  gr.getDocumentOrThrow =
  aj =
  gr.getFromWindowOrThrow =
  ij =
  gr.getFromWindow =
    void 0);
function Vu(t) {
  let e;
  return typeof window < "u" && typeof window[t] < "u" && (e = window[t]), e;
}
var ij = (gr.getFromWindow = Vu);
function Od(t) {
  const e = Vu(t);
  if (!e) throw new Error(`${t} is not defined in Window`);
  return e;
}
var aj = (gr.getFromWindowOrThrow = Od);
function C6e() {
  return Od("document");
}
var sj = (gr.getDocumentOrThrow = C6e);
function A6e() {
  return Vu("document");
}
var oj = (gr.getDocument = A6e);
function k6e() {
  return Od("navigator");
}
var cj = (gr.getNavigatorOrThrow = k6e);
function S6e() {
  return Vu("navigator");
}
var lj = (gr.getNavigator = S6e);
function M6e() {
  return Od("location");
}
var uj = (gr.getLocationOrThrow = M6e);
function I6e() {
  return Vu("location");
}
var fj = (gr.getLocation = I6e);
function R6e() {
  return Od("crypto");
}
var dj = (gr.getCryptoOrThrow = R6e);
function P6e() {
  return Vu("crypto");
}
var hj = (gr.getCrypto = P6e);
function N6e() {
  return Od("localStorage");
}
var pj = (gr.getLocalStorageOrThrow = N6e);
function B6e() {
  return Vu("localStorage");
}
nj = gr.getLocalStorage = B6e;
Object.defineProperty(HT, "__esModule", {
  value: !0,
});
var mj = (HT.getWindowMetadata = void 0);
const vI = gr;
function D6e() {
  let t, e;
  try {
    (t = vI.getDocumentOrThrow()), (e = vI.getLocationOrThrow());
  } catch {
    return null;
  }
  function r() {
    const m = t.getElementsByTagName("link"),
      v = [];
    for (let E = 0; E < m.length; E++) {
      const A = m[E],
        I = A.getAttribute("rel");
      if (I && I.toLowerCase().indexOf("icon") > -1) {
        const b = A.getAttribute("href");
        if (b)
          if (
            b.toLowerCase().indexOf("https:") === -1 &&
            b.toLowerCase().indexOf("http:") === -1 &&
            b.indexOf("//") !== 0
          ) {
            let w = e.protocol + "//" + e.host;
            if (b.indexOf("/") === 0) w += b;
            else {
              const S = e.pathname.split("/");
              S.pop();
              const k = S.join("/");
              w += k + "/" + b;
            }
            v.push(w);
          } else if (b.indexOf("//") === 0) {
            const w = e.protocol + b;
            v.push(w);
          } else v.push(b);
      }
    }
    return v;
  }
  function n(...m) {
    const v = t.getElementsByTagName("meta");
    for (let E = 0; E < v.length; E++) {
      const A = v[E],
        I = ["itemprop", "property", "name"]
          .map((b) => A.getAttribute(b))
          .filter((b) => (b ? m.includes(b) : !1));
      if (I.length && I) {
        const b = A.getAttribute("content");
        if (b) return b;
      }
    }
    return "";
  }
  function i() {
    let m = n("name", "og:site_name", "og:title", "twitter:title");
    return m || (m = t.title), m;
  }
  function a() {
    return n(
      "description",
      "og:description",
      "twitter:description",
      "keywords"
    );
  }
  const s = i(),
    o = a(),
    c = e.origin,
    u = r();
  return {
    description: o,
    url: c,
    icons: u,
    name: s,
  };
}
mj = HT.getWindowMetadata = D6e;
var O6e = function () {
    for (var t = 0, e = 0, r = arguments.length; e < r; e++)
      t += arguments[e].length;
    for (var n = Array(t), i = 0, e = 0; e < r; e++)
      for (var a = arguments[e], s = 0, o = a.length; s < o; s++, i++)
        n[i] = a[s];
    return n;
  },
  F6e = (function () {
    function t(e, r, n) {
      (this.name = e),
        (this.version = r),
        (this.os = n),
        (this.type = "browser");
    }
    return t;
  })(),
  L6e = (function () {
    function t(e) {
      (this.version = e),
        (this.type = "node"),
        (this.name = "node"),
        (this.os = process.platform);
    }
    return t;
  })(),
  $6e = (function () {
    function t(e, r, n, i) {
      (this.name = e),
        (this.version = r),
        (this.os = n),
        (this.bot = i),
        (this.type = "bot-device");
    }
    return t;
  })(),
  U6e = (function () {
    function t() {
      (this.type = "bot"),
        (this.bot = !0),
        (this.name = "bot"),
        (this.version = null),
        (this.os = null);
    }
    return t;
  })(),
  W6e = (function () {
    function t() {
      (this.type = "react-native"),
        (this.name = "react-native"),
        (this.version = null),
        (this.os = null);
    }
    return t;
  })(),
  j6e =
    /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/,
  H6e =
    /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,
  xI = 3,
  z6e = [
    ["aol", /AOLShield\/([0-9\._]+)/],
    ["edge", /Edge\/([0-9\._]+)/],
    ["edge-ios", /EdgiOS\/([0-9\._]+)/],
    ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
    ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
    ["samsung", /SamsungBrowser\/([0-9\.]+)/],
    ["silk", /\bSilk\/([0-9._-]+)\b/],
    ["miui", /MiuiBrowser\/([0-9\.]+)$/],
    ["beaker", /BeakerBrowser\/([0-9\.]+)/],
    ["edge-chromium", /EdgA?\/([0-9\.]+)/],
    [
      "chromium-webview",
      /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/,
    ],
    ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
    ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
    ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
    ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
    ["fxios", /FxiOS\/([0-9\.]+)/],
    ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
    ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
    ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
    ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
    ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
    ["ie", /MSIE\s(7\.0)/],
    ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
    ["android", /Android\s([0-9\.]+)/],
    ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
    ["safari", /Version\/([0-9\._]+).*Safari/],
    ["facebook", /FBAV\/([0-9\.]+)/],
    ["instagram", /Instagram\s([0-9\.]+)/],
    ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
    ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
    ["searchbot", j6e],
  ],
  wI = [
    ["iOS", /iP(hone|od|ad)/],
    ["Android OS", /Android/],
    ["BlackBerry OS", /BlackBerry|BB10/],
    ["Windows Mobile", /IEMobile/],
    ["Amazon OS", /Kindle/],
    ["Windows 3.11", /Win16/],
    ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
    ["Windows 98", /(Windows 98)|(Win98)/],
    ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
    ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
    ["Windows Server 2003", /(Windows NT 5.2)/],
    ["Windows Vista", /(Windows NT 6.0)/],
    ["Windows 7", /(Windows NT 6.1)/],
    ["Windows 8", /(Windows NT 6.2)/],
    ["Windows 8.1", /(Windows NT 6.3)/],
    ["Windows 10", /(Windows NT 10.0)/],
    ["Windows ME", /Windows ME/],
    ["Open BSD", /OpenBSD/],
    ["Sun OS", /SunOS/],
    ["Chrome OS", /CrOS/],
    ["Linux", /(Linux)|(X11)/],
    ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
    ["QNX", /QNX/],
    ["BeOS", /BeOS/],
    ["OS/2", /OS\/2/],
  ];
function q6e(t) {
  return t
    ? _I(t)
    : typeof document > "u" &&
      typeof navigator < "u" &&
      navigator.product === "ReactNative"
    ? new W6e()
    : typeof navigator < "u"
    ? _I(navigator.userAgent)
    : G6e();
}
function V6e(t) {
  return (
    t !== "" &&
    z6e.reduce(function (e, r) {
      var n = r[0],
        i = r[1];
      if (e) return e;
      var a = i.exec(t);
      return !!a && [n, a];
    }, !1)
  );
}
function _I(t) {
  var e = V6e(t);
  if (!e) return null;
  var r = e[0],
    n = e[1];
  if (r === "searchbot") return new U6e();
  var i = n[1] && n[1].split(/[._]/).slice(0, 3);
  i ? i.length < xI && (i = O6e(i, Z6e(xI - i.length))) : (i = []);
  var a = i.join("."),
    s = K6e(t),
    o = H6e.exec(t);
  return o && o[1] ? new $6e(r, a, s, o[1]) : new F6e(r, a, s);
}
function K6e(t) {
  for (var e = 0, r = wI.length; e < r; e++) {
    var n = wI[e],
      i = n[0],
      a = n[1],
      s = a.exec(t);
    if (s) return i;
  }
  return null;
}
function G6e() {
  var t = typeof process < "u" && process.version;
  return t ? new L6e(process.version.slice(1)) : null;
}
function Z6e(t) {
  for (var e = [], r = 0; r < t; r++) e.push("0");
  return e;
}
function Fx(t) {
  return q6e(t);
}
function Lx() {
  const t = Fx();
  return t && t.os ? t.os : void 0;
}
function yj() {
  const t = Lx();
  return t ? t.toLowerCase().includes("android") : !1;
}
function gj() {
  const t = Lx();
  return t
    ? t.toLowerCase().includes("ios") ||
        (t.toLowerCase().includes("mac") && navigator.maxTouchPoints > 1)
    : !1;
}
function bj() {
  return Lx() ? yj() || gj() : !1;
}
function vj() {
  const t = Fx();
  return t && t.name ? t.name.toLowerCase() === "node" : !1;
}
function xj() {
  return !vj() && !!wj();
}
const J6e = ij,
  Q6e = aj,
  Y6e = sj,
  X6e = oj,
  e_e = cj,
  wj = lj,
  t_e = uj,
  _j = fj,
  r_e = dj,
  n_e = hj,
  i_e = pj,
  $x = nj;
function w4() {
  return mj();
}
function a_e(t) {
  if (typeof t != "string")
    throw new Error(`Cannot safe json parse value of type ${typeof t}`);
  try {
    return JSON.parse(t);
  } catch {
    return t;
  }
}
function s_e(t) {
  return typeof t == "string" ? t : JSON.stringify(t);
}
const Ej = a_e,
  Tj = s_e;
function zT(t, e) {
  const r = Tj(e),
    n = $x();
  n && n.setItem(t, r);
}
function qT(t) {
  let e = null,
    r = null;
  const n = $x();
  return n && (r = n.getItem(t)), (e = r && Ej(r)), e;
}
function VT(t) {
  const e = $x();
  e && e.removeItem(t);
}
const mb = "WALLETCONNECT_DEEPLINK_CHOICE";
function o_e(t, e) {
  const r = encodeURIComponent(t);
  return e.universalLink
    ? `${e.universalLink}/wc?uri=${r}`
    : e.deepLink
    ? `${e.deepLink}${e.deepLink.endsWith(":") ? "//" : "/"}wc?uri=${r}`
    : "";
}
function c_e(t) {
  const e = t.href.split("?")[0];
  zT(
    mb,
    Object.assign(Object.assign({}, t), {
      href: e,
    })
  );
}
function Cj(t, e) {
  return t.filter((r) => r.name.toLowerCase().includes(e.toLowerCase()))[0];
}
function l_e(t, e) {
  let r = t;
  return e && (r = e.map((n) => Cj(t, n)).filter(Boolean)), r;
}
const Aj = "https://registry.walletconnect.com";
function u_e() {
  return Aj + "/api/v2/wallets";
}
function f_e() {
  return Aj + "/api/v2/dapps";
}
function kj(t, e = "mobile") {
  var r;
  return {
    name: t.name || "",
    shortName: t.metadata.shortName || "",
    color: t.metadata.colors.primary || "",
    logo: (r = t.image_url.sm) !== null && r !== void 0 ? r : "",
    universalLink: t[e].universal || "",
    deepLink: t[e].native || "",
  };
}
function d_e(t, e = "mobile") {
  return Object.values(t)
    .filter((r) => !!r[e].universal || !!r[e].native)
    .map((r) => kj(r, e));
}
const h_e = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        detectEnv: Fx,
        detectOS: Lx,
        formatIOSMobile: o_e,
        formatMobileRegistry: d_e,
        formatMobileRegistryEntry: kj,
        getClientMeta: w4,
        getCrypto: n_e,
        getCryptoOrThrow: r_e,
        getDappRegistryUrl: f_e,
        getDocument: X6e,
        getDocumentOrThrow: Y6e,
        getFromWindow: J6e,
        getFromWindowOrThrow: Q6e,
        getLocal: qT,
        getLocalStorage: $x,
        getLocalStorageOrThrow: i_e,
        getLocation: _j,
        getLocationOrThrow: t_e,
        getMobileLinkRegistry: l_e,
        getMobileRegistryEntry: Cj,
        getNavigator: wj,
        getNavigatorOrThrow: e_e,
        getWalletRegistryUrl: u_e,
        isAndroid: yj,
        isBrowser: xj,
        isIOS: gj,
        isMobile: bj,
        isNode: vj,
        mobileLinkChoiceKey: mb,
        removeLocal: VT,
        safeJsonParse: Ej,
        safeJsonStringify: Tj,
        saveMobileLinkInfo: c_e,
        setLocal: zT,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  p_e = [
    "eth_sendTransaction",
    "eth_signTransaction",
    "eth_sign",
    "eth_signTypedData",
    "eth_signTypedData_v1",
    "eth_signTypedData_v2",
    "eth_signTypedData_v3",
    "eth_signTypedData_v4",
    "personal_sign",
    "wallet_addEthereumChain",
    "wallet_switchEthereumChain",
    "wallet_getPermissions",
    "wallet_requestPermissions",
    "wallet_registerOnboarding",
    "wallet_watchAsset",
    "wallet_scanQRCode",
  ],
  m_e = {
    1: "mainnet",
    3: "ropsten",
    4: "rinkeby",
    5: "goerli",
    42: "kovan",
  };
var KT = {
  exports: {},
};
KT.exports;
(function (t) {
  (function (e, r) {
    function n(C, l) {
      if (!C) throw new Error(l || "Assertion failed");
    }
    function i(C, l) {
      C.super_ = l;
      var p = function () {};
      (p.prototype = l.prototype),
        (C.prototype = new p()),
        (C.prototype.constructor = C);
    }
    function a(C, l, p) {
      if (a.isBN(C)) return C;
      (this.negative = 0),
        (this.words = null),
        (this.length = 0),
        (this.red = null),
        C !== null &&
          ((l === "le" || l === "be") && ((p = l), (l = 10)),
          this._init(C || 0, l || 10, p || "be"));
    }
    typeof e == "object" ? (e.exports = a) : (r.BN = a),
      (a.BN = a),
      (a.wordSize = 26);
    var s;
    try {
      s = Pu.Buffer;
    } catch {}
    (a.isBN = function (l) {
      return l instanceof a
        ? !0
        : l !== null &&
            typeof l == "object" &&
            l.constructor.wordSize === a.wordSize &&
            Array.isArray(l.words);
    }),
      (a.max = function (l, p) {
        return l.cmp(p) > 0 ? l : p;
      }),
      (a.min = function (l, p) {
        return l.cmp(p) < 0 ? l : p;
      }),
      (a.prototype._init = function (l, p, y) {
        if (typeof l == "number") return this._initNumber(l, p, y);
        if (typeof l == "object") return this._initArray(l, p, y);
        p === "hex" && (p = 16),
          n(p === (p | 0) && p >= 2 && p <= 36),
          (l = l.toString().replace(/\s+/g, ""));
        var h = 0;
        l[0] === "-" && h++,
          p === 16 ? this._parseHex(l, h) : this._parseBase(l, p, h),
          l[0] === "-" && (this.negative = 1),
          this.strip(),
          y === "le" && this._initArray(this.toArray(), p, y);
      }),
      (a.prototype._initNumber = function (l, p, y) {
        l < 0 && ((this.negative = 1), (l = -l)),
          l < 67108864
            ? ((this.words = [l & 67108863]), (this.length = 1))
            : l < 4503599627370496
            ? ((this.words = [l & 67108863, (l / 67108864) & 67108863]),
              (this.length = 2))
            : (n(l < 9007199254740992),
              (this.words = [l & 67108863, (l / 67108864) & 67108863, 1]),
              (this.length = 3)),
          y === "le" && this._initArray(this.toArray(), p, y);
      }),
      (a.prototype._initArray = function (l, p, y) {
        if ((n(typeof l.length == "number"), l.length <= 0))
          return (this.words = [0]), (this.length = 1), this;
        (this.length = Math.ceil(l.length / 3)),
          (this.words = new Array(this.length));
        for (var h = 0; h < this.length; h++) this.words[h] = 0;
        var g,
          T,
          R = 0;
        if (y === "be")
          for (h = l.length - 1, g = 0; h >= 0; h -= 3)
            (T = l[h] | (l[h - 1] << 8) | (l[h - 2] << 16)),
              (this.words[g] |= (T << R) & 67108863),
              (this.words[g + 1] = (T >>> (26 - R)) & 67108863),
              (R += 24),
              R >= 26 && ((R -= 26), g++);
        else if (y === "le")
          for (h = 0, g = 0; h < l.length; h += 3)
            (T = l[h] | (l[h + 1] << 8) | (l[h + 2] << 16)),
              (this.words[g] |= (T << R) & 67108863),
              (this.words[g + 1] = (T >>> (26 - R)) & 67108863),
              (R += 24),
              R >= 26 && ((R -= 26), g++);
        return this.strip();
      });
    function o(C, l, p) {
      for (var y = 0, h = Math.min(C.length, p), g = l; g < h; g++) {
        var T = C.charCodeAt(g) - 48;
        (y <<= 4),
          T >= 49 && T <= 54
            ? (y |= T - 49 + 10)
            : T >= 17 && T <= 22
            ? (y |= T - 17 + 10)
            : (y |= T & 15);
      }
      return y;
    }
    a.prototype._parseHex = function (l, p) {
      (this.length = Math.ceil((l.length - p) / 6)),
        (this.words = new Array(this.length));
      for (var y = 0; y < this.length; y++) this.words[y] = 0;
      var h,
        g,
        T = 0;
      for (y = l.length - 6, h = 0; y >= p; y -= 6)
        (g = o(l, y, y + 6)),
          (this.words[h] |= (g << T) & 67108863),
          (this.words[h + 1] |= (g >>> (26 - T)) & 4194303),
          (T += 24),
          T >= 26 && ((T -= 26), h++);
      y + 6 !== p &&
        ((g = o(l, p, y + 6)),
        (this.words[h] |= (g << T) & 67108863),
        (this.words[h + 1] |= (g >>> (26 - T)) & 4194303)),
        this.strip();
    };
    function c(C, l, p, y) {
      for (var h = 0, g = Math.min(C.length, p), T = l; T < g; T++) {
        var R = C.charCodeAt(T) - 48;
        (h *= y),
          R >= 49
            ? (h += R - 49 + 10)
            : R >= 17
            ? (h += R - 17 + 10)
            : (h += R);
      }
      return h;
    }
    (a.prototype._parseBase = function (l, p, y) {
      (this.words = [0]), (this.length = 1);
      for (var h = 0, g = 1; g <= 67108863; g *= p) h++;
      h--, (g = (g / p) | 0);
      for (
        var T = l.length - y,
          R = T % h,
          x = Math.min(T, T - R) + y,
          f = 0,
          _ = y;
        _ < x;
        _ += h
      )
        (f = c(l, _, _ + h, p)),
          this.imuln(g),
          this.words[0] + f < 67108864 ? (this.words[0] += f) : this._iaddn(f);
      if (R !== 0) {
        var P = 1;
        for (f = c(l, _, l.length, p), _ = 0; _ < R; _++) P *= p;
        this.imuln(P),
          this.words[0] + f < 67108864 ? (this.words[0] += f) : this._iaddn(f);
      }
    }),
      (a.prototype.copy = function (l) {
        l.words = new Array(this.length);
        for (var p = 0; p < this.length; p++) l.words[p] = this.words[p];
        (l.length = this.length),
          (l.negative = this.negative),
          (l.red = this.red);
      }),
      (a.prototype.clone = function () {
        var l = new a(null);
        return this.copy(l), l;
      }),
      (a.prototype._expand = function (l) {
        for (; this.length < l; ) this.words[this.length++] = 0;
        return this;
      }),
      (a.prototype.strip = function () {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }),
      (a.prototype._normSign = function () {
        return (
          this.length === 1 && this.words[0] === 0 && (this.negative = 0), this
        );
      }),
      (a.prototype.inspect = function () {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      });
    var u = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000",
      ],
      d = [
        0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
      ],
      m = [
        0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607,
        16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536,
        11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101,
        5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368,
        20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875,
        60466176,
      ];
    (a.prototype.toString = function (l, p) {
      (l = l || 10), (p = p | 0 || 1);
      var y;
      if (l === 16 || l === "hex") {
        y = "";
        for (var h = 0, g = 0, T = 0; T < this.length; T++) {
          var R = this.words[T],
            x = (((R << h) | g) & 16777215).toString(16);
          (g = (R >>> (24 - h)) & 16777215),
            g !== 0 || T !== this.length - 1
              ? (y = u[6 - x.length] + x + y)
              : (y = x + y),
            (h += 2),
            h >= 26 && ((h -= 26), T--);
        }
        for (g !== 0 && (y = g.toString(16) + y); y.length % p !== 0; )
          y = "0" + y;
        return this.negative !== 0 && (y = "-" + y), y;
      }
      if (l === (l | 0) && l >= 2 && l <= 36) {
        var f = d[l],
          _ = m[l];
        y = "";
        var P = this.clone();
        for (P.negative = 0; !P.isZero(); ) {
          var M = P.modn(_).toString(l);
          (P = P.idivn(_)),
            P.isZero() ? (y = M + y) : (y = u[f - M.length] + M + y);
        }
        for (this.isZero() && (y = "0" + y); y.length % p !== 0; ) y = "0" + y;
        return this.negative !== 0 && (y = "-" + y), y;
      }
      n(!1, "Base should be between 2 and 36");
    }),
      (a.prototype.toNumber = function () {
        var l = this.words[0];
        return (
          this.length === 2
            ? (l += this.words[1] * 67108864)
            : this.length === 3 && this.words[2] === 1
            ? (l += 4503599627370496 + this.words[1] * 67108864)
            : this.length > 2 &&
              n(!1, "Number can only safely store up to 53 bits"),
          this.negative !== 0 ? -l : l
        );
      }),
      (a.prototype.toJSON = function () {
        return this.toString(16);
      }),
      (a.prototype.toBuffer = function (l, p) {
        return n(typeof s < "u"), this.toArrayLike(s, l, p);
      }),
      (a.prototype.toArray = function (l, p) {
        return this.toArrayLike(Array, l, p);
      }),
      (a.prototype.toArrayLike = function (l, p, y) {
        var h = this.byteLength(),
          g = y || Math.max(1, h);
        n(h <= g, "byte array longer than desired length"),
          n(g > 0, "Requested array length <= 0"),
          this.strip();
        var T = p === "le",
          R = new l(g),
          x,
          f,
          _ = this.clone();
        if (T) {
          for (f = 0; !_.isZero(); f++)
            (x = _.andln(255)), _.iushrn(8), (R[f] = x);
          for (; f < g; f++) R[f] = 0;
        } else {
          for (f = 0; f < g - h; f++) R[f] = 0;
          for (f = 0; !_.isZero(); f++)
            (x = _.andln(255)), _.iushrn(8), (R[g - f - 1] = x);
        }
        return R;
      }),
      Math.clz32
        ? (a.prototype._countBits = function (l) {
            return 32 - Math.clz32(l);
          })
        : (a.prototype._countBits = function (l) {
            var p = l,
              y = 0;
            return (
              p >= 4096 && ((y += 13), (p >>>= 13)),
              p >= 64 && ((y += 7), (p >>>= 7)),
              p >= 8 && ((y += 4), (p >>>= 4)),
              p >= 2 && ((y += 2), (p >>>= 2)),
              y + p
            );
          }),
      (a.prototype._zeroBits = function (l) {
        if (l === 0) return 26;
        var p = l,
          y = 0;
        return (
          p & 8191 || ((y += 13), (p >>>= 13)),
          p & 127 || ((y += 7), (p >>>= 7)),
          p & 15 || ((y += 4), (p >>>= 4)),
          p & 3 || ((y += 2), (p >>>= 2)),
          p & 1 || y++,
          y
        );
      }),
      (a.prototype.bitLength = function () {
        var l = this.words[this.length - 1],
          p = this._countBits(l);
        return (this.length - 1) * 26 + p;
      });
    function v(C) {
      for (var l = new Array(C.bitLength()), p = 0; p < l.length; p++) {
        var y = (p / 26) | 0,
          h = p % 26;
        l[p] = (C.words[y] & (1 << h)) >>> h;
      }
      return l;
    }
    (a.prototype.zeroBits = function () {
      if (this.isZero()) return 0;
      for (var l = 0, p = 0; p < this.length; p++) {
        var y = this._zeroBits(this.words[p]);
        if (((l += y), y !== 26)) break;
      }
      return l;
    }),
      (a.prototype.byteLength = function () {
        return Math.ceil(this.bitLength() / 8);
      }),
      (a.prototype.toTwos = function (l) {
        return this.negative !== 0
          ? this.abs().inotn(l).iaddn(1)
          : this.clone();
      }),
      (a.prototype.fromTwos = function (l) {
        return this.testn(l - 1) ? this.notn(l).iaddn(1).ineg() : this.clone();
      }),
      (a.prototype.isNeg = function () {
        return this.negative !== 0;
      }),
      (a.prototype.neg = function () {
        return this.clone().ineg();
      }),
      (a.prototype.ineg = function () {
        return this.isZero() || (this.negative ^= 1), this;
      }),
      (a.prototype.iuor = function (l) {
        for (; this.length < l.length; ) this.words[this.length++] = 0;
        for (var p = 0; p < l.length; p++)
          this.words[p] = this.words[p] | l.words[p];
        return this.strip();
      }),
      (a.prototype.ior = function (l) {
        return n((this.negative | l.negative) === 0), this.iuor(l);
      }),
      (a.prototype.or = function (l) {
        return this.length > l.length
          ? this.clone().ior(l)
          : l.clone().ior(this);
      }),
      (a.prototype.uor = function (l) {
        return this.length > l.length
          ? this.clone().iuor(l)
          : l.clone().iuor(this);
      }),
      (a.prototype.iuand = function (l) {
        var p;
        this.length > l.length ? (p = l) : (p = this);
        for (var y = 0; y < p.length; y++)
          this.words[y] = this.words[y] & l.words[y];
        return (this.length = p.length), this.strip();
      }),
      (a.prototype.iand = function (l) {
        return n((this.negative | l.negative) === 0), this.iuand(l);
      }),
      (a.prototype.and = function (l) {
        return this.length > l.length
          ? this.clone().iand(l)
          : l.clone().iand(this);
      }),
      (a.prototype.uand = function (l) {
        return this.length > l.length
          ? this.clone().iuand(l)
          : l.clone().iuand(this);
      }),
      (a.prototype.iuxor = function (l) {
        var p, y;
        this.length > l.length ? ((p = this), (y = l)) : ((p = l), (y = this));
        for (var h = 0; h < y.length; h++)
          this.words[h] = p.words[h] ^ y.words[h];
        if (this !== p) for (; h < p.length; h++) this.words[h] = p.words[h];
        return (this.length = p.length), this.strip();
      }),
      (a.prototype.ixor = function (l) {
        return n((this.negative | l.negative) === 0), this.iuxor(l);
      }),
      (a.prototype.xor = function (l) {
        return this.length > l.length
          ? this.clone().ixor(l)
          : l.clone().ixor(this);
      }),
      (a.prototype.uxor = function (l) {
        return this.length > l.length
          ? this.clone().iuxor(l)
          : l.clone().iuxor(this);
      }),
      (a.prototype.inotn = function (l) {
        n(typeof l == "number" && l >= 0);
        var p = Math.ceil(l / 26) | 0,
          y = l % 26;
        this._expand(p), y > 0 && p--;
        for (var h = 0; h < p; h++) this.words[h] = ~this.words[h] & 67108863;
        return (
          y > 0 && (this.words[h] = ~this.words[h] & (67108863 >> (26 - y))),
          this.strip()
        );
      }),
      (a.prototype.notn = function (l) {
        return this.clone().inotn(l);
      }),
      (a.prototype.setn = function (l, p) {
        n(typeof l == "number" && l >= 0);
        var y = (l / 26) | 0,
          h = l % 26;
        return (
          this._expand(y + 1),
          p
            ? (this.words[y] = this.words[y] | (1 << h))
            : (this.words[y] = this.words[y] & ~(1 << h)),
          this.strip()
        );
      }),
      (a.prototype.iadd = function (l) {
        var p;
        if (this.negative !== 0 && l.negative === 0)
          return (
            (this.negative = 0),
            (p = this.isub(l)),
            (this.negative ^= 1),
            this._normSign()
          );
        if (this.negative === 0 && l.negative !== 0)
          return (
            (l.negative = 0),
            (p = this.isub(l)),
            (l.negative = 1),
            p._normSign()
          );
        var y, h;
        this.length > l.length ? ((y = this), (h = l)) : ((y = l), (h = this));
        for (var g = 0, T = 0; T < h.length; T++)
          (p = (y.words[T] | 0) + (h.words[T] | 0) + g),
            (this.words[T] = p & 67108863),
            (g = p >>> 26);
        for (; g !== 0 && T < y.length; T++)
          (p = (y.words[T] | 0) + g),
            (this.words[T] = p & 67108863),
            (g = p >>> 26);
        if (((this.length = y.length), g !== 0))
          (this.words[this.length] = g), this.length++;
        else if (y !== this)
          for (; T < y.length; T++) this.words[T] = y.words[T];
        return this;
      }),
      (a.prototype.add = function (l) {
        var p;
        return l.negative !== 0 && this.negative === 0
          ? ((l.negative = 0), (p = this.sub(l)), (l.negative ^= 1), p)
          : l.negative === 0 && this.negative !== 0
          ? ((this.negative = 0), (p = l.sub(this)), (this.negative = 1), p)
          : this.length > l.length
          ? this.clone().iadd(l)
          : l.clone().iadd(this);
      }),
      (a.prototype.isub = function (l) {
        if (l.negative !== 0) {
          l.negative = 0;
          var p = this.iadd(l);
          return (l.negative = 1), p._normSign();
        } else if (this.negative !== 0)
          return (
            (this.negative = 0),
            this.iadd(l),
            (this.negative = 1),
            this._normSign()
          );
        var y = this.cmp(l);
        if (y === 0)
          return (
            (this.negative = 0), (this.length = 1), (this.words[0] = 0), this
          );
        var h, g;
        y > 0 ? ((h = this), (g = l)) : ((h = l), (g = this));
        for (var T = 0, R = 0; R < g.length; R++)
          (p = (h.words[R] | 0) - (g.words[R] | 0) + T),
            (T = p >> 26),
            (this.words[R] = p & 67108863);
        for (; T !== 0 && R < h.length; R++)
          (p = (h.words[R] | 0) + T),
            (T = p >> 26),
            (this.words[R] = p & 67108863);
        if (T === 0 && R < h.length && h !== this)
          for (; R < h.length; R++) this.words[R] = h.words[R];
        return (
          (this.length = Math.max(this.length, R)),
          h !== this && (this.negative = 1),
          this.strip()
        );
      }),
      (a.prototype.sub = function (l) {
        return this.clone().isub(l);
      });
    function E(C, l, p) {
      p.negative = l.negative ^ C.negative;
      var y = (C.length + l.length) | 0;
      (p.length = y), (y = (y - 1) | 0);
      var h = C.words[0] | 0,
        g = l.words[0] | 0,
        T = h * g,
        R = T & 67108863,
        x = (T / 67108864) | 0;
      p.words[0] = R;
      for (var f = 1; f < y; f++) {
        for (
          var _ = x >>> 26,
            P = x & 67108863,
            M = Math.min(f, l.length - 1),
            D = Math.max(0, f - C.length + 1);
          D <= M;
          D++
        ) {
          var q = (f - D) | 0;
          (h = C.words[q] | 0),
            (g = l.words[D] | 0),
            (T = h * g + P),
            (_ += (T / 67108864) | 0),
            (P = T & 67108863);
        }
        (p.words[f] = P | 0), (x = _ | 0);
      }
      return x !== 0 ? (p.words[f] = x | 0) : p.length--, p.strip();
    }
    var A = function (l, p, y) {
      var h = l.words,
        g = p.words,
        T = y.words,
        R = 0,
        x,
        f,
        _,
        P = h[0] | 0,
        M = P & 8191,
        D = P >>> 13,
        q = h[1] | 0,
        B = q & 8191,
        H = q >>> 13,
        Q = h[2] | 0,
        Z = Q & 8191,
        te = Q >>> 13,
        Te = h[3] | 0,
        K = Te & 8191,
        G = Te >>> 13,
        he = h[4] | 0,
        se = he & 8191,
        pe = he >>> 13,
        Y = h[5] | 0,
        $ = Y & 8191,
        W = Y >>> 13,
        re = h[6] | 0,
        ee = re & 8191,
        ce = re >>> 13,
        Ce = h[7] | 0,
        me = Ce & 8191,
        ge = Ce >>> 13,
        it = h[8] | 0,
        ve = it & 8191,
        z = it >>> 13,
        U = h[9] | 0,
        L = U & 8191,
        J = U >>> 13,
        fe = g[0] | 0,
        ie = fe & 8191,
        le = fe >>> 13,
        nt = g[1] | 0,
        Ee = nt & 8191,
        we = nt >>> 13,
        ft = g[2] | 0,
        xe = ft & 8191,
        Pe = ft >>> 13,
        hr = g[3] | 0,
        Ne = hr & 8191,
        Me = hr >>> 13,
        _r = g[4] | 0,
        Be = _r & 8191,
        De = _r >>> 13,
        pr = g[5] | 0,
        Oe = pr & 8191,
        Fe = pr >>> 13,
        mr = g[6] | 0,
        Le = mr & 8191,
        Ie = mr >>> 13,
        At = g[7] | 0,
        Ae = At & 8191,
        Re = At >>> 13,
        Er = g[8] | 0,
        $e = Er & 8191,
        Ue = Er >>> 13,
        Mr = g[9] | 0,
        We = Mr & 8191,
        je = Mr >>> 13;
      (y.negative = l.negative ^ p.negative),
        (y.length = 19),
        (x = Math.imul(M, ie)),
        (f = Math.imul(M, le)),
        (f = (f + Math.imul(D, ie)) | 0),
        (_ = Math.imul(D, le));
      var ur = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (ur >>> 26)) | 0),
        (ur &= 67108863),
        (x = Math.imul(B, ie)),
        (f = Math.imul(B, le)),
        (f = (f + Math.imul(H, ie)) | 0),
        (_ = Math.imul(H, le)),
        (x = (x + Math.imul(M, Ee)) | 0),
        (f = (f + Math.imul(M, we)) | 0),
        (f = (f + Math.imul(D, Ee)) | 0),
        (_ = (_ + Math.imul(D, we)) | 0);
      var mt = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (mt >>> 26)) | 0),
        (mt &= 67108863),
        (x = Math.imul(Z, ie)),
        (f = Math.imul(Z, le)),
        (f = (f + Math.imul(te, ie)) | 0),
        (_ = Math.imul(te, le)),
        (x = (x + Math.imul(B, Ee)) | 0),
        (f = (f + Math.imul(B, we)) | 0),
        (f = (f + Math.imul(H, Ee)) | 0),
        (_ = (_ + Math.imul(H, we)) | 0),
        (x = (x + Math.imul(M, xe)) | 0),
        (f = (f + Math.imul(M, Pe)) | 0),
        (f = (f + Math.imul(D, xe)) | 0),
        (_ = (_ + Math.imul(D, Pe)) | 0);
      var yt = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (yt >>> 26)) | 0),
        (yt &= 67108863),
        (x = Math.imul(K, ie)),
        (f = Math.imul(K, le)),
        (f = (f + Math.imul(G, ie)) | 0),
        (_ = Math.imul(G, le)),
        (x = (x + Math.imul(Z, Ee)) | 0),
        (f = (f + Math.imul(Z, we)) | 0),
        (f = (f + Math.imul(te, Ee)) | 0),
        (_ = (_ + Math.imul(te, we)) | 0),
        (x = (x + Math.imul(B, xe)) | 0),
        (f = (f + Math.imul(B, Pe)) | 0),
        (f = (f + Math.imul(H, xe)) | 0),
        (_ = (_ + Math.imul(H, Pe)) | 0),
        (x = (x + Math.imul(M, Ne)) | 0),
        (f = (f + Math.imul(M, Me)) | 0),
        (f = (f + Math.imul(D, Ne)) | 0),
        (_ = (_ + Math.imul(D, Me)) | 0);
      var rr = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (rr >>> 26)) | 0),
        (rr &= 67108863),
        (x = Math.imul(se, ie)),
        (f = Math.imul(se, le)),
        (f = (f + Math.imul(pe, ie)) | 0),
        (_ = Math.imul(pe, le)),
        (x = (x + Math.imul(K, Ee)) | 0),
        (f = (f + Math.imul(K, we)) | 0),
        (f = (f + Math.imul(G, Ee)) | 0),
        (_ = (_ + Math.imul(G, we)) | 0),
        (x = (x + Math.imul(Z, xe)) | 0),
        (f = (f + Math.imul(Z, Pe)) | 0),
        (f = (f + Math.imul(te, xe)) | 0),
        (_ = (_ + Math.imul(te, Pe)) | 0),
        (x = (x + Math.imul(B, Ne)) | 0),
        (f = (f + Math.imul(B, Me)) | 0),
        (f = (f + Math.imul(H, Ne)) | 0),
        (_ = (_ + Math.imul(H, Me)) | 0),
        (x = (x + Math.imul(M, Be)) | 0),
        (f = (f + Math.imul(M, De)) | 0),
        (f = (f + Math.imul(D, Be)) | 0),
        (_ = (_ + Math.imul(D, De)) | 0);
      var nr = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (nr >>> 26)) | 0),
        (nr &= 67108863),
        (x = Math.imul($, ie)),
        (f = Math.imul($, le)),
        (f = (f + Math.imul(W, ie)) | 0),
        (_ = Math.imul(W, le)),
        (x = (x + Math.imul(se, Ee)) | 0),
        (f = (f + Math.imul(se, we)) | 0),
        (f = (f + Math.imul(pe, Ee)) | 0),
        (_ = (_ + Math.imul(pe, we)) | 0),
        (x = (x + Math.imul(K, xe)) | 0),
        (f = (f + Math.imul(K, Pe)) | 0),
        (f = (f + Math.imul(G, xe)) | 0),
        (_ = (_ + Math.imul(G, Pe)) | 0),
        (x = (x + Math.imul(Z, Ne)) | 0),
        (f = (f + Math.imul(Z, Me)) | 0),
        (f = (f + Math.imul(te, Ne)) | 0),
        (_ = (_ + Math.imul(te, Me)) | 0),
        (x = (x + Math.imul(B, Be)) | 0),
        (f = (f + Math.imul(B, De)) | 0),
        (f = (f + Math.imul(H, Be)) | 0),
        (_ = (_ + Math.imul(H, De)) | 0),
        (x = (x + Math.imul(M, Oe)) | 0),
        (f = (f + Math.imul(M, Fe)) | 0),
        (f = (f + Math.imul(D, Oe)) | 0),
        (_ = (_ + Math.imul(D, Fe)) | 0);
      var ir = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (ir >>> 26)) | 0),
        (ir &= 67108863),
        (x = Math.imul(ee, ie)),
        (f = Math.imul(ee, le)),
        (f = (f + Math.imul(ce, ie)) | 0),
        (_ = Math.imul(ce, le)),
        (x = (x + Math.imul($, Ee)) | 0),
        (f = (f + Math.imul($, we)) | 0),
        (f = (f + Math.imul(W, Ee)) | 0),
        (_ = (_ + Math.imul(W, we)) | 0),
        (x = (x + Math.imul(se, xe)) | 0),
        (f = (f + Math.imul(se, Pe)) | 0),
        (f = (f + Math.imul(pe, xe)) | 0),
        (_ = (_ + Math.imul(pe, Pe)) | 0),
        (x = (x + Math.imul(K, Ne)) | 0),
        (f = (f + Math.imul(K, Me)) | 0),
        (f = (f + Math.imul(G, Ne)) | 0),
        (_ = (_ + Math.imul(G, Me)) | 0),
        (x = (x + Math.imul(Z, Be)) | 0),
        (f = (f + Math.imul(Z, De)) | 0),
        (f = (f + Math.imul(te, Be)) | 0),
        (_ = (_ + Math.imul(te, De)) | 0),
        (x = (x + Math.imul(B, Oe)) | 0),
        (f = (f + Math.imul(B, Fe)) | 0),
        (f = (f + Math.imul(H, Oe)) | 0),
        (_ = (_ + Math.imul(H, Fe)) | 0),
        (x = (x + Math.imul(M, Le)) | 0),
        (f = (f + Math.imul(M, Ie)) | 0),
        (f = (f + Math.imul(D, Le)) | 0),
        (_ = (_ + Math.imul(D, Ie)) | 0);
      var ar = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (ar >>> 26)) | 0),
        (ar &= 67108863),
        (x = Math.imul(me, ie)),
        (f = Math.imul(me, le)),
        (f = (f + Math.imul(ge, ie)) | 0),
        (_ = Math.imul(ge, le)),
        (x = (x + Math.imul(ee, Ee)) | 0),
        (f = (f + Math.imul(ee, we)) | 0),
        (f = (f + Math.imul(ce, Ee)) | 0),
        (_ = (_ + Math.imul(ce, we)) | 0),
        (x = (x + Math.imul($, xe)) | 0),
        (f = (f + Math.imul($, Pe)) | 0),
        (f = (f + Math.imul(W, xe)) | 0),
        (_ = (_ + Math.imul(W, Pe)) | 0),
        (x = (x + Math.imul(se, Ne)) | 0),
        (f = (f + Math.imul(se, Me)) | 0),
        (f = (f + Math.imul(pe, Ne)) | 0),
        (_ = (_ + Math.imul(pe, Me)) | 0),
        (x = (x + Math.imul(K, Be)) | 0),
        (f = (f + Math.imul(K, De)) | 0),
        (f = (f + Math.imul(G, Be)) | 0),
        (_ = (_ + Math.imul(G, De)) | 0),
        (x = (x + Math.imul(Z, Oe)) | 0),
        (f = (f + Math.imul(Z, Fe)) | 0),
        (f = (f + Math.imul(te, Oe)) | 0),
        (_ = (_ + Math.imul(te, Fe)) | 0),
        (x = (x + Math.imul(B, Le)) | 0),
        (f = (f + Math.imul(B, Ie)) | 0),
        (f = (f + Math.imul(H, Le)) | 0),
        (_ = (_ + Math.imul(H, Ie)) | 0),
        (x = (x + Math.imul(M, Ae)) | 0),
        (f = (f + Math.imul(M, Re)) | 0),
        (f = (f + Math.imul(D, Ae)) | 0),
        (_ = (_ + Math.imul(D, Re)) | 0);
      var sr = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (sr >>> 26)) | 0),
        (sr &= 67108863),
        (x = Math.imul(ve, ie)),
        (f = Math.imul(ve, le)),
        (f = (f + Math.imul(z, ie)) | 0),
        (_ = Math.imul(z, le)),
        (x = (x + Math.imul(me, Ee)) | 0),
        (f = (f + Math.imul(me, we)) | 0),
        (f = (f + Math.imul(ge, Ee)) | 0),
        (_ = (_ + Math.imul(ge, we)) | 0),
        (x = (x + Math.imul(ee, xe)) | 0),
        (f = (f + Math.imul(ee, Pe)) | 0),
        (f = (f + Math.imul(ce, xe)) | 0),
        (_ = (_ + Math.imul(ce, Pe)) | 0),
        (x = (x + Math.imul($, Ne)) | 0),
        (f = (f + Math.imul($, Me)) | 0),
        (f = (f + Math.imul(W, Ne)) | 0),
        (_ = (_ + Math.imul(W, Me)) | 0),
        (x = (x + Math.imul(se, Be)) | 0),
        (f = (f + Math.imul(se, De)) | 0),
        (f = (f + Math.imul(pe, Be)) | 0),
        (_ = (_ + Math.imul(pe, De)) | 0),
        (x = (x + Math.imul(K, Oe)) | 0),
        (f = (f + Math.imul(K, Fe)) | 0),
        (f = (f + Math.imul(G, Oe)) | 0),
        (_ = (_ + Math.imul(G, Fe)) | 0),
        (x = (x + Math.imul(Z, Le)) | 0),
        (f = (f + Math.imul(Z, Ie)) | 0),
        (f = (f + Math.imul(te, Le)) | 0),
        (_ = (_ + Math.imul(te, Ie)) | 0),
        (x = (x + Math.imul(B, Ae)) | 0),
        (f = (f + Math.imul(B, Re)) | 0),
        (f = (f + Math.imul(H, Ae)) | 0),
        (_ = (_ + Math.imul(H, Re)) | 0),
        (x = (x + Math.imul(M, $e)) | 0),
        (f = (f + Math.imul(M, Ue)) | 0),
        (f = (f + Math.imul(D, $e)) | 0),
        (_ = (_ + Math.imul(D, Ue)) | 0);
      var Ir = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (Ir >>> 26)) | 0),
        (Ir &= 67108863),
        (x = Math.imul(L, ie)),
        (f = Math.imul(L, le)),
        (f = (f + Math.imul(J, ie)) | 0),
        (_ = Math.imul(J, le)),
        (x = (x + Math.imul(ve, Ee)) | 0),
        (f = (f + Math.imul(ve, we)) | 0),
        (f = (f + Math.imul(z, Ee)) | 0),
        (_ = (_ + Math.imul(z, we)) | 0),
        (x = (x + Math.imul(me, xe)) | 0),
        (f = (f + Math.imul(me, Pe)) | 0),
        (f = (f + Math.imul(ge, xe)) | 0),
        (_ = (_ + Math.imul(ge, Pe)) | 0),
        (x = (x + Math.imul(ee, Ne)) | 0),
        (f = (f + Math.imul(ee, Me)) | 0),
        (f = (f + Math.imul(ce, Ne)) | 0),
        (_ = (_ + Math.imul(ce, Me)) | 0),
        (x = (x + Math.imul($, Be)) | 0),
        (f = (f + Math.imul($, De)) | 0),
        (f = (f + Math.imul(W, Be)) | 0),
        (_ = (_ + Math.imul(W, De)) | 0),
        (x = (x + Math.imul(se, Oe)) | 0),
        (f = (f + Math.imul(se, Fe)) | 0),
        (f = (f + Math.imul(pe, Oe)) | 0),
        (_ = (_ + Math.imul(pe, Fe)) | 0),
        (x = (x + Math.imul(K, Le)) | 0),
        (f = (f + Math.imul(K, Ie)) | 0),
        (f = (f + Math.imul(G, Le)) | 0),
        (_ = (_ + Math.imul(G, Ie)) | 0),
        (x = (x + Math.imul(Z, Ae)) | 0),
        (f = (f + Math.imul(Z, Re)) | 0),
        (f = (f + Math.imul(te, Ae)) | 0),
        (_ = (_ + Math.imul(te, Re)) | 0),
        (x = (x + Math.imul(B, $e)) | 0),
        (f = (f + Math.imul(B, Ue)) | 0),
        (f = (f + Math.imul(H, $e)) | 0),
        (_ = (_ + Math.imul(H, Ue)) | 0),
        (x = (x + Math.imul(M, We)) | 0),
        (f = (f + Math.imul(M, je)) | 0),
        (f = (f + Math.imul(D, We)) | 0),
        (_ = (_ + Math.imul(D, je)) | 0);
      var Rr = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (Rr >>> 26)) | 0),
        (Rr &= 67108863),
        (x = Math.imul(L, Ee)),
        (f = Math.imul(L, we)),
        (f = (f + Math.imul(J, Ee)) | 0),
        (_ = Math.imul(J, we)),
        (x = (x + Math.imul(ve, xe)) | 0),
        (f = (f + Math.imul(ve, Pe)) | 0),
        (f = (f + Math.imul(z, xe)) | 0),
        (_ = (_ + Math.imul(z, Pe)) | 0),
        (x = (x + Math.imul(me, Ne)) | 0),
        (f = (f + Math.imul(me, Me)) | 0),
        (f = (f + Math.imul(ge, Ne)) | 0),
        (_ = (_ + Math.imul(ge, Me)) | 0),
        (x = (x + Math.imul(ee, Be)) | 0),
        (f = (f + Math.imul(ee, De)) | 0),
        (f = (f + Math.imul(ce, Be)) | 0),
        (_ = (_ + Math.imul(ce, De)) | 0),
        (x = (x + Math.imul($, Oe)) | 0),
        (f = (f + Math.imul($, Fe)) | 0),
        (f = (f + Math.imul(W, Oe)) | 0),
        (_ = (_ + Math.imul(W, Fe)) | 0),
        (x = (x + Math.imul(se, Le)) | 0),
        (f = (f + Math.imul(se, Ie)) | 0),
        (f = (f + Math.imul(pe, Le)) | 0),
        (_ = (_ + Math.imul(pe, Ie)) | 0),
        (x = (x + Math.imul(K, Ae)) | 0),
        (f = (f + Math.imul(K, Re)) | 0),
        (f = (f + Math.imul(G, Ae)) | 0),
        (_ = (_ + Math.imul(G, Re)) | 0),
        (x = (x + Math.imul(Z, $e)) | 0),
        (f = (f + Math.imul(Z, Ue)) | 0),
        (f = (f + Math.imul(te, $e)) | 0),
        (_ = (_ + Math.imul(te, Ue)) | 0),
        (x = (x + Math.imul(B, We)) | 0),
        (f = (f + Math.imul(B, je)) | 0),
        (f = (f + Math.imul(H, We)) | 0),
        (_ = (_ + Math.imul(H, je)) | 0);
      var Pr = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (Pr >>> 26)) | 0),
        (Pr &= 67108863),
        (x = Math.imul(L, xe)),
        (f = Math.imul(L, Pe)),
        (f = (f + Math.imul(J, xe)) | 0),
        (_ = Math.imul(J, Pe)),
        (x = (x + Math.imul(ve, Ne)) | 0),
        (f = (f + Math.imul(ve, Me)) | 0),
        (f = (f + Math.imul(z, Ne)) | 0),
        (_ = (_ + Math.imul(z, Me)) | 0),
        (x = (x + Math.imul(me, Be)) | 0),
        (f = (f + Math.imul(me, De)) | 0),
        (f = (f + Math.imul(ge, Be)) | 0),
        (_ = (_ + Math.imul(ge, De)) | 0),
        (x = (x + Math.imul(ee, Oe)) | 0),
        (f = (f + Math.imul(ee, Fe)) | 0),
        (f = (f + Math.imul(ce, Oe)) | 0),
        (_ = (_ + Math.imul(ce, Fe)) | 0),
        (x = (x + Math.imul($, Le)) | 0),
        (f = (f + Math.imul($, Ie)) | 0),
        (f = (f + Math.imul(W, Le)) | 0),
        (_ = (_ + Math.imul(W, Ie)) | 0),
        (x = (x + Math.imul(se, Ae)) | 0),
        (f = (f + Math.imul(se, Re)) | 0),
        (f = (f + Math.imul(pe, Ae)) | 0),
        (_ = (_ + Math.imul(pe, Re)) | 0),
        (x = (x + Math.imul(K, $e)) | 0),
        (f = (f + Math.imul(K, Ue)) | 0),
        (f = (f + Math.imul(G, $e)) | 0),
        (_ = (_ + Math.imul(G, Ue)) | 0),
        (x = (x + Math.imul(Z, We)) | 0),
        (f = (f + Math.imul(Z, je)) | 0),
        (f = (f + Math.imul(te, We)) | 0),
        (_ = (_ + Math.imul(te, je)) | 0);
      var Nr = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (Nr >>> 26)) | 0),
        (Nr &= 67108863),
        (x = Math.imul(L, Ne)),
        (f = Math.imul(L, Me)),
        (f = (f + Math.imul(J, Ne)) | 0),
        (_ = Math.imul(J, Me)),
        (x = (x + Math.imul(ve, Be)) | 0),
        (f = (f + Math.imul(ve, De)) | 0),
        (f = (f + Math.imul(z, Be)) | 0),
        (_ = (_ + Math.imul(z, De)) | 0),
        (x = (x + Math.imul(me, Oe)) | 0),
        (f = (f + Math.imul(me, Fe)) | 0),
        (f = (f + Math.imul(ge, Oe)) | 0),
        (_ = (_ + Math.imul(ge, Fe)) | 0),
        (x = (x + Math.imul(ee, Le)) | 0),
        (f = (f + Math.imul(ee, Ie)) | 0),
        (f = (f + Math.imul(ce, Le)) | 0),
        (_ = (_ + Math.imul(ce, Ie)) | 0),
        (x = (x + Math.imul($, Ae)) | 0),
        (f = (f + Math.imul($, Re)) | 0),
        (f = (f + Math.imul(W, Ae)) | 0),
        (_ = (_ + Math.imul(W, Re)) | 0),
        (x = (x + Math.imul(se, $e)) | 0),
        (f = (f + Math.imul(se, Ue)) | 0),
        (f = (f + Math.imul(pe, $e)) | 0),
        (_ = (_ + Math.imul(pe, Ue)) | 0),
        (x = (x + Math.imul(K, We)) | 0),
        (f = (f + Math.imul(K, je)) | 0),
        (f = (f + Math.imul(G, We)) | 0),
        (_ = (_ + Math.imul(G, je)) | 0);
      var Br = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (Br >>> 26)) | 0),
        (Br &= 67108863),
        (x = Math.imul(L, Be)),
        (f = Math.imul(L, De)),
        (f = (f + Math.imul(J, Be)) | 0),
        (_ = Math.imul(J, De)),
        (x = (x + Math.imul(ve, Oe)) | 0),
        (f = (f + Math.imul(ve, Fe)) | 0),
        (f = (f + Math.imul(z, Oe)) | 0),
        (_ = (_ + Math.imul(z, Fe)) | 0),
        (x = (x + Math.imul(me, Le)) | 0),
        (f = (f + Math.imul(me, Ie)) | 0),
        (f = (f + Math.imul(ge, Le)) | 0),
        (_ = (_ + Math.imul(ge, Ie)) | 0),
        (x = (x + Math.imul(ee, Ae)) | 0),
        (f = (f + Math.imul(ee, Re)) | 0),
        (f = (f + Math.imul(ce, Ae)) | 0),
        (_ = (_ + Math.imul(ce, Re)) | 0),
        (x = (x + Math.imul($, $e)) | 0),
        (f = (f + Math.imul($, Ue)) | 0),
        (f = (f + Math.imul(W, $e)) | 0),
        (_ = (_ + Math.imul(W, Ue)) | 0),
        (x = (x + Math.imul(se, We)) | 0),
        (f = (f + Math.imul(se, je)) | 0),
        (f = (f + Math.imul(pe, We)) | 0),
        (_ = (_ + Math.imul(pe, je)) | 0);
      var Dr = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (Dr >>> 26)) | 0),
        (Dr &= 67108863),
        (x = Math.imul(L, Oe)),
        (f = Math.imul(L, Fe)),
        (f = (f + Math.imul(J, Oe)) | 0),
        (_ = Math.imul(J, Fe)),
        (x = (x + Math.imul(ve, Le)) | 0),
        (f = (f + Math.imul(ve, Ie)) | 0),
        (f = (f + Math.imul(z, Le)) | 0),
        (_ = (_ + Math.imul(z, Ie)) | 0),
        (x = (x + Math.imul(me, Ae)) | 0),
        (f = (f + Math.imul(me, Re)) | 0),
        (f = (f + Math.imul(ge, Ae)) | 0),
        (_ = (_ + Math.imul(ge, Re)) | 0),
        (x = (x + Math.imul(ee, $e)) | 0),
        (f = (f + Math.imul(ee, Ue)) | 0),
        (f = (f + Math.imul(ce, $e)) | 0),
        (_ = (_ + Math.imul(ce, Ue)) | 0),
        (x = (x + Math.imul($, We)) | 0),
        (f = (f + Math.imul($, je)) | 0),
        (f = (f + Math.imul(W, We)) | 0),
        (_ = (_ + Math.imul(W, je)) | 0);
      var Or = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (Or >>> 26)) | 0),
        (Or &= 67108863),
        (x = Math.imul(L, Le)),
        (f = Math.imul(L, Ie)),
        (f = (f + Math.imul(J, Le)) | 0),
        (_ = Math.imul(J, Ie)),
        (x = (x + Math.imul(ve, Ae)) | 0),
        (f = (f + Math.imul(ve, Re)) | 0),
        (f = (f + Math.imul(z, Ae)) | 0),
        (_ = (_ + Math.imul(z, Re)) | 0),
        (x = (x + Math.imul(me, $e)) | 0),
        (f = (f + Math.imul(me, Ue)) | 0),
        (f = (f + Math.imul(ge, $e)) | 0),
        (_ = (_ + Math.imul(ge, Ue)) | 0),
        (x = (x + Math.imul(ee, We)) | 0),
        (f = (f + Math.imul(ee, je)) | 0),
        (f = (f + Math.imul(ce, We)) | 0),
        (_ = (_ + Math.imul(ce, je)) | 0);
      var Fr = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (Fr >>> 26)) | 0),
        (Fr &= 67108863),
        (x = Math.imul(L, Ae)),
        (f = Math.imul(L, Re)),
        (f = (f + Math.imul(J, Ae)) | 0),
        (_ = Math.imul(J, Re)),
        (x = (x + Math.imul(ve, $e)) | 0),
        (f = (f + Math.imul(ve, Ue)) | 0),
        (f = (f + Math.imul(z, $e)) | 0),
        (_ = (_ + Math.imul(z, Ue)) | 0),
        (x = (x + Math.imul(me, We)) | 0),
        (f = (f + Math.imul(me, je)) | 0),
        (f = (f + Math.imul(ge, We)) | 0),
        (_ = (_ + Math.imul(ge, je)) | 0);
      var Lr = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (Lr >>> 26)) | 0),
        (Lr &= 67108863),
        (x = Math.imul(L, $e)),
        (f = Math.imul(L, Ue)),
        (f = (f + Math.imul(J, $e)) | 0),
        (_ = Math.imul(J, Ue)),
        (x = (x + Math.imul(ve, We)) | 0),
        (f = (f + Math.imul(ve, je)) | 0),
        (f = (f + Math.imul(z, We)) | 0),
        (_ = (_ + Math.imul(z, je)) | 0);
      var bn = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (bn >>> 26)) | 0),
        (bn &= 67108863),
        (x = Math.imul(L, We)),
        (f = Math.imul(L, je)),
        (f = (f + Math.imul(J, We)) | 0),
        (_ = Math.imul(J, je));
      var vn = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      return (
        (R = (((_ + (f >>> 13)) | 0) + (vn >>> 26)) | 0),
        (vn &= 67108863),
        (T[0] = ur),
        (T[1] = mt),
        (T[2] = yt),
        (T[3] = rr),
        (T[4] = nr),
        (T[5] = ir),
        (T[6] = ar),
        (T[7] = sr),
        (T[8] = Ir),
        (T[9] = Rr),
        (T[10] = Pr),
        (T[11] = Nr),
        (T[12] = Br),
        (T[13] = Dr),
        (T[14] = Or),
        (T[15] = Fr),
        (T[16] = Lr),
        (T[17] = bn),
        (T[18] = vn),
        R !== 0 && ((T[19] = R), y.length++),
        y
      );
    };
    Math.imul || (A = E);
    function I(C, l, p) {
      (p.negative = l.negative ^ C.negative), (p.length = C.length + l.length);
      for (var y = 0, h = 0, g = 0; g < p.length - 1; g++) {
        var T = h;
        h = 0;
        for (
          var R = y & 67108863,
            x = Math.min(g, l.length - 1),
            f = Math.max(0, g - C.length + 1);
          f <= x;
          f++
        ) {
          var _ = g - f,
            P = C.words[_] | 0,
            M = l.words[f] | 0,
            D = P * M,
            q = D & 67108863;
          (T = (T + ((D / 67108864) | 0)) | 0),
            (q = (q + R) | 0),
            (R = q & 67108863),
            (T = (T + (q >>> 26)) | 0),
            (h += T >>> 26),
            (T &= 67108863);
        }
        (p.words[g] = R), (y = T), (T = h);
      }
      return y !== 0 ? (p.words[g] = y) : p.length--, p.strip();
    }
    function b(C, l, p) {
      var y = new w();
      return y.mulp(C, l, p);
    }
    a.prototype.mulTo = function (l, p) {
      var y,
        h = this.length + l.length;
      return (
        this.length === 10 && l.length === 10
          ? (y = A(this, l, p))
          : h < 63
          ? (y = E(this, l, p))
          : h < 1024
          ? (y = I(this, l, p))
          : (y = b(this, l, p)),
        y
      );
    };
    function w(C, l) {
      (this.x = C), (this.y = l);
    }
    (w.prototype.makeRBT = function (l) {
      for (
        var p = new Array(l), y = a.prototype._countBits(l) - 1, h = 0;
        h < l;
        h++
      )
        p[h] = this.revBin(h, y, l);
      return p;
    }),
      (w.prototype.revBin = function (l, p, y) {
        if (l === 0 || l === y - 1) return l;
        for (var h = 0, g = 0; g < p; g++)
          (h |= (l & 1) << (p - g - 1)), (l >>= 1);
        return h;
      }),
      (w.prototype.permute = function (l, p, y, h, g, T) {
        for (var R = 0; R < T; R++) (h[R] = p[l[R]]), (g[R] = y[l[R]]);
      }),
      (w.prototype.transform = function (l, p, y, h, g, T) {
        this.permute(T, l, p, y, h, g);
        for (var R = 1; R < g; R <<= 1)
          for (
            var x = R << 1,
              f = Math.cos((2 * Math.PI) / x),
              _ = Math.sin((2 * Math.PI) / x),
              P = 0;
            P < g;
            P += x
          )
            for (var M = f, D = _, q = 0; q < R; q++) {
              var B = y[P + q],
                H = h[P + q],
                Q = y[P + q + R],
                Z = h[P + q + R],
                te = M * Q - D * Z;
              (Z = M * Z + D * Q),
                (Q = te),
                (y[P + q] = B + Q),
                (h[P + q] = H + Z),
                (y[P + q + R] = B - Q),
                (h[P + q + R] = H - Z),
                q !== x &&
                  ((te = f * M - _ * D), (D = f * D + _ * M), (M = te));
            }
      }),
      (w.prototype.guessLen13b = function (l, p) {
        var y = Math.max(p, l) | 1,
          h = y & 1,
          g = 0;
        for (y = (y / 2) | 0; y; y = y >>> 1) g++;
        return 1 << (g + 1 + h);
      }),
      (w.prototype.conjugate = function (l, p, y) {
        if (!(y <= 1))
          for (var h = 0; h < y / 2; h++) {
            var g = l[h];
            (l[h] = l[y - h - 1]),
              (l[y - h - 1] = g),
              (g = p[h]),
              (p[h] = -p[y - h - 1]),
              (p[y - h - 1] = -g);
          }
      }),
      (w.prototype.normalize13b = function (l, p) {
        for (var y = 0, h = 0; h < p / 2; h++) {
          var g =
            Math.round(l[2 * h + 1] / p) * 8192 + Math.round(l[2 * h] / p) + y;
          (l[h] = g & 67108863),
            g < 67108864 ? (y = 0) : (y = (g / 67108864) | 0);
        }
        return l;
      }),
      (w.prototype.convert13b = function (l, p, y, h) {
        for (var g = 0, T = 0; T < p; T++)
          (g = g + (l[T] | 0)),
            (y[2 * T] = g & 8191),
            (g = g >>> 13),
            (y[2 * T + 1] = g & 8191),
            (g = g >>> 13);
        for (T = 2 * p; T < h; ++T) y[T] = 0;
        n(g === 0), n((g & -8192) === 0);
      }),
      (w.prototype.stub = function (l) {
        for (var p = new Array(l), y = 0; y < l; y++) p[y] = 0;
        return p;
      }),
      (w.prototype.mulp = function (l, p, y) {
        var h = 2 * this.guessLen13b(l.length, p.length),
          g = this.makeRBT(h),
          T = this.stub(h),
          R = new Array(h),
          x = new Array(h),
          f = new Array(h),
          _ = new Array(h),
          P = new Array(h),
          M = new Array(h),
          D = y.words;
        (D.length = h),
          this.convert13b(l.words, l.length, R, h),
          this.convert13b(p.words, p.length, _, h),
          this.transform(R, T, x, f, h, g),
          this.transform(_, T, P, M, h, g);
        for (var q = 0; q < h; q++) {
          var B = x[q] * P[q] - f[q] * M[q];
          (f[q] = x[q] * M[q] + f[q] * P[q]), (x[q] = B);
        }
        return (
          this.conjugate(x, f, h),
          this.transform(x, f, D, T, h, g),
          this.conjugate(D, T, h),
          this.normalize13b(D, h),
          (y.negative = l.negative ^ p.negative),
          (y.length = l.length + p.length),
          y.strip()
        );
      }),
      (a.prototype.mul = function (l) {
        var p = new a(null);
        return (p.words = new Array(this.length + l.length)), this.mulTo(l, p);
      }),
      (a.prototype.mulf = function (l) {
        var p = new a(null);
        return (p.words = new Array(this.length + l.length)), b(this, l, p);
      }),
      (a.prototype.imul = function (l) {
        return this.clone().mulTo(l, this);
      }),
      (a.prototype.imuln = function (l) {
        n(typeof l == "number"), n(l < 67108864);
        for (var p = 0, y = 0; y < this.length; y++) {
          var h = (this.words[y] | 0) * l,
            g = (h & 67108863) + (p & 67108863);
          (p >>= 26),
            (p += (h / 67108864) | 0),
            (p += g >>> 26),
            (this.words[y] = g & 67108863);
        }
        return p !== 0 && ((this.words[y] = p), this.length++), this;
      }),
      (a.prototype.muln = function (l) {
        return this.clone().imuln(l);
      }),
      (a.prototype.sqr = function () {
        return this.mul(this);
      }),
      (a.prototype.isqr = function () {
        return this.imul(this.clone());
      }),
      (a.prototype.pow = function (l) {
        var p = v(l);
        if (p.length === 0) return new a(1);
        for (var y = this, h = 0; h < p.length && p[h] === 0; h++, y = y.sqr());
        if (++h < p.length)
          for (var g = y.sqr(); h < p.length; h++, g = g.sqr())
            p[h] !== 0 && (y = y.mul(g));
        return y;
      }),
      (a.prototype.iushln = function (l) {
        n(typeof l == "number" && l >= 0);
        var p = l % 26,
          y = (l - p) / 26,
          h = (67108863 >>> (26 - p)) << (26 - p),
          g;
        if (p !== 0) {
          var T = 0;
          for (g = 0; g < this.length; g++) {
            var R = this.words[g] & h,
              x = ((this.words[g] | 0) - R) << p;
            (this.words[g] = x | T), (T = R >>> (26 - p));
          }
          T && ((this.words[g] = T), this.length++);
        }
        if (y !== 0) {
          for (g = this.length - 1; g >= 0; g--)
            this.words[g + y] = this.words[g];
          for (g = 0; g < y; g++) this.words[g] = 0;
          this.length += y;
        }
        return this.strip();
      }),
      (a.prototype.ishln = function (l) {
        return n(this.negative === 0), this.iushln(l);
      }),
      (a.prototype.iushrn = function (l, p, y) {
        n(typeof l == "number" && l >= 0);
        var h;
        p ? (h = (p - (p % 26)) / 26) : (h = 0);
        var g = l % 26,
          T = Math.min((l - g) / 26, this.length),
          R = 67108863 ^ ((67108863 >>> g) << g),
          x = y;
        if (((h -= T), (h = Math.max(0, h)), x)) {
          for (var f = 0; f < T; f++) x.words[f] = this.words[f];
          x.length = T;
        }
        if (T !== 0)
          if (this.length > T)
            for (this.length -= T, f = 0; f < this.length; f++)
              this.words[f] = this.words[f + T];
          else (this.words[0] = 0), (this.length = 1);
        var _ = 0;
        for (f = this.length - 1; f >= 0 && (_ !== 0 || f >= h); f--) {
          var P = this.words[f] | 0;
          (this.words[f] = (_ << (26 - g)) | (P >>> g)), (_ = P & R);
        }
        return (
          x && _ !== 0 && (x.words[x.length++] = _),
          this.length === 0 && ((this.words[0] = 0), (this.length = 1)),
          this.strip()
        );
      }),
      (a.prototype.ishrn = function (l, p, y) {
        return n(this.negative === 0), this.iushrn(l, p, y);
      }),
      (a.prototype.shln = function (l) {
        return this.clone().ishln(l);
      }),
      (a.prototype.ushln = function (l) {
        return this.clone().iushln(l);
      }),
      (a.prototype.shrn = function (l) {
        return this.clone().ishrn(l);
      }),
      (a.prototype.ushrn = function (l) {
        return this.clone().iushrn(l);
      }),
      (a.prototype.testn = function (l) {
        n(typeof l == "number" && l >= 0);
        var p = l % 26,
          y = (l - p) / 26,
          h = 1 << p;
        if (this.length <= y) return !1;
        var g = this.words[y];
        return !!(g & h);
      }),
      (a.prototype.imaskn = function (l) {
        n(typeof l == "number" && l >= 0);
        var p = l % 26,
          y = (l - p) / 26;
        if (
          (n(this.negative === 0, "imaskn works only with positive numbers"),
          this.length <= y)
        )
          return this;
        if (
          (p !== 0 && y++, (this.length = Math.min(y, this.length)), p !== 0)
        ) {
          var h = 67108863 ^ ((67108863 >>> p) << p);
          this.words[this.length - 1] &= h;
        }
        return this.strip();
      }),
      (a.prototype.maskn = function (l) {
        return this.clone().imaskn(l);
      }),
      (a.prototype.iaddn = function (l) {
        return (
          n(typeof l == "number"),
          n(l < 67108864),
          l < 0
            ? this.isubn(-l)
            : this.negative !== 0
            ? this.length === 1 && (this.words[0] | 0) < l
              ? ((this.words[0] = l - (this.words[0] | 0)),
                (this.negative = 0),
                this)
              : ((this.negative = 0), this.isubn(l), (this.negative = 1), this)
            : this._iaddn(l)
        );
      }),
      (a.prototype._iaddn = function (l) {
        this.words[0] += l;
        for (var p = 0; p < this.length && this.words[p] >= 67108864; p++)
          (this.words[p] -= 67108864),
            p === this.length - 1
              ? (this.words[p + 1] = 1)
              : this.words[p + 1]++;
        return (this.length = Math.max(this.length, p + 1)), this;
      }),
      (a.prototype.isubn = function (l) {
        if ((n(typeof l == "number"), n(l < 67108864), l < 0))
          return this.iaddn(-l);
        if (this.negative !== 0)
          return (this.negative = 0), this.iaddn(l), (this.negative = 1), this;
        if (((this.words[0] -= l), this.length === 1 && this.words[0] < 0))
          (this.words[0] = -this.words[0]), (this.negative = 1);
        else
          for (var p = 0; p < this.length && this.words[p] < 0; p++)
            (this.words[p] += 67108864), (this.words[p + 1] -= 1);
        return this.strip();
      }),
      (a.prototype.addn = function (l) {
        return this.clone().iaddn(l);
      }),
      (a.prototype.subn = function (l) {
        return this.clone().isubn(l);
      }),
      (a.prototype.iabs = function () {
        return (this.negative = 0), this;
      }),
      (a.prototype.abs = function () {
        return this.clone().iabs();
      }),
      (a.prototype._ishlnsubmul = function (l, p, y) {
        var h = l.length + y,
          g;
        this._expand(h);
        var T,
          R = 0;
        for (g = 0; g < l.length; g++) {
          T = (this.words[g + y] | 0) + R;
          var x = (l.words[g] | 0) * p;
          (T -= x & 67108863),
            (R = (T >> 26) - ((x / 67108864) | 0)),
            (this.words[g + y] = T & 67108863);
        }
        for (; g < this.length - y; g++)
          (T = (this.words[g + y] | 0) + R),
            (R = T >> 26),
            (this.words[g + y] = T & 67108863);
        if (R === 0) return this.strip();
        for (n(R === -1), R = 0, g = 0; g < this.length; g++)
          (T = -(this.words[g] | 0) + R),
            (R = T >> 26),
            (this.words[g] = T & 67108863);
        return (this.negative = 1), this.strip();
      }),
      (a.prototype._wordDiv = function (l, p) {
        var y = this.length - l.length,
          h = this.clone(),
          g = l,
          T = g.words[g.length - 1] | 0,
          R = this._countBits(T);
        (y = 26 - R),
          y !== 0 &&
            ((g = g.ushln(y)), h.iushln(y), (T = g.words[g.length - 1] | 0));
        var x = h.length - g.length,
          f;
        if (p !== "mod") {
          (f = new a(null)),
            (f.length = x + 1),
            (f.words = new Array(f.length));
          for (var _ = 0; _ < f.length; _++) f.words[_] = 0;
        }
        var P = h.clone()._ishlnsubmul(g, 1, x);
        P.negative === 0 && ((h = P), f && (f.words[x] = 1));
        for (var M = x - 1; M >= 0; M--) {
          var D =
            (h.words[g.length + M] | 0) * 67108864 +
            (h.words[g.length + M - 1] | 0);
          for (
            D = Math.min((D / T) | 0, 67108863), h._ishlnsubmul(g, D, M);
            h.negative !== 0;

          )
            D--,
              (h.negative = 0),
              h._ishlnsubmul(g, 1, M),
              h.isZero() || (h.negative ^= 1);
          f && (f.words[M] = D);
        }
        return (
          f && f.strip(),
          h.strip(),
          p !== "div" && y !== 0 && h.iushrn(y),
          {
            div: f || null,
            mod: h,
          }
        );
      }),
      (a.prototype.divmod = function (l, p, y) {
        if ((n(!l.isZero()), this.isZero()))
          return {
            div: new a(0),
            mod: new a(0),
          };
        var h, g, T;
        return this.negative !== 0 && l.negative === 0
          ? ((T = this.neg().divmod(l, p)),
            p !== "mod" && (h = T.div.neg()),
            p !== "div" &&
              ((g = T.mod.neg()), y && g.negative !== 0 && g.iadd(l)),
            {
              div: h,
              mod: g,
            })
          : this.negative === 0 && l.negative !== 0
          ? ((T = this.divmod(l.neg(), p)),
            p !== "mod" && (h = T.div.neg()),
            {
              div: h,
              mod: T.mod,
            })
          : this.negative & l.negative
          ? ((T = this.neg().divmod(l.neg(), p)),
            p !== "div" &&
              ((g = T.mod.neg()), y && g.negative !== 0 && g.isub(l)),
            {
              div: T.div,
              mod: g,
            })
          : l.length > this.length || this.cmp(l) < 0
          ? {
              div: new a(0),
              mod: this,
            }
          : l.length === 1
          ? p === "div"
            ? {
                div: this.divn(l.words[0]),
                mod: null,
              }
            : p === "mod"
            ? {
                div: null,
                mod: new a(this.modn(l.words[0])),
              }
            : {
                div: this.divn(l.words[0]),
                mod: new a(this.modn(l.words[0])),
              }
          : this._wordDiv(l, p);
      }),
      (a.prototype.div = function (l) {
        return this.divmod(l, "div", !1).div;
      }),
      (a.prototype.mod = function (l) {
        return this.divmod(l, "mod", !1).mod;
      }),
      (a.prototype.umod = function (l) {
        return this.divmod(l, "mod", !0).mod;
      }),
      (a.prototype.divRound = function (l) {
        var p = this.divmod(l);
        if (p.mod.isZero()) return p.div;
        var y = p.div.negative !== 0 ? p.mod.isub(l) : p.mod,
          h = l.ushrn(1),
          g = l.andln(1),
          T = y.cmp(h);
        return T < 0 || (g === 1 && T === 0)
          ? p.div
          : p.div.negative !== 0
          ? p.div.isubn(1)
          : p.div.iaddn(1);
      }),
      (a.prototype.modn = function (l) {
        n(l <= 67108863);
        for (var p = (1 << 26) % l, y = 0, h = this.length - 1; h >= 0; h--)
          y = (p * y + (this.words[h] | 0)) % l;
        return y;
      }),
      (a.prototype.idivn = function (l) {
        n(l <= 67108863);
        for (var p = 0, y = this.length - 1; y >= 0; y--) {
          var h = (this.words[y] | 0) + p * 67108864;
          (this.words[y] = (h / l) | 0), (p = h % l);
        }
        return this.strip();
      }),
      (a.prototype.divn = function (l) {
        return this.clone().idivn(l);
      }),
      (a.prototype.egcd = function (l) {
        n(l.negative === 0), n(!l.isZero());
        var p = this,
          y = l.clone();
        p.negative !== 0 ? (p = p.umod(l)) : (p = p.clone());
        for (
          var h = new a(1), g = new a(0), T = new a(0), R = new a(1), x = 0;
          p.isEven() && y.isEven();

        )
          p.iushrn(1), y.iushrn(1), ++x;
        for (var f = y.clone(), _ = p.clone(); !p.isZero(); ) {
          for (var P = 0, M = 1; !(p.words[0] & M) && P < 26; ++P, M <<= 1);
          if (P > 0)
            for (p.iushrn(P); P-- > 0; )
              (h.isOdd() || g.isOdd()) && (h.iadd(f), g.isub(_)),
                h.iushrn(1),
                g.iushrn(1);
          for (var D = 0, q = 1; !(y.words[0] & q) && D < 26; ++D, q <<= 1);
          if (D > 0)
            for (y.iushrn(D); D-- > 0; )
              (T.isOdd() || R.isOdd()) && (T.iadd(f), R.isub(_)),
                T.iushrn(1),
                R.iushrn(1);
          p.cmp(y) >= 0
            ? (p.isub(y), h.isub(T), g.isub(R))
            : (y.isub(p), T.isub(h), R.isub(g));
        }
        return {
          a: T,
          b: R,
          gcd: y.iushln(x),
        };
      }),
      (a.prototype._invmp = function (l) {
        n(l.negative === 0), n(!l.isZero());
        var p = this,
          y = l.clone();
        p.negative !== 0 ? (p = p.umod(l)) : (p = p.clone());
        for (
          var h = new a(1), g = new a(0), T = y.clone();
          p.cmpn(1) > 0 && y.cmpn(1) > 0;

        ) {
          for (var R = 0, x = 1; !(p.words[0] & x) && R < 26; ++R, x <<= 1);
          if (R > 0)
            for (p.iushrn(R); R-- > 0; ) h.isOdd() && h.iadd(T), h.iushrn(1);
          for (var f = 0, _ = 1; !(y.words[0] & _) && f < 26; ++f, _ <<= 1);
          if (f > 0)
            for (y.iushrn(f); f-- > 0; ) g.isOdd() && g.iadd(T), g.iushrn(1);
          p.cmp(y) >= 0 ? (p.isub(y), h.isub(g)) : (y.isub(p), g.isub(h));
        }
        var P;
        return (
          p.cmpn(1) === 0 ? (P = h) : (P = g), P.cmpn(0) < 0 && P.iadd(l), P
        );
      }),
      (a.prototype.gcd = function (l) {
        if (this.isZero()) return l.abs();
        if (l.isZero()) return this.abs();
        var p = this.clone(),
          y = l.clone();
        (p.negative = 0), (y.negative = 0);
        for (var h = 0; p.isEven() && y.isEven(); h++) p.iushrn(1), y.iushrn(1);
        do {
          for (; p.isEven(); ) p.iushrn(1);
          for (; y.isEven(); ) y.iushrn(1);
          var g = p.cmp(y);
          if (g < 0) {
            var T = p;
            (p = y), (y = T);
          } else if (g === 0 || y.cmpn(1) === 0) break;
          p.isub(y);
        } while (!0);
        return y.iushln(h);
      }),
      (a.prototype.invm = function (l) {
        return this.egcd(l).a.umod(l);
      }),
      (a.prototype.isEven = function () {
        return (this.words[0] & 1) === 0;
      }),
      (a.prototype.isOdd = function () {
        return (this.words[0] & 1) === 1;
      }),
      (a.prototype.andln = function (l) {
        return this.words[0] & l;
      }),
      (a.prototype.bincn = function (l) {
        n(typeof l == "number");
        var p = l % 26,
          y = (l - p) / 26,
          h = 1 << p;
        if (this.length <= y)
          return this._expand(y + 1), (this.words[y] |= h), this;
        for (var g = h, T = y; g !== 0 && T < this.length; T++) {
          var R = this.words[T] | 0;
          (R += g), (g = R >>> 26), (R &= 67108863), (this.words[T] = R);
        }
        return g !== 0 && ((this.words[T] = g), this.length++), this;
      }),
      (a.prototype.isZero = function () {
        return this.length === 1 && this.words[0] === 0;
      }),
      (a.prototype.cmpn = function (l) {
        var p = l < 0;
        if (this.negative !== 0 && !p) return -1;
        if (this.negative === 0 && p) return 1;
        this.strip();
        var y;
        if (this.length > 1) y = 1;
        else {
          p && (l = -l), n(l <= 67108863, "Number is too big");
          var h = this.words[0] | 0;
          y = h === l ? 0 : h < l ? -1 : 1;
        }
        return this.negative !== 0 ? -y | 0 : y;
      }),
      (a.prototype.cmp = function (l) {
        if (this.negative !== 0 && l.negative === 0) return -1;
        if (this.negative === 0 && l.negative !== 0) return 1;
        var p = this.ucmp(l);
        return this.negative !== 0 ? -p | 0 : p;
      }),
      (a.prototype.ucmp = function (l) {
        if (this.length > l.length) return 1;
        if (this.length < l.length) return -1;
        for (var p = 0, y = this.length - 1; y >= 0; y--) {
          var h = this.words[y] | 0,
            g = l.words[y] | 0;
          if (h !== g) {
            h < g ? (p = -1) : h > g && (p = 1);
            break;
          }
        }
        return p;
      }),
      (a.prototype.gtn = function (l) {
        return this.cmpn(l) === 1;
      }),
      (a.prototype.gt = function (l) {
        return this.cmp(l) === 1;
      }),
      (a.prototype.gten = function (l) {
        return this.cmpn(l) >= 0;
      }),
      (a.prototype.gte = function (l) {
        return this.cmp(l) >= 0;
      }),
      (a.prototype.ltn = function (l) {
        return this.cmpn(l) === -1;
      }),
      (a.prototype.lt = function (l) {
        return this.cmp(l) === -1;
      }),
      (a.prototype.lten = function (l) {
        return this.cmpn(l) <= 0;
      }),
      (a.prototype.lte = function (l) {
        return this.cmp(l) <= 0;
      }),
      (a.prototype.eqn = function (l) {
        return this.cmpn(l) === 0;
      }),
      (a.prototype.eq = function (l) {
        return this.cmp(l) === 0;
      }),
      (a.red = function (l) {
        return new j(l);
      }),
      (a.prototype.toRed = function (l) {
        return (
          n(!this.red, "Already a number in reduction context"),
          n(this.negative === 0, "red works only with positives"),
          l.convertTo(this)._forceRed(l)
        );
      }),
      (a.prototype.fromRed = function () {
        return (
          n(this.red, "fromRed works only with numbers in reduction context"),
          this.red.convertFrom(this)
        );
      }),
      (a.prototype._forceRed = function (l) {
        return (this.red = l), this;
      }),
      (a.prototype.forceRed = function (l) {
        return (
          n(!this.red, "Already a number in reduction context"),
          this._forceRed(l)
        );
      }),
      (a.prototype.redAdd = function (l) {
        return (
          n(this.red, "redAdd works only with red numbers"),
          this.red.add(this, l)
        );
      }),
      (a.prototype.redIAdd = function (l) {
        return (
          n(this.red, "redIAdd works only with red numbers"),
          this.red.iadd(this, l)
        );
      }),
      (a.prototype.redSub = function (l) {
        return (
          n(this.red, "redSub works only with red numbers"),
          this.red.sub(this, l)
        );
      }),
      (a.prototype.redISub = function (l) {
        return (
          n(this.red, "redISub works only with red numbers"),
          this.red.isub(this, l)
        );
      }),
      (a.prototype.redShl = function (l) {
        return (
          n(this.red, "redShl works only with red numbers"),
          this.red.shl(this, l)
        );
      }),
      (a.prototype.redMul = function (l) {
        return (
          n(this.red, "redMul works only with red numbers"),
          this.red._verify2(this, l),
          this.red.mul(this, l)
        );
      }),
      (a.prototype.redIMul = function (l) {
        return (
          n(this.red, "redMul works only with red numbers"),
          this.red._verify2(this, l),
          this.red.imul(this, l)
        );
      }),
      (a.prototype.redSqr = function () {
        return (
          n(this.red, "redSqr works only with red numbers"),
          this.red._verify1(this),
          this.red.sqr(this)
        );
      }),
      (a.prototype.redISqr = function () {
        return (
          n(this.red, "redISqr works only with red numbers"),
          this.red._verify1(this),
          this.red.isqr(this)
        );
      }),
      (a.prototype.redSqrt = function () {
        return (
          n(this.red, "redSqrt works only with red numbers"),
          this.red._verify1(this),
          this.red.sqrt(this)
        );
      }),
      (a.prototype.redInvm = function () {
        return (
          n(this.red, "redInvm works only with red numbers"),
          this.red._verify1(this),
          this.red.invm(this)
        );
      }),
      (a.prototype.redNeg = function () {
        return (
          n(this.red, "redNeg works only with red numbers"),
          this.red._verify1(this),
          this.red.neg(this)
        );
      }),
      (a.prototype.redPow = function (l) {
        return (
          n(this.red && !l.red, "redPow(normalNum)"),
          this.red._verify1(this),
          this.red.pow(this, l)
        );
      });
    var S = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null,
    };
    function k(C, l) {
      (this.name = C),
        (this.p = new a(l, 16)),
        (this.n = this.p.bitLength()),
        (this.k = new a(1).iushln(this.n).isub(this.p)),
        (this.tmp = this._tmp());
    }
    (k.prototype._tmp = function () {
      var l = new a(null);
      return (l.words = new Array(Math.ceil(this.n / 13))), l;
    }),
      (k.prototype.ireduce = function (l) {
        var p = l,
          y;
        do
          this.split(p, this.tmp),
            (p = this.imulK(p)),
            (p = p.iadd(this.tmp)),
            (y = p.bitLength());
        while (y > this.n);
        var h = y < this.n ? -1 : p.ucmp(this.p);
        return (
          h === 0
            ? ((p.words[0] = 0), (p.length = 1))
            : h > 0
            ? p.isub(this.p)
            : p.strip(),
          p
        );
      }),
      (k.prototype.split = function (l, p) {
        l.iushrn(this.n, 0, p);
      }),
      (k.prototype.imulK = function (l) {
        return l.imul(this.k);
      });
    function N() {
      k.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    i(N, k),
      (N.prototype.split = function (l, p) {
        for (var y = 4194303, h = Math.min(l.length, 9), g = 0; g < h; g++)
          p.words[g] = l.words[g];
        if (((p.length = h), l.length <= 9)) {
          (l.words[0] = 0), (l.length = 1);
          return;
        }
        var T = l.words[9];
        for (p.words[p.length++] = T & y, g = 10; g < l.length; g++) {
          var R = l.words[g] | 0;
          (l.words[g - 10] = ((R & y) << 4) | (T >>> 22)), (T = R);
        }
        (T >>>= 22),
          (l.words[g - 10] = T),
          T === 0 && l.length > 10 ? (l.length -= 10) : (l.length -= 9);
      }),
      (N.prototype.imulK = function (l) {
        (l.words[l.length] = 0), (l.words[l.length + 1] = 0), (l.length += 2);
        for (var p = 0, y = 0; y < l.length; y++) {
          var h = l.words[y] | 0;
          (p += h * 977),
            (l.words[y] = p & 67108863),
            (p = h * 64 + ((p / 67108864) | 0));
        }
        return (
          l.words[l.length - 1] === 0 &&
            (l.length--, l.words[l.length - 1] === 0 && l.length--),
          l
        );
      });
    function O() {
      k.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    i(O, k);
    function F() {
      k.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    i(F, k);
    function V() {
      k.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    i(V, k),
      (V.prototype.imulK = function (l) {
        for (var p = 0, y = 0; y < l.length; y++) {
          var h = (l.words[y] | 0) * 19 + p,
            g = h & 67108863;
          (h >>>= 26), (l.words[y] = g), (p = h);
        }
        return p !== 0 && (l.words[l.length++] = p), l;
      }),
      (a._prime = function (l) {
        if (S[l]) return S[l];
        var p;
        if (l === "k256") p = new N();
        else if (l === "p224") p = new O();
        else if (l === "p192") p = new F();
        else if (l === "p25519") p = new V();
        else throw new Error("Unknown prime " + l);
        return (S[l] = p), p;
      });
    function j(C) {
      if (typeof C == "string") {
        var l = a._prime(C);
        (this.m = l.p), (this.prime = l);
      } else
        n(C.gtn(1), "modulus must be greater than 1"),
          (this.m = C),
          (this.prime = null);
    }
    (j.prototype._verify1 = function (l) {
      n(l.negative === 0, "red works only with positives"),
        n(l.red, "red works only with red numbers");
    }),
      (j.prototype._verify2 = function (l, p) {
        n((l.negative | p.negative) === 0, "red works only with positives"),
          n(l.red && l.red === p.red, "red works only with red numbers");
      }),
      (j.prototype.imod = function (l) {
        return this.prime
          ? this.prime.ireduce(l)._forceRed(this)
          : l.umod(this.m)._forceRed(this);
      }),
      (j.prototype.neg = function (l) {
        return l.isZero() ? l.clone() : this.m.sub(l)._forceRed(this);
      }),
      (j.prototype.add = function (l, p) {
        this._verify2(l, p);
        var y = l.add(p);
        return y.cmp(this.m) >= 0 && y.isub(this.m), y._forceRed(this);
      }),
      (j.prototype.iadd = function (l, p) {
        this._verify2(l, p);
        var y = l.iadd(p);
        return y.cmp(this.m) >= 0 && y.isub(this.m), y;
      }),
      (j.prototype.sub = function (l, p) {
        this._verify2(l, p);
        var y = l.sub(p);
        return y.cmpn(0) < 0 && y.iadd(this.m), y._forceRed(this);
      }),
      (j.prototype.isub = function (l, p) {
        this._verify2(l, p);
        var y = l.isub(p);
        return y.cmpn(0) < 0 && y.iadd(this.m), y;
      }),
      (j.prototype.shl = function (l, p) {
        return this._verify1(l), this.imod(l.ushln(p));
      }),
      (j.prototype.imul = function (l, p) {
        return this._verify2(l, p), this.imod(l.imul(p));
      }),
      (j.prototype.mul = function (l, p) {
        return this._verify2(l, p), this.imod(l.mul(p));
      }),
      (j.prototype.isqr = function (l) {
        return this.imul(l, l.clone());
      }),
      (j.prototype.sqr = function (l) {
        return this.mul(l, l);
      }),
      (j.prototype.sqrt = function (l) {
        if (l.isZero()) return l.clone();
        var p = this.m.andln(3);
        if ((n(p % 2 === 1), p === 3)) {
          var y = this.m.add(new a(1)).iushrn(2);
          return this.pow(l, y);
        }
        for (var h = this.m.subn(1), g = 0; !h.isZero() && h.andln(1) === 0; )
          g++, h.iushrn(1);
        n(!h.isZero());
        var T = new a(1).toRed(this),
          R = T.redNeg(),
          x = this.m.subn(1).iushrn(1),
          f = this.m.bitLength();
        for (f = new a(2 * f * f).toRed(this); this.pow(f, x).cmp(R) !== 0; )
          f.redIAdd(R);
        for (
          var _ = this.pow(f, h),
            P = this.pow(l, h.addn(1).iushrn(1)),
            M = this.pow(l, h),
            D = g;
          M.cmp(T) !== 0;

        ) {
          for (var q = M, B = 0; q.cmp(T) !== 0; B++) q = q.redSqr();
          n(B < D);
          var H = this.pow(_, new a(1).iushln(D - B - 1));
          (P = P.redMul(H)), (_ = H.redSqr()), (M = M.redMul(_)), (D = B);
        }
        return P;
      }),
      (j.prototype.invm = function (l) {
        var p = l._invmp(this.m);
        return p.negative !== 0
          ? ((p.negative = 0), this.imod(p).redNeg())
          : this.imod(p);
      }),
      (j.prototype.pow = function (l, p) {
        if (p.isZero()) return new a(1).toRed(this);
        if (p.cmpn(1) === 0) return l.clone();
        var y = 4,
          h = new Array(1 << y);
        (h[0] = new a(1).toRed(this)), (h[1] = l);
        for (var g = 2; g < h.length; g++) h[g] = this.mul(h[g - 1], l);
        var T = h[0],
          R = 0,
          x = 0,
          f = p.bitLength() % 26;
        for (f === 0 && (f = 26), g = p.length - 1; g >= 0; g--) {
          for (var _ = p.words[g], P = f - 1; P >= 0; P--) {
            var M = (_ >> P) & 1;
            if ((T !== h[0] && (T = this.sqr(T)), M === 0 && R === 0)) {
              x = 0;
              continue;
            }
            (R <<= 1),
              (R |= M),
              x++,
              !(x !== y && (g !== 0 || P !== 0)) &&
                ((T = this.mul(T, h[R])), (x = 0), (R = 0));
          }
          f = 26;
        }
        return T;
      }),
      (j.prototype.convertTo = function (l) {
        var p = l.umod(this.m);
        return p === l ? p.clone() : p;
      }),
      (j.prototype.convertFrom = function (l) {
        var p = l.clone();
        return (p.red = null), p;
      }),
      (a.mont = function (l) {
        return new X(l);
      });
    function X(C) {
      j.call(this, C),
        (this.shift = this.m.bitLength()),
        this.shift % 26 !== 0 && (this.shift += 26 - (this.shift % 26)),
        (this.r = new a(1).iushln(this.shift)),
        (this.r2 = this.imod(this.r.sqr())),
        (this.rinv = this.r._invmp(this.m)),
        (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
        (this.minv = this.minv.umod(this.r)),
        (this.minv = this.r.sub(this.minv));
    }
    i(X, j),
      (X.prototype.convertTo = function (l) {
        return this.imod(l.ushln(this.shift));
      }),
      (X.prototype.convertFrom = function (l) {
        var p = this.imod(l.mul(this.rinv));
        return (p.red = null), p;
      }),
      (X.prototype.imul = function (l, p) {
        if (l.isZero() || p.isZero())
          return (l.words[0] = 0), (l.length = 1), l;
        var y = l.imul(p),
          h = y.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
          g = y.isub(h).iushrn(this.shift),
          T = g;
        return (
          g.cmp(this.m) >= 0
            ? (T = g.isub(this.m))
            : g.cmpn(0) < 0 && (T = g.iadd(this.m)),
          T._forceRed(this)
        );
      }),
      (X.prototype.mul = function (l, p) {
        if (l.isZero() || p.isZero()) return new a(0)._forceRed(this);
        var y = l.mul(p),
          h = y.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
          g = y.isub(h).iushrn(this.shift),
          T = g;
        return (
          g.cmp(this.m) >= 0
            ? (T = g.isub(this.m))
            : g.cmpn(0) < 0 && (T = g.iadd(this.m)),
          T._forceRed(this)
        );
      }),
      (X.prototype.invm = function (l) {
        var p = this.imod(l._invmp(this.m).mul(this.r2));
        return p._forceRed(this);
      });
  })(t, ke);
})(KT);
KT.exports;
var y_e = GT;
GT.strict = Sj;
GT.loose = Mj;
var g_e = Object.prototype.toString,
  b_e = {
    "[object Int8Array]": !0,
    "[object Int16Array]": !0,
    "[object Int32Array]": !0,
    "[object Uint8Array]": !0,
    "[object Uint8ClampedArray]": !0,
    "[object Uint16Array]": !0,
    "[object Uint32Array]": !0,
    "[object Float32Array]": !0,
    "[object Float64Array]": !0,
  };
function GT(t) {
  return Sj(t) || Mj(t);
}
function Sj(t) {
  return (
    t instanceof Int8Array ||
    t instanceof Int16Array ||
    t instanceof Int32Array ||
    t instanceof Uint8Array ||
    t instanceof Uint8ClampedArray ||
    t instanceof Uint16Array ||
    t instanceof Uint32Array ||
    t instanceof Float32Array ||
    t instanceof Float64Array
  );
}
function Mj(t) {
  return b_e[g_e.call(t)];
}
var v_e = y_e.strict,
  x_e = function (e) {
    if (v_e(e)) {
      var r = Buffer.from(e.buffer);
      return (
        e.byteLength !== e.buffer.byteLength &&
          (r = r.slice(e.byteOffset, e.byteOffset + e.byteLength)),
        r
      );
    } else return Buffer.from(e);
  };
const w_e = mn(x_e),
  Ij = "hex",
  Rj = "utf8",
  Ux = "0";
function Qf(t) {
  return new Uint8Array(t);
}
function Pj(t, e = !1) {
  const r = t.toString(Ij);
  return e ? Fd(r) : r;
}
function __e(t) {
  return t.toString(Rj);
}
function Wx(t) {
  return w_e(t);
}
function sf(t, e = !1) {
  return Pj(Wx(t), e);
}
function E_e(t) {
  return __e(Wx(t));
}
function T_e(t) {
  return Buffer.from(cl(t), Ij);
}
function of(t) {
  return Qf(T_e(t));
}
function ZT(t) {
  return Buffer.from(t, Rj);
}
function C_e(t) {
  return Qf(ZT(t));
}
function A_e(t, e = !1) {
  return Pj(ZT(t), e);
}
function k_e(t, e) {
  return !(typeof t != "string" || !t.match(/^0x[0-9A-Fa-f]*$/));
}
function Nj(...t) {
  let e = [];
  return (
    t.forEach((r) => (e = e.concat(Array.from(r)))), new Uint8Array([...e])
  );
}
function S_e(t, e = 8) {
  const r = t % e;
  return r ? ((t - r) / e) * e + e : t;
}
function M_e(t, e = 8, r = Ux) {
  return I_e(t, S_e(t.length, e), r);
}
function I_e(t, e, r = Ux) {
  return P_e(t, e, !0, r);
}
function cl(t) {
  return t.replace(/^0x/, "");
}
function Fd(t) {
  return t.startsWith("0x") ? t : `0x${t}`;
}
function Bj(t) {
  return (t = cl(t)), (t = M_e(t, 2)), t && (t = Fd(t)), t;
}
function R_e(t) {
  const e = t.startsWith("0x");
  return (
    (t = cl(t)), (t = t.startsWith(Ux) ? t.substring(1) : t), e ? Fd(t) : t
  );
}
function P_e(t, e, r, n = Ux) {
  const i = e - t.length;
  let a = t;
  return i > 0 && (a = n.repeat(i) + t), a;
}
function N_e(t, e) {
  let r;
  const n = m_e[t];
  return n && (r = `https://${n}.infura.io/v3/${e}`), r;
}
function B_e(t, e) {
  let r;
  const n = N_e(t, e.infuraId);
  return e.custom && e.custom[t] ? (r = e.custom[t]) : n && (r = n), r;
}
var D_e = {};
(function (t) {
  const e = Ov,
    r = Fv,
    n = Lv,
    i = (b) => b == null;
  function a(b) {
    switch (b.arrayFormat) {
      case "index":
        return (w) => (S, k) => {
          const N = S.length;
          return k === void 0 ||
            (b.skipNull && k === null) ||
            (b.skipEmptyString && k === "")
            ? S
            : k === null
            ? [...S, [c(w, b), "[", N, "]"].join("")]
            : [...S, [c(w, b), "[", c(N, b), "]=", c(k, b)].join("")];
        };
      case "bracket":
        return (w) => (S, k) =>
          k === void 0 ||
          (b.skipNull && k === null) ||
          (b.skipEmptyString && k === "")
            ? S
            : k === null
            ? [...S, [c(w, b), "[]"].join("")]
            : [...S, [c(w, b), "[]=", c(k, b)].join("")];
      case "comma":
      case "separator":
        return (w) => (S, k) =>
          k == null || k.length === 0
            ? S
            : S.length === 0
            ? [[c(w, b), "=", c(k, b)].join("")]
            : [[S, c(k, b)].join(b.arrayFormatSeparator)];
      default:
        return (w) => (S, k) =>
          k === void 0 ||
          (b.skipNull && k === null) ||
          (b.skipEmptyString && k === "")
            ? S
            : k === null
            ? [...S, c(w, b)]
            : [...S, [c(w, b), "=", c(k, b)].join("")];
    }
  }
  function s(b) {
    let w;
    switch (b.arrayFormat) {
      case "index":
        return (S, k, N) => {
          if (
            ((w = /\[(\d*)\]$/.exec(S)), (S = S.replace(/\[\d*\]$/, "")), !w)
          ) {
            N[S] = k;
            return;
          }
          N[S] === void 0 && (N[S] = {}), (N[S][w[1]] = k);
        };
      case "bracket":
        return (S, k, N) => {
          if (((w = /(\[\])$/.exec(S)), (S = S.replace(/\[\]$/, "")), !w)) {
            N[S] = k;
            return;
          }
          if (N[S] === void 0) {
            N[S] = [k];
            return;
          }
          N[S] = [].concat(N[S], k);
        };
      case "comma":
      case "separator":
        return (S, k, N) => {
          const F =
            typeof k == "string" &&
            k.split("").indexOf(b.arrayFormatSeparator) > -1
              ? k.split(b.arrayFormatSeparator).map((V) => u(V, b))
              : k === null
              ? k
              : u(k, b);
          N[S] = F;
        };
      default:
        return (S, k, N) => {
          if (N[S] === void 0) {
            N[S] = k;
            return;
          }
          N[S] = [].concat(N[S], k);
        };
    }
  }
  function o(b) {
    if (typeof b != "string" || b.length !== 1)
      throw new TypeError(
        "arrayFormatSeparator must be single character string"
      );
  }
  function c(b, w) {
    return w.encode ? (w.strict ? e(b) : encodeURIComponent(b)) : b;
  }
  function u(b, w) {
    return w.decode ? r(b) : b;
  }
  function d(b) {
    return Array.isArray(b)
      ? b.sort()
      : typeof b == "object"
      ? d(Object.keys(b))
          .sort((w, S) => Number(w) - Number(S))
          .map((w) => b[w])
      : b;
  }
  function m(b) {
    const w = b.indexOf("#");
    return w !== -1 && (b = b.slice(0, w)), b;
  }
  function v(b) {
    let w = "";
    const S = b.indexOf("#");
    return S !== -1 && (w = b.slice(S)), w;
  }
  function E(b) {
    b = m(b);
    const w = b.indexOf("?");
    return w === -1 ? "" : b.slice(w + 1);
  }
  function A(b, w) {
    return (
      w.parseNumbers &&
      !Number.isNaN(Number(b)) &&
      typeof b == "string" &&
      b.trim() !== ""
        ? (b = Number(b))
        : w.parseBooleans &&
          b !== null &&
          (b.toLowerCase() === "true" || b.toLowerCase() === "false") &&
          (b = b.toLowerCase() === "true"),
      b
    );
  }
  function I(b, w) {
    (w = Object.assign(
      {
        decode: !0,
        sort: !0,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: !1,
        parseBooleans: !1,
      },
      w
    )),
      o(w.arrayFormatSeparator);
    const S = s(w),
      k = Object.create(null);
    if (typeof b != "string" || ((b = b.trim().replace(/^[?#&]/, "")), !b))
      return k;
    for (const N of b.split("&")) {
      let [O, F] = n(w.decode ? N.replace(/\+/g, " ") : N, "=");
      (F =
        F === void 0
          ? null
          : ["comma", "separator"].includes(w.arrayFormat)
          ? F
          : u(F, w)),
        S(u(O, w), F, k);
    }
    for (const N of Object.keys(k)) {
      const O = k[N];
      if (typeof O == "object" && O !== null)
        for (const F of Object.keys(O)) O[F] = A(O[F], w);
      else k[N] = A(O, w);
    }
    return w.sort === !1
      ? k
      : (w.sort === !0
          ? Object.keys(k).sort()
          : Object.keys(k).sort(w.sort)
        ).reduce((N, O) => {
          const F = k[O];
          return (
            F && typeof F == "object" && !Array.isArray(F)
              ? (N[O] = d(F))
              : (N[O] = F),
            N
          );
        }, Object.create(null));
  }
  (t.extract = E),
    (t.parse = I),
    (t.stringify = (b, w) => {
      if (!b) return "";
      (w = Object.assign(
        {
          encode: !0,
          strict: !0,
          arrayFormat: "none",
          arrayFormatSeparator: ",",
        },
        w
      )),
        o(w.arrayFormatSeparator);
      const S = (F) =>
          (w.skipNull && i(b[F])) || (w.skipEmptyString && b[F] === ""),
        k = a(w),
        N = {};
      for (const F of Object.keys(b)) S(F) || (N[F] = b[F]);
      const O = Object.keys(N);
      return (
        w.sort !== !1 && O.sort(w.sort),
        O.map((F) => {
          const V = b[F];
          return V === void 0
            ? ""
            : V === null
            ? c(F, w)
            : Array.isArray(V)
            ? V.reduce(k(F), []).join("&")
            : c(F, w) + "=" + c(V, w);
        })
          .filter((F) => F.length > 0)
          .join("&")
      );
    }),
    (t.parseUrl = (b, w) => {
      w = Object.assign(
        {
          decode: !0,
        },
        w
      );
      const [S, k] = n(b, "#");
      return Object.assign(
        {
          url: S.split("?")[0] || "",
          query: I(E(b), w),
        },
        w && w.parseFragmentIdentifier && k
          ? {
              fragmentIdentifier: u(k, w),
            }
          : {}
      );
    }),
    (t.stringifyUrl = (b, w) => {
      w = Object.assign(
        {
          encode: !0,
          strict: !0,
        },
        w
      );
      const S = m(b.url).split("?")[0] || "",
        k = t.extract(b.url),
        N = t.parse(k, {
          sort: !1,
        }),
        O = Object.assign(N, b.query);
      let F = t.stringify(O, w);
      F && (F = `?${F}`);
      let V = v(b.url);
      return (
        b.fragmentIdentifier && (V = `#${c(b.fragmentIdentifier, w)}`),
        `${S}${F}${V}`
      );
    });
})(D_e);
var Dj = {
  exports: {},
};
(function (t) {
  var e = Object.prototype.hasOwnProperty,
    r = "~";
  function n() {}
  Object.create &&
    ((n.prototype = Object.create(null)), new n().__proto__ || (r = !1));
  function i(c, u, d) {
    (this.fn = c), (this.context = u), (this.once = d || !1);
  }
  function a(c, u, d, m, v) {
    if (typeof d != "function")
      throw new TypeError("The listener must be a function");
    var E = new i(d, m || c, v),
      A = r ? r + u : u;
    return (
      c._events[A]
        ? c._events[A].fn
          ? (c._events[A] = [c._events[A], E])
          : c._events[A].push(E)
        : ((c._events[A] = E), c._eventsCount++),
      c
    );
  }
  function s(c, u) {
    --c._eventsCount === 0 ? (c._events = new n()) : delete c._events[u];
  }
  function o() {
    (this._events = new n()), (this._eventsCount = 0);
  }
  (o.prototype.eventNames = function () {
    var u = [],
      d,
      m;
    if (this._eventsCount === 0) return u;
    for (m in (d = this._events)) e.call(d, m) && u.push(r ? m.slice(1) : m);
    return Object.getOwnPropertySymbols
      ? u.concat(Object.getOwnPropertySymbols(d))
      : u;
  }),
    (o.prototype.listeners = function (u) {
      var d = r ? r + u : u,
        m = this._events[d];
      if (!m) return [];
      if (m.fn) return [m.fn];
      for (var v = 0, E = m.length, A = new Array(E); v < E; v++)
        A[v] = m[v].fn;
      return A;
    }),
    (o.prototype.listenerCount = function (u) {
      var d = r ? r + u : u,
        m = this._events[d];
      return m ? (m.fn ? 1 : m.length) : 0;
    }),
    (o.prototype.emit = function (u, d, m, v, E, A) {
      var I = r ? r + u : u;
      if (!this._events[I]) return !1;
      var b = this._events[I],
        w = arguments.length,
        S,
        k;
      if (b.fn) {
        switch ((b.once && this.removeListener(u, b.fn, void 0, !0), w)) {
          case 1:
            return b.fn.call(b.context), !0;
          case 2:
            return b.fn.call(b.context, d), !0;
          case 3:
            return b.fn.call(b.context, d, m), !0;
          case 4:
            return b.fn.call(b.context, d, m, v), !0;
          case 5:
            return b.fn.call(b.context, d, m, v, E), !0;
          case 6:
            return b.fn.call(b.context, d, m, v, E, A), !0;
        }
        for (k = 1, S = new Array(w - 1); k < w; k++) S[k - 1] = arguments[k];
        b.fn.apply(b.context, S);
      } else {
        var N = b.length,
          O;
        for (k = 0; k < N; k++)
          switch (
            (b[k].once && this.removeListener(u, b[k].fn, void 0, !0), w)
          ) {
            case 1:
              b[k].fn.call(b[k].context);
              break;
            case 2:
              b[k].fn.call(b[k].context, d);
              break;
            case 3:
              b[k].fn.call(b[k].context, d, m);
              break;
            case 4:
              b[k].fn.call(b[k].context, d, m, v);
              break;
            default:
              if (!S)
                for (O = 1, S = new Array(w - 1); O < w; O++)
                  S[O - 1] = arguments[O];
              b[k].fn.apply(b[k].context, S);
          }
      }
      return !0;
    }),
    (o.prototype.on = function (u, d, m) {
      return a(this, u, d, m, !1);
    }),
    (o.prototype.once = function (u, d, m) {
      return a(this, u, d, m, !0);
    }),
    (o.prototype.removeListener = function (u, d, m, v) {
      var E = r ? r + u : u;
      if (!this._events[E]) return this;
      if (!d) return s(this, E), this;
      var A = this._events[E];
      if (A.fn)
        A.fn === d && (!v || A.once) && (!m || A.context === m) && s(this, E);
      else {
        for (var I = 0, b = [], w = A.length; I < w; I++)
          (A[I].fn !== d || (v && !A[I].once) || (m && A[I].context !== m)) &&
            b.push(A[I]);
        b.length ? (this._events[E] = b.length === 1 ? b[0] : b) : s(this, E);
      }
      return this;
    }),
    (o.prototype.removeAllListeners = function (u) {
      var d;
      return (
        u
          ? ((d = r ? r + u : u), this._events[d] && s(this, d))
          : ((this._events = new n()), (this._eventsCount = 0)),
        this
      );
    }),
    (o.prototype.off = o.prototype.removeListener),
    (o.prototype.addListener = o.prototype.on),
    (o.prefixed = r),
    (o.EventEmitter = o),
    (t.exports = o);
})(Dj);
var O_e = Dj.exports;
const F_e = mn(O_e),
  L_e = [
    "session_request",
    "session_update",
    "exchange_key",
    "connect",
    "disconnect",
    "display_uri",
    "modal_closed",
    "transport_open",
    "transport_close",
    "transport_error",
  ],
  Oj = [
    "eth_sendTransaction",
    "eth_signTransaction",
    "eth_sign",
    "eth_signTypedData",
    "eth_signTypedData_v1",
    "eth_signTypedData_v2",
    "eth_signTypedData_v3",
    "eth_signTypedData_v4",
    "personal_sign",
    "wallet_addEthereumChain",
    "wallet_switchEthereumChain",
    "wallet_getPermissions",
    "wallet_requestPermissions",
    "wallet_registerOnboarding",
    "wallet_watchAsset",
    "wallet_scanQRCode",
  ];
var JT = {
  exports: {},
};
JT.exports;
(function (t) {
  (function (e, r) {
    function n(C, l) {
      if (!C) throw new Error(l || "Assertion failed");
    }
    function i(C, l) {
      C.super_ = l;
      var p = function () {};
      (p.prototype = l.prototype),
        (C.prototype = new p()),
        (C.prototype.constructor = C);
    }
    function a(C, l, p) {
      if (a.isBN(C)) return C;
      (this.negative = 0),
        (this.words = null),
        (this.length = 0),
        (this.red = null),
        C !== null &&
          ((l === "le" || l === "be") && ((p = l), (l = 10)),
          this._init(C || 0, l || 10, p || "be"));
    }
    typeof e == "object" ? (e.exports = a) : (r.BN = a),
      (a.BN = a),
      (a.wordSize = 26);
    var s;
    try {
      s = Pu.Buffer;
    } catch {}
    (a.isBN = function (l) {
      return l instanceof a
        ? !0
        : l !== null &&
            typeof l == "object" &&
            l.constructor.wordSize === a.wordSize &&
            Array.isArray(l.words);
    }),
      (a.max = function (l, p) {
        return l.cmp(p) > 0 ? l : p;
      }),
      (a.min = function (l, p) {
        return l.cmp(p) < 0 ? l : p;
      }),
      (a.prototype._init = function (l, p, y) {
        if (typeof l == "number") return this._initNumber(l, p, y);
        if (typeof l == "object") return this._initArray(l, p, y);
        p === "hex" && (p = 16),
          n(p === (p | 0) && p >= 2 && p <= 36),
          (l = l.toString().replace(/\s+/g, ""));
        var h = 0;
        l[0] === "-" && h++,
          p === 16 ? this._parseHex(l, h) : this._parseBase(l, p, h),
          l[0] === "-" && (this.negative = 1),
          this.strip(),
          y === "le" && this._initArray(this.toArray(), p, y);
      }),
      (a.prototype._initNumber = function (l, p, y) {
        l < 0 && ((this.negative = 1), (l = -l)),
          l < 67108864
            ? ((this.words = [l & 67108863]), (this.length = 1))
            : l < 4503599627370496
            ? ((this.words = [l & 67108863, (l / 67108864) & 67108863]),
              (this.length = 2))
            : (n(l < 9007199254740992),
              (this.words = [l & 67108863, (l / 67108864) & 67108863, 1]),
              (this.length = 3)),
          y === "le" && this._initArray(this.toArray(), p, y);
      }),
      (a.prototype._initArray = function (l, p, y) {
        if ((n(typeof l.length == "number"), l.length <= 0))
          return (this.words = [0]), (this.length = 1), this;
        (this.length = Math.ceil(l.length / 3)),
          (this.words = new Array(this.length));
        for (var h = 0; h < this.length; h++) this.words[h] = 0;
        var g,
          T,
          R = 0;
        if (y === "be")
          for (h = l.length - 1, g = 0; h >= 0; h -= 3)
            (T = l[h] | (l[h - 1] << 8) | (l[h - 2] << 16)),
              (this.words[g] |= (T << R) & 67108863),
              (this.words[g + 1] = (T >>> (26 - R)) & 67108863),
              (R += 24),
              R >= 26 && ((R -= 26), g++);
        else if (y === "le")
          for (h = 0, g = 0; h < l.length; h += 3)
            (T = l[h] | (l[h + 1] << 8) | (l[h + 2] << 16)),
              (this.words[g] |= (T << R) & 67108863),
              (this.words[g + 1] = (T >>> (26 - R)) & 67108863),
              (R += 24),
              R >= 26 && ((R -= 26), g++);
        return this.strip();
      });
    function o(C, l, p) {
      for (var y = 0, h = Math.min(C.length, p), g = l; g < h; g++) {
        var T = C.charCodeAt(g) - 48;
        (y <<= 4),
          T >= 49 && T <= 54
            ? (y |= T - 49 + 10)
            : T >= 17 && T <= 22
            ? (y |= T - 17 + 10)
            : (y |= T & 15);
      }
      return y;
    }
    a.prototype._parseHex = function (l, p) {
      (this.length = Math.ceil((l.length - p) / 6)),
        (this.words = new Array(this.length));
      for (var y = 0; y < this.length; y++) this.words[y] = 0;
      var h,
        g,
        T = 0;
      for (y = l.length - 6, h = 0; y >= p; y -= 6)
        (g = o(l, y, y + 6)),
          (this.words[h] |= (g << T) & 67108863),
          (this.words[h + 1] |= (g >>> (26 - T)) & 4194303),
          (T += 24),
          T >= 26 && ((T -= 26), h++);
      y + 6 !== p &&
        ((g = o(l, p, y + 6)),
        (this.words[h] |= (g << T) & 67108863),
        (this.words[h + 1] |= (g >>> (26 - T)) & 4194303)),
        this.strip();
    };
    function c(C, l, p, y) {
      for (var h = 0, g = Math.min(C.length, p), T = l; T < g; T++) {
        var R = C.charCodeAt(T) - 48;
        (h *= y),
          R >= 49
            ? (h += R - 49 + 10)
            : R >= 17
            ? (h += R - 17 + 10)
            : (h += R);
      }
      return h;
    }
    (a.prototype._parseBase = function (l, p, y) {
      (this.words = [0]), (this.length = 1);
      for (var h = 0, g = 1; g <= 67108863; g *= p) h++;
      h--, (g = (g / p) | 0);
      for (
        var T = l.length - y,
          R = T % h,
          x = Math.min(T, T - R) + y,
          f = 0,
          _ = y;
        _ < x;
        _ += h
      )
        (f = c(l, _, _ + h, p)),
          this.imuln(g),
          this.words[0] + f < 67108864 ? (this.words[0] += f) : this._iaddn(f);
      if (R !== 0) {
        var P = 1;
        for (f = c(l, _, l.length, p), _ = 0; _ < R; _++) P *= p;
        this.imuln(P),
          this.words[0] + f < 67108864 ? (this.words[0] += f) : this._iaddn(f);
      }
    }),
      (a.prototype.copy = function (l) {
        l.words = new Array(this.length);
        for (var p = 0; p < this.length; p++) l.words[p] = this.words[p];
        (l.length = this.length),
          (l.negative = this.negative),
          (l.red = this.red);
      }),
      (a.prototype.clone = function () {
        var l = new a(null);
        return this.copy(l), l;
      }),
      (a.prototype._expand = function (l) {
        for (; this.length < l; ) this.words[this.length++] = 0;
        return this;
      }),
      (a.prototype.strip = function () {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }),
      (a.prototype._normSign = function () {
        return (
          this.length === 1 && this.words[0] === 0 && (this.negative = 0), this
        );
      }),
      (a.prototype.inspect = function () {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      });
    var u = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000",
      ],
      d = [
        0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
      ],
      m = [
        0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607,
        16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536,
        11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101,
        5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368,
        20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875,
        60466176,
      ];
    (a.prototype.toString = function (l, p) {
      (l = l || 10), (p = p | 0 || 1);
      var y;
      if (l === 16 || l === "hex") {
        y = "";
        for (var h = 0, g = 0, T = 0; T < this.length; T++) {
          var R = this.words[T],
            x = (((R << h) | g) & 16777215).toString(16);
          (g = (R >>> (24 - h)) & 16777215),
            g !== 0 || T !== this.length - 1
              ? (y = u[6 - x.length] + x + y)
              : (y = x + y),
            (h += 2),
            h >= 26 && ((h -= 26), T--);
        }
        for (g !== 0 && (y = g.toString(16) + y); y.length % p !== 0; )
          y = "0" + y;
        return this.negative !== 0 && (y = "-" + y), y;
      }
      if (l === (l | 0) && l >= 2 && l <= 36) {
        var f = d[l],
          _ = m[l];
        y = "";
        var P = this.clone();
        for (P.negative = 0; !P.isZero(); ) {
          var M = P.modn(_).toString(l);
          (P = P.idivn(_)),
            P.isZero() ? (y = M + y) : (y = u[f - M.length] + M + y);
        }
        for (this.isZero() && (y = "0" + y); y.length % p !== 0; ) y = "0" + y;
        return this.negative !== 0 && (y = "-" + y), y;
      }
      n(!1, "Base should be between 2 and 36");
    }),
      (a.prototype.toNumber = function () {
        var l = this.words[0];
        return (
          this.length === 2
            ? (l += this.words[1] * 67108864)
            : this.length === 3 && this.words[2] === 1
            ? (l += 4503599627370496 + this.words[1] * 67108864)
            : this.length > 2 &&
              n(!1, "Number can only safely store up to 53 bits"),
          this.negative !== 0 ? -l : l
        );
      }),
      (a.prototype.toJSON = function () {
        return this.toString(16);
      }),
      (a.prototype.toBuffer = function (l, p) {
        return n(typeof s < "u"), this.toArrayLike(s, l, p);
      }),
      (a.prototype.toArray = function (l, p) {
        return this.toArrayLike(Array, l, p);
      }),
      (a.prototype.toArrayLike = function (l, p, y) {
        var h = this.byteLength(),
          g = y || Math.max(1, h);
        n(h <= g, "byte array longer than desired length"),
          n(g > 0, "Requested array length <= 0"),
          this.strip();
        var T = p === "le",
          R = new l(g),
          x,
          f,
          _ = this.clone();
        if (T) {
          for (f = 0; !_.isZero(); f++)
            (x = _.andln(255)), _.iushrn(8), (R[f] = x);
          for (; f < g; f++) R[f] = 0;
        } else {
          for (f = 0; f < g - h; f++) R[f] = 0;
          for (f = 0; !_.isZero(); f++)
            (x = _.andln(255)), _.iushrn(8), (R[g - f - 1] = x);
        }
        return R;
      }),
      Math.clz32
        ? (a.prototype._countBits = function (l) {
            return 32 - Math.clz32(l);
          })
        : (a.prototype._countBits = function (l) {
            var p = l,
              y = 0;
            return (
              p >= 4096 && ((y += 13), (p >>>= 13)),
              p >= 64 && ((y += 7), (p >>>= 7)),
              p >= 8 && ((y += 4), (p >>>= 4)),
              p >= 2 && ((y += 2), (p >>>= 2)),
              y + p
            );
          }),
      (a.prototype._zeroBits = function (l) {
        if (l === 0) return 26;
        var p = l,
          y = 0;
        return (
          p & 8191 || ((y += 13), (p >>>= 13)),
          p & 127 || ((y += 7), (p >>>= 7)),
          p & 15 || ((y += 4), (p >>>= 4)),
          p & 3 || ((y += 2), (p >>>= 2)),
          p & 1 || y++,
          y
        );
      }),
      (a.prototype.bitLength = function () {
        var l = this.words[this.length - 1],
          p = this._countBits(l);
        return (this.length - 1) * 26 + p;
      });
    function v(C) {
      for (var l = new Array(C.bitLength()), p = 0; p < l.length; p++) {
        var y = (p / 26) | 0,
          h = p % 26;
        l[p] = (C.words[y] & (1 << h)) >>> h;
      }
      return l;
    }
    (a.prototype.zeroBits = function () {
      if (this.isZero()) return 0;
      for (var l = 0, p = 0; p < this.length; p++) {
        var y = this._zeroBits(this.words[p]);
        if (((l += y), y !== 26)) break;
      }
      return l;
    }),
      (a.prototype.byteLength = function () {
        return Math.ceil(this.bitLength() / 8);
      }),
      (a.prototype.toTwos = function (l) {
        return this.negative !== 0
          ? this.abs().inotn(l).iaddn(1)
          : this.clone();
      }),
      (a.prototype.fromTwos = function (l) {
        return this.testn(l - 1) ? this.notn(l).iaddn(1).ineg() : this.clone();
      }),
      (a.prototype.isNeg = function () {
        return this.negative !== 0;
      }),
      (a.prototype.neg = function () {
        return this.clone().ineg();
      }),
      (a.prototype.ineg = function () {
        return this.isZero() || (this.negative ^= 1), this;
      }),
      (a.prototype.iuor = function (l) {
        for (; this.length < l.length; ) this.words[this.length++] = 0;
        for (var p = 0; p < l.length; p++)
          this.words[p] = this.words[p] | l.words[p];
        return this.strip();
      }),
      (a.prototype.ior = function (l) {
        return n((this.negative | l.negative) === 0), this.iuor(l);
      }),
      (a.prototype.or = function (l) {
        return this.length > l.length
          ? this.clone().ior(l)
          : l.clone().ior(this);
      }),
      (a.prototype.uor = function (l) {
        return this.length > l.length
          ? this.clone().iuor(l)
          : l.clone().iuor(this);
      }),
      (a.prototype.iuand = function (l) {
        var p;
        this.length > l.length ? (p = l) : (p = this);
        for (var y = 0; y < p.length; y++)
          this.words[y] = this.words[y] & l.words[y];
        return (this.length = p.length), this.strip();
      }),
      (a.prototype.iand = function (l) {
        return n((this.negative | l.negative) === 0), this.iuand(l);
      }),
      (a.prototype.and = function (l) {
        return this.length > l.length
          ? this.clone().iand(l)
          : l.clone().iand(this);
      }),
      (a.prototype.uand = function (l) {
        return this.length > l.length
          ? this.clone().iuand(l)
          : l.clone().iuand(this);
      }),
      (a.prototype.iuxor = function (l) {
        var p, y;
        this.length > l.length ? ((p = this), (y = l)) : ((p = l), (y = this));
        for (var h = 0; h < y.length; h++)
          this.words[h] = p.words[h] ^ y.words[h];
        if (this !== p) for (; h < p.length; h++) this.words[h] = p.words[h];
        return (this.length = p.length), this.strip();
      }),
      (a.prototype.ixor = function (l) {
        return n((this.negative | l.negative) === 0), this.iuxor(l);
      }),
      (a.prototype.xor = function (l) {
        return this.length > l.length
          ? this.clone().ixor(l)
          : l.clone().ixor(this);
      }),
      (a.prototype.uxor = function (l) {
        return this.length > l.length
          ? this.clone().iuxor(l)
          : l.clone().iuxor(this);
      }),
      (a.prototype.inotn = function (l) {
        n(typeof l == "number" && l >= 0);
        var p = Math.ceil(l / 26) | 0,
          y = l % 26;
        this._expand(p), y > 0 && p--;
        for (var h = 0; h < p; h++) this.words[h] = ~this.words[h] & 67108863;
        return (
          y > 0 && (this.words[h] = ~this.words[h] & (67108863 >> (26 - y))),
          this.strip()
        );
      }),
      (a.prototype.notn = function (l) {
        return this.clone().inotn(l);
      }),
      (a.prototype.setn = function (l, p) {
        n(typeof l == "number" && l >= 0);
        var y = (l / 26) | 0,
          h = l % 26;
        return (
          this._expand(y + 1),
          p
            ? (this.words[y] = this.words[y] | (1 << h))
            : (this.words[y] = this.words[y] & ~(1 << h)),
          this.strip()
        );
      }),
      (a.prototype.iadd = function (l) {
        var p;
        if (this.negative !== 0 && l.negative === 0)
          return (
            (this.negative = 0),
            (p = this.isub(l)),
            (this.negative ^= 1),
            this._normSign()
          );
        if (this.negative === 0 && l.negative !== 0)
          return (
            (l.negative = 0),
            (p = this.isub(l)),
            (l.negative = 1),
            p._normSign()
          );
        var y, h;
        this.length > l.length ? ((y = this), (h = l)) : ((y = l), (h = this));
        for (var g = 0, T = 0; T < h.length; T++)
          (p = (y.words[T] | 0) + (h.words[T] | 0) + g),
            (this.words[T] = p & 67108863),
            (g = p >>> 26);
        for (; g !== 0 && T < y.length; T++)
          (p = (y.words[T] | 0) + g),
            (this.words[T] = p & 67108863),
            (g = p >>> 26);
        if (((this.length = y.length), g !== 0))
          (this.words[this.length] = g), this.length++;
        else if (y !== this)
          for (; T < y.length; T++) this.words[T] = y.words[T];
        return this;
      }),
      (a.prototype.add = function (l) {
        var p;
        return l.negative !== 0 && this.negative === 0
          ? ((l.negative = 0), (p = this.sub(l)), (l.negative ^= 1), p)
          : l.negative === 0 && this.negative !== 0
          ? ((this.negative = 0), (p = l.sub(this)), (this.negative = 1), p)
          : this.length > l.length
          ? this.clone().iadd(l)
          : l.clone().iadd(this);
      }),
      (a.prototype.isub = function (l) {
        if (l.negative !== 0) {
          l.negative = 0;
          var p = this.iadd(l);
          return (l.negative = 1), p._normSign();
        } else if (this.negative !== 0)
          return (
            (this.negative = 0),
            this.iadd(l),
            (this.negative = 1),
            this._normSign()
          );
        var y = this.cmp(l);
        if (y === 0)
          return (
            (this.negative = 0), (this.length = 1), (this.words[0] = 0), this
          );
        var h, g;
        y > 0 ? ((h = this), (g = l)) : ((h = l), (g = this));
        for (var T = 0, R = 0; R < g.length; R++)
          (p = (h.words[R] | 0) - (g.words[R] | 0) + T),
            (T = p >> 26),
            (this.words[R] = p & 67108863);
        for (; T !== 0 && R < h.length; R++)
          (p = (h.words[R] | 0) + T),
            (T = p >> 26),
            (this.words[R] = p & 67108863);
        if (T === 0 && R < h.length && h !== this)
          for (; R < h.length; R++) this.words[R] = h.words[R];
        return (
          (this.length = Math.max(this.length, R)),
          h !== this && (this.negative = 1),
          this.strip()
        );
      }),
      (a.prototype.sub = function (l) {
        return this.clone().isub(l);
      });
    function E(C, l, p) {
      p.negative = l.negative ^ C.negative;
      var y = (C.length + l.length) | 0;
      (p.length = y), (y = (y - 1) | 0);
      var h = C.words[0] | 0,
        g = l.words[0] | 0,
        T = h * g,
        R = T & 67108863,
        x = (T / 67108864) | 0;
      p.words[0] = R;
      for (var f = 1; f < y; f++) {
        for (
          var _ = x >>> 26,
            P = x & 67108863,
            M = Math.min(f, l.length - 1),
            D = Math.max(0, f - C.length + 1);
          D <= M;
          D++
        ) {
          var q = (f - D) | 0;
          (h = C.words[q] | 0),
            (g = l.words[D] | 0),
            (T = h * g + P),
            (_ += (T / 67108864) | 0),
            (P = T & 67108863);
        }
        (p.words[f] = P | 0), (x = _ | 0);
      }
      return x !== 0 ? (p.words[f] = x | 0) : p.length--, p.strip();
    }
    var A = function (l, p, y) {
      var h = l.words,
        g = p.words,
        T = y.words,
        R = 0,
        x,
        f,
        _,
        P = h[0] | 0,
        M = P & 8191,
        D = P >>> 13,
        q = h[1] | 0,
        B = q & 8191,
        H = q >>> 13,
        Q = h[2] | 0,
        Z = Q & 8191,
        te = Q >>> 13,
        Te = h[3] | 0,
        K = Te & 8191,
        G = Te >>> 13,
        he = h[4] | 0,
        se = he & 8191,
        pe = he >>> 13,
        Y = h[5] | 0,
        $ = Y & 8191,
        W = Y >>> 13,
        re = h[6] | 0,
        ee = re & 8191,
        ce = re >>> 13,
        Ce = h[7] | 0,
        me = Ce & 8191,
        ge = Ce >>> 13,
        it = h[8] | 0,
        ve = it & 8191,
        z = it >>> 13,
        U = h[9] | 0,
        L = U & 8191,
        J = U >>> 13,
        fe = g[0] | 0,
        ie = fe & 8191,
        le = fe >>> 13,
        nt = g[1] | 0,
        Ee = nt & 8191,
        we = nt >>> 13,
        ft = g[2] | 0,
        xe = ft & 8191,
        Pe = ft >>> 13,
        hr = g[3] | 0,
        Ne = hr & 8191,
        Me = hr >>> 13,
        _r = g[4] | 0,
        Be = _r & 8191,
        De = _r >>> 13,
        pr = g[5] | 0,
        Oe = pr & 8191,
        Fe = pr >>> 13,
        mr = g[6] | 0,
        Le = mr & 8191,
        Ie = mr >>> 13,
        At = g[7] | 0,
        Ae = At & 8191,
        Re = At >>> 13,
        Er = g[8] | 0,
        $e = Er & 8191,
        Ue = Er >>> 13,
        Mr = g[9] | 0,
        We = Mr & 8191,
        je = Mr >>> 13;
      (y.negative = l.negative ^ p.negative),
        (y.length = 19),
        (x = Math.imul(M, ie)),
        (f = Math.imul(M, le)),
        (f = (f + Math.imul(D, ie)) | 0),
        (_ = Math.imul(D, le));
      var ur = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (ur >>> 26)) | 0),
        (ur &= 67108863),
        (x = Math.imul(B, ie)),
        (f = Math.imul(B, le)),
        (f = (f + Math.imul(H, ie)) | 0),
        (_ = Math.imul(H, le)),
        (x = (x + Math.imul(M, Ee)) | 0),
        (f = (f + Math.imul(M, we)) | 0),
        (f = (f + Math.imul(D, Ee)) | 0),
        (_ = (_ + Math.imul(D, we)) | 0);
      var mt = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (mt >>> 26)) | 0),
        (mt &= 67108863),
        (x = Math.imul(Z, ie)),
        (f = Math.imul(Z, le)),
        (f = (f + Math.imul(te, ie)) | 0),
        (_ = Math.imul(te, le)),
        (x = (x + Math.imul(B, Ee)) | 0),
        (f = (f + Math.imul(B, we)) | 0),
        (f = (f + Math.imul(H, Ee)) | 0),
        (_ = (_ + Math.imul(H, we)) | 0),
        (x = (x + Math.imul(M, xe)) | 0),
        (f = (f + Math.imul(M, Pe)) | 0),
        (f = (f + Math.imul(D, xe)) | 0),
        (_ = (_ + Math.imul(D, Pe)) | 0);
      var yt = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (yt >>> 26)) | 0),
        (yt &= 67108863),
        (x = Math.imul(K, ie)),
        (f = Math.imul(K, le)),
        (f = (f + Math.imul(G, ie)) | 0),
        (_ = Math.imul(G, le)),
        (x = (x + Math.imul(Z, Ee)) | 0),
        (f = (f + Math.imul(Z, we)) | 0),
        (f = (f + Math.imul(te, Ee)) | 0),
        (_ = (_ + Math.imul(te, we)) | 0),
        (x = (x + Math.imul(B, xe)) | 0),
        (f = (f + Math.imul(B, Pe)) | 0),
        (f = (f + Math.imul(H, xe)) | 0),
        (_ = (_ + Math.imul(H, Pe)) | 0),
        (x = (x + Math.imul(M, Ne)) | 0),
        (f = (f + Math.imul(M, Me)) | 0),
        (f = (f + Math.imul(D, Ne)) | 0),
        (_ = (_ + Math.imul(D, Me)) | 0);
      var rr = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (rr >>> 26)) | 0),
        (rr &= 67108863),
        (x = Math.imul(se, ie)),
        (f = Math.imul(se, le)),
        (f = (f + Math.imul(pe, ie)) | 0),
        (_ = Math.imul(pe, le)),
        (x = (x + Math.imul(K, Ee)) | 0),
        (f = (f + Math.imul(K, we)) | 0),
        (f = (f + Math.imul(G, Ee)) | 0),
        (_ = (_ + Math.imul(G, we)) | 0),
        (x = (x + Math.imul(Z, xe)) | 0),
        (f = (f + Math.imul(Z, Pe)) | 0),
        (f = (f + Math.imul(te, xe)) | 0),
        (_ = (_ + Math.imul(te, Pe)) | 0),
        (x = (x + Math.imul(B, Ne)) | 0),
        (f = (f + Math.imul(B, Me)) | 0),
        (f = (f + Math.imul(H, Ne)) | 0),
        (_ = (_ + Math.imul(H, Me)) | 0),
        (x = (x + Math.imul(M, Be)) | 0),
        (f = (f + Math.imul(M, De)) | 0),
        (f = (f + Math.imul(D, Be)) | 0),
        (_ = (_ + Math.imul(D, De)) | 0);
      var nr = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (nr >>> 26)) | 0),
        (nr &= 67108863),
        (x = Math.imul($, ie)),
        (f = Math.imul($, le)),
        (f = (f + Math.imul(W, ie)) | 0),
        (_ = Math.imul(W, le)),
        (x = (x + Math.imul(se, Ee)) | 0),
        (f = (f + Math.imul(se, we)) | 0),
        (f = (f + Math.imul(pe, Ee)) | 0),
        (_ = (_ + Math.imul(pe, we)) | 0),
        (x = (x + Math.imul(K, xe)) | 0),
        (f = (f + Math.imul(K, Pe)) | 0),
        (f = (f + Math.imul(G, xe)) | 0),
        (_ = (_ + Math.imul(G, Pe)) | 0),
        (x = (x + Math.imul(Z, Ne)) | 0),
        (f = (f + Math.imul(Z, Me)) | 0),
        (f = (f + Math.imul(te, Ne)) | 0),
        (_ = (_ + Math.imul(te, Me)) | 0),
        (x = (x + Math.imul(B, Be)) | 0),
        (f = (f + Math.imul(B, De)) | 0),
        (f = (f + Math.imul(H, Be)) | 0),
        (_ = (_ + Math.imul(H, De)) | 0),
        (x = (x + Math.imul(M, Oe)) | 0),
        (f = (f + Math.imul(M, Fe)) | 0),
        (f = (f + Math.imul(D, Oe)) | 0),
        (_ = (_ + Math.imul(D, Fe)) | 0);
      var ir = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (ir >>> 26)) | 0),
        (ir &= 67108863),
        (x = Math.imul(ee, ie)),
        (f = Math.imul(ee, le)),
        (f = (f + Math.imul(ce, ie)) | 0),
        (_ = Math.imul(ce, le)),
        (x = (x + Math.imul($, Ee)) | 0),
        (f = (f + Math.imul($, we)) | 0),
        (f = (f + Math.imul(W, Ee)) | 0),
        (_ = (_ + Math.imul(W, we)) | 0),
        (x = (x + Math.imul(se, xe)) | 0),
        (f = (f + Math.imul(se, Pe)) | 0),
        (f = (f + Math.imul(pe, xe)) | 0),
        (_ = (_ + Math.imul(pe, Pe)) | 0),
        (x = (x + Math.imul(K, Ne)) | 0),
        (f = (f + Math.imul(K, Me)) | 0),
        (f = (f + Math.imul(G, Ne)) | 0),
        (_ = (_ + Math.imul(G, Me)) | 0),
        (x = (x + Math.imul(Z, Be)) | 0),
        (f = (f + Math.imul(Z, De)) | 0),
        (f = (f + Math.imul(te, Be)) | 0),
        (_ = (_ + Math.imul(te, De)) | 0),
        (x = (x + Math.imul(B, Oe)) | 0),
        (f = (f + Math.imul(B, Fe)) | 0),
        (f = (f + Math.imul(H, Oe)) | 0),
        (_ = (_ + Math.imul(H, Fe)) | 0),
        (x = (x + Math.imul(M, Le)) | 0),
        (f = (f + Math.imul(M, Ie)) | 0),
        (f = (f + Math.imul(D, Le)) | 0),
        (_ = (_ + Math.imul(D, Ie)) | 0);
      var ar = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (ar >>> 26)) | 0),
        (ar &= 67108863),
        (x = Math.imul(me, ie)),
        (f = Math.imul(me, le)),
        (f = (f + Math.imul(ge, ie)) | 0),
        (_ = Math.imul(ge, le)),
        (x = (x + Math.imul(ee, Ee)) | 0),
        (f = (f + Math.imul(ee, we)) | 0),
        (f = (f + Math.imul(ce, Ee)) | 0),
        (_ = (_ + Math.imul(ce, we)) | 0),
        (x = (x + Math.imul($, xe)) | 0),
        (f = (f + Math.imul($, Pe)) | 0),
        (f = (f + Math.imul(W, xe)) | 0),
        (_ = (_ + Math.imul(W, Pe)) | 0),
        (x = (x + Math.imul(se, Ne)) | 0),
        (f = (f + Math.imul(se, Me)) | 0),
        (f = (f + Math.imul(pe, Ne)) | 0),
        (_ = (_ + Math.imul(pe, Me)) | 0),
        (x = (x + Math.imul(K, Be)) | 0),
        (f = (f + Math.imul(K, De)) | 0),
        (f = (f + Math.imul(G, Be)) | 0),
        (_ = (_ + Math.imul(G, De)) | 0),
        (x = (x + Math.imul(Z, Oe)) | 0),
        (f = (f + Math.imul(Z, Fe)) | 0),
        (f = (f + Math.imul(te, Oe)) | 0),
        (_ = (_ + Math.imul(te, Fe)) | 0),
        (x = (x + Math.imul(B, Le)) | 0),
        (f = (f + Math.imul(B, Ie)) | 0),
        (f = (f + Math.imul(H, Le)) | 0),
        (_ = (_ + Math.imul(H, Ie)) | 0),
        (x = (x + Math.imul(M, Ae)) | 0),
        (f = (f + Math.imul(M, Re)) | 0),
        (f = (f + Math.imul(D, Ae)) | 0),
        (_ = (_ + Math.imul(D, Re)) | 0);
      var sr = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (sr >>> 26)) | 0),
        (sr &= 67108863),
        (x = Math.imul(ve, ie)),
        (f = Math.imul(ve, le)),
        (f = (f + Math.imul(z, ie)) | 0),
        (_ = Math.imul(z, le)),
        (x = (x + Math.imul(me, Ee)) | 0),
        (f = (f + Math.imul(me, we)) | 0),
        (f = (f + Math.imul(ge, Ee)) | 0),
        (_ = (_ + Math.imul(ge, we)) | 0),
        (x = (x + Math.imul(ee, xe)) | 0),
        (f = (f + Math.imul(ee, Pe)) | 0),
        (f = (f + Math.imul(ce, xe)) | 0),
        (_ = (_ + Math.imul(ce, Pe)) | 0),
        (x = (x + Math.imul($, Ne)) | 0),
        (f = (f + Math.imul($, Me)) | 0),
        (f = (f + Math.imul(W, Ne)) | 0),
        (_ = (_ + Math.imul(W, Me)) | 0),
        (x = (x + Math.imul(se, Be)) | 0),
        (f = (f + Math.imul(se, De)) | 0),
        (f = (f + Math.imul(pe, Be)) | 0),
        (_ = (_ + Math.imul(pe, De)) | 0),
        (x = (x + Math.imul(K, Oe)) | 0),
        (f = (f + Math.imul(K, Fe)) | 0),
        (f = (f + Math.imul(G, Oe)) | 0),
        (_ = (_ + Math.imul(G, Fe)) | 0),
        (x = (x + Math.imul(Z, Le)) | 0),
        (f = (f + Math.imul(Z, Ie)) | 0),
        (f = (f + Math.imul(te, Le)) | 0),
        (_ = (_ + Math.imul(te, Ie)) | 0),
        (x = (x + Math.imul(B, Ae)) | 0),
        (f = (f + Math.imul(B, Re)) | 0),
        (f = (f + Math.imul(H, Ae)) | 0),
        (_ = (_ + Math.imul(H, Re)) | 0),
        (x = (x + Math.imul(M, $e)) | 0),
        (f = (f + Math.imul(M, Ue)) | 0),
        (f = (f + Math.imul(D, $e)) | 0),
        (_ = (_ + Math.imul(D, Ue)) | 0);
      var Ir = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (Ir >>> 26)) | 0),
        (Ir &= 67108863),
        (x = Math.imul(L, ie)),
        (f = Math.imul(L, le)),
        (f = (f + Math.imul(J, ie)) | 0),
        (_ = Math.imul(J, le)),
        (x = (x + Math.imul(ve, Ee)) | 0),
        (f = (f + Math.imul(ve, we)) | 0),
        (f = (f + Math.imul(z, Ee)) | 0),
        (_ = (_ + Math.imul(z, we)) | 0),
        (x = (x + Math.imul(me, xe)) | 0),
        (f = (f + Math.imul(me, Pe)) | 0),
        (f = (f + Math.imul(ge, xe)) | 0),
        (_ = (_ + Math.imul(ge, Pe)) | 0),
        (x = (x + Math.imul(ee, Ne)) | 0),
        (f = (f + Math.imul(ee, Me)) | 0),
        (f = (f + Math.imul(ce, Ne)) | 0),
        (_ = (_ + Math.imul(ce, Me)) | 0),
        (x = (x + Math.imul($, Be)) | 0),
        (f = (f + Math.imul($, De)) | 0),
        (f = (f + Math.imul(W, Be)) | 0),
        (_ = (_ + Math.imul(W, De)) | 0),
        (x = (x + Math.imul(se, Oe)) | 0),
        (f = (f + Math.imul(se, Fe)) | 0),
        (f = (f + Math.imul(pe, Oe)) | 0),
        (_ = (_ + Math.imul(pe, Fe)) | 0),
        (x = (x + Math.imul(K, Le)) | 0),
        (f = (f + Math.imul(K, Ie)) | 0),
        (f = (f + Math.imul(G, Le)) | 0),
        (_ = (_ + Math.imul(G, Ie)) | 0),
        (x = (x + Math.imul(Z, Ae)) | 0),
        (f = (f + Math.imul(Z, Re)) | 0),
        (f = (f + Math.imul(te, Ae)) | 0),
        (_ = (_ + Math.imul(te, Re)) | 0),
        (x = (x + Math.imul(B, $e)) | 0),
        (f = (f + Math.imul(B, Ue)) | 0),
        (f = (f + Math.imul(H, $e)) | 0),
        (_ = (_ + Math.imul(H, Ue)) | 0),
        (x = (x + Math.imul(M, We)) | 0),
        (f = (f + Math.imul(M, je)) | 0),
        (f = (f + Math.imul(D, We)) | 0),
        (_ = (_ + Math.imul(D, je)) | 0);
      var Rr = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (Rr >>> 26)) | 0),
        (Rr &= 67108863),
        (x = Math.imul(L, Ee)),
        (f = Math.imul(L, we)),
        (f = (f + Math.imul(J, Ee)) | 0),
        (_ = Math.imul(J, we)),
        (x = (x + Math.imul(ve, xe)) | 0),
        (f = (f + Math.imul(ve, Pe)) | 0),
        (f = (f + Math.imul(z, xe)) | 0),
        (_ = (_ + Math.imul(z, Pe)) | 0),
        (x = (x + Math.imul(me, Ne)) | 0),
        (f = (f + Math.imul(me, Me)) | 0),
        (f = (f + Math.imul(ge, Ne)) | 0),
        (_ = (_ + Math.imul(ge, Me)) | 0),
        (x = (x + Math.imul(ee, Be)) | 0),
        (f = (f + Math.imul(ee, De)) | 0),
        (f = (f + Math.imul(ce, Be)) | 0),
        (_ = (_ + Math.imul(ce, De)) | 0),
        (x = (x + Math.imul($, Oe)) | 0),
        (f = (f + Math.imul($, Fe)) | 0),
        (f = (f + Math.imul(W, Oe)) | 0),
        (_ = (_ + Math.imul(W, Fe)) | 0),
        (x = (x + Math.imul(se, Le)) | 0),
        (f = (f + Math.imul(se, Ie)) | 0),
        (f = (f + Math.imul(pe, Le)) | 0),
        (_ = (_ + Math.imul(pe, Ie)) | 0),
        (x = (x + Math.imul(K, Ae)) | 0),
        (f = (f + Math.imul(K, Re)) | 0),
        (f = (f + Math.imul(G, Ae)) | 0),
        (_ = (_ + Math.imul(G, Re)) | 0),
        (x = (x + Math.imul(Z, $e)) | 0),
        (f = (f + Math.imul(Z, Ue)) | 0),
        (f = (f + Math.imul(te, $e)) | 0),
        (_ = (_ + Math.imul(te, Ue)) | 0),
        (x = (x + Math.imul(B, We)) | 0),
        (f = (f + Math.imul(B, je)) | 0),
        (f = (f + Math.imul(H, We)) | 0),
        (_ = (_ + Math.imul(H, je)) | 0);
      var Pr = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (Pr >>> 26)) | 0),
        (Pr &= 67108863),
        (x = Math.imul(L, xe)),
        (f = Math.imul(L, Pe)),
        (f = (f + Math.imul(J, xe)) | 0),
        (_ = Math.imul(J, Pe)),
        (x = (x + Math.imul(ve, Ne)) | 0),
        (f = (f + Math.imul(ve, Me)) | 0),
        (f = (f + Math.imul(z, Ne)) | 0),
        (_ = (_ + Math.imul(z, Me)) | 0),
        (x = (x + Math.imul(me, Be)) | 0),
        (f = (f + Math.imul(me, De)) | 0),
        (f = (f + Math.imul(ge, Be)) | 0),
        (_ = (_ + Math.imul(ge, De)) | 0),
        (x = (x + Math.imul(ee, Oe)) | 0),
        (f = (f + Math.imul(ee, Fe)) | 0),
        (f = (f + Math.imul(ce, Oe)) | 0),
        (_ = (_ + Math.imul(ce, Fe)) | 0),
        (x = (x + Math.imul($, Le)) | 0),
        (f = (f + Math.imul($, Ie)) | 0),
        (f = (f + Math.imul(W, Le)) | 0),
        (_ = (_ + Math.imul(W, Ie)) | 0),
        (x = (x + Math.imul(se, Ae)) | 0),
        (f = (f + Math.imul(se, Re)) | 0),
        (f = (f + Math.imul(pe, Ae)) | 0),
        (_ = (_ + Math.imul(pe, Re)) | 0),
        (x = (x + Math.imul(K, $e)) | 0),
        (f = (f + Math.imul(K, Ue)) | 0),
        (f = (f + Math.imul(G, $e)) | 0),
        (_ = (_ + Math.imul(G, Ue)) | 0),
        (x = (x + Math.imul(Z, We)) | 0),
        (f = (f + Math.imul(Z, je)) | 0),
        (f = (f + Math.imul(te, We)) | 0),
        (_ = (_ + Math.imul(te, je)) | 0);
      var Nr = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (Nr >>> 26)) | 0),
        (Nr &= 67108863),
        (x = Math.imul(L, Ne)),
        (f = Math.imul(L, Me)),
        (f = (f + Math.imul(J, Ne)) | 0),
        (_ = Math.imul(J, Me)),
        (x = (x + Math.imul(ve, Be)) | 0),
        (f = (f + Math.imul(ve, De)) | 0),
        (f = (f + Math.imul(z, Be)) | 0),
        (_ = (_ + Math.imul(z, De)) | 0),
        (x = (x + Math.imul(me, Oe)) | 0),
        (f = (f + Math.imul(me, Fe)) | 0),
        (f = (f + Math.imul(ge, Oe)) | 0),
        (_ = (_ + Math.imul(ge, Fe)) | 0),
        (x = (x + Math.imul(ee, Le)) | 0),
        (f = (f + Math.imul(ee, Ie)) | 0),
        (f = (f + Math.imul(ce, Le)) | 0),
        (_ = (_ + Math.imul(ce, Ie)) | 0),
        (x = (x + Math.imul($, Ae)) | 0),
        (f = (f + Math.imul($, Re)) | 0),
        (f = (f + Math.imul(W, Ae)) | 0),
        (_ = (_ + Math.imul(W, Re)) | 0),
        (x = (x + Math.imul(se, $e)) | 0),
        (f = (f + Math.imul(se, Ue)) | 0),
        (f = (f + Math.imul(pe, $e)) | 0),
        (_ = (_ + Math.imul(pe, Ue)) | 0),
        (x = (x + Math.imul(K, We)) | 0),
        (f = (f + Math.imul(K, je)) | 0),
        (f = (f + Math.imul(G, We)) | 0),
        (_ = (_ + Math.imul(G, je)) | 0);
      var Br = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (Br >>> 26)) | 0),
        (Br &= 67108863),
        (x = Math.imul(L, Be)),
        (f = Math.imul(L, De)),
        (f = (f + Math.imul(J, Be)) | 0),
        (_ = Math.imul(J, De)),
        (x = (x + Math.imul(ve, Oe)) | 0),
        (f = (f + Math.imul(ve, Fe)) | 0),
        (f = (f + Math.imul(z, Oe)) | 0),
        (_ = (_ + Math.imul(z, Fe)) | 0),
        (x = (x + Math.imul(me, Le)) | 0),
        (f = (f + Math.imul(me, Ie)) | 0),
        (f = (f + Math.imul(ge, Le)) | 0),
        (_ = (_ + Math.imul(ge, Ie)) | 0),
        (x = (x + Math.imul(ee, Ae)) | 0),
        (f = (f + Math.imul(ee, Re)) | 0),
        (f = (f + Math.imul(ce, Ae)) | 0),
        (_ = (_ + Math.imul(ce, Re)) | 0),
        (x = (x + Math.imul($, $e)) | 0),
        (f = (f + Math.imul($, Ue)) | 0),
        (f = (f + Math.imul(W, $e)) | 0),
        (_ = (_ + Math.imul(W, Ue)) | 0),
        (x = (x + Math.imul(se, We)) | 0),
        (f = (f + Math.imul(se, je)) | 0),
        (f = (f + Math.imul(pe, We)) | 0),
        (_ = (_ + Math.imul(pe, je)) | 0);
      var Dr = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (Dr >>> 26)) | 0),
        (Dr &= 67108863),
        (x = Math.imul(L, Oe)),
        (f = Math.imul(L, Fe)),
        (f = (f + Math.imul(J, Oe)) | 0),
        (_ = Math.imul(J, Fe)),
        (x = (x + Math.imul(ve, Le)) | 0),
        (f = (f + Math.imul(ve, Ie)) | 0),
        (f = (f + Math.imul(z, Le)) | 0),
        (_ = (_ + Math.imul(z, Ie)) | 0),
        (x = (x + Math.imul(me, Ae)) | 0),
        (f = (f + Math.imul(me, Re)) | 0),
        (f = (f + Math.imul(ge, Ae)) | 0),
        (_ = (_ + Math.imul(ge, Re)) | 0),
        (x = (x + Math.imul(ee, $e)) | 0),
        (f = (f + Math.imul(ee, Ue)) | 0),
        (f = (f + Math.imul(ce, $e)) | 0),
        (_ = (_ + Math.imul(ce, Ue)) | 0),
        (x = (x + Math.imul($, We)) | 0),
        (f = (f + Math.imul($, je)) | 0),
        (f = (f + Math.imul(W, We)) | 0),
        (_ = (_ + Math.imul(W, je)) | 0);
      var Or = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (Or >>> 26)) | 0),
        (Or &= 67108863),
        (x = Math.imul(L, Le)),
        (f = Math.imul(L, Ie)),
        (f = (f + Math.imul(J, Le)) | 0),
        (_ = Math.imul(J, Ie)),
        (x = (x + Math.imul(ve, Ae)) | 0),
        (f = (f + Math.imul(ve, Re)) | 0),
        (f = (f + Math.imul(z, Ae)) | 0),
        (_ = (_ + Math.imul(z, Re)) | 0),
        (x = (x + Math.imul(me, $e)) | 0),
        (f = (f + Math.imul(me, Ue)) | 0),
        (f = (f + Math.imul(ge, $e)) | 0),
        (_ = (_ + Math.imul(ge, Ue)) | 0),
        (x = (x + Math.imul(ee, We)) | 0),
        (f = (f + Math.imul(ee, je)) | 0),
        (f = (f + Math.imul(ce, We)) | 0),
        (_ = (_ + Math.imul(ce, je)) | 0);
      var Fr = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (Fr >>> 26)) | 0),
        (Fr &= 67108863),
        (x = Math.imul(L, Ae)),
        (f = Math.imul(L, Re)),
        (f = (f + Math.imul(J, Ae)) | 0),
        (_ = Math.imul(J, Re)),
        (x = (x + Math.imul(ve, $e)) | 0),
        (f = (f + Math.imul(ve, Ue)) | 0),
        (f = (f + Math.imul(z, $e)) | 0),
        (_ = (_ + Math.imul(z, Ue)) | 0),
        (x = (x + Math.imul(me, We)) | 0),
        (f = (f + Math.imul(me, je)) | 0),
        (f = (f + Math.imul(ge, We)) | 0),
        (_ = (_ + Math.imul(ge, je)) | 0);
      var Lr = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (Lr >>> 26)) | 0),
        (Lr &= 67108863),
        (x = Math.imul(L, $e)),
        (f = Math.imul(L, Ue)),
        (f = (f + Math.imul(J, $e)) | 0),
        (_ = Math.imul(J, Ue)),
        (x = (x + Math.imul(ve, We)) | 0),
        (f = (f + Math.imul(ve, je)) | 0),
        (f = (f + Math.imul(z, We)) | 0),
        (_ = (_ + Math.imul(z, je)) | 0);
      var bn = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (bn >>> 26)) | 0),
        (bn &= 67108863),
        (x = Math.imul(L, We)),
        (f = Math.imul(L, je)),
        (f = (f + Math.imul(J, We)) | 0),
        (_ = Math.imul(J, je));
      var vn = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      return (
        (R = (((_ + (f >>> 13)) | 0) + (vn >>> 26)) | 0),
        (vn &= 67108863),
        (T[0] = ur),
        (T[1] = mt),
        (T[2] = yt),
        (T[3] = rr),
        (T[4] = nr),
        (T[5] = ir),
        (T[6] = ar),
        (T[7] = sr),
        (T[8] = Ir),
        (T[9] = Rr),
        (T[10] = Pr),
        (T[11] = Nr),
        (T[12] = Br),
        (T[13] = Dr),
        (T[14] = Or),
        (T[15] = Fr),
        (T[16] = Lr),
        (T[17] = bn),
        (T[18] = vn),
        R !== 0 && ((T[19] = R), y.length++),
        y
      );
    };
    Math.imul || (A = E);
    function I(C, l, p) {
      (p.negative = l.negative ^ C.negative), (p.length = C.length + l.length);
      for (var y = 0, h = 0, g = 0; g < p.length - 1; g++) {
        var T = h;
        h = 0;
        for (
          var R = y & 67108863,
            x = Math.min(g, l.length - 1),
            f = Math.max(0, g - C.length + 1);
          f <= x;
          f++
        ) {
          var _ = g - f,
            P = C.words[_] | 0,
            M = l.words[f] | 0,
            D = P * M,
            q = D & 67108863;
          (T = (T + ((D / 67108864) | 0)) | 0),
            (q = (q + R) | 0),
            (R = q & 67108863),
            (T = (T + (q >>> 26)) | 0),
            (h += T >>> 26),
            (T &= 67108863);
        }
        (p.words[g] = R), (y = T), (T = h);
      }
      return y !== 0 ? (p.words[g] = y) : p.length--, p.strip();
    }
    function b(C, l, p) {
      var y = new w();
      return y.mulp(C, l, p);
    }
    a.prototype.mulTo = function (l, p) {
      var y,
        h = this.length + l.length;
      return (
        this.length === 10 && l.length === 10
          ? (y = A(this, l, p))
          : h < 63
          ? (y = E(this, l, p))
          : h < 1024
          ? (y = I(this, l, p))
          : (y = b(this, l, p)),
        y
      );
    };
    function w(C, l) {
      (this.x = C), (this.y = l);
    }
    (w.prototype.makeRBT = function (l) {
      for (
        var p = new Array(l), y = a.prototype._countBits(l) - 1, h = 0;
        h < l;
        h++
      )
        p[h] = this.revBin(h, y, l);
      return p;
    }),
      (w.prototype.revBin = function (l, p, y) {
        if (l === 0 || l === y - 1) return l;
        for (var h = 0, g = 0; g < p; g++)
          (h |= (l & 1) << (p - g - 1)), (l >>= 1);
        return h;
      }),
      (w.prototype.permute = function (l, p, y, h, g, T) {
        for (var R = 0; R < T; R++) (h[R] = p[l[R]]), (g[R] = y[l[R]]);
      }),
      (w.prototype.transform = function (l, p, y, h, g, T) {
        this.permute(T, l, p, y, h, g);
        for (var R = 1; R < g; R <<= 1)
          for (
            var x = R << 1,
              f = Math.cos((2 * Math.PI) / x),
              _ = Math.sin((2 * Math.PI) / x),
              P = 0;
            P < g;
            P += x
          )
            for (var M = f, D = _, q = 0; q < R; q++) {
              var B = y[P + q],
                H = h[P + q],
                Q = y[P + q + R],
                Z = h[P + q + R],
                te = M * Q - D * Z;
              (Z = M * Z + D * Q),
                (Q = te),
                (y[P + q] = B + Q),
                (h[P + q] = H + Z),
                (y[P + q + R] = B - Q),
                (h[P + q + R] = H - Z),
                q !== x &&
                  ((te = f * M - _ * D), (D = f * D + _ * M), (M = te));
            }
      }),
      (w.prototype.guessLen13b = function (l, p) {
        var y = Math.max(p, l) | 1,
          h = y & 1,
          g = 0;
        for (y = (y / 2) | 0; y; y = y >>> 1) g++;
        return 1 << (g + 1 + h);
      }),
      (w.prototype.conjugate = function (l, p, y) {
        if (!(y <= 1))
          for (var h = 0; h < y / 2; h++) {
            var g = l[h];
            (l[h] = l[y - h - 1]),
              (l[y - h - 1] = g),
              (g = p[h]),
              (p[h] = -p[y - h - 1]),
              (p[y - h - 1] = -g);
          }
      }),
      (w.prototype.normalize13b = function (l, p) {
        for (var y = 0, h = 0; h < p / 2; h++) {
          var g =
            Math.round(l[2 * h + 1] / p) * 8192 + Math.round(l[2 * h] / p) + y;
          (l[h] = g & 67108863),
            g < 67108864 ? (y = 0) : (y = (g / 67108864) | 0);
        }
        return l;
      }),
      (w.prototype.convert13b = function (l, p, y, h) {
        for (var g = 0, T = 0; T < p; T++)
          (g = g + (l[T] | 0)),
            (y[2 * T] = g & 8191),
            (g = g >>> 13),
            (y[2 * T + 1] = g & 8191),
            (g = g >>> 13);
        for (T = 2 * p; T < h; ++T) y[T] = 0;
        n(g === 0), n((g & -8192) === 0);
      }),
      (w.prototype.stub = function (l) {
        for (var p = new Array(l), y = 0; y < l; y++) p[y] = 0;
        return p;
      }),
      (w.prototype.mulp = function (l, p, y) {
        var h = 2 * this.guessLen13b(l.length, p.length),
          g = this.makeRBT(h),
          T = this.stub(h),
          R = new Array(h),
          x = new Array(h),
          f = new Array(h),
          _ = new Array(h),
          P = new Array(h),
          M = new Array(h),
          D = y.words;
        (D.length = h),
          this.convert13b(l.words, l.length, R, h),
          this.convert13b(p.words, p.length, _, h),
          this.transform(R, T, x, f, h, g),
          this.transform(_, T, P, M, h, g);
        for (var q = 0; q < h; q++) {
          var B = x[q] * P[q] - f[q] * M[q];
          (f[q] = x[q] * M[q] + f[q] * P[q]), (x[q] = B);
        }
        return (
          this.conjugate(x, f, h),
          this.transform(x, f, D, T, h, g),
          this.conjugate(D, T, h),
          this.normalize13b(D, h),
          (y.negative = l.negative ^ p.negative),
          (y.length = l.length + p.length),
          y.strip()
        );
      }),
      (a.prototype.mul = function (l) {
        var p = new a(null);
        return (p.words = new Array(this.length + l.length)), this.mulTo(l, p);
      }),
      (a.prototype.mulf = function (l) {
        var p = new a(null);
        return (p.words = new Array(this.length + l.length)), b(this, l, p);
      }),
      (a.prototype.imul = function (l) {
        return this.clone().mulTo(l, this);
      }),
      (a.prototype.imuln = function (l) {
        n(typeof l == "number"), n(l < 67108864);
        for (var p = 0, y = 0; y < this.length; y++) {
          var h = (this.words[y] | 0) * l,
            g = (h & 67108863) + (p & 67108863);
          (p >>= 26),
            (p += (h / 67108864) | 0),
            (p += g >>> 26),
            (this.words[y] = g & 67108863);
        }
        return p !== 0 && ((this.words[y] = p), this.length++), this;
      }),
      (a.prototype.muln = function (l) {
        return this.clone().imuln(l);
      }),
      (a.prototype.sqr = function () {
        return this.mul(this);
      }),
      (a.prototype.isqr = function () {
        return this.imul(this.clone());
      }),
      (a.prototype.pow = function (l) {
        var p = v(l);
        if (p.length === 0) return new a(1);
        for (var y = this, h = 0; h < p.length && p[h] === 0; h++, y = y.sqr());
        if (++h < p.length)
          for (var g = y.sqr(); h < p.length; h++, g = g.sqr())
            p[h] !== 0 && (y = y.mul(g));
        return y;
      }),
      (a.prototype.iushln = function (l) {
        n(typeof l == "number" && l >= 0);
        var p = l % 26,
          y = (l - p) / 26,
          h = (67108863 >>> (26 - p)) << (26 - p),
          g;
        if (p !== 0) {
          var T = 0;
          for (g = 0; g < this.length; g++) {
            var R = this.words[g] & h,
              x = ((this.words[g] | 0) - R) << p;
            (this.words[g] = x | T), (T = R >>> (26 - p));
          }
          T && ((this.words[g] = T), this.length++);
        }
        if (y !== 0) {
          for (g = this.length - 1; g >= 0; g--)
            this.words[g + y] = this.words[g];
          for (g = 0; g < y; g++) this.words[g] = 0;
          this.length += y;
        }
        return this.strip();
      }),
      (a.prototype.ishln = function (l) {
        return n(this.negative === 0), this.iushln(l);
      }),
      (a.prototype.iushrn = function (l, p, y) {
        n(typeof l == "number" && l >= 0);
        var h;
        p ? (h = (p - (p % 26)) / 26) : (h = 0);
        var g = l % 26,
          T = Math.min((l - g) / 26, this.length),
          R = 67108863 ^ ((67108863 >>> g) << g),
          x = y;
        if (((h -= T), (h = Math.max(0, h)), x)) {
          for (var f = 0; f < T; f++) x.words[f] = this.words[f];
          x.length = T;
        }
        if (T !== 0)
          if (this.length > T)
            for (this.length -= T, f = 0; f < this.length; f++)
              this.words[f] = this.words[f + T];
          else (this.words[0] = 0), (this.length = 1);
        var _ = 0;
        for (f = this.length - 1; f >= 0 && (_ !== 0 || f >= h); f--) {
          var P = this.words[f] | 0;
          (this.words[f] = (_ << (26 - g)) | (P >>> g)), (_ = P & R);
        }
        return (
          x && _ !== 0 && (x.words[x.length++] = _),
          this.length === 0 && ((this.words[0] = 0), (this.length = 1)),
          this.strip()
        );
      }),
      (a.prototype.ishrn = function (l, p, y) {
        return n(this.negative === 0), this.iushrn(l, p, y);
      }),
      (a.prototype.shln = function (l) {
        return this.clone().ishln(l);
      }),
      (a.prototype.ushln = function (l) {
        return this.clone().iushln(l);
      }),
      (a.prototype.shrn = function (l) {
        return this.clone().ishrn(l);
      }),
      (a.prototype.ushrn = function (l) {
        return this.clone().iushrn(l);
      }),
      (a.prototype.testn = function (l) {
        n(typeof l == "number" && l >= 0);
        var p = l % 26,
          y = (l - p) / 26,
          h = 1 << p;
        if (this.length <= y) return !1;
        var g = this.words[y];
        return !!(g & h);
      }),
      (a.prototype.imaskn = function (l) {
        n(typeof l == "number" && l >= 0);
        var p = l % 26,
          y = (l - p) / 26;
        if (
          (n(this.negative === 0, "imaskn works only with positive numbers"),
          this.length <= y)
        )
          return this;
        if (
          (p !== 0 && y++, (this.length = Math.min(y, this.length)), p !== 0)
        ) {
          var h = 67108863 ^ ((67108863 >>> p) << p);
          this.words[this.length - 1] &= h;
        }
        return this.strip();
      }),
      (a.prototype.maskn = function (l) {
        return this.clone().imaskn(l);
      }),
      (a.prototype.iaddn = function (l) {
        return (
          n(typeof l == "number"),
          n(l < 67108864),
          l < 0
            ? this.isubn(-l)
            : this.negative !== 0
            ? this.length === 1 && (this.words[0] | 0) < l
              ? ((this.words[0] = l - (this.words[0] | 0)),
                (this.negative = 0),
                this)
              : ((this.negative = 0), this.isubn(l), (this.negative = 1), this)
            : this._iaddn(l)
        );
      }),
      (a.prototype._iaddn = function (l) {
        this.words[0] += l;
        for (var p = 0; p < this.length && this.words[p] >= 67108864; p++)
          (this.words[p] -= 67108864),
            p === this.length - 1
              ? (this.words[p + 1] = 1)
              : this.words[p + 1]++;
        return (this.length = Math.max(this.length, p + 1)), this;
      }),
      (a.prototype.isubn = function (l) {
        if ((n(typeof l == "number"), n(l < 67108864), l < 0))
          return this.iaddn(-l);
        if (this.negative !== 0)
          return (this.negative = 0), this.iaddn(l), (this.negative = 1), this;
        if (((this.words[0] -= l), this.length === 1 && this.words[0] < 0))
          (this.words[0] = -this.words[0]), (this.negative = 1);
        else
          for (var p = 0; p < this.length && this.words[p] < 0; p++)
            (this.words[p] += 67108864), (this.words[p + 1] -= 1);
        return this.strip();
      }),
      (a.prototype.addn = function (l) {
        return this.clone().iaddn(l);
      }),
      (a.prototype.subn = function (l) {
        return this.clone().isubn(l);
      }),
      (a.prototype.iabs = function () {
        return (this.negative = 0), this;
      }),
      (a.prototype.abs = function () {
        return this.clone().iabs();
      }),
      (a.prototype._ishlnsubmul = function (l, p, y) {
        var h = l.length + y,
          g;
        this._expand(h);
        var T,
          R = 0;
        for (g = 0; g < l.length; g++) {
          T = (this.words[g + y] | 0) + R;
          var x = (l.words[g] | 0) * p;
          (T -= x & 67108863),
            (R = (T >> 26) - ((x / 67108864) | 0)),
            (this.words[g + y] = T & 67108863);
        }
        for (; g < this.length - y; g++)
          (T = (this.words[g + y] | 0) + R),
            (R = T >> 26),
            (this.words[g + y] = T & 67108863);
        if (R === 0) return this.strip();
        for (n(R === -1), R = 0, g = 0; g < this.length; g++)
          (T = -(this.words[g] | 0) + R),
            (R = T >> 26),
            (this.words[g] = T & 67108863);
        return (this.negative = 1), this.strip();
      }),
      (a.prototype._wordDiv = function (l, p) {
        var y = this.length - l.length,
          h = this.clone(),
          g = l,
          T = g.words[g.length - 1] | 0,
          R = this._countBits(T);
        (y = 26 - R),
          y !== 0 &&
            ((g = g.ushln(y)), h.iushln(y), (T = g.words[g.length - 1] | 0));
        var x = h.length - g.length,
          f;
        if (p !== "mod") {
          (f = new a(null)),
            (f.length = x + 1),
            (f.words = new Array(f.length));
          for (var _ = 0; _ < f.length; _++) f.words[_] = 0;
        }
        var P = h.clone()._ishlnsubmul(g, 1, x);
        P.negative === 0 && ((h = P), f && (f.words[x] = 1));
        for (var M = x - 1; M >= 0; M--) {
          var D =
            (h.words[g.length + M] | 0) * 67108864 +
            (h.words[g.length + M - 1] | 0);
          for (
            D = Math.min((D / T) | 0, 67108863), h._ishlnsubmul(g, D, M);
            h.negative !== 0;

          )
            D--,
              (h.negative = 0),
              h._ishlnsubmul(g, 1, M),
              h.isZero() || (h.negative ^= 1);
          f && (f.words[M] = D);
        }
        return (
          f && f.strip(),
          h.strip(),
          p !== "div" && y !== 0 && h.iushrn(y),
          {
            div: f || null,
            mod: h,
          }
        );
      }),
      (a.prototype.divmod = function (l, p, y) {
        if ((n(!l.isZero()), this.isZero()))
          return {
            div: new a(0),
            mod: new a(0),
          };
        var h, g, T;
        return this.negative !== 0 && l.negative === 0
          ? ((T = this.neg().divmod(l, p)),
            p !== "mod" && (h = T.div.neg()),
            p !== "div" &&
              ((g = T.mod.neg()), y && g.negative !== 0 && g.iadd(l)),
            {
              div: h,
              mod: g,
            })
          : this.negative === 0 && l.negative !== 0
          ? ((T = this.divmod(l.neg(), p)),
            p !== "mod" && (h = T.div.neg()),
            {
              div: h,
              mod: T.mod,
            })
          : this.negative & l.negative
          ? ((T = this.neg().divmod(l.neg(), p)),
            p !== "div" &&
              ((g = T.mod.neg()), y && g.negative !== 0 && g.isub(l)),
            {
              div: T.div,
              mod: g,
            })
          : l.length > this.length || this.cmp(l) < 0
          ? {
              div: new a(0),
              mod: this,
            }
          : l.length === 1
          ? p === "div"
            ? {
                div: this.divn(l.words[0]),
                mod: null,
              }
            : p === "mod"
            ? {
                div: null,
                mod: new a(this.modn(l.words[0])),
              }
            : {
                div: this.divn(l.words[0]),
                mod: new a(this.modn(l.words[0])),
              }
          : this._wordDiv(l, p);
      }),
      (a.prototype.div = function (l) {
        return this.divmod(l, "div", !1).div;
      }),
      (a.prototype.mod = function (l) {
        return this.divmod(l, "mod", !1).mod;
      }),
      (a.prototype.umod = function (l) {
        return this.divmod(l, "mod", !0).mod;
      }),
      (a.prototype.divRound = function (l) {
        var p = this.divmod(l);
        if (p.mod.isZero()) return p.div;
        var y = p.div.negative !== 0 ? p.mod.isub(l) : p.mod,
          h = l.ushrn(1),
          g = l.andln(1),
          T = y.cmp(h);
        return T < 0 || (g === 1 && T === 0)
          ? p.div
          : p.div.negative !== 0
          ? p.div.isubn(1)
          : p.div.iaddn(1);
      }),
      (a.prototype.modn = function (l) {
        n(l <= 67108863);
        for (var p = (1 << 26) % l, y = 0, h = this.length - 1; h >= 0; h--)
          y = (p * y + (this.words[h] | 0)) % l;
        return y;
      }),
      (a.prototype.idivn = function (l) {
        n(l <= 67108863);
        for (var p = 0, y = this.length - 1; y >= 0; y--) {
          var h = (this.words[y] | 0) + p * 67108864;
          (this.words[y] = (h / l) | 0), (p = h % l);
        }
        return this.strip();
      }),
      (a.prototype.divn = function (l) {
        return this.clone().idivn(l);
      }),
      (a.prototype.egcd = function (l) {
        n(l.negative === 0), n(!l.isZero());
        var p = this,
          y = l.clone();
        p.negative !== 0 ? (p = p.umod(l)) : (p = p.clone());
        for (
          var h = new a(1), g = new a(0), T = new a(0), R = new a(1), x = 0;
          p.isEven() && y.isEven();

        )
          p.iushrn(1), y.iushrn(1), ++x;
        for (var f = y.clone(), _ = p.clone(); !p.isZero(); ) {
          for (var P = 0, M = 1; !(p.words[0] & M) && P < 26; ++P, M <<= 1);
          if (P > 0)
            for (p.iushrn(P); P-- > 0; )
              (h.isOdd() || g.isOdd()) && (h.iadd(f), g.isub(_)),
                h.iushrn(1),
                g.iushrn(1);
          for (var D = 0, q = 1; !(y.words[0] & q) && D < 26; ++D, q <<= 1);
          if (D > 0)
            for (y.iushrn(D); D-- > 0; )
              (T.isOdd() || R.isOdd()) && (T.iadd(f), R.isub(_)),
                T.iushrn(1),
                R.iushrn(1);
          p.cmp(y) >= 0
            ? (p.isub(y), h.isub(T), g.isub(R))
            : (y.isub(p), T.isub(h), R.isub(g));
        }
        return {
          a: T,
          b: R,
          gcd: y.iushln(x),
        };
      }),
      (a.prototype._invmp = function (l) {
        n(l.negative === 0), n(!l.isZero());
        var p = this,
          y = l.clone();
        p.negative !== 0 ? (p = p.umod(l)) : (p = p.clone());
        for (
          var h = new a(1), g = new a(0), T = y.clone();
          p.cmpn(1) > 0 && y.cmpn(1) > 0;

        ) {
          for (var R = 0, x = 1; !(p.words[0] & x) && R < 26; ++R, x <<= 1);
          if (R > 0)
            for (p.iushrn(R); R-- > 0; ) h.isOdd() && h.iadd(T), h.iushrn(1);
          for (var f = 0, _ = 1; !(y.words[0] & _) && f < 26; ++f, _ <<= 1);
          if (f > 0)
            for (y.iushrn(f); f-- > 0; ) g.isOdd() && g.iadd(T), g.iushrn(1);
          p.cmp(y) >= 0 ? (p.isub(y), h.isub(g)) : (y.isub(p), g.isub(h));
        }
        var P;
        return (
          p.cmpn(1) === 0 ? (P = h) : (P = g), P.cmpn(0) < 0 && P.iadd(l), P
        );
      }),
      (a.prototype.gcd = function (l) {
        if (this.isZero()) return l.abs();
        if (l.isZero()) return this.abs();
        var p = this.clone(),
          y = l.clone();
        (p.negative = 0), (y.negative = 0);
        for (var h = 0; p.isEven() && y.isEven(); h++) p.iushrn(1), y.iushrn(1);
        do {
          for (; p.isEven(); ) p.iushrn(1);
          for (; y.isEven(); ) y.iushrn(1);
          var g = p.cmp(y);
          if (g < 0) {
            var T = p;
            (p = y), (y = T);
          } else if (g === 0 || y.cmpn(1) === 0) break;
          p.isub(y);
        } while (!0);
        return y.iushln(h);
      }),
      (a.prototype.invm = function (l) {
        return this.egcd(l).a.umod(l);
      }),
      (a.prototype.isEven = function () {
        return (this.words[0] & 1) === 0;
      }),
      (a.prototype.isOdd = function () {
        return (this.words[0] & 1) === 1;
      }),
      (a.prototype.andln = function (l) {
        return this.words[0] & l;
      }),
      (a.prototype.bincn = function (l) {
        n(typeof l == "number");
        var p = l % 26,
          y = (l - p) / 26,
          h = 1 << p;
        if (this.length <= y)
          return this._expand(y + 1), (this.words[y] |= h), this;
        for (var g = h, T = y; g !== 0 && T < this.length; T++) {
          var R = this.words[T] | 0;
          (R += g), (g = R >>> 26), (R &= 67108863), (this.words[T] = R);
        }
        return g !== 0 && ((this.words[T] = g), this.length++), this;
      }),
      (a.prototype.isZero = function () {
        return this.length === 1 && this.words[0] === 0;
      }),
      (a.prototype.cmpn = function (l) {
        var p = l < 0;
        if (this.negative !== 0 && !p) return -1;
        if (this.negative === 0 && p) return 1;
        this.strip();
        var y;
        if (this.length > 1) y = 1;
        else {
          p && (l = -l), n(l <= 67108863, "Number is too big");
          var h = this.words[0] | 0;
          y = h === l ? 0 : h < l ? -1 : 1;
        }
        return this.negative !== 0 ? -y | 0 : y;
      }),
      (a.prototype.cmp = function (l) {
        if (this.negative !== 0 && l.negative === 0) return -1;
        if (this.negative === 0 && l.negative !== 0) return 1;
        var p = this.ucmp(l);
        return this.negative !== 0 ? -p | 0 : p;
      }),
      (a.prototype.ucmp = function (l) {
        if (this.length > l.length) return 1;
        if (this.length < l.length) return -1;
        for (var p = 0, y = this.length - 1; y >= 0; y--) {
          var h = this.words[y] | 0,
            g = l.words[y] | 0;
          if (h !== g) {
            h < g ? (p = -1) : h > g && (p = 1);
            break;
          }
        }
        return p;
      }),
      (a.prototype.gtn = function (l) {
        return this.cmpn(l) === 1;
      }),
      (a.prototype.gt = function (l) {
        return this.cmp(l) === 1;
      }),
      (a.prototype.gten = function (l) {
        return this.cmpn(l) >= 0;
      }),
      (a.prototype.gte = function (l) {
        return this.cmp(l) >= 0;
      }),
      (a.prototype.ltn = function (l) {
        return this.cmpn(l) === -1;
      }),
      (a.prototype.lt = function (l) {
        return this.cmp(l) === -1;
      }),
      (a.prototype.lten = function (l) {
        return this.cmpn(l) <= 0;
      }),
      (a.prototype.lte = function (l) {
        return this.cmp(l) <= 0;
      }),
      (a.prototype.eqn = function (l) {
        return this.cmpn(l) === 0;
      }),
      (a.prototype.eq = function (l) {
        return this.cmp(l) === 0;
      }),
      (a.red = function (l) {
        return new j(l);
      }),
      (a.prototype.toRed = function (l) {
        return (
          n(!this.red, "Already a number in reduction context"),
          n(this.negative === 0, "red works only with positives"),
          l.convertTo(this)._forceRed(l)
        );
      }),
      (a.prototype.fromRed = function () {
        return (
          n(this.red, "fromRed works only with numbers in reduction context"),
          this.red.convertFrom(this)
        );
      }),
      (a.prototype._forceRed = function (l) {
        return (this.red = l), this;
      }),
      (a.prototype.forceRed = function (l) {
        return (
          n(!this.red, "Already a number in reduction context"),
          this._forceRed(l)
        );
      }),
      (a.prototype.redAdd = function (l) {
        return (
          n(this.red, "redAdd works only with red numbers"),
          this.red.add(this, l)
        );
      }),
      (a.prototype.redIAdd = function (l) {
        return (
          n(this.red, "redIAdd works only with red numbers"),
          this.red.iadd(this, l)
        );
      }),
      (a.prototype.redSub = function (l) {
        return (
          n(this.red, "redSub works only with red numbers"),
          this.red.sub(this, l)
        );
      }),
      (a.prototype.redISub = function (l) {
        return (
          n(this.red, "redISub works only with red numbers"),
          this.red.isub(this, l)
        );
      }),
      (a.prototype.redShl = function (l) {
        return (
          n(this.red, "redShl works only with red numbers"),
          this.red.shl(this, l)
        );
      }),
      (a.prototype.redMul = function (l) {
        return (
          n(this.red, "redMul works only with red numbers"),
          this.red._verify2(this, l),
          this.red.mul(this, l)
        );
      }),
      (a.prototype.redIMul = function (l) {
        return (
          n(this.red, "redMul works only with red numbers"),
          this.red._verify2(this, l),
          this.red.imul(this, l)
        );
      }),
      (a.prototype.redSqr = function () {
        return (
          n(this.red, "redSqr works only with red numbers"),
          this.red._verify1(this),
          this.red.sqr(this)
        );
      }),
      (a.prototype.redISqr = function () {
        return (
          n(this.red, "redISqr works only with red numbers"),
          this.red._verify1(this),
          this.red.isqr(this)
        );
      }),
      (a.prototype.redSqrt = function () {
        return (
          n(this.red, "redSqrt works only with red numbers"),
          this.red._verify1(this),
          this.red.sqrt(this)
        );
      }),
      (a.prototype.redInvm = function () {
        return (
          n(this.red, "redInvm works only with red numbers"),
          this.red._verify1(this),
          this.red.invm(this)
        );
      }),
      (a.prototype.redNeg = function () {
        return (
          n(this.red, "redNeg works only with red numbers"),
          this.red._verify1(this),
          this.red.neg(this)
        );
      }),
      (a.prototype.redPow = function (l) {
        return (
          n(this.red && !l.red, "redPow(normalNum)"),
          this.red._verify1(this),
          this.red.pow(this, l)
        );
      });
    var S = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null,
    };
    function k(C, l) {
      (this.name = C),
        (this.p = new a(l, 16)),
        (this.n = this.p.bitLength()),
        (this.k = new a(1).iushln(this.n).isub(this.p)),
        (this.tmp = this._tmp());
    }
    (k.prototype._tmp = function () {
      var l = new a(null);
      return (l.words = new Array(Math.ceil(this.n / 13))), l;
    }),
      (k.prototype.ireduce = function (l) {
        var p = l,
          y;
        do
          this.split(p, this.tmp),
            (p = this.imulK(p)),
            (p = p.iadd(this.tmp)),
            (y = p.bitLength());
        while (y > this.n);
        var h = y < this.n ? -1 : p.ucmp(this.p);
        return (
          h === 0
            ? ((p.words[0] = 0), (p.length = 1))
            : h > 0
            ? p.isub(this.p)
            : p.strip(),
          p
        );
      }),
      (k.prototype.split = function (l, p) {
        l.iushrn(this.n, 0, p);
      }),
      (k.prototype.imulK = function (l) {
        return l.imul(this.k);
      });
    function N() {
      k.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    i(N, k),
      (N.prototype.split = function (l, p) {
        for (var y = 4194303, h = Math.min(l.length, 9), g = 0; g < h; g++)
          p.words[g] = l.words[g];
        if (((p.length = h), l.length <= 9)) {
          (l.words[0] = 0), (l.length = 1);
          return;
        }
        var T = l.words[9];
        for (p.words[p.length++] = T & y, g = 10; g < l.length; g++) {
          var R = l.words[g] | 0;
          (l.words[g - 10] = ((R & y) << 4) | (T >>> 22)), (T = R);
        }
        (T >>>= 22),
          (l.words[g - 10] = T),
          T === 0 && l.length > 10 ? (l.length -= 10) : (l.length -= 9);
      }),
      (N.prototype.imulK = function (l) {
        (l.words[l.length] = 0), (l.words[l.length + 1] = 0), (l.length += 2);
        for (var p = 0, y = 0; y < l.length; y++) {
          var h = l.words[y] | 0;
          (p += h * 977),
            (l.words[y] = p & 67108863),
            (p = h * 64 + ((p / 67108864) | 0));
        }
        return (
          l.words[l.length - 1] === 0 &&
            (l.length--, l.words[l.length - 1] === 0 && l.length--),
          l
        );
      });
    function O() {
      k.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    i(O, k);
    function F() {
      k.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    i(F, k);
    function V() {
      k.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    i(V, k),
      (V.prototype.imulK = function (l) {
        for (var p = 0, y = 0; y < l.length; y++) {
          var h = (l.words[y] | 0) * 19 + p,
            g = h & 67108863;
          (h >>>= 26), (l.words[y] = g), (p = h);
        }
        return p !== 0 && (l.words[l.length++] = p), l;
      }),
      (a._prime = function (l) {
        if (S[l]) return S[l];
        var p;
        if (l === "k256") p = new N();
        else if (l === "p224") p = new O();
        else if (l === "p192") p = new F();
        else if (l === "p25519") p = new V();
        else throw new Error("Unknown prime " + l);
        return (S[l] = p), p;
      });
    function j(C) {
      if (typeof C == "string") {
        var l = a._prime(C);
        (this.m = l.p), (this.prime = l);
      } else
        n(C.gtn(1), "modulus must be greater than 1"),
          (this.m = C),
          (this.prime = null);
    }
    (j.prototype._verify1 = function (l) {
      n(l.negative === 0, "red works only with positives"),
        n(l.red, "red works only with red numbers");
    }),
      (j.prototype._verify2 = function (l, p) {
        n((l.negative | p.negative) === 0, "red works only with positives"),
          n(l.red && l.red === p.red, "red works only with red numbers");
      }),
      (j.prototype.imod = function (l) {
        return this.prime
          ? this.prime.ireduce(l)._forceRed(this)
          : l.umod(this.m)._forceRed(this);
      }),
      (j.prototype.neg = function (l) {
        return l.isZero() ? l.clone() : this.m.sub(l)._forceRed(this);
      }),
      (j.prototype.add = function (l, p) {
        this._verify2(l, p);
        var y = l.add(p);
        return y.cmp(this.m) >= 0 && y.isub(this.m), y._forceRed(this);
      }),
      (j.prototype.iadd = function (l, p) {
        this._verify2(l, p);
        var y = l.iadd(p);
        return y.cmp(this.m) >= 0 && y.isub(this.m), y;
      }),
      (j.prototype.sub = function (l, p) {
        this._verify2(l, p);
        var y = l.sub(p);
        return y.cmpn(0) < 0 && y.iadd(this.m), y._forceRed(this);
      }),
      (j.prototype.isub = function (l, p) {
        this._verify2(l, p);
        var y = l.isub(p);
        return y.cmpn(0) < 0 && y.iadd(this.m), y;
      }),
      (j.prototype.shl = function (l, p) {
        return this._verify1(l), this.imod(l.ushln(p));
      }),
      (j.prototype.imul = function (l, p) {
        return this._verify2(l, p), this.imod(l.imul(p));
      }),
      (j.prototype.mul = function (l, p) {
        return this._verify2(l, p), this.imod(l.mul(p));
      }),
      (j.prototype.isqr = function (l) {
        return this.imul(l, l.clone());
      }),
      (j.prototype.sqr = function (l) {
        return this.mul(l, l);
      }),
      (j.prototype.sqrt = function (l) {
        if (l.isZero()) return l.clone();
        var p = this.m.andln(3);
        if ((n(p % 2 === 1), p === 3)) {
          var y = this.m.add(new a(1)).iushrn(2);
          return this.pow(l, y);
        }
        for (var h = this.m.subn(1), g = 0; !h.isZero() && h.andln(1) === 0; )
          g++, h.iushrn(1);
        n(!h.isZero());
        var T = new a(1).toRed(this),
          R = T.redNeg(),
          x = this.m.subn(1).iushrn(1),
          f = this.m.bitLength();
        for (f = new a(2 * f * f).toRed(this); this.pow(f, x).cmp(R) !== 0; )
          f.redIAdd(R);
        for (
          var _ = this.pow(f, h),
            P = this.pow(l, h.addn(1).iushrn(1)),
            M = this.pow(l, h),
            D = g;
          M.cmp(T) !== 0;

        ) {
          for (var q = M, B = 0; q.cmp(T) !== 0; B++) q = q.redSqr();
          n(B < D);
          var H = this.pow(_, new a(1).iushln(D - B - 1));
          (P = P.redMul(H)), (_ = H.redSqr()), (M = M.redMul(_)), (D = B);
        }
        return P;
      }),
      (j.prototype.invm = function (l) {
        var p = l._invmp(this.m);
        return p.negative !== 0
          ? ((p.negative = 0), this.imod(p).redNeg())
          : this.imod(p);
      }),
      (j.prototype.pow = function (l, p) {
        if (p.isZero()) return new a(1).toRed(this);
        if (p.cmpn(1) === 0) return l.clone();
        var y = 4,
          h = new Array(1 << y);
        (h[0] = new a(1).toRed(this)), (h[1] = l);
        for (var g = 2; g < h.length; g++) h[g] = this.mul(h[g - 1], l);
        var T = h[0],
          R = 0,
          x = 0,
          f = p.bitLength() % 26;
        for (f === 0 && (f = 26), g = p.length - 1; g >= 0; g--) {
          for (var _ = p.words[g], P = f - 1; P >= 0; P--) {
            var M = (_ >> P) & 1;
            if ((T !== h[0] && (T = this.sqr(T)), M === 0 && R === 0)) {
              x = 0;
              continue;
            }
            (R <<= 1),
              (R |= M),
              x++,
              !(x !== y && (g !== 0 || P !== 0)) &&
                ((T = this.mul(T, h[R])), (x = 0), (R = 0));
          }
          f = 26;
        }
        return T;
      }),
      (j.prototype.convertTo = function (l) {
        var p = l.umod(this.m);
        return p === l ? p.clone() : p;
      }),
      (j.prototype.convertFrom = function (l) {
        var p = l.clone();
        return (p.red = null), p;
      }),
      (a.mont = function (l) {
        return new X(l);
      });
    function X(C) {
      j.call(this, C),
        (this.shift = this.m.bitLength()),
        this.shift % 26 !== 0 && (this.shift += 26 - (this.shift % 26)),
        (this.r = new a(1).iushln(this.shift)),
        (this.r2 = this.imod(this.r.sqr())),
        (this.rinv = this.r._invmp(this.m)),
        (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
        (this.minv = this.minv.umod(this.r)),
        (this.minv = this.r.sub(this.minv));
    }
    i(X, j),
      (X.prototype.convertTo = function (l) {
        return this.imod(l.ushln(this.shift));
      }),
      (X.prototype.convertFrom = function (l) {
        var p = this.imod(l.mul(this.rinv));
        return (p.red = null), p;
      }),
      (X.prototype.imul = function (l, p) {
        if (l.isZero() || p.isZero())
          return (l.words[0] = 0), (l.length = 1), l;
        var y = l.imul(p),
          h = y.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
          g = y.isub(h).iushrn(this.shift),
          T = g;
        return (
          g.cmp(this.m) >= 0
            ? (T = g.isub(this.m))
            : g.cmpn(0) < 0 && (T = g.iadd(this.m)),
          T._forceRed(this)
        );
      }),
      (X.prototype.mul = function (l, p) {
        if (l.isZero() || p.isZero()) return new a(0)._forceRed(this);
        var y = l.mul(p),
          h = y.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
          g = y.isub(h).iushrn(this.shift),
          T = g;
        return (
          g.cmp(this.m) >= 0
            ? (T = g.isub(this.m))
            : g.cmpn(0) < 0 && (T = g.iadd(this.m)),
          T._forceRed(this)
        );
      }),
      (X.prototype.invm = function (l) {
        var p = this.imod(l._invmp(this.m).mul(this.r2));
        return p._forceRed(this);
      });
  })(t, ke);
})(JT);
var $_e = JT.exports;
const U_e = mn($_e);
function W_e(t, e) {
  return sf(new Uint8Array(t), !e);
}
function j_e(t) {
  return ZT(t);
}
function H_e(t, e) {
  return A_e(t, !e);
}
function z_e(t) {
  return of(t).buffer;
}
function Fj(t, e) {
  const r = cl(Bj(new U_e(t).toString(16)));
  return e ? r : Fd(r);
}
function Cy(t) {
  return Bj(t);
}
function q_e(t) {
  return R_e(Fd(t));
}
const V_e = JE;
function R5() {
  return ((e, r) => {
    for (
      r = e = "";
      e++ < 36;
      r +=
        (e * 51) & 52
          ? (e ^ 15 ? 8 ^ (Math.random() * (e ^ 20 ? 16 : 4)) : 4).toString(16)
          : "-"
    );
    return r;
  })();
}
function K_e(t) {
  return t === "" || (typeof t == "string" && t.trim() === "");
}
function G_e(t) {
  return !(t && t.length);
}
function Lj(t, e) {
  return k_e(t);
}
function Z_e(t) {
  return typeof t.method < "u";
}
function Ch(t) {
  return typeof t.result < "u";
}
function yb(t) {
  return typeof t.error < "u";
}
function EI(t) {
  return typeof t.event < "u";
}
function J_e(t) {
  return L_e.includes(t) || t.startsWith("wc_");
}
function Q_e(t) {
  return t.method.startsWith("wc_") ? !0 : !Oj.includes(t.method);
}
function Y_e(t) {
  t = cl(t.toLowerCase());
  const e = cl(xB.keccak_256(j_e(t)));
  let r = "";
  for (let n = 0; n < t.length; n++)
    parseInt(e[n], 16) > 7 ? (r += t[n].toUpperCase()) : (r += t[n]);
  return Fd(r);
}
const X_e = (t) =>
  t
    ? t.toLowerCase().substring(0, 2) !== "0x"
      ? !1
      : /^(0x)?[0-9a-f]{40}$/i.test(t)
      ? /^(0x)?[0-9a-f]{40}$/.test(t) || /^(0x)?[0-9A-F]{40}$/.test(t)
        ? !0
        : t === Y_e(t)
      : !1
    : !1;
function TI(t) {
  return !G_e(t) && !Lj(t[0]) && (t[0] = H_e(t[0])), t;
}
function P5(t) {
  if (typeof t.type < "u" && t.type !== "0") return t;
  if (typeof t.from > "u" || !X_e(t.from))
    throw new Error("Transaction object must include a valid 'from' value.");
  function e(i) {
    let a = i;
    return (
      (typeof i == "number" || (typeof i == "string" && !K_e(i))) &&
        (Lj(i) ? typeof i == "string" && (a = Cy(i)) : (a = Fj(i))),
      typeof a == "string" && (a = q_e(a)),
      a
    );
  }
  const r = {
      from: Cy(t.from),
      to: typeof t.to > "u" ? void 0 : Cy(t.to),
      gasPrice: typeof t.gasPrice > "u" ? "" : e(t.gasPrice),
      gas:
        typeof t.gas > "u"
          ? typeof t.gasLimit > "u"
            ? ""
            : e(t.gasLimit)
          : e(t.gas),
      value: typeof t.value > "u" ? "" : e(t.value),
      nonce: typeof t.nonce > "u" ? "" : e(t.nonce),
      data: typeof t.data > "u" ? "" : Cy(t.data) || "0x",
    },
    n = ["gasPrice", "gas", "value", "nonce"];
  return (
    Object.keys(r).forEach((i) => {
      (typeof r[i] > "u" || (typeof r[i] == "string" && !r[i].trim().length)) &&
        n.includes(i) &&
        delete r[i];
    }),
    r
  );
}
function e4e(t) {
  const e = t.message || "Failed or Rejected Request";
  let r = -32e3;
  if (t && !t.code)
    switch (e) {
      case "Parse error":
        r = -32700;
        break;
      case "Invalid request":
        r = -32600;
        break;
      case "Method not found":
        r = -32601;
        break;
      case "Invalid params":
        r = -32602;
        break;
      case "Internal error":
        r = -32603;
        break;
      default:
        r = -32e3;
        break;
    }
  const n = {
    code: r,
    message: e,
  };
  return t.data && (n.data = t.data), n;
}
var $j = {};
(function (t) {
  const e = Ov,
    r = Fv,
    n = Lv,
    i = (b) => b == null;
  function a(b) {
    switch (b.arrayFormat) {
      case "index":
        return (w) => (S, k) => {
          const N = S.length;
          return k === void 0 ||
            (b.skipNull && k === null) ||
            (b.skipEmptyString && k === "")
            ? S
            : k === null
            ? [...S, [c(w, b), "[", N, "]"].join("")]
            : [...S, [c(w, b), "[", c(N, b), "]=", c(k, b)].join("")];
        };
      case "bracket":
        return (w) => (S, k) =>
          k === void 0 ||
          (b.skipNull && k === null) ||
          (b.skipEmptyString && k === "")
            ? S
            : k === null
            ? [...S, [c(w, b), "[]"].join("")]
            : [...S, [c(w, b), "[]=", c(k, b)].join("")];
      case "comma":
      case "separator":
        return (w) => (S, k) =>
          k == null || k.length === 0
            ? S
            : S.length === 0
            ? [[c(w, b), "=", c(k, b)].join("")]
            : [[S, c(k, b)].join(b.arrayFormatSeparator)];
      default:
        return (w) => (S, k) =>
          k === void 0 ||
          (b.skipNull && k === null) ||
          (b.skipEmptyString && k === "")
            ? S
            : k === null
            ? [...S, c(w, b)]
            : [...S, [c(w, b), "=", c(k, b)].join("")];
    }
  }
  function s(b) {
    let w;
    switch (b.arrayFormat) {
      case "index":
        return (S, k, N) => {
          if (
            ((w = /\[(\d*)\]$/.exec(S)), (S = S.replace(/\[\d*\]$/, "")), !w)
          ) {
            N[S] = k;
            return;
          }
          N[S] === void 0 && (N[S] = {}), (N[S][w[1]] = k);
        };
      case "bracket":
        return (S, k, N) => {
          if (((w = /(\[\])$/.exec(S)), (S = S.replace(/\[\]$/, "")), !w)) {
            N[S] = k;
            return;
          }
          if (N[S] === void 0) {
            N[S] = [k];
            return;
          }
          N[S] = [].concat(N[S], k);
        };
      case "comma":
      case "separator":
        return (S, k, N) => {
          const F =
            typeof k == "string" &&
            k.split("").indexOf(b.arrayFormatSeparator) > -1
              ? k.split(b.arrayFormatSeparator).map((V) => u(V, b))
              : k === null
              ? k
              : u(k, b);
          N[S] = F;
        };
      default:
        return (S, k, N) => {
          if (N[S] === void 0) {
            N[S] = k;
            return;
          }
          N[S] = [].concat(N[S], k);
        };
    }
  }
  function o(b) {
    if (typeof b != "string" || b.length !== 1)
      throw new TypeError(
        "arrayFormatSeparator must be single character string"
      );
  }
  function c(b, w) {
    return w.encode ? (w.strict ? e(b) : encodeURIComponent(b)) : b;
  }
  function u(b, w) {
    return w.decode ? r(b) : b;
  }
  function d(b) {
    return Array.isArray(b)
      ? b.sort()
      : typeof b == "object"
      ? d(Object.keys(b))
          .sort((w, S) => Number(w) - Number(S))
          .map((w) => b[w])
      : b;
  }
  function m(b) {
    const w = b.indexOf("#");
    return w !== -1 && (b = b.slice(0, w)), b;
  }
  function v(b) {
    let w = "";
    const S = b.indexOf("#");
    return S !== -1 && (w = b.slice(S)), w;
  }
  function E(b) {
    b = m(b);
    const w = b.indexOf("?");
    return w === -1 ? "" : b.slice(w + 1);
  }
  function A(b, w) {
    return (
      w.parseNumbers &&
      !Number.isNaN(Number(b)) &&
      typeof b == "string" &&
      b.trim() !== ""
        ? (b = Number(b))
        : w.parseBooleans &&
          b !== null &&
          (b.toLowerCase() === "true" || b.toLowerCase() === "false") &&
          (b = b.toLowerCase() === "true"),
      b
    );
  }
  function I(b, w) {
    (w = Object.assign(
      {
        decode: !0,
        sort: !0,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: !1,
        parseBooleans: !1,
      },
      w
    )),
      o(w.arrayFormatSeparator);
    const S = s(w),
      k = Object.create(null);
    if (typeof b != "string" || ((b = b.trim().replace(/^[?#&]/, "")), !b))
      return k;
    for (const N of b.split("&")) {
      let [O, F] = n(w.decode ? N.replace(/\+/g, " ") : N, "=");
      (F =
        F === void 0
          ? null
          : ["comma", "separator"].includes(w.arrayFormat)
          ? F
          : u(F, w)),
        S(u(O, w), F, k);
    }
    for (const N of Object.keys(k)) {
      const O = k[N];
      if (typeof O == "object" && O !== null)
        for (const F of Object.keys(O)) O[F] = A(O[F], w);
      else k[N] = A(O, w);
    }
    return w.sort === !1
      ? k
      : (w.sort === !0
          ? Object.keys(k).sort()
          : Object.keys(k).sort(w.sort)
        ).reduce((N, O) => {
          const F = k[O];
          return (
            F && typeof F == "object" && !Array.isArray(F)
              ? (N[O] = d(F))
              : (N[O] = F),
            N
          );
        }, Object.create(null));
  }
  (t.extract = E),
    (t.parse = I),
    (t.stringify = (b, w) => {
      if (!b) return "";
      (w = Object.assign(
        {
          encode: !0,
          strict: !0,
          arrayFormat: "none",
          arrayFormatSeparator: ",",
        },
        w
      )),
        o(w.arrayFormatSeparator);
      const S = (F) =>
          (w.skipNull && i(b[F])) || (w.skipEmptyString && b[F] === ""),
        k = a(w),
        N = {};
      for (const F of Object.keys(b)) S(F) || (N[F] = b[F]);
      const O = Object.keys(N);
      return (
        w.sort !== !1 && O.sort(w.sort),
        O.map((F) => {
          const V = b[F];
          return V === void 0
            ? ""
            : V === null
            ? c(F, w)
            : Array.isArray(V)
            ? V.reduce(k(F), []).join("&")
            : c(F, w) + "=" + c(V, w);
        })
          .filter((F) => F.length > 0)
          .join("&")
      );
    }),
    (t.parseUrl = (b, w) => {
      w = Object.assign(
        {
          decode: !0,
        },
        w
      );
      const [S, k] = n(b, "#");
      return Object.assign(
        {
          url: S.split("?")[0] || "",
          query: I(E(b), w),
        },
        w && w.parseFragmentIdentifier && k
          ? {
              fragmentIdentifier: u(k, w),
            }
          : {}
      );
    }),
    (t.stringifyUrl = (b, w) => {
      w = Object.assign(
        {
          encode: !0,
          strict: !0,
        },
        w
      );
      const S = m(b.url).split("?")[0] || "",
        k = t.extract(b.url),
        N = t.parse(k, {
          sort: !1,
        }),
        O = Object.assign(N, b.query);
      let F = t.stringify(O, w);
      F && (F = `?${F}`);
      let V = v(b.url);
      return (
        b.fragmentIdentifier && (V = `#${c(b.fragmentIdentifier, w)}`),
        `${S}${F}${V}`
      );
    });
})($j);
function t4e(t) {
  return $j.parse(t);
}
function r4e(t) {
  return typeof t.bridge < "u";
}
function n4e(t) {
  const e = t.indexOf(":"),
    r = t.indexOf("?") !== -1 ? t.indexOf("?") : void 0,
    n = t.substring(0, e),
    i = t.substring(e + 1, r);
  function a(m) {
    const E = m.split("@");
    return {
      handshakeTopic: E[0],
      version: parseInt(E[1], 10),
    };
  }
  const s = a(i),
    o = typeof r < "u" ? t.substr(r) : "";
  function c(m) {
    const v = t4e(m);
    return {
      key: v.key || "",
      bridge: v.bridge || "",
    };
  }
  const u = c(o);
  return Object.assign(
    Object.assign(
      {
        protocol: n,
      },
      s
    ),
    u
  );
}
var QT = {
  exports: {},
};
QT.exports;
(function (t) {
  (function (e, r) {
    function n(C, l) {
      if (!C) throw new Error(l || "Assertion failed");
    }
    function i(C, l) {
      C.super_ = l;
      var p = function () {};
      (p.prototype = l.prototype),
        (C.prototype = new p()),
        (C.prototype.constructor = C);
    }
    function a(C, l, p) {
      if (a.isBN(C)) return C;
      (this.negative = 0),
        (this.words = null),
        (this.length = 0),
        (this.red = null),
        C !== null &&
          ((l === "le" || l === "be") && ((p = l), (l = 10)),
          this._init(C || 0, l || 10, p || "be"));
    }
    typeof e == "object" ? (e.exports = a) : (r.BN = a),
      (a.BN = a),
      (a.wordSize = 26);
    var s;
    try {
      s = Pu.Buffer;
    } catch {}
    (a.isBN = function (l) {
      return l instanceof a
        ? !0
        : l !== null &&
            typeof l == "object" &&
            l.constructor.wordSize === a.wordSize &&
            Array.isArray(l.words);
    }),
      (a.max = function (l, p) {
        return l.cmp(p) > 0 ? l : p;
      }),
      (a.min = function (l, p) {
        return l.cmp(p) < 0 ? l : p;
      }),
      (a.prototype._init = function (l, p, y) {
        if (typeof l == "number") return this._initNumber(l, p, y);
        if (typeof l == "object") return this._initArray(l, p, y);
        p === "hex" && (p = 16),
          n(p === (p | 0) && p >= 2 && p <= 36),
          (l = l.toString().replace(/\s+/g, ""));
        var h = 0;
        l[0] === "-" && h++,
          p === 16 ? this._parseHex(l, h) : this._parseBase(l, p, h),
          l[0] === "-" && (this.negative = 1),
          this.strip(),
          y === "le" && this._initArray(this.toArray(), p, y);
      }),
      (a.prototype._initNumber = function (l, p, y) {
        l < 0 && ((this.negative = 1), (l = -l)),
          l < 67108864
            ? ((this.words = [l & 67108863]), (this.length = 1))
            : l < 4503599627370496
            ? ((this.words = [l & 67108863, (l / 67108864) & 67108863]),
              (this.length = 2))
            : (n(l < 9007199254740992),
              (this.words = [l & 67108863, (l / 67108864) & 67108863, 1]),
              (this.length = 3)),
          y === "le" && this._initArray(this.toArray(), p, y);
      }),
      (a.prototype._initArray = function (l, p, y) {
        if ((n(typeof l.length == "number"), l.length <= 0))
          return (this.words = [0]), (this.length = 1), this;
        (this.length = Math.ceil(l.length / 3)),
          (this.words = new Array(this.length));
        for (var h = 0; h < this.length; h++) this.words[h] = 0;
        var g,
          T,
          R = 0;
        if (y === "be")
          for (h = l.length - 1, g = 0; h >= 0; h -= 3)
            (T = l[h] | (l[h - 1] << 8) | (l[h - 2] << 16)),
              (this.words[g] |= (T << R) & 67108863),
              (this.words[g + 1] = (T >>> (26 - R)) & 67108863),
              (R += 24),
              R >= 26 && ((R -= 26), g++);
        else if (y === "le")
          for (h = 0, g = 0; h < l.length; h += 3)
            (T = l[h] | (l[h + 1] << 8) | (l[h + 2] << 16)),
              (this.words[g] |= (T << R) & 67108863),
              (this.words[g + 1] = (T >>> (26 - R)) & 67108863),
              (R += 24),
              R >= 26 && ((R -= 26), g++);
        return this.strip();
      });
    function o(C, l, p) {
      for (var y = 0, h = Math.min(C.length, p), g = l; g < h; g++) {
        var T = C.charCodeAt(g) - 48;
        (y <<= 4),
          T >= 49 && T <= 54
            ? (y |= T - 49 + 10)
            : T >= 17 && T <= 22
            ? (y |= T - 17 + 10)
            : (y |= T & 15);
      }
      return y;
    }
    a.prototype._parseHex = function (l, p) {
      (this.length = Math.ceil((l.length - p) / 6)),
        (this.words = new Array(this.length));
      for (var y = 0; y < this.length; y++) this.words[y] = 0;
      var h,
        g,
        T = 0;
      for (y = l.length - 6, h = 0; y >= p; y -= 6)
        (g = o(l, y, y + 6)),
          (this.words[h] |= (g << T) & 67108863),
          (this.words[h + 1] |= (g >>> (26 - T)) & 4194303),
          (T += 24),
          T >= 26 && ((T -= 26), h++);
      y + 6 !== p &&
        ((g = o(l, p, y + 6)),
        (this.words[h] |= (g << T) & 67108863),
        (this.words[h + 1] |= (g >>> (26 - T)) & 4194303)),
        this.strip();
    };
    function c(C, l, p, y) {
      for (var h = 0, g = Math.min(C.length, p), T = l; T < g; T++) {
        var R = C.charCodeAt(T) - 48;
        (h *= y),
          R >= 49
            ? (h += R - 49 + 10)
            : R >= 17
            ? (h += R - 17 + 10)
            : (h += R);
      }
      return h;
    }
    (a.prototype._parseBase = function (l, p, y) {
      (this.words = [0]), (this.length = 1);
      for (var h = 0, g = 1; g <= 67108863; g *= p) h++;
      h--, (g = (g / p) | 0);
      for (
        var T = l.length - y,
          R = T % h,
          x = Math.min(T, T - R) + y,
          f = 0,
          _ = y;
        _ < x;
        _ += h
      )
        (f = c(l, _, _ + h, p)),
          this.imuln(g),
          this.words[0] + f < 67108864 ? (this.words[0] += f) : this._iaddn(f);
      if (R !== 0) {
        var P = 1;
        for (f = c(l, _, l.length, p), _ = 0; _ < R; _++) P *= p;
        this.imuln(P),
          this.words[0] + f < 67108864 ? (this.words[0] += f) : this._iaddn(f);
      }
    }),
      (a.prototype.copy = function (l) {
        l.words = new Array(this.length);
        for (var p = 0; p < this.length; p++) l.words[p] = this.words[p];
        (l.length = this.length),
          (l.negative = this.negative),
          (l.red = this.red);
      }),
      (a.prototype.clone = function () {
        var l = new a(null);
        return this.copy(l), l;
      }),
      (a.prototype._expand = function (l) {
        for (; this.length < l; ) this.words[this.length++] = 0;
        return this;
      }),
      (a.prototype.strip = function () {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }),
      (a.prototype._normSign = function () {
        return (
          this.length === 1 && this.words[0] === 0 && (this.negative = 0), this
        );
      }),
      (a.prototype.inspect = function () {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      });
    var u = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000",
      ],
      d = [
        0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
      ],
      m = [
        0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607,
        16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536,
        11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101,
        5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368,
        20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875,
        60466176,
      ];
    (a.prototype.toString = function (l, p) {
      (l = l || 10), (p = p | 0 || 1);
      var y;
      if (l === 16 || l === "hex") {
        y = "";
        for (var h = 0, g = 0, T = 0; T < this.length; T++) {
          var R = this.words[T],
            x = (((R << h) | g) & 16777215).toString(16);
          (g = (R >>> (24 - h)) & 16777215),
            g !== 0 || T !== this.length - 1
              ? (y = u[6 - x.length] + x + y)
              : (y = x + y),
            (h += 2),
            h >= 26 && ((h -= 26), T--);
        }
        for (g !== 0 && (y = g.toString(16) + y); y.length % p !== 0; )
          y = "0" + y;
        return this.negative !== 0 && (y = "-" + y), y;
      }
      if (l === (l | 0) && l >= 2 && l <= 36) {
        var f = d[l],
          _ = m[l];
        y = "";
        var P = this.clone();
        for (P.negative = 0; !P.isZero(); ) {
          var M = P.modn(_).toString(l);
          (P = P.idivn(_)),
            P.isZero() ? (y = M + y) : (y = u[f - M.length] + M + y);
        }
        for (this.isZero() && (y = "0" + y); y.length % p !== 0; ) y = "0" + y;
        return this.negative !== 0 && (y = "-" + y), y;
      }
      n(!1, "Base should be between 2 and 36");
    }),
      (a.prototype.toNumber = function () {
        var l = this.words[0];
        return (
          this.length === 2
            ? (l += this.words[1] * 67108864)
            : this.length === 3 && this.words[2] === 1
            ? (l += 4503599627370496 + this.words[1] * 67108864)
            : this.length > 2 &&
              n(!1, "Number can only safely store up to 53 bits"),
          this.negative !== 0 ? -l : l
        );
      }),
      (a.prototype.toJSON = function () {
        return this.toString(16);
      }),
      (a.prototype.toBuffer = function (l, p) {
        return n(typeof s < "u"), this.toArrayLike(s, l, p);
      }),
      (a.prototype.toArray = function (l, p) {
        return this.toArrayLike(Array, l, p);
      }),
      (a.prototype.toArrayLike = function (l, p, y) {
        var h = this.byteLength(),
          g = y || Math.max(1, h);
        n(h <= g, "byte array longer than desired length"),
          n(g > 0, "Requested array length <= 0"),
          this.strip();
        var T = p === "le",
          R = new l(g),
          x,
          f,
          _ = this.clone();
        if (T) {
          for (f = 0; !_.isZero(); f++)
            (x = _.andln(255)), _.iushrn(8), (R[f] = x);
          for (; f < g; f++) R[f] = 0;
        } else {
          for (f = 0; f < g - h; f++) R[f] = 0;
          for (f = 0; !_.isZero(); f++)
            (x = _.andln(255)), _.iushrn(8), (R[g - f - 1] = x);
        }
        return R;
      }),
      Math.clz32
        ? (a.prototype._countBits = function (l) {
            return 32 - Math.clz32(l);
          })
        : (a.prototype._countBits = function (l) {
            var p = l,
              y = 0;
            return (
              p >= 4096 && ((y += 13), (p >>>= 13)),
              p >= 64 && ((y += 7), (p >>>= 7)),
              p >= 8 && ((y += 4), (p >>>= 4)),
              p >= 2 && ((y += 2), (p >>>= 2)),
              y + p
            );
          }),
      (a.prototype._zeroBits = function (l) {
        if (l === 0) return 26;
        var p = l,
          y = 0;
        return (
          p & 8191 || ((y += 13), (p >>>= 13)),
          p & 127 || ((y += 7), (p >>>= 7)),
          p & 15 || ((y += 4), (p >>>= 4)),
          p & 3 || ((y += 2), (p >>>= 2)),
          p & 1 || y++,
          y
        );
      }),
      (a.prototype.bitLength = function () {
        var l = this.words[this.length - 1],
          p = this._countBits(l);
        return (this.length - 1) * 26 + p;
      });
    function v(C) {
      for (var l = new Array(C.bitLength()), p = 0; p < l.length; p++) {
        var y = (p / 26) | 0,
          h = p % 26;
        l[p] = (C.words[y] & (1 << h)) >>> h;
      }
      return l;
    }
    (a.prototype.zeroBits = function () {
      if (this.isZero()) return 0;
      for (var l = 0, p = 0; p < this.length; p++) {
        var y = this._zeroBits(this.words[p]);
        if (((l += y), y !== 26)) break;
      }
      return l;
    }),
      (a.prototype.byteLength = function () {
        return Math.ceil(this.bitLength() / 8);
      }),
      (a.prototype.toTwos = function (l) {
        return this.negative !== 0
          ? this.abs().inotn(l).iaddn(1)
          : this.clone();
      }),
      (a.prototype.fromTwos = function (l) {
        return this.testn(l - 1) ? this.notn(l).iaddn(1).ineg() : this.clone();
      }),
      (a.prototype.isNeg = function () {
        return this.negative !== 0;
      }),
      (a.prototype.neg = function () {
        return this.clone().ineg();
      }),
      (a.prototype.ineg = function () {
        return this.isZero() || (this.negative ^= 1), this;
      }),
      (a.prototype.iuor = function (l) {
        for (; this.length < l.length; ) this.words[this.length++] = 0;
        for (var p = 0; p < l.length; p++)
          this.words[p] = this.words[p] | l.words[p];
        return this.strip();
      }),
      (a.prototype.ior = function (l) {
        return n((this.negative | l.negative) === 0), this.iuor(l);
      }),
      (a.prototype.or = function (l) {
        return this.length > l.length
          ? this.clone().ior(l)
          : l.clone().ior(this);
      }),
      (a.prototype.uor = function (l) {
        return this.length > l.length
          ? this.clone().iuor(l)
          : l.clone().iuor(this);
      }),
      (a.prototype.iuand = function (l) {
        var p;
        this.length > l.length ? (p = l) : (p = this);
        for (var y = 0; y < p.length; y++)
          this.words[y] = this.words[y] & l.words[y];
        return (this.length = p.length), this.strip();
      }),
      (a.prototype.iand = function (l) {
        return n((this.negative | l.negative) === 0), this.iuand(l);
      }),
      (a.prototype.and = function (l) {
        return this.length > l.length
          ? this.clone().iand(l)
          : l.clone().iand(this);
      }),
      (a.prototype.uand = function (l) {
        return this.length > l.length
          ? this.clone().iuand(l)
          : l.clone().iuand(this);
      }),
      (a.prototype.iuxor = function (l) {
        var p, y;
        this.length > l.length ? ((p = this), (y = l)) : ((p = l), (y = this));
        for (var h = 0; h < y.length; h++)
          this.words[h] = p.words[h] ^ y.words[h];
        if (this !== p) for (; h < p.length; h++) this.words[h] = p.words[h];
        return (this.length = p.length), this.strip();
      }),
      (a.prototype.ixor = function (l) {
        return n((this.negative | l.negative) === 0), this.iuxor(l);
      }),
      (a.prototype.xor = function (l) {
        return this.length > l.length
          ? this.clone().ixor(l)
          : l.clone().ixor(this);
      }),
      (a.prototype.uxor = function (l) {
        return this.length > l.length
          ? this.clone().iuxor(l)
          : l.clone().iuxor(this);
      }),
      (a.prototype.inotn = function (l) {
        n(typeof l == "number" && l >= 0);
        var p = Math.ceil(l / 26) | 0,
          y = l % 26;
        this._expand(p), y > 0 && p--;
        for (var h = 0; h < p; h++) this.words[h] = ~this.words[h] & 67108863;
        return (
          y > 0 && (this.words[h] = ~this.words[h] & (67108863 >> (26 - y))),
          this.strip()
        );
      }),
      (a.prototype.notn = function (l) {
        return this.clone().inotn(l);
      }),
      (a.prototype.setn = function (l, p) {
        n(typeof l == "number" && l >= 0);
        var y = (l / 26) | 0,
          h = l % 26;
        return (
          this._expand(y + 1),
          p
            ? (this.words[y] = this.words[y] | (1 << h))
            : (this.words[y] = this.words[y] & ~(1 << h)),
          this.strip()
        );
      }),
      (a.prototype.iadd = function (l) {
        var p;
        if (this.negative !== 0 && l.negative === 0)
          return (
            (this.negative = 0),
            (p = this.isub(l)),
            (this.negative ^= 1),
            this._normSign()
          );
        if (this.negative === 0 && l.negative !== 0)
          return (
            (l.negative = 0),
            (p = this.isub(l)),
            (l.negative = 1),
            p._normSign()
          );
        var y, h;
        this.length > l.length ? ((y = this), (h = l)) : ((y = l), (h = this));
        for (var g = 0, T = 0; T < h.length; T++)
          (p = (y.words[T] | 0) + (h.words[T] | 0) + g),
            (this.words[T] = p & 67108863),
            (g = p >>> 26);
        for (; g !== 0 && T < y.length; T++)
          (p = (y.words[T] | 0) + g),
            (this.words[T] = p & 67108863),
            (g = p >>> 26);
        if (((this.length = y.length), g !== 0))
          (this.words[this.length] = g), this.length++;
        else if (y !== this)
          for (; T < y.length; T++) this.words[T] = y.words[T];
        return this;
      }),
      (a.prototype.add = function (l) {
        var p;
        return l.negative !== 0 && this.negative === 0
          ? ((l.negative = 0), (p = this.sub(l)), (l.negative ^= 1), p)
          : l.negative === 0 && this.negative !== 0
          ? ((this.negative = 0), (p = l.sub(this)), (this.negative = 1), p)
          : this.length > l.length
          ? this.clone().iadd(l)
          : l.clone().iadd(this);
      }),
      (a.prototype.isub = function (l) {
        if (l.negative !== 0) {
          l.negative = 0;
          var p = this.iadd(l);
          return (l.negative = 1), p._normSign();
        } else if (this.negative !== 0)
          return (
            (this.negative = 0),
            this.iadd(l),
            (this.negative = 1),
            this._normSign()
          );
        var y = this.cmp(l);
        if (y === 0)
          return (
            (this.negative = 0), (this.length = 1), (this.words[0] = 0), this
          );
        var h, g;
        y > 0 ? ((h = this), (g = l)) : ((h = l), (g = this));
        for (var T = 0, R = 0; R < g.length; R++)
          (p = (h.words[R] | 0) - (g.words[R] | 0) + T),
            (T = p >> 26),
            (this.words[R] = p & 67108863);
        for (; T !== 0 && R < h.length; R++)
          (p = (h.words[R] | 0) + T),
            (T = p >> 26),
            (this.words[R] = p & 67108863);
        if (T === 0 && R < h.length && h !== this)
          for (; R < h.length; R++) this.words[R] = h.words[R];
        return (
          (this.length = Math.max(this.length, R)),
          h !== this && (this.negative = 1),
          this.strip()
        );
      }),
      (a.prototype.sub = function (l) {
        return this.clone().isub(l);
      });
    function E(C, l, p) {
      p.negative = l.negative ^ C.negative;
      var y = (C.length + l.length) | 0;
      (p.length = y), (y = (y - 1) | 0);
      var h = C.words[0] | 0,
        g = l.words[0] | 0,
        T = h * g,
        R = T & 67108863,
        x = (T / 67108864) | 0;
      p.words[0] = R;
      for (var f = 1; f < y; f++) {
        for (
          var _ = x >>> 26,
            P = x & 67108863,
            M = Math.min(f, l.length - 1),
            D = Math.max(0, f - C.length + 1);
          D <= M;
          D++
        ) {
          var q = (f - D) | 0;
          (h = C.words[q] | 0),
            (g = l.words[D] | 0),
            (T = h * g + P),
            (_ += (T / 67108864) | 0),
            (P = T & 67108863);
        }
        (p.words[f] = P | 0), (x = _ | 0);
      }
      return x !== 0 ? (p.words[f] = x | 0) : p.length--, p.strip();
    }
    var A = function (l, p, y) {
      var h = l.words,
        g = p.words,
        T = y.words,
        R = 0,
        x,
        f,
        _,
        P = h[0] | 0,
        M = P & 8191,
        D = P >>> 13,
        q = h[1] | 0,
        B = q & 8191,
        H = q >>> 13,
        Q = h[2] | 0,
        Z = Q & 8191,
        te = Q >>> 13,
        Te = h[3] | 0,
        K = Te & 8191,
        G = Te >>> 13,
        he = h[4] | 0,
        se = he & 8191,
        pe = he >>> 13,
        Y = h[5] | 0,
        $ = Y & 8191,
        W = Y >>> 13,
        re = h[6] | 0,
        ee = re & 8191,
        ce = re >>> 13,
        Ce = h[7] | 0,
        me = Ce & 8191,
        ge = Ce >>> 13,
        it = h[8] | 0,
        ve = it & 8191,
        z = it >>> 13,
        U = h[9] | 0,
        L = U & 8191,
        J = U >>> 13,
        fe = g[0] | 0,
        ie = fe & 8191,
        le = fe >>> 13,
        nt = g[1] | 0,
        Ee = nt & 8191,
        we = nt >>> 13,
        ft = g[2] | 0,
        xe = ft & 8191,
        Pe = ft >>> 13,
        hr = g[3] | 0,
        Ne = hr & 8191,
        Me = hr >>> 13,
        _r = g[4] | 0,
        Be = _r & 8191,
        De = _r >>> 13,
        pr = g[5] | 0,
        Oe = pr & 8191,
        Fe = pr >>> 13,
        mr = g[6] | 0,
        Le = mr & 8191,
        Ie = mr >>> 13,
        At = g[7] | 0,
        Ae = At & 8191,
        Re = At >>> 13,
        Er = g[8] | 0,
        $e = Er & 8191,
        Ue = Er >>> 13,
        Mr = g[9] | 0,
        We = Mr & 8191,
        je = Mr >>> 13;
      (y.negative = l.negative ^ p.negative),
        (y.length = 19),
        (x = Math.imul(M, ie)),
        (f = Math.imul(M, le)),
        (f = (f + Math.imul(D, ie)) | 0),
        (_ = Math.imul(D, le));
      var ur = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (ur >>> 26)) | 0),
        (ur &= 67108863),
        (x = Math.imul(B, ie)),
        (f = Math.imul(B, le)),
        (f = (f + Math.imul(H, ie)) | 0),
        (_ = Math.imul(H, le)),
        (x = (x + Math.imul(M, Ee)) | 0),
        (f = (f + Math.imul(M, we)) | 0),
        (f = (f + Math.imul(D, Ee)) | 0),
        (_ = (_ + Math.imul(D, we)) | 0);
      var mt = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (mt >>> 26)) | 0),
        (mt &= 67108863),
        (x = Math.imul(Z, ie)),
        (f = Math.imul(Z, le)),
        (f = (f + Math.imul(te, ie)) | 0),
        (_ = Math.imul(te, le)),
        (x = (x + Math.imul(B, Ee)) | 0),
        (f = (f + Math.imul(B, we)) | 0),
        (f = (f + Math.imul(H, Ee)) | 0),
        (_ = (_ + Math.imul(H, we)) | 0),
        (x = (x + Math.imul(M, xe)) | 0),
        (f = (f + Math.imul(M, Pe)) | 0),
        (f = (f + Math.imul(D, xe)) | 0),
        (_ = (_ + Math.imul(D, Pe)) | 0);
      var yt = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (yt >>> 26)) | 0),
        (yt &= 67108863),
        (x = Math.imul(K, ie)),
        (f = Math.imul(K, le)),
        (f = (f + Math.imul(G, ie)) | 0),
        (_ = Math.imul(G, le)),
        (x = (x + Math.imul(Z, Ee)) | 0),
        (f = (f + Math.imul(Z, we)) | 0),
        (f = (f + Math.imul(te, Ee)) | 0),
        (_ = (_ + Math.imul(te, we)) | 0),
        (x = (x + Math.imul(B, xe)) | 0),
        (f = (f + Math.imul(B, Pe)) | 0),
        (f = (f + Math.imul(H, xe)) | 0),
        (_ = (_ + Math.imul(H, Pe)) | 0),
        (x = (x + Math.imul(M, Ne)) | 0),
        (f = (f + Math.imul(M, Me)) | 0),
        (f = (f + Math.imul(D, Ne)) | 0),
        (_ = (_ + Math.imul(D, Me)) | 0);
      var rr = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (rr >>> 26)) | 0),
        (rr &= 67108863),
        (x = Math.imul(se, ie)),
        (f = Math.imul(se, le)),
        (f = (f + Math.imul(pe, ie)) | 0),
        (_ = Math.imul(pe, le)),
        (x = (x + Math.imul(K, Ee)) | 0),
        (f = (f + Math.imul(K, we)) | 0),
        (f = (f + Math.imul(G, Ee)) | 0),
        (_ = (_ + Math.imul(G, we)) | 0),
        (x = (x + Math.imul(Z, xe)) | 0),
        (f = (f + Math.imul(Z, Pe)) | 0),
        (f = (f + Math.imul(te, xe)) | 0),
        (_ = (_ + Math.imul(te, Pe)) | 0),
        (x = (x + Math.imul(B, Ne)) | 0),
        (f = (f + Math.imul(B, Me)) | 0),
        (f = (f + Math.imul(H, Ne)) | 0),
        (_ = (_ + Math.imul(H, Me)) | 0),
        (x = (x + Math.imul(M, Be)) | 0),
        (f = (f + Math.imul(M, De)) | 0),
        (f = (f + Math.imul(D, Be)) | 0),
        (_ = (_ + Math.imul(D, De)) | 0);
      var nr = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (nr >>> 26)) | 0),
        (nr &= 67108863),
        (x = Math.imul($, ie)),
        (f = Math.imul($, le)),
        (f = (f + Math.imul(W, ie)) | 0),
        (_ = Math.imul(W, le)),
        (x = (x + Math.imul(se, Ee)) | 0),
        (f = (f + Math.imul(se, we)) | 0),
        (f = (f + Math.imul(pe, Ee)) | 0),
        (_ = (_ + Math.imul(pe, we)) | 0),
        (x = (x + Math.imul(K, xe)) | 0),
        (f = (f + Math.imul(K, Pe)) | 0),
        (f = (f + Math.imul(G, xe)) | 0),
        (_ = (_ + Math.imul(G, Pe)) | 0),
        (x = (x + Math.imul(Z, Ne)) | 0),
        (f = (f + Math.imul(Z, Me)) | 0),
        (f = (f + Math.imul(te, Ne)) | 0),
        (_ = (_ + Math.imul(te, Me)) | 0),
        (x = (x + Math.imul(B, Be)) | 0),
        (f = (f + Math.imul(B, De)) | 0),
        (f = (f + Math.imul(H, Be)) | 0),
        (_ = (_ + Math.imul(H, De)) | 0),
        (x = (x + Math.imul(M, Oe)) | 0),
        (f = (f + Math.imul(M, Fe)) | 0),
        (f = (f + Math.imul(D, Oe)) | 0),
        (_ = (_ + Math.imul(D, Fe)) | 0);
      var ir = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (ir >>> 26)) | 0),
        (ir &= 67108863),
        (x = Math.imul(ee, ie)),
        (f = Math.imul(ee, le)),
        (f = (f + Math.imul(ce, ie)) | 0),
        (_ = Math.imul(ce, le)),
        (x = (x + Math.imul($, Ee)) | 0),
        (f = (f + Math.imul($, we)) | 0),
        (f = (f + Math.imul(W, Ee)) | 0),
        (_ = (_ + Math.imul(W, we)) | 0),
        (x = (x + Math.imul(se, xe)) | 0),
        (f = (f + Math.imul(se, Pe)) | 0),
        (f = (f + Math.imul(pe, xe)) | 0),
        (_ = (_ + Math.imul(pe, Pe)) | 0),
        (x = (x + Math.imul(K, Ne)) | 0),
        (f = (f + Math.imul(K, Me)) | 0),
        (f = (f + Math.imul(G, Ne)) | 0),
        (_ = (_ + Math.imul(G, Me)) | 0),
        (x = (x + Math.imul(Z, Be)) | 0),
        (f = (f + Math.imul(Z, De)) | 0),
        (f = (f + Math.imul(te, Be)) | 0),
        (_ = (_ + Math.imul(te, De)) | 0),
        (x = (x + Math.imul(B, Oe)) | 0),
        (f = (f + Math.imul(B, Fe)) | 0),
        (f = (f + Math.imul(H, Oe)) | 0),
        (_ = (_ + Math.imul(H, Fe)) | 0),
        (x = (x + Math.imul(M, Le)) | 0),
        (f = (f + Math.imul(M, Ie)) | 0),
        (f = (f + Math.imul(D, Le)) | 0),
        (_ = (_ + Math.imul(D, Ie)) | 0);
      var ar = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (ar >>> 26)) | 0),
        (ar &= 67108863),
        (x = Math.imul(me, ie)),
        (f = Math.imul(me, le)),
        (f = (f + Math.imul(ge, ie)) | 0),
        (_ = Math.imul(ge, le)),
        (x = (x + Math.imul(ee, Ee)) | 0),
        (f = (f + Math.imul(ee, we)) | 0),
        (f = (f + Math.imul(ce, Ee)) | 0),
        (_ = (_ + Math.imul(ce, we)) | 0),
        (x = (x + Math.imul($, xe)) | 0),
        (f = (f + Math.imul($, Pe)) | 0),
        (f = (f + Math.imul(W, xe)) | 0),
        (_ = (_ + Math.imul(W, Pe)) | 0),
        (x = (x + Math.imul(se, Ne)) | 0),
        (f = (f + Math.imul(se, Me)) | 0),
        (f = (f + Math.imul(pe, Ne)) | 0),
        (_ = (_ + Math.imul(pe, Me)) | 0),
        (x = (x + Math.imul(K, Be)) | 0),
        (f = (f + Math.imul(K, De)) | 0),
        (f = (f + Math.imul(G, Be)) | 0),
        (_ = (_ + Math.imul(G, De)) | 0),
        (x = (x + Math.imul(Z, Oe)) | 0),
        (f = (f + Math.imul(Z, Fe)) | 0),
        (f = (f + Math.imul(te, Oe)) | 0),
        (_ = (_ + Math.imul(te, Fe)) | 0),
        (x = (x + Math.imul(B, Le)) | 0),
        (f = (f + Math.imul(B, Ie)) | 0),
        (f = (f + Math.imul(H, Le)) | 0),
        (_ = (_ + Math.imul(H, Ie)) | 0),
        (x = (x + Math.imul(M, Ae)) | 0),
        (f = (f + Math.imul(M, Re)) | 0),
        (f = (f + Math.imul(D, Ae)) | 0),
        (_ = (_ + Math.imul(D, Re)) | 0);
      var sr = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (sr >>> 26)) | 0),
        (sr &= 67108863),
        (x = Math.imul(ve, ie)),
        (f = Math.imul(ve, le)),
        (f = (f + Math.imul(z, ie)) | 0),
        (_ = Math.imul(z, le)),
        (x = (x + Math.imul(me, Ee)) | 0),
        (f = (f + Math.imul(me, we)) | 0),
        (f = (f + Math.imul(ge, Ee)) | 0),
        (_ = (_ + Math.imul(ge, we)) | 0),
        (x = (x + Math.imul(ee, xe)) | 0),
        (f = (f + Math.imul(ee, Pe)) | 0),
        (f = (f + Math.imul(ce, xe)) | 0),
        (_ = (_ + Math.imul(ce, Pe)) | 0),
        (x = (x + Math.imul($, Ne)) | 0),
        (f = (f + Math.imul($, Me)) | 0),
        (f = (f + Math.imul(W, Ne)) | 0),
        (_ = (_ + Math.imul(W, Me)) | 0),
        (x = (x + Math.imul(se, Be)) | 0),
        (f = (f + Math.imul(se, De)) | 0),
        (f = (f + Math.imul(pe, Be)) | 0),
        (_ = (_ + Math.imul(pe, De)) | 0),
        (x = (x + Math.imul(K, Oe)) | 0),
        (f = (f + Math.imul(K, Fe)) | 0),
        (f = (f + Math.imul(G, Oe)) | 0),
        (_ = (_ + Math.imul(G, Fe)) | 0),
        (x = (x + Math.imul(Z, Le)) | 0),
        (f = (f + Math.imul(Z, Ie)) | 0),
        (f = (f + Math.imul(te, Le)) | 0),
        (_ = (_ + Math.imul(te, Ie)) | 0),
        (x = (x + Math.imul(B, Ae)) | 0),
        (f = (f + Math.imul(B, Re)) | 0),
        (f = (f + Math.imul(H, Ae)) | 0),
        (_ = (_ + Math.imul(H, Re)) | 0),
        (x = (x + Math.imul(M, $e)) | 0),
        (f = (f + Math.imul(M, Ue)) | 0),
        (f = (f + Math.imul(D, $e)) | 0),
        (_ = (_ + Math.imul(D, Ue)) | 0);
      var Ir = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (Ir >>> 26)) | 0),
        (Ir &= 67108863),
        (x = Math.imul(L, ie)),
        (f = Math.imul(L, le)),
        (f = (f + Math.imul(J, ie)) | 0),
        (_ = Math.imul(J, le)),
        (x = (x + Math.imul(ve, Ee)) | 0),
        (f = (f + Math.imul(ve, we)) | 0),
        (f = (f + Math.imul(z, Ee)) | 0),
        (_ = (_ + Math.imul(z, we)) | 0),
        (x = (x + Math.imul(me, xe)) | 0),
        (f = (f + Math.imul(me, Pe)) | 0),
        (f = (f + Math.imul(ge, xe)) | 0),
        (_ = (_ + Math.imul(ge, Pe)) | 0),
        (x = (x + Math.imul(ee, Ne)) | 0),
        (f = (f + Math.imul(ee, Me)) | 0),
        (f = (f + Math.imul(ce, Ne)) | 0),
        (_ = (_ + Math.imul(ce, Me)) | 0),
        (x = (x + Math.imul($, Be)) | 0),
        (f = (f + Math.imul($, De)) | 0),
        (f = (f + Math.imul(W, Be)) | 0),
        (_ = (_ + Math.imul(W, De)) | 0),
        (x = (x + Math.imul(se, Oe)) | 0),
        (f = (f + Math.imul(se, Fe)) | 0),
        (f = (f + Math.imul(pe, Oe)) | 0),
        (_ = (_ + Math.imul(pe, Fe)) | 0),
        (x = (x + Math.imul(K, Le)) | 0),
        (f = (f + Math.imul(K, Ie)) | 0),
        (f = (f + Math.imul(G, Le)) | 0),
        (_ = (_ + Math.imul(G, Ie)) | 0),
        (x = (x + Math.imul(Z, Ae)) | 0),
        (f = (f + Math.imul(Z, Re)) | 0),
        (f = (f + Math.imul(te, Ae)) | 0),
        (_ = (_ + Math.imul(te, Re)) | 0),
        (x = (x + Math.imul(B, $e)) | 0),
        (f = (f + Math.imul(B, Ue)) | 0),
        (f = (f + Math.imul(H, $e)) | 0),
        (_ = (_ + Math.imul(H, Ue)) | 0),
        (x = (x + Math.imul(M, We)) | 0),
        (f = (f + Math.imul(M, je)) | 0),
        (f = (f + Math.imul(D, We)) | 0),
        (_ = (_ + Math.imul(D, je)) | 0);
      var Rr = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (Rr >>> 26)) | 0),
        (Rr &= 67108863),
        (x = Math.imul(L, Ee)),
        (f = Math.imul(L, we)),
        (f = (f + Math.imul(J, Ee)) | 0),
        (_ = Math.imul(J, we)),
        (x = (x + Math.imul(ve, xe)) | 0),
        (f = (f + Math.imul(ve, Pe)) | 0),
        (f = (f + Math.imul(z, xe)) | 0),
        (_ = (_ + Math.imul(z, Pe)) | 0),
        (x = (x + Math.imul(me, Ne)) | 0),
        (f = (f + Math.imul(me, Me)) | 0),
        (f = (f + Math.imul(ge, Ne)) | 0),
        (_ = (_ + Math.imul(ge, Me)) | 0),
        (x = (x + Math.imul(ee, Be)) | 0),
        (f = (f + Math.imul(ee, De)) | 0),
        (f = (f + Math.imul(ce, Be)) | 0),
        (_ = (_ + Math.imul(ce, De)) | 0),
        (x = (x + Math.imul($, Oe)) | 0),
        (f = (f + Math.imul($, Fe)) | 0),
        (f = (f + Math.imul(W, Oe)) | 0),
        (_ = (_ + Math.imul(W, Fe)) | 0),
        (x = (x + Math.imul(se, Le)) | 0),
        (f = (f + Math.imul(se, Ie)) | 0),
        (f = (f + Math.imul(pe, Le)) | 0),
        (_ = (_ + Math.imul(pe, Ie)) | 0),
        (x = (x + Math.imul(K, Ae)) | 0),
        (f = (f + Math.imul(K, Re)) | 0),
        (f = (f + Math.imul(G, Ae)) | 0),
        (_ = (_ + Math.imul(G, Re)) | 0),
        (x = (x + Math.imul(Z, $e)) | 0),
        (f = (f + Math.imul(Z, Ue)) | 0),
        (f = (f + Math.imul(te, $e)) | 0),
        (_ = (_ + Math.imul(te, Ue)) | 0),
        (x = (x + Math.imul(B, We)) | 0),
        (f = (f + Math.imul(B, je)) | 0),
        (f = (f + Math.imul(H, We)) | 0),
        (_ = (_ + Math.imul(H, je)) | 0);
      var Pr = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (Pr >>> 26)) | 0),
        (Pr &= 67108863),
        (x = Math.imul(L, xe)),
        (f = Math.imul(L, Pe)),
        (f = (f + Math.imul(J, xe)) | 0),
        (_ = Math.imul(J, Pe)),
        (x = (x + Math.imul(ve, Ne)) | 0),
        (f = (f + Math.imul(ve, Me)) | 0),
        (f = (f + Math.imul(z, Ne)) | 0),
        (_ = (_ + Math.imul(z, Me)) | 0),
        (x = (x + Math.imul(me, Be)) | 0),
        (f = (f + Math.imul(me, De)) | 0),
        (f = (f + Math.imul(ge, Be)) | 0),
        (_ = (_ + Math.imul(ge, De)) | 0),
        (x = (x + Math.imul(ee, Oe)) | 0),
        (f = (f + Math.imul(ee, Fe)) | 0),
        (f = (f + Math.imul(ce, Oe)) | 0),
        (_ = (_ + Math.imul(ce, Fe)) | 0),
        (x = (x + Math.imul($, Le)) | 0),
        (f = (f + Math.imul($, Ie)) | 0),
        (f = (f + Math.imul(W, Le)) | 0),
        (_ = (_ + Math.imul(W, Ie)) | 0),
        (x = (x + Math.imul(se, Ae)) | 0),
        (f = (f + Math.imul(se, Re)) | 0),
        (f = (f + Math.imul(pe, Ae)) | 0),
        (_ = (_ + Math.imul(pe, Re)) | 0),
        (x = (x + Math.imul(K, $e)) | 0),
        (f = (f + Math.imul(K, Ue)) | 0),
        (f = (f + Math.imul(G, $e)) | 0),
        (_ = (_ + Math.imul(G, Ue)) | 0),
        (x = (x + Math.imul(Z, We)) | 0),
        (f = (f + Math.imul(Z, je)) | 0),
        (f = (f + Math.imul(te, We)) | 0),
        (_ = (_ + Math.imul(te, je)) | 0);
      var Nr = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (Nr >>> 26)) | 0),
        (Nr &= 67108863),
        (x = Math.imul(L, Ne)),
        (f = Math.imul(L, Me)),
        (f = (f + Math.imul(J, Ne)) | 0),
        (_ = Math.imul(J, Me)),
        (x = (x + Math.imul(ve, Be)) | 0),
        (f = (f + Math.imul(ve, De)) | 0),
        (f = (f + Math.imul(z, Be)) | 0),
        (_ = (_ + Math.imul(z, De)) | 0),
        (x = (x + Math.imul(me, Oe)) | 0),
        (f = (f + Math.imul(me, Fe)) | 0),
        (f = (f + Math.imul(ge, Oe)) | 0),
        (_ = (_ + Math.imul(ge, Fe)) | 0),
        (x = (x + Math.imul(ee, Le)) | 0),
        (f = (f + Math.imul(ee, Ie)) | 0),
        (f = (f + Math.imul(ce, Le)) | 0),
        (_ = (_ + Math.imul(ce, Ie)) | 0),
        (x = (x + Math.imul($, Ae)) | 0),
        (f = (f + Math.imul($, Re)) | 0),
        (f = (f + Math.imul(W, Ae)) | 0),
        (_ = (_ + Math.imul(W, Re)) | 0),
        (x = (x + Math.imul(se, $e)) | 0),
        (f = (f + Math.imul(se, Ue)) | 0),
        (f = (f + Math.imul(pe, $e)) | 0),
        (_ = (_ + Math.imul(pe, Ue)) | 0),
        (x = (x + Math.imul(K, We)) | 0),
        (f = (f + Math.imul(K, je)) | 0),
        (f = (f + Math.imul(G, We)) | 0),
        (_ = (_ + Math.imul(G, je)) | 0);
      var Br = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (Br >>> 26)) | 0),
        (Br &= 67108863),
        (x = Math.imul(L, Be)),
        (f = Math.imul(L, De)),
        (f = (f + Math.imul(J, Be)) | 0),
        (_ = Math.imul(J, De)),
        (x = (x + Math.imul(ve, Oe)) | 0),
        (f = (f + Math.imul(ve, Fe)) | 0),
        (f = (f + Math.imul(z, Oe)) | 0),
        (_ = (_ + Math.imul(z, Fe)) | 0),
        (x = (x + Math.imul(me, Le)) | 0),
        (f = (f + Math.imul(me, Ie)) | 0),
        (f = (f + Math.imul(ge, Le)) | 0),
        (_ = (_ + Math.imul(ge, Ie)) | 0),
        (x = (x + Math.imul(ee, Ae)) | 0),
        (f = (f + Math.imul(ee, Re)) | 0),
        (f = (f + Math.imul(ce, Ae)) | 0),
        (_ = (_ + Math.imul(ce, Re)) | 0),
        (x = (x + Math.imul($, $e)) | 0),
        (f = (f + Math.imul($, Ue)) | 0),
        (f = (f + Math.imul(W, $e)) | 0),
        (_ = (_ + Math.imul(W, Ue)) | 0),
        (x = (x + Math.imul(se, We)) | 0),
        (f = (f + Math.imul(se, je)) | 0),
        (f = (f + Math.imul(pe, We)) | 0),
        (_ = (_ + Math.imul(pe, je)) | 0);
      var Dr = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (Dr >>> 26)) | 0),
        (Dr &= 67108863),
        (x = Math.imul(L, Oe)),
        (f = Math.imul(L, Fe)),
        (f = (f + Math.imul(J, Oe)) | 0),
        (_ = Math.imul(J, Fe)),
        (x = (x + Math.imul(ve, Le)) | 0),
        (f = (f + Math.imul(ve, Ie)) | 0),
        (f = (f + Math.imul(z, Le)) | 0),
        (_ = (_ + Math.imul(z, Ie)) | 0),
        (x = (x + Math.imul(me, Ae)) | 0),
        (f = (f + Math.imul(me, Re)) | 0),
        (f = (f + Math.imul(ge, Ae)) | 0),
        (_ = (_ + Math.imul(ge, Re)) | 0),
        (x = (x + Math.imul(ee, $e)) | 0),
        (f = (f + Math.imul(ee, Ue)) | 0),
        (f = (f + Math.imul(ce, $e)) | 0),
        (_ = (_ + Math.imul(ce, Ue)) | 0),
        (x = (x + Math.imul($, We)) | 0),
        (f = (f + Math.imul($, je)) | 0),
        (f = (f + Math.imul(W, We)) | 0),
        (_ = (_ + Math.imul(W, je)) | 0);
      var Or = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (Or >>> 26)) | 0),
        (Or &= 67108863),
        (x = Math.imul(L, Le)),
        (f = Math.imul(L, Ie)),
        (f = (f + Math.imul(J, Le)) | 0),
        (_ = Math.imul(J, Ie)),
        (x = (x + Math.imul(ve, Ae)) | 0),
        (f = (f + Math.imul(ve, Re)) | 0),
        (f = (f + Math.imul(z, Ae)) | 0),
        (_ = (_ + Math.imul(z, Re)) | 0),
        (x = (x + Math.imul(me, $e)) | 0),
        (f = (f + Math.imul(me, Ue)) | 0),
        (f = (f + Math.imul(ge, $e)) | 0),
        (_ = (_ + Math.imul(ge, Ue)) | 0),
        (x = (x + Math.imul(ee, We)) | 0),
        (f = (f + Math.imul(ee, je)) | 0),
        (f = (f + Math.imul(ce, We)) | 0),
        (_ = (_ + Math.imul(ce, je)) | 0);
      var Fr = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (Fr >>> 26)) | 0),
        (Fr &= 67108863),
        (x = Math.imul(L, Ae)),
        (f = Math.imul(L, Re)),
        (f = (f + Math.imul(J, Ae)) | 0),
        (_ = Math.imul(J, Re)),
        (x = (x + Math.imul(ve, $e)) | 0),
        (f = (f + Math.imul(ve, Ue)) | 0),
        (f = (f + Math.imul(z, $e)) | 0),
        (_ = (_ + Math.imul(z, Ue)) | 0),
        (x = (x + Math.imul(me, We)) | 0),
        (f = (f + Math.imul(me, je)) | 0),
        (f = (f + Math.imul(ge, We)) | 0),
        (_ = (_ + Math.imul(ge, je)) | 0);
      var Lr = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (Lr >>> 26)) | 0),
        (Lr &= 67108863),
        (x = Math.imul(L, $e)),
        (f = Math.imul(L, Ue)),
        (f = (f + Math.imul(J, $e)) | 0),
        (_ = Math.imul(J, Ue)),
        (x = (x + Math.imul(ve, We)) | 0),
        (f = (f + Math.imul(ve, je)) | 0),
        (f = (f + Math.imul(z, We)) | 0),
        (_ = (_ + Math.imul(z, je)) | 0);
      var bn = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (bn >>> 26)) | 0),
        (bn &= 67108863),
        (x = Math.imul(L, We)),
        (f = Math.imul(L, je)),
        (f = (f + Math.imul(J, We)) | 0),
        (_ = Math.imul(J, je));
      var vn = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      return (
        (R = (((_ + (f >>> 13)) | 0) + (vn >>> 26)) | 0),
        (vn &= 67108863),
        (T[0] = ur),
        (T[1] = mt),
        (T[2] = yt),
        (T[3] = rr),
        (T[4] = nr),
        (T[5] = ir),
        (T[6] = ar),
        (T[7] = sr),
        (T[8] = Ir),
        (T[9] = Rr),
        (T[10] = Pr),
        (T[11] = Nr),
        (T[12] = Br),
        (T[13] = Dr),
        (T[14] = Or),
        (T[15] = Fr),
        (T[16] = Lr),
        (T[17] = bn),
        (T[18] = vn),
        R !== 0 && ((T[19] = R), y.length++),
        y
      );
    };
    Math.imul || (A = E);
    function I(C, l, p) {
      (p.negative = l.negative ^ C.negative), (p.length = C.length + l.length);
      for (var y = 0, h = 0, g = 0; g < p.length - 1; g++) {
        var T = h;
        h = 0;
        for (
          var R = y & 67108863,
            x = Math.min(g, l.length - 1),
            f = Math.max(0, g - C.length + 1);
          f <= x;
          f++
        ) {
          var _ = g - f,
            P = C.words[_] | 0,
            M = l.words[f] | 0,
            D = P * M,
            q = D & 67108863;
          (T = (T + ((D / 67108864) | 0)) | 0),
            (q = (q + R) | 0),
            (R = q & 67108863),
            (T = (T + (q >>> 26)) | 0),
            (h += T >>> 26),
            (T &= 67108863);
        }
        (p.words[g] = R), (y = T), (T = h);
      }
      return y !== 0 ? (p.words[g] = y) : p.length--, p.strip();
    }
    function b(C, l, p) {
      var y = new w();
      return y.mulp(C, l, p);
    }
    a.prototype.mulTo = function (l, p) {
      var y,
        h = this.length + l.length;
      return (
        this.length === 10 && l.length === 10
          ? (y = A(this, l, p))
          : h < 63
          ? (y = E(this, l, p))
          : h < 1024
          ? (y = I(this, l, p))
          : (y = b(this, l, p)),
        y
      );
    };
    function w(C, l) {
      (this.x = C), (this.y = l);
    }
    (w.prototype.makeRBT = function (l) {
      for (
        var p = new Array(l), y = a.prototype._countBits(l) - 1, h = 0;
        h < l;
        h++
      )
        p[h] = this.revBin(h, y, l);
      return p;
    }),
      (w.prototype.revBin = function (l, p, y) {
        if (l === 0 || l === y - 1) return l;
        for (var h = 0, g = 0; g < p; g++)
          (h |= (l & 1) << (p - g - 1)), (l >>= 1);
        return h;
      }),
      (w.prototype.permute = function (l, p, y, h, g, T) {
        for (var R = 0; R < T; R++) (h[R] = p[l[R]]), (g[R] = y[l[R]]);
      }),
      (w.prototype.transform = function (l, p, y, h, g, T) {
        this.permute(T, l, p, y, h, g);
        for (var R = 1; R < g; R <<= 1)
          for (
            var x = R << 1,
              f = Math.cos((2 * Math.PI) / x),
              _ = Math.sin((2 * Math.PI) / x),
              P = 0;
            P < g;
            P += x
          )
            for (var M = f, D = _, q = 0; q < R; q++) {
              var B = y[P + q],
                H = h[P + q],
                Q = y[P + q + R],
                Z = h[P + q + R],
                te = M * Q - D * Z;
              (Z = M * Z + D * Q),
                (Q = te),
                (y[P + q] = B + Q),
                (h[P + q] = H + Z),
                (y[P + q + R] = B - Q),
                (h[P + q + R] = H - Z),
                q !== x &&
                  ((te = f * M - _ * D), (D = f * D + _ * M), (M = te));
            }
      }),
      (w.prototype.guessLen13b = function (l, p) {
        var y = Math.max(p, l) | 1,
          h = y & 1,
          g = 0;
        for (y = (y / 2) | 0; y; y = y >>> 1) g++;
        return 1 << (g + 1 + h);
      }),
      (w.prototype.conjugate = function (l, p, y) {
        if (!(y <= 1))
          for (var h = 0; h < y / 2; h++) {
            var g = l[h];
            (l[h] = l[y - h - 1]),
              (l[y - h - 1] = g),
              (g = p[h]),
              (p[h] = -p[y - h - 1]),
              (p[y - h - 1] = -g);
          }
      }),
      (w.prototype.normalize13b = function (l, p) {
        for (var y = 0, h = 0; h < p / 2; h++) {
          var g =
            Math.round(l[2 * h + 1] / p) * 8192 + Math.round(l[2 * h] / p) + y;
          (l[h] = g & 67108863),
            g < 67108864 ? (y = 0) : (y = (g / 67108864) | 0);
        }
        return l;
      }),
      (w.prototype.convert13b = function (l, p, y, h) {
        for (var g = 0, T = 0; T < p; T++)
          (g = g + (l[T] | 0)),
            (y[2 * T] = g & 8191),
            (g = g >>> 13),
            (y[2 * T + 1] = g & 8191),
            (g = g >>> 13);
        for (T = 2 * p; T < h; ++T) y[T] = 0;
        n(g === 0), n((g & -8192) === 0);
      }),
      (w.prototype.stub = function (l) {
        for (var p = new Array(l), y = 0; y < l; y++) p[y] = 0;
        return p;
      }),
      (w.prototype.mulp = function (l, p, y) {
        var h = 2 * this.guessLen13b(l.length, p.length),
          g = this.makeRBT(h),
          T = this.stub(h),
          R = new Array(h),
          x = new Array(h),
          f = new Array(h),
          _ = new Array(h),
          P = new Array(h),
          M = new Array(h),
          D = y.words;
        (D.length = h),
          this.convert13b(l.words, l.length, R, h),
          this.convert13b(p.words, p.length, _, h),
          this.transform(R, T, x, f, h, g),
          this.transform(_, T, P, M, h, g);
        for (var q = 0; q < h; q++) {
          var B = x[q] * P[q] - f[q] * M[q];
          (f[q] = x[q] * M[q] + f[q] * P[q]), (x[q] = B);
        }
        return (
          this.conjugate(x, f, h),
          this.transform(x, f, D, T, h, g),
          this.conjugate(D, T, h),
          this.normalize13b(D, h),
          (y.negative = l.negative ^ p.negative),
          (y.length = l.length + p.length),
          y.strip()
        );
      }),
      (a.prototype.mul = function (l) {
        var p = new a(null);
        return (p.words = new Array(this.length + l.length)), this.mulTo(l, p);
      }),
      (a.prototype.mulf = function (l) {
        var p = new a(null);
        return (p.words = new Array(this.length + l.length)), b(this, l, p);
      }),
      (a.prototype.imul = function (l) {
        return this.clone().mulTo(l, this);
      }),
      (a.prototype.imuln = function (l) {
        n(typeof l == "number"), n(l < 67108864);
        for (var p = 0, y = 0; y < this.length; y++) {
          var h = (this.words[y] | 0) * l,
            g = (h & 67108863) + (p & 67108863);
          (p >>= 26),
            (p += (h / 67108864) | 0),
            (p += g >>> 26),
            (this.words[y] = g & 67108863);
        }
        return p !== 0 && ((this.words[y] = p), this.length++), this;
      }),
      (a.prototype.muln = function (l) {
        return this.clone().imuln(l);
      }),
      (a.prototype.sqr = function () {
        return this.mul(this);
      }),
      (a.prototype.isqr = function () {
        return this.imul(this.clone());
      }),
      (a.prototype.pow = function (l) {
        var p = v(l);
        if (p.length === 0) return new a(1);
        for (var y = this, h = 0; h < p.length && p[h] === 0; h++, y = y.sqr());
        if (++h < p.length)
          for (var g = y.sqr(); h < p.length; h++, g = g.sqr())
            p[h] !== 0 && (y = y.mul(g));
        return y;
      }),
      (a.prototype.iushln = function (l) {
        n(typeof l == "number" && l >= 0);
        var p = l % 26,
          y = (l - p) / 26,
          h = (67108863 >>> (26 - p)) << (26 - p),
          g;
        if (p !== 0) {
          var T = 0;
          for (g = 0; g < this.length; g++) {
            var R = this.words[g] & h,
              x = ((this.words[g] | 0) - R) << p;
            (this.words[g] = x | T), (T = R >>> (26 - p));
          }
          T && ((this.words[g] = T), this.length++);
        }
        if (y !== 0) {
          for (g = this.length - 1; g >= 0; g--)
            this.words[g + y] = this.words[g];
          for (g = 0; g < y; g++) this.words[g] = 0;
          this.length += y;
        }
        return this.strip();
      }),
      (a.prototype.ishln = function (l) {
        return n(this.negative === 0), this.iushln(l);
      }),
      (a.prototype.iushrn = function (l, p, y) {
        n(typeof l == "number" && l >= 0);
        var h;
        p ? (h = (p - (p % 26)) / 26) : (h = 0);
        var g = l % 26,
          T = Math.min((l - g) / 26, this.length),
          R = 67108863 ^ ((67108863 >>> g) << g),
          x = y;
        if (((h -= T), (h = Math.max(0, h)), x)) {
          for (var f = 0; f < T; f++) x.words[f] = this.words[f];
          x.length = T;
        }
        if (T !== 0)
          if (this.length > T)
            for (this.length -= T, f = 0; f < this.length; f++)
              this.words[f] = this.words[f + T];
          else (this.words[0] = 0), (this.length = 1);
        var _ = 0;
        for (f = this.length - 1; f >= 0 && (_ !== 0 || f >= h); f--) {
          var P = this.words[f] | 0;
          (this.words[f] = (_ << (26 - g)) | (P >>> g)), (_ = P & R);
        }
        return (
          x && _ !== 0 && (x.words[x.length++] = _),
          this.length === 0 && ((this.words[0] = 0), (this.length = 1)),
          this.strip()
        );
      }),
      (a.prototype.ishrn = function (l, p, y) {
        return n(this.negative === 0), this.iushrn(l, p, y);
      }),
      (a.prototype.shln = function (l) {
        return this.clone().ishln(l);
      }),
      (a.prototype.ushln = function (l) {
        return this.clone().iushln(l);
      }),
      (a.prototype.shrn = function (l) {
        return this.clone().ishrn(l);
      }),
      (a.prototype.ushrn = function (l) {
        return this.clone().iushrn(l);
      }),
      (a.prototype.testn = function (l) {
        n(typeof l == "number" && l >= 0);
        var p = l % 26,
          y = (l - p) / 26,
          h = 1 << p;
        if (this.length <= y) return !1;
        var g = this.words[y];
        return !!(g & h);
      }),
      (a.prototype.imaskn = function (l) {
        n(typeof l == "number" && l >= 0);
        var p = l % 26,
          y = (l - p) / 26;
        if (
          (n(this.negative === 0, "imaskn works only with positive numbers"),
          this.length <= y)
        )
          return this;
        if (
          (p !== 0 && y++, (this.length = Math.min(y, this.length)), p !== 0)
        ) {
          var h = 67108863 ^ ((67108863 >>> p) << p);
          this.words[this.length - 1] &= h;
        }
        return this.strip();
      }),
      (a.prototype.maskn = function (l) {
        return this.clone().imaskn(l);
      }),
      (a.prototype.iaddn = function (l) {
        return (
          n(typeof l == "number"),
          n(l < 67108864),
          l < 0
            ? this.isubn(-l)
            : this.negative !== 0
            ? this.length === 1 && (this.words[0] | 0) < l
              ? ((this.words[0] = l - (this.words[0] | 0)),
                (this.negative = 0),
                this)
              : ((this.negative = 0), this.isubn(l), (this.negative = 1), this)
            : this._iaddn(l)
        );
      }),
      (a.prototype._iaddn = function (l) {
        this.words[0] += l;
        for (var p = 0; p < this.length && this.words[p] >= 67108864; p++)
          (this.words[p] -= 67108864),
            p === this.length - 1
              ? (this.words[p + 1] = 1)
              : this.words[p + 1]++;
        return (this.length = Math.max(this.length, p + 1)), this;
      }),
      (a.prototype.isubn = function (l) {
        if ((n(typeof l == "number"), n(l < 67108864), l < 0))
          return this.iaddn(-l);
        if (this.negative !== 0)
          return (this.negative = 0), this.iaddn(l), (this.negative = 1), this;
        if (((this.words[0] -= l), this.length === 1 && this.words[0] < 0))
          (this.words[0] = -this.words[0]), (this.negative = 1);
        else
          for (var p = 0; p < this.length && this.words[p] < 0; p++)
            (this.words[p] += 67108864), (this.words[p + 1] -= 1);
        return this.strip();
      }),
      (a.prototype.addn = function (l) {
        return this.clone().iaddn(l);
      }),
      (a.prototype.subn = function (l) {
        return this.clone().isubn(l);
      }),
      (a.prototype.iabs = function () {
        return (this.negative = 0), this;
      }),
      (a.prototype.abs = function () {
        return this.clone().iabs();
      }),
      (a.prototype._ishlnsubmul = function (l, p, y) {
        var h = l.length + y,
          g;
        this._expand(h);
        var T,
          R = 0;
        for (g = 0; g < l.length; g++) {
          T = (this.words[g + y] | 0) + R;
          var x = (l.words[g] | 0) * p;
          (T -= x & 67108863),
            (R = (T >> 26) - ((x / 67108864) | 0)),
            (this.words[g + y] = T & 67108863);
        }
        for (; g < this.length - y; g++)
          (T = (this.words[g + y] | 0) + R),
            (R = T >> 26),
            (this.words[g + y] = T & 67108863);
        if (R === 0) return this.strip();
        for (n(R === -1), R = 0, g = 0; g < this.length; g++)
          (T = -(this.words[g] | 0) + R),
            (R = T >> 26),
            (this.words[g] = T & 67108863);
        return (this.negative = 1), this.strip();
      }),
      (a.prototype._wordDiv = function (l, p) {
        var y = this.length - l.length,
          h = this.clone(),
          g = l,
          T = g.words[g.length - 1] | 0,
          R = this._countBits(T);
        (y = 26 - R),
          y !== 0 &&
            ((g = g.ushln(y)), h.iushln(y), (T = g.words[g.length - 1] | 0));
        var x = h.length - g.length,
          f;
        if (p !== "mod") {
          (f = new a(null)),
            (f.length = x + 1),
            (f.words = new Array(f.length));
          for (var _ = 0; _ < f.length; _++) f.words[_] = 0;
        }
        var P = h.clone()._ishlnsubmul(g, 1, x);
        P.negative === 0 && ((h = P), f && (f.words[x] = 1));
        for (var M = x - 1; M >= 0; M--) {
          var D =
            (h.words[g.length + M] | 0) * 67108864 +
            (h.words[g.length + M - 1] | 0);
          for (
            D = Math.min((D / T) | 0, 67108863), h._ishlnsubmul(g, D, M);
            h.negative !== 0;

          )
            D--,
              (h.negative = 0),
              h._ishlnsubmul(g, 1, M),
              h.isZero() || (h.negative ^= 1);
          f && (f.words[M] = D);
        }
        return (
          f && f.strip(),
          h.strip(),
          p !== "div" && y !== 0 && h.iushrn(y),
          {
            div: f || null,
            mod: h,
          }
        );
      }),
      (a.prototype.divmod = function (l, p, y) {
        if ((n(!l.isZero()), this.isZero()))
          return {
            div: new a(0),
            mod: new a(0),
          };
        var h, g, T;
        return this.negative !== 0 && l.negative === 0
          ? ((T = this.neg().divmod(l, p)),
            p !== "mod" && (h = T.div.neg()),
            p !== "div" &&
              ((g = T.mod.neg()), y && g.negative !== 0 && g.iadd(l)),
            {
              div: h,
              mod: g,
            })
          : this.negative === 0 && l.negative !== 0
          ? ((T = this.divmod(l.neg(), p)),
            p !== "mod" && (h = T.div.neg()),
            {
              div: h,
              mod: T.mod,
            })
          : this.negative & l.negative
          ? ((T = this.neg().divmod(l.neg(), p)),
            p !== "div" &&
              ((g = T.mod.neg()), y && g.negative !== 0 && g.isub(l)),
            {
              div: T.div,
              mod: g,
            })
          : l.length > this.length || this.cmp(l) < 0
          ? {
              div: new a(0),
              mod: this,
            }
          : l.length === 1
          ? p === "div"
            ? {
                div: this.divn(l.words[0]),
                mod: null,
              }
            : p === "mod"
            ? {
                div: null,
                mod: new a(this.modn(l.words[0])),
              }
            : {
                div: this.divn(l.words[0]),
                mod: new a(this.modn(l.words[0])),
              }
          : this._wordDiv(l, p);
      }),
      (a.prototype.div = function (l) {
        return this.divmod(l, "div", !1).div;
      }),
      (a.prototype.mod = function (l) {
        return this.divmod(l, "mod", !1).mod;
      }),
      (a.prototype.umod = function (l) {
        return this.divmod(l, "mod", !0).mod;
      }),
      (a.prototype.divRound = function (l) {
        var p = this.divmod(l);
        if (p.mod.isZero()) return p.div;
        var y = p.div.negative !== 0 ? p.mod.isub(l) : p.mod,
          h = l.ushrn(1),
          g = l.andln(1),
          T = y.cmp(h);
        return T < 0 || (g === 1 && T === 0)
          ? p.div
          : p.div.negative !== 0
          ? p.div.isubn(1)
          : p.div.iaddn(1);
      }),
      (a.prototype.modn = function (l) {
        n(l <= 67108863);
        for (var p = (1 << 26) % l, y = 0, h = this.length - 1; h >= 0; h--)
          y = (p * y + (this.words[h] | 0)) % l;
        return y;
      }),
      (a.prototype.idivn = function (l) {
        n(l <= 67108863);
        for (var p = 0, y = this.length - 1; y >= 0; y--) {
          var h = (this.words[y] | 0) + p * 67108864;
          (this.words[y] = (h / l) | 0), (p = h % l);
        }
        return this.strip();
      }),
      (a.prototype.divn = function (l) {
        return this.clone().idivn(l);
      }),
      (a.prototype.egcd = function (l) {
        n(l.negative === 0), n(!l.isZero());
        var p = this,
          y = l.clone();
        p.negative !== 0 ? (p = p.umod(l)) : (p = p.clone());
        for (
          var h = new a(1), g = new a(0), T = new a(0), R = new a(1), x = 0;
          p.isEven() && y.isEven();

        )
          p.iushrn(1), y.iushrn(1), ++x;
        for (var f = y.clone(), _ = p.clone(); !p.isZero(); ) {
          for (var P = 0, M = 1; !(p.words[0] & M) && P < 26; ++P, M <<= 1);
          if (P > 0)
            for (p.iushrn(P); P-- > 0; )
              (h.isOdd() || g.isOdd()) && (h.iadd(f), g.isub(_)),
                h.iushrn(1),
                g.iushrn(1);
          for (var D = 0, q = 1; !(y.words[0] & q) && D < 26; ++D, q <<= 1);
          if (D > 0)
            for (y.iushrn(D); D-- > 0; )
              (T.isOdd() || R.isOdd()) && (T.iadd(f), R.isub(_)),
                T.iushrn(1),
                R.iushrn(1);
          p.cmp(y) >= 0
            ? (p.isub(y), h.isub(T), g.isub(R))
            : (y.isub(p), T.isub(h), R.isub(g));
        }
        return {
          a: T,
          b: R,
          gcd: y.iushln(x),
        };
      }),
      (a.prototype._invmp = function (l) {
        n(l.negative === 0), n(!l.isZero());
        var p = this,
          y = l.clone();
        p.negative !== 0 ? (p = p.umod(l)) : (p = p.clone());
        for (
          var h = new a(1), g = new a(0), T = y.clone();
          p.cmpn(1) > 0 && y.cmpn(1) > 0;

        ) {
          for (var R = 0, x = 1; !(p.words[0] & x) && R < 26; ++R, x <<= 1);
          if (R > 0)
            for (p.iushrn(R); R-- > 0; ) h.isOdd() && h.iadd(T), h.iushrn(1);
          for (var f = 0, _ = 1; !(y.words[0] & _) && f < 26; ++f, _ <<= 1);
          if (f > 0)
            for (y.iushrn(f); f-- > 0; ) g.isOdd() && g.iadd(T), g.iushrn(1);
          p.cmp(y) >= 0 ? (p.isub(y), h.isub(g)) : (y.isub(p), g.isub(h));
        }
        var P;
        return (
          p.cmpn(1) === 0 ? (P = h) : (P = g), P.cmpn(0) < 0 && P.iadd(l), P
        );
      }),
      (a.prototype.gcd = function (l) {
        if (this.isZero()) return l.abs();
        if (l.isZero()) return this.abs();
        var p = this.clone(),
          y = l.clone();
        (p.negative = 0), (y.negative = 0);
        for (var h = 0; p.isEven() && y.isEven(); h++) p.iushrn(1), y.iushrn(1);
        do {
          for (; p.isEven(); ) p.iushrn(1);
          for (; y.isEven(); ) y.iushrn(1);
          var g = p.cmp(y);
          if (g < 0) {
            var T = p;
            (p = y), (y = T);
          } else if (g === 0 || y.cmpn(1) === 0) break;
          p.isub(y);
        } while (!0);
        return y.iushln(h);
      }),
      (a.prototype.invm = function (l) {
        return this.egcd(l).a.umod(l);
      }),
      (a.prototype.isEven = function () {
        return (this.words[0] & 1) === 0;
      }),
      (a.prototype.isOdd = function () {
        return (this.words[0] & 1) === 1;
      }),
      (a.prototype.andln = function (l) {
        return this.words[0] & l;
      }),
      (a.prototype.bincn = function (l) {
        n(typeof l == "number");
        var p = l % 26,
          y = (l - p) / 26,
          h = 1 << p;
        if (this.length <= y)
          return this._expand(y + 1), (this.words[y] |= h), this;
        for (var g = h, T = y; g !== 0 && T < this.length; T++) {
          var R = this.words[T] | 0;
          (R += g), (g = R >>> 26), (R &= 67108863), (this.words[T] = R);
        }
        return g !== 0 && ((this.words[T] = g), this.length++), this;
      }),
      (a.prototype.isZero = function () {
        return this.length === 1 && this.words[0] === 0;
      }),
      (a.prototype.cmpn = function (l) {
        var p = l < 0;
        if (this.negative !== 0 && !p) return -1;
        if (this.negative === 0 && p) return 1;
        this.strip();
        var y;
        if (this.length > 1) y = 1;
        else {
          p && (l = -l), n(l <= 67108863, "Number is too big");
          var h = this.words[0] | 0;
          y = h === l ? 0 : h < l ? -1 : 1;
        }
        return this.negative !== 0 ? -y | 0 : y;
      }),
      (a.prototype.cmp = function (l) {
        if (this.negative !== 0 && l.negative === 0) return -1;
        if (this.negative === 0 && l.negative !== 0) return 1;
        var p = this.ucmp(l);
        return this.negative !== 0 ? -p | 0 : p;
      }),
      (a.prototype.ucmp = function (l) {
        if (this.length > l.length) return 1;
        if (this.length < l.length) return -1;
        for (var p = 0, y = this.length - 1; y >= 0; y--) {
          var h = this.words[y] | 0,
            g = l.words[y] | 0;
          if (h !== g) {
            h < g ? (p = -1) : h > g && (p = 1);
            break;
          }
        }
        return p;
      }),
      (a.prototype.gtn = function (l) {
        return this.cmpn(l) === 1;
      }),
      (a.prototype.gt = function (l) {
        return this.cmp(l) === 1;
      }),
      (a.prototype.gten = function (l) {
        return this.cmpn(l) >= 0;
      }),
      (a.prototype.gte = function (l) {
        return this.cmp(l) >= 0;
      }),
      (a.prototype.ltn = function (l) {
        return this.cmpn(l) === -1;
      }),
      (a.prototype.lt = function (l) {
        return this.cmp(l) === -1;
      }),
      (a.prototype.lten = function (l) {
        return this.cmpn(l) <= 0;
      }),
      (a.prototype.lte = function (l) {
        return this.cmp(l) <= 0;
      }),
      (a.prototype.eqn = function (l) {
        return this.cmpn(l) === 0;
      }),
      (a.prototype.eq = function (l) {
        return this.cmp(l) === 0;
      }),
      (a.red = function (l) {
        return new j(l);
      }),
      (a.prototype.toRed = function (l) {
        return (
          n(!this.red, "Already a number in reduction context"),
          n(this.negative === 0, "red works only with positives"),
          l.convertTo(this)._forceRed(l)
        );
      }),
      (a.prototype.fromRed = function () {
        return (
          n(this.red, "fromRed works only with numbers in reduction context"),
          this.red.convertFrom(this)
        );
      }),
      (a.prototype._forceRed = function (l) {
        return (this.red = l), this;
      }),
      (a.prototype.forceRed = function (l) {
        return (
          n(!this.red, "Already a number in reduction context"),
          this._forceRed(l)
        );
      }),
      (a.prototype.redAdd = function (l) {
        return (
          n(this.red, "redAdd works only with red numbers"),
          this.red.add(this, l)
        );
      }),
      (a.prototype.redIAdd = function (l) {
        return (
          n(this.red, "redIAdd works only with red numbers"),
          this.red.iadd(this, l)
        );
      }),
      (a.prototype.redSub = function (l) {
        return (
          n(this.red, "redSub works only with red numbers"),
          this.red.sub(this, l)
        );
      }),
      (a.prototype.redISub = function (l) {
        return (
          n(this.red, "redISub works only with red numbers"),
          this.red.isub(this, l)
        );
      }),
      (a.prototype.redShl = function (l) {
        return (
          n(this.red, "redShl works only with red numbers"),
          this.red.shl(this, l)
        );
      }),
      (a.prototype.redMul = function (l) {
        return (
          n(this.red, "redMul works only with red numbers"),
          this.red._verify2(this, l),
          this.red.mul(this, l)
        );
      }),
      (a.prototype.redIMul = function (l) {
        return (
          n(this.red, "redMul works only with red numbers"),
          this.red._verify2(this, l),
          this.red.imul(this, l)
        );
      }),
      (a.prototype.redSqr = function () {
        return (
          n(this.red, "redSqr works only with red numbers"),
          this.red._verify1(this),
          this.red.sqr(this)
        );
      }),
      (a.prototype.redISqr = function () {
        return (
          n(this.red, "redISqr works only with red numbers"),
          this.red._verify1(this),
          this.red.isqr(this)
        );
      }),
      (a.prototype.redSqrt = function () {
        return (
          n(this.red, "redSqrt works only with red numbers"),
          this.red._verify1(this),
          this.red.sqrt(this)
        );
      }),
      (a.prototype.redInvm = function () {
        return (
          n(this.red, "redInvm works only with red numbers"),
          this.red._verify1(this),
          this.red.invm(this)
        );
      }),
      (a.prototype.redNeg = function () {
        return (
          n(this.red, "redNeg works only with red numbers"),
          this.red._verify1(this),
          this.red.neg(this)
        );
      }),
      (a.prototype.redPow = function (l) {
        return (
          n(this.red && !l.red, "redPow(normalNum)"),
          this.red._verify1(this),
          this.red.pow(this, l)
        );
      });
    var S = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null,
    };
    function k(C, l) {
      (this.name = C),
        (this.p = new a(l, 16)),
        (this.n = this.p.bitLength()),
        (this.k = new a(1).iushln(this.n).isub(this.p)),
        (this.tmp = this._tmp());
    }
    (k.prototype._tmp = function () {
      var l = new a(null);
      return (l.words = new Array(Math.ceil(this.n / 13))), l;
    }),
      (k.prototype.ireduce = function (l) {
        var p = l,
          y;
        do
          this.split(p, this.tmp),
            (p = this.imulK(p)),
            (p = p.iadd(this.tmp)),
            (y = p.bitLength());
        while (y > this.n);
        var h = y < this.n ? -1 : p.ucmp(this.p);
        return (
          h === 0
            ? ((p.words[0] = 0), (p.length = 1))
            : h > 0
            ? p.isub(this.p)
            : p.strip(),
          p
        );
      }),
      (k.prototype.split = function (l, p) {
        l.iushrn(this.n, 0, p);
      }),
      (k.prototype.imulK = function (l) {
        return l.imul(this.k);
      });
    function N() {
      k.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    i(N, k),
      (N.prototype.split = function (l, p) {
        for (var y = 4194303, h = Math.min(l.length, 9), g = 0; g < h; g++)
          p.words[g] = l.words[g];
        if (((p.length = h), l.length <= 9)) {
          (l.words[0] = 0), (l.length = 1);
          return;
        }
        var T = l.words[9];
        for (p.words[p.length++] = T & y, g = 10; g < l.length; g++) {
          var R = l.words[g] | 0;
          (l.words[g - 10] = ((R & y) << 4) | (T >>> 22)), (T = R);
        }
        (T >>>= 22),
          (l.words[g - 10] = T),
          T === 0 && l.length > 10 ? (l.length -= 10) : (l.length -= 9);
      }),
      (N.prototype.imulK = function (l) {
        (l.words[l.length] = 0), (l.words[l.length + 1] = 0), (l.length += 2);
        for (var p = 0, y = 0; y < l.length; y++) {
          var h = l.words[y] | 0;
          (p += h * 977),
            (l.words[y] = p & 67108863),
            (p = h * 64 + ((p / 67108864) | 0));
        }
        return (
          l.words[l.length - 1] === 0 &&
            (l.length--, l.words[l.length - 1] === 0 && l.length--),
          l
        );
      });
    function O() {
      k.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    i(O, k);
    function F() {
      k.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    i(F, k);
    function V() {
      k.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    i(V, k),
      (V.prototype.imulK = function (l) {
        for (var p = 0, y = 0; y < l.length; y++) {
          var h = (l.words[y] | 0) * 19 + p,
            g = h & 67108863;
          (h >>>= 26), (l.words[y] = g), (p = h);
        }
        return p !== 0 && (l.words[l.length++] = p), l;
      }),
      (a._prime = function (l) {
        if (S[l]) return S[l];
        var p;
        if (l === "k256") p = new N();
        else if (l === "p224") p = new O();
        else if (l === "p192") p = new F();
        else if (l === "p25519") p = new V();
        else throw new Error("Unknown prime " + l);
        return (S[l] = p), p;
      });
    function j(C) {
      if (typeof C == "string") {
        var l = a._prime(C);
        (this.m = l.p), (this.prime = l);
      } else
        n(C.gtn(1), "modulus must be greater than 1"),
          (this.m = C),
          (this.prime = null);
    }
    (j.prototype._verify1 = function (l) {
      n(l.negative === 0, "red works only with positives"),
        n(l.red, "red works only with red numbers");
    }),
      (j.prototype._verify2 = function (l, p) {
        n((l.negative | p.negative) === 0, "red works only with positives"),
          n(l.red && l.red === p.red, "red works only with red numbers");
      }),
      (j.prototype.imod = function (l) {
        return this.prime
          ? this.prime.ireduce(l)._forceRed(this)
          : l.umod(this.m)._forceRed(this);
      }),
      (j.prototype.neg = function (l) {
        return l.isZero() ? l.clone() : this.m.sub(l)._forceRed(this);
      }),
      (j.prototype.add = function (l, p) {
        this._verify2(l, p);
        var y = l.add(p);
        return y.cmp(this.m) >= 0 && y.isub(this.m), y._forceRed(this);
      }),
      (j.prototype.iadd = function (l, p) {
        this._verify2(l, p);
        var y = l.iadd(p);
        return y.cmp(this.m) >= 0 && y.isub(this.m), y;
      }),
      (j.prototype.sub = function (l, p) {
        this._verify2(l, p);
        var y = l.sub(p);
        return y.cmpn(0) < 0 && y.iadd(this.m), y._forceRed(this);
      }),
      (j.prototype.isub = function (l, p) {
        this._verify2(l, p);
        var y = l.isub(p);
        return y.cmpn(0) < 0 && y.iadd(this.m), y;
      }),
      (j.prototype.shl = function (l, p) {
        return this._verify1(l), this.imod(l.ushln(p));
      }),
      (j.prototype.imul = function (l, p) {
        return this._verify2(l, p), this.imod(l.imul(p));
      }),
      (j.prototype.mul = function (l, p) {
        return this._verify2(l, p), this.imod(l.mul(p));
      }),
      (j.prototype.isqr = function (l) {
        return this.imul(l, l.clone());
      }),
      (j.prototype.sqr = function (l) {
        return this.mul(l, l);
      }),
      (j.prototype.sqrt = function (l) {
        if (l.isZero()) return l.clone();
        var p = this.m.andln(3);
        if ((n(p % 2 === 1), p === 3)) {
          var y = this.m.add(new a(1)).iushrn(2);
          return this.pow(l, y);
        }
        for (var h = this.m.subn(1), g = 0; !h.isZero() && h.andln(1) === 0; )
          g++, h.iushrn(1);
        n(!h.isZero());
        var T = new a(1).toRed(this),
          R = T.redNeg(),
          x = this.m.subn(1).iushrn(1),
          f = this.m.bitLength();
        for (f = new a(2 * f * f).toRed(this); this.pow(f, x).cmp(R) !== 0; )
          f.redIAdd(R);
        for (
          var _ = this.pow(f, h),
            P = this.pow(l, h.addn(1).iushrn(1)),
            M = this.pow(l, h),
            D = g;
          M.cmp(T) !== 0;

        ) {
          for (var q = M, B = 0; q.cmp(T) !== 0; B++) q = q.redSqr();
          n(B < D);
          var H = this.pow(_, new a(1).iushln(D - B - 1));
          (P = P.redMul(H)), (_ = H.redSqr()), (M = M.redMul(_)), (D = B);
        }
        return P;
      }),
      (j.prototype.invm = function (l) {
        var p = l._invmp(this.m);
        return p.negative !== 0
          ? ((p.negative = 0), this.imod(p).redNeg())
          : this.imod(p);
      }),
      (j.prototype.pow = function (l, p) {
        if (p.isZero()) return new a(1).toRed(this);
        if (p.cmpn(1) === 0) return l.clone();
        var y = 4,
          h = new Array(1 << y);
        (h[0] = new a(1).toRed(this)), (h[1] = l);
        for (var g = 2; g < h.length; g++) h[g] = this.mul(h[g - 1], l);
        var T = h[0],
          R = 0,
          x = 0,
          f = p.bitLength() % 26;
        for (f === 0 && (f = 26), g = p.length - 1; g >= 0; g--) {
          for (var _ = p.words[g], P = f - 1; P >= 0; P--) {
            var M = (_ >> P) & 1;
            if ((T !== h[0] && (T = this.sqr(T)), M === 0 && R === 0)) {
              x = 0;
              continue;
            }
            (R <<= 1),
              (R |= M),
              x++,
              !(x !== y && (g !== 0 || P !== 0)) &&
                ((T = this.mul(T, h[R])), (x = 0), (R = 0));
          }
          f = 26;
        }
        return T;
      }),
      (j.prototype.convertTo = function (l) {
        var p = l.umod(this.m);
        return p === l ? p.clone() : p;
      }),
      (j.prototype.convertFrom = function (l) {
        var p = l.clone();
        return (p.red = null), p;
      }),
      (a.mont = function (l) {
        return new X(l);
      });
    function X(C) {
      j.call(this, C),
        (this.shift = this.m.bitLength()),
        this.shift % 26 !== 0 && (this.shift += 26 - (this.shift % 26)),
        (this.r = new a(1).iushln(this.shift)),
        (this.r2 = this.imod(this.r.sqr())),
        (this.rinv = this.r._invmp(this.m)),
        (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
        (this.minv = this.minv.umod(this.r)),
        (this.minv = this.r.sub(this.minv));
    }
    i(X, j),
      (X.prototype.convertTo = function (l) {
        return this.imod(l.ushln(this.shift));
      }),
      (X.prototype.convertFrom = function (l) {
        var p = this.imod(l.mul(this.rinv));
        return (p.red = null), p;
      }),
      (X.prototype.imul = function (l, p) {
        if (l.isZero() || p.isZero())
          return (l.words[0] = 0), (l.length = 1), l;
        var y = l.imul(p),
          h = y.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
          g = y.isub(h).iushrn(this.shift),
          T = g;
        return (
          g.cmp(this.m) >= 0
            ? (T = g.isub(this.m))
            : g.cmpn(0) < 0 && (T = g.iadd(this.m)),
          T._forceRed(this)
        );
      }),
      (X.prototype.mul = function (l, p) {
        if (l.isZero() || p.isZero()) return new a(0)._forceRed(this);
        var y = l.mul(p),
          h = y.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
          g = y.isub(h).iushrn(this.shift),
          T = g;
        return (
          g.cmp(this.m) >= 0
            ? (T = g.isub(this.m))
            : g.cmpn(0) < 0 && (T = g.iadd(this.m)),
          T._forceRed(this)
        );
      }),
      (X.prototype.invm = function (l) {
        var p = this.imod(l._invmp(this.m).mul(this.r2));
        return p._forceRed(this);
      });
  })(t, ke);
})(QT);
QT.exports;
var YT = {};
(function (t) {
  const e = Ov,
    r = Fv,
    n = Lv,
    i = (b) => b == null;
  function a(b) {
    switch (b.arrayFormat) {
      case "index":
        return (w) => (S, k) => {
          const N = S.length;
          return k === void 0 ||
            (b.skipNull && k === null) ||
            (b.skipEmptyString && k === "")
            ? S
            : k === null
            ? [...S, [c(w, b), "[", N, "]"].join("")]
            : [...S, [c(w, b), "[", c(N, b), "]=", c(k, b)].join("")];
        };
      case "bracket":
        return (w) => (S, k) =>
          k === void 0 ||
          (b.skipNull && k === null) ||
          (b.skipEmptyString && k === "")
            ? S
            : k === null
            ? [...S, [c(w, b), "[]"].join("")]
            : [...S, [c(w, b), "[]=", c(k, b)].join("")];
      case "comma":
      case "separator":
        return (w) => (S, k) =>
          k == null || k.length === 0
            ? S
            : S.length === 0
            ? [[c(w, b), "=", c(k, b)].join("")]
            : [[S, c(k, b)].join(b.arrayFormatSeparator)];
      default:
        return (w) => (S, k) =>
          k === void 0 ||
          (b.skipNull && k === null) ||
          (b.skipEmptyString && k === "")
            ? S
            : k === null
            ? [...S, c(w, b)]
            : [...S, [c(w, b), "=", c(k, b)].join("")];
    }
  }
  function s(b) {
    let w;
    switch (b.arrayFormat) {
      case "index":
        return (S, k, N) => {
          if (
            ((w = /\[(\d*)\]$/.exec(S)), (S = S.replace(/\[\d*\]$/, "")), !w)
          ) {
            N[S] = k;
            return;
          }
          N[S] === void 0 && (N[S] = {}), (N[S][w[1]] = k);
        };
      case "bracket":
        return (S, k, N) => {
          if (((w = /(\[\])$/.exec(S)), (S = S.replace(/\[\]$/, "")), !w)) {
            N[S] = k;
            return;
          }
          if (N[S] === void 0) {
            N[S] = [k];
            return;
          }
          N[S] = [].concat(N[S], k);
        };
      case "comma":
      case "separator":
        return (S, k, N) => {
          const F =
            typeof k == "string" &&
            k.split("").indexOf(b.arrayFormatSeparator) > -1
              ? k.split(b.arrayFormatSeparator).map((V) => u(V, b))
              : k === null
              ? k
              : u(k, b);
          N[S] = F;
        };
      default:
        return (S, k, N) => {
          if (N[S] === void 0) {
            N[S] = k;
            return;
          }
          N[S] = [].concat(N[S], k);
        };
    }
  }
  function o(b) {
    if (typeof b != "string" || b.length !== 1)
      throw new TypeError(
        "arrayFormatSeparator must be single character string"
      );
  }
  function c(b, w) {
    return w.encode ? (w.strict ? e(b) : encodeURIComponent(b)) : b;
  }
  function u(b, w) {
    return w.decode ? r(b) : b;
  }
  function d(b) {
    return Array.isArray(b)
      ? b.sort()
      : typeof b == "object"
      ? d(Object.keys(b))
          .sort((w, S) => Number(w) - Number(S))
          .map((w) => b[w])
      : b;
  }
  function m(b) {
    const w = b.indexOf("#");
    return w !== -1 && (b = b.slice(0, w)), b;
  }
  function v(b) {
    let w = "";
    const S = b.indexOf("#");
    return S !== -1 && (w = b.slice(S)), w;
  }
  function E(b) {
    b = m(b);
    const w = b.indexOf("?");
    return w === -1 ? "" : b.slice(w + 1);
  }
  function A(b, w) {
    return (
      w.parseNumbers &&
      !Number.isNaN(Number(b)) &&
      typeof b == "string" &&
      b.trim() !== ""
        ? (b = Number(b))
        : w.parseBooleans &&
          b !== null &&
          (b.toLowerCase() === "true" || b.toLowerCase() === "false") &&
          (b = b.toLowerCase() === "true"),
      b
    );
  }
  function I(b, w) {
    (w = Object.assign(
      {
        decode: !0,
        sort: !0,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: !1,
        parseBooleans: !1,
      },
      w
    )),
      o(w.arrayFormatSeparator);
    const S = s(w),
      k = Object.create(null);
    if (typeof b != "string" || ((b = b.trim().replace(/^[?#&]/, "")), !b))
      return k;
    for (const N of b.split("&")) {
      let [O, F] = n(w.decode ? N.replace(/\+/g, " ") : N, "=");
      (F =
        F === void 0
          ? null
          : ["comma", "separator"].includes(w.arrayFormat)
          ? F
          : u(F, w)),
        S(u(O, w), F, k);
    }
    for (const N of Object.keys(k)) {
      const O = k[N];
      if (typeof O == "object" && O !== null)
        for (const F of Object.keys(O)) O[F] = A(O[F], w);
      else k[N] = A(O, w);
    }
    return w.sort === !1
      ? k
      : (w.sort === !0
          ? Object.keys(k).sort()
          : Object.keys(k).sort(w.sort)
        ).reduce((N, O) => {
          const F = k[O];
          return (
            F && typeof F == "object" && !Array.isArray(F)
              ? (N[O] = d(F))
              : (N[O] = F),
            N
          );
        }, Object.create(null));
  }
  (t.extract = E),
    (t.parse = I),
    (t.stringify = (b, w) => {
      if (!b) return "";
      (w = Object.assign(
        {
          encode: !0,
          strict: !0,
          arrayFormat: "none",
          arrayFormatSeparator: ",",
        },
        w
      )),
        o(w.arrayFormatSeparator);
      const S = (F) =>
          (w.skipNull && i(b[F])) || (w.skipEmptyString && b[F] === ""),
        k = a(w),
        N = {};
      for (const F of Object.keys(b)) S(F) || (N[F] = b[F]);
      const O = Object.keys(N);
      return (
        w.sort !== !1 && O.sort(w.sort),
        O.map((F) => {
          const V = b[F];
          return V === void 0
            ? ""
            : V === null
            ? c(F, w)
            : Array.isArray(V)
            ? V.reduce(k(F), []).join("&")
            : c(F, w) + "=" + c(V, w);
        })
          .filter((F) => F.length > 0)
          .join("&")
      );
    }),
    (t.parseUrl = (b, w) => {
      w = Object.assign(
        {
          decode: !0,
        },
        w
      );
      const [S, k] = n(b, "#");
      return Object.assign(
        {
          url: S.split("?")[0] || "",
          query: I(E(b), w),
        },
        w && w.parseFragmentIdentifier && k
          ? {
              fragmentIdentifier: u(k, w),
            }
          : {}
      );
    }),
    (t.stringifyUrl = (b, w) => {
      w = Object.assign(
        {
          encode: !0,
          strict: !0,
        },
        w
      );
      const S = m(b.url).split("?")[0] || "",
        k = t.extract(b.url),
        N = t.parse(k, {
          sort: !1,
        }),
        O = Object.assign(N, b.query);
      let F = t.stringify(O, w);
      F && (F = `?${F}`);
      let V = v(b.url);
      return (
        b.fragmentIdentifier && (V = `#${c(b.fragmentIdentifier, w)}`),
        `${S}${F}${V}`
      );
    });
})(YT);
function i4e(t) {
  const e = t.indexOf("?") !== -1 ? t.indexOf("?") : void 0;
  return typeof e < "u" ? t.substr(e) : "";
}
function a4e(t, e) {
  let r = s4e(t);
  return (r = Object.assign(Object.assign({}, r), e)), (t = o4e(r)), t;
}
function s4e(t) {
  return YT.parse(t);
}
function o4e(t) {
  return YT.stringify(t);
}
class c4e {
  constructor() {
    (this._eventEmitters = []),
      typeof window < "u" &&
        typeof window.addEventListener < "u" &&
        (window.addEventListener("online", () => this.trigger("online")),
        window.addEventListener("offline", () => this.trigger("offline")));
  }
  on(e, r) {
    this._eventEmitters.push({
      event: e,
      callback: r,
    });
  }
  trigger(e) {
    let r = [];
    e && (r = this._eventEmitters.filter((n) => n.event === e)),
      r.forEach((n) => {
        n.callback();
      });
  }
}
// const l4e = typeof global.WebSocket < "u" ? global.WebSocket : require("ws") ;
class u4e {
  constructor(e) {
    if (
      ((this.opts = e),
      (this._queue = []),
      (this._events = []),
      (this._subscriptions = []),
      (this._protocol = e.protocol),
      (this._version = e.version),
      (this._url = ""),
      (this._netMonitor = null),
      (this._socket = null),
      (this._nextSocket = null),
      (this._subscriptions = e.subscriptions || []),
      (this._netMonitor = e.netMonitor || new c4e()),
      !e.url || typeof e.url != "string")
    )
      throw new Error("Missing or invalid WebSocket url");
    (this._url = e.url),
      this._netMonitor.on("online", () => this._socketCreate());
  }
  set readyState(e) {}
  get readyState() {
    return this._socket ? this._socket.readyState : -1;
  }
  set connecting(e) {}
  get connecting() {
    return this.readyState === 0;
  }
  set connected(e) {}
  get connected() {
    return this.readyState === 1;
  }
  set closing(e) {}
  get closing() {
    return this.readyState === 2;
  }
  set closed(e) {}
  get closed() {
    return this.readyState === 3;
  }
  open() {
    this._socketCreate();
  }
  close() {
    this._socketClose();
  }
  send(e, r, n) {
    if (!r || typeof r != "string")
      throw new Error("Missing or invalid topic field");
    this._socketSend({
      topic: r,
      type: "pub",
      payload: e,
      silent: !!n,
    });
  }
  subscribe(e) {
    this._socketSend({
      topic: e,
      type: "sub",
      payload: "",
      silent: !0,
    });
  }
  on(e, r) {
    this._events.push({
      event: e,
      callback: r,
    });
  }
  _socketCreate() {
    if (this._nextSocket) return;
    const e = f4e(this._url, this._protocol, this._version);
    if (((this._nextSocket = new l4e(e)), !this._nextSocket))
      throw new Error("Failed to create socket");
    (this._nextSocket.onmessage = (r) => this._socketReceive(r)),
      (this._nextSocket.onopen = () => this._socketOpen()),
      (this._nextSocket.onerror = (r) => this._socketError(r)),
      (this._nextSocket.onclose = () => {
        setTimeout(() => {
          (this._nextSocket = null), this._socketCreate();
        }, 1e3);
      });
  }
  _socketOpen() {
    this._socketClose(),
      (this._socket = this._nextSocket),
      (this._nextSocket = null),
      this._queueSubscriptions(),
      this._pushQueue();
  }
  _socketClose() {
    this._socket && ((this._socket.onclose = () => {}), this._socket.close());
  }
  _socketSend(e) {
    const r = JSON.stringify(e);
    this._socket && this._socket.readyState === 1
      ? this._socket.send(r)
      : (this._setToQueue(e), this._socketCreate());
  }
  async _socketReceive(e) {
    let r;
    try {
      r = JSON.parse(e.data);
    } catch {
      return;
    }
    if (
      (this._socketSend({
        topic: r.topic,
        type: "ack",
        payload: "",
        silent: !0,
      }),
      this._socket && this._socket.readyState === 1)
    ) {
      const n = this._events.filter((i) => i.event === "message");
      n && n.length && n.forEach((i) => i.callback(r));
    }
  }
  _socketError(e) {
    const r = this._events.filter((n) => n.event === "error");
    r && r.length && r.forEach((n) => n.callback(e));
  }
  _queueSubscriptions() {
    this._subscriptions.forEach((r) =>
      this._queue.push({
        topic: r,
        type: "sub",
        payload: "",
        silent: !0,
      })
    ),
      (this._subscriptions = this.opts.subscriptions || []);
  }
  _setToQueue(e) {
    this._queue.push(e);
  }
  _pushQueue() {
    this._queue.forEach((r) => this._socketSend(r)), (this._queue = []);
  }
}
function f4e(t, e, r) {
  var n, i;
  const s = (
      t.startsWith("https")
        ? t.replace("https", "wss")
        : t.startsWith("http")
        ? t.replace("http", "ws")
        : t
    ).split("?"),
    o = xj()
      ? {
          protocol: e,
          version: r,
          env: "browser",
          host: ((n = _j()) === null || n === void 0 ? void 0 : n.host) || "",
        }
      : {
          protocol: e,
          version: r,
          env: ((i = Fx()) === null || i === void 0 ? void 0 : i.name) || "",
        },
    c = a4e(i4e(s[1] || ""), o);
  return s[0] + "?" + c;
}
const N5 = "Session currently connected",
  Il = "Session currently disconnected",
  d4e = "Session Rejected",
  h4e = "Missing JSON RPC response",
  p4e = 'JSON-RPC success response must include "result" field',
  m4e = 'JSON-RPC error response must include "error" field',
  y4e = 'JSON RPC request must have valid "method" value',
  g4e = 'JSON RPC request must have valid "id" value',
  b4e = "Missing one of the required parameters: bridge / uri / session",
  CI = "JSON RPC response format is invalid",
  v4e = "URI format is invalid",
  x4e = "QRCode Modal not provided",
  AI = "User close QRCode Modal";
class w4e {
  constructor() {
    this._eventEmitters = [];
  }
  subscribe(e) {
    this._eventEmitters.push(e);
  }
  unsubscribe(e) {
    this._eventEmitters = this._eventEmitters.filter((r) => r.event !== e);
  }
  trigger(e) {
    let r = [],
      n;
    Z_e(e)
      ? (n = e.method)
      : Ch(e) || yb(e)
      ? (n = `response:${e.id}`)
      : EI(e)
      ? (n = e.event)
      : (n = ""),
      n && (r = this._eventEmitters.filter((i) => i.event === n)),
      (!r || !r.length) &&
        !J_e(n) &&
        !EI(n) &&
        (r = this._eventEmitters.filter((i) => i.event === "call_request")),
      r.forEach((i) => {
        if (yb(e)) {
          const a = new Error(e.error.message);
          i.callback(a, null);
        } else i.callback(null, e);
      });
  }
}
class _4e {
  constructor(e = "walletconnect") {
    this.storageId = e;
  }
  getSession() {
    let e = null;
    const r = qT(this.storageId);
    return r && r4e(r) && (e = r), e;
  }
  setSession(e) {
    return zT(this.storageId, e), e;
  }
  removeSession() {
    VT(this.storageId);
  }
}
const E4e = "walletconnect.org",
  T4e = "abcdefghijklmnopqrstuvwxyz0123456789",
  Uj = T4e.split("").map((t) => `https://${t}.bridge.walletconnect.org`);
function C4e(t) {
  let e = t.indexOf("//") > -1 ? t.split("/")[2] : t.split("/")[0];
  return (e = e.split(":")[0]), (e = e.split("?")[0]), e;
}
function A4e(t) {
  return C4e(t).split(".").slice(-2).join(".");
}
function k4e() {
  return Math.floor(Math.random() * Uj.length);
}
function S4e() {
  return Uj[k4e()];
}
function M4e(t) {
  return A4e(t) === E4e;
}
function I4e(t) {
  return M4e(t) ? S4e() : t;
}
class R4e {
  constructor(e) {
    if (
      ((this.protocol = "wc"),
      (this.version = 1),
      (this._bridge = ""),
      (this._key = null),
      (this._clientId = ""),
      (this._clientMeta = null),
      (this._peerId = ""),
      (this._peerMeta = null),
      (this._handshakeId = 0),
      (this._handshakeTopic = ""),
      (this._connected = !1),
      (this._accounts = []),
      (this._chainId = 0),
      (this._networkId = 0),
      (this._rpcUrl = ""),
      (this._eventManager = new w4e()),
      (this._clientMeta = w4() || e.connectorOpts.clientMeta || null),
      (this._cryptoLib = e.cryptoLib),
      (this._sessionStorage =
        e.sessionStorage || new _4e(e.connectorOpts.storageId)),
      (this._qrcodeModal = e.connectorOpts.qrcodeModal),
      (this._qrcodeModalOptions = e.connectorOpts.qrcodeModalOptions),
      (this._signingMethods = [
        ...Oj,
        ...(e.connectorOpts.signingMethods || []),
      ]),
      !e.connectorOpts.bridge &&
        !e.connectorOpts.uri &&
        !e.connectorOpts.session)
    )
      throw new Error(b4e);
    e.connectorOpts.bridge && (this.bridge = I4e(e.connectorOpts.bridge)),
      e.connectorOpts.uri && (this.uri = e.connectorOpts.uri);
    const r = e.connectorOpts.session || this._getStorageSession();
    r && (this.session = r),
      this.handshakeId &&
        this._subscribeToSessionResponse(
          this.handshakeId,
          "Session request rejected"
        ),
      (this._transport =
        e.transport ||
        new u4e({
          protocol: this.protocol,
          version: this.version,
          url: this.bridge,
          subscriptions: [this.clientId],
        })),
      this._subscribeToInternalEvents(),
      this._initTransport(),
      e.connectorOpts.uri && this._subscribeToSessionRequest(),
      e.pushServerOpts && this._registerPushServer(e.pushServerOpts);
  }
  set bridge(e) {
    e && (this._bridge = e);
  }
  get bridge() {
    return this._bridge;
  }
  set key(e) {
    if (!e) return;
    const r = z_e(e);
    this._key = r;
  }
  get key() {
    return this._key ? W_e(this._key, !0) : "";
  }
  set clientId(e) {
    e && (this._clientId = e);
  }
  get clientId() {
    let e = this._clientId;
    return e || (e = this._clientId = R5()), this._clientId;
  }
  set peerId(e) {
    e && (this._peerId = e);
  }
  get peerId() {
    return this._peerId;
  }
  set clientMeta(e) {}
  get clientMeta() {
    let e = this._clientMeta;
    return e || (e = this._clientMeta = w4()), e;
  }
  set peerMeta(e) {
    this._peerMeta = e;
  }
  get peerMeta() {
    return this._peerMeta;
  }
  set handshakeTopic(e) {
    e && (this._handshakeTopic = e);
  }
  get handshakeTopic() {
    return this._handshakeTopic;
  }
  set handshakeId(e) {
    e && (this._handshakeId = e);
  }
  get handshakeId() {
    return this._handshakeId;
  }
  get uri() {
    return this._formatUri();
  }
  set uri(e) {
    if (!e) return;
    const { handshakeTopic: r, bridge: n, key: i } = this._parseUri(e);
    (this.handshakeTopic = r), (this.bridge = n), (this.key = i);
  }
  set chainId(e) {
    this._chainId = e;
  }
  get chainId() {
    return this._chainId;
  }
  set networkId(e) {
    this._networkId = e;
  }
  get networkId() {
    return this._networkId;
  }
  set accounts(e) {
    this._accounts = e;
  }
  get accounts() {
    return this._accounts;
  }
  set rpcUrl(e) {
    this._rpcUrl = e;
  }
  get rpcUrl() {
    return this._rpcUrl;
  }
  set connected(e) {}
  get connected() {
    return this._connected;
  }
  set pending(e) {}
  get pending() {
    return !!this._handshakeTopic;
  }
  get session() {
    return {
      connected: this.connected,
      accounts: this.accounts,
      chainId: this.chainId,
      bridge: this.bridge,
      key: this.key,
      clientId: this.clientId,
      clientMeta: this.clientMeta,
      peerId: this.peerId,
      peerMeta: this.peerMeta,
      handshakeId: this.handshakeId,
      handshakeTopic: this.handshakeTopic,
    };
  }
  set session(e) {
    e &&
      ((this._connected = e.connected),
      (this.accounts = e.accounts),
      (this.chainId = e.chainId),
      (this.bridge = e.bridge),
      (this.key = e.key),
      (this.clientId = e.clientId),
      (this.clientMeta = e.clientMeta),
      (this.peerId = e.peerId),
      (this.peerMeta = e.peerMeta),
      (this.handshakeId = e.handshakeId),
      (this.handshakeTopic = e.handshakeTopic));
  }
  on(e, r) {
    const n = {
      event: e,
      callback: r,
    };
    this._eventManager.subscribe(n);
  }
  off(e) {
    this._eventManager.unsubscribe(e);
  }
  async createInstantRequest(e) {
    this._key = await this._generateKey();
    const r = this._formatRequest({
      method: "wc_instantRequest",
      params: [
        {
          peerId: this.clientId,
          peerMeta: this.clientMeta,
          request: this._formatRequest(e),
        },
      ],
    });
    (this.handshakeId = r.id),
      (this.handshakeTopic = R5()),
      this._eventManager.trigger({
        event: "display_uri",
        params: [this.uri],
      }),
      this.on("modal_closed", () => {
        throw new Error(AI);
      });
    const n = () => {
      this.killSession();
    };
    try {
      const i = await this._sendCallRequest(r);
      return i && n(), i;
    } catch (i) {
      throw (n(), i);
    }
  }
  async connect(e) {
    if (!this._qrcodeModal) throw new Error(x4e);
    return this.connected
      ? {
          chainId: this.chainId,
          accounts: this.accounts,
        }
      : (await this.createSession(e),
        new Promise(async (r, n) => {
          this.on("modal_closed", () => n(new Error(AI))),
            this.on("connect", (i, a) => {
              if (i) return n(i);
              r(a.params[0]);
            });
        }));
  }
  async createSession(e) {
    if (this._connected) throw new Error(N5);
    if (this.pending) return;
    this._key = await this._generateKey();
    const r = this._formatRequest({
      method: "wc_sessionRequest",
      params: [
        {
          peerId: this.clientId,
          peerMeta: this.clientMeta,
          chainId: e && e.chainId ? e.chainId : null,
        },
      ],
    });
    (this.handshakeId = r.id),
      (this.handshakeTopic = R5()),
      this._sendSessionRequest(r, "Session update rejected", {
        topic: this.handshakeTopic,
      }),
      this._eventManager.trigger({
        event: "display_uri",
        params: [this.uri],
      });
  }
  approveSession(e) {
    if (this._connected) throw new Error(N5);
    (this.chainId = e.chainId),
      (this.accounts = e.accounts),
      (this.networkId = e.networkId || 0),
      (this.rpcUrl = e.rpcUrl || "");
    const r = {
        approved: !0,
        chainId: this.chainId,
        networkId: this.networkId,
        accounts: this.accounts,
        rpcUrl: this.rpcUrl,
        peerId: this.clientId,
        peerMeta: this.clientMeta,
      },
      n = {
        id: this.handshakeId,
        jsonrpc: "2.0",
        result: r,
      };
    this._sendResponse(n),
      (this._connected = !0),
      this._setStorageSession(),
      this._eventManager.trigger({
        event: "connect",
        params: [
          {
            peerId: this.peerId,
            peerMeta: this.peerMeta,
            chainId: this.chainId,
            accounts: this.accounts,
          },
        ],
      });
  }
  rejectSession(e) {
    if (this._connected) throw new Error(N5);
    const r = e && e.message ? e.message : d4e,
      n = this._formatResponse({
        id: this.handshakeId,
        error: {
          message: r,
        },
      });
    this._sendResponse(n),
      (this._connected = !1),
      this._eventManager.trigger({
        event: "disconnect",
        params: [
          {
            message: r,
          },
        ],
      }),
      this._removeStorageSession();
  }
  updateSession(e) {
    if (!this._connected) throw new Error(Il);
    (this.chainId = e.chainId),
      (this.accounts = e.accounts),
      (this.networkId = e.networkId || 0),
      (this.rpcUrl = e.rpcUrl || "");
    const r = {
        approved: !0,
        chainId: this.chainId,
        networkId: this.networkId,
        accounts: this.accounts,
        rpcUrl: this.rpcUrl,
      },
      n = this._formatRequest({
        method: "wc_sessionUpdate",
        params: [r],
      });
    this._sendSessionRequest(n, "Session update rejected"),
      this._eventManager.trigger({
        event: "session_update",
        params: [
          {
            chainId: this.chainId,
            accounts: this.accounts,
          },
        ],
      }),
      this._manageStorageSession();
  }
  async killSession(e) {
    const r = e ? e.message : "Session Disconnected",
      n = {
        approved: !1,
        chainId: null,
        networkId: null,
        accounts: null,
      },
      i = this._formatRequest({
        method: "wc_sessionUpdate",
        params: [n],
      });
    await this._sendRequest(i), this._handleSessionDisconnect(r);
  }
  async sendTransaction(e) {
    if (!this._connected) throw new Error(Il);
    const r = P5(e),
      n = this._formatRequest({
        method: "eth_sendTransaction",
        params: [r],
      });
    return await this._sendCallRequest(n);
  }
  async signTransaction(e) {
    if (!this._connected) throw new Error(Il);
    const r = P5(e),
      n = this._formatRequest({
        method: "eth_signTransaction",
        params: [r],
      });
    return await this._sendCallRequest(n);
  }
  async signMessage(e) {
    if (!this._connected) throw new Error(Il);
    const r = this._formatRequest({
      method: "eth_sign",
      params: e,
    });
    return await this._sendCallRequest(r);
  }
  async signPersonalMessage(e) {
    if (!this._connected) throw new Error(Il);
    e = TI(e);
    const r = this._formatRequest({
      method: "personal_sign",
      params: e,
    });
    return await this._sendCallRequest(r);
  }
  async signTypedData(e) {
    if (!this._connected) throw new Error(Il);
    const r = this._formatRequest({
      method: "eth_signTypedData",
      params: e,
    });
    return await this._sendCallRequest(r);
  }
  async updateChain(e) {
    if (!this._connected) throw new Error("Session currently disconnected");
    const r = this._formatRequest({
      method: "wallet_updateChain",
      params: [e],
    });
    return await this._sendCallRequest(r);
  }
  unsafeSend(e, r) {
    return (
      this._sendRequest(e, r),
      this._eventManager.trigger({
        event: "call_request_sent",
        params: [
          {
            request: e,
            options: r,
          },
        ],
      }),
      new Promise((n, i) => {
        this._subscribeToResponse(e.id, (a, s) => {
          if (a) {
            i(a);
            return;
          }
          if (!s) throw new Error(h4e);
          n(s);
        });
      })
    );
  }
  async sendCustomRequest(e, r) {
    if (!this._connected) throw new Error(Il);
    switch (e.method) {
      case "eth_accounts":
        return this.accounts;
      case "eth_chainId":
        return Fj(this.chainId);
      case "eth_sendTransaction":
      case "eth_signTransaction":
        e.params && (e.params[0] = P5(e.params[0]));
        break;
      case "personal_sign":
        e.params && (e.params = TI(e.params));
        break;
    }
    const n = this._formatRequest(e);
    return await this._sendCallRequest(n, r);
  }
  approveRequest(e) {
    if (Ch(e)) {
      const r = this._formatResponse(e);
      this._sendResponse(r);
    } else throw new Error(p4e);
  }
  rejectRequest(e) {
    if (yb(e)) {
      const r = this._formatResponse(e);
      this._sendResponse(r);
    } else throw new Error(m4e);
  }
  transportClose() {
    this._transport.close();
  }
  async _sendRequest(e, r) {
    const n = this._formatRequest(e),
      i = await this._encrypt(n),
      a = typeof (r == null ? void 0 : r.topic) < "u" ? r.topic : this.peerId,
      s = JSON.stringify(i),
      o =
        typeof (r == null ? void 0 : r.forcePushNotification) < "u"
          ? !r.forcePushNotification
          : Q_e(n);
    this._transport.send(s, a, o);
  }
  async _sendResponse(e) {
    const r = await this._encrypt(e),
      n = this.peerId,
      i = JSON.stringify(r);
    this._transport.send(i, n, !0);
  }
  async _sendSessionRequest(e, r, n) {
    this._sendRequest(e, n), this._subscribeToSessionResponse(e.id, r);
  }
  _sendCallRequest(e, r) {
    return (
      this._sendRequest(e, r),
      this._eventManager.trigger({
        event: "call_request_sent",
        params: [
          {
            request: e,
            options: r,
          },
        ],
      }),
      this._subscribeToCallResponse(e.id)
    );
  }
  _formatRequest(e) {
    if (typeof e.method > "u") throw new Error(y4e);
    return {
      id: typeof e.id > "u" ? V_e() : e.id,
      jsonrpc: "2.0",
      method: e.method,
      params: typeof e.params > "u" ? [] : e.params,
    };
  }
  _formatResponse(e) {
    if (typeof e.id > "u") throw new Error(g4e);
    const r = {
      id: e.id,
      jsonrpc: "2.0",
    };
    if (yb(e)) {
      const n = e4e(e.error);
      return Object.assign(Object.assign(Object.assign({}, r), e), {
        error: n,
      });
    } else if (Ch(e)) return Object.assign(Object.assign({}, r), e);
    throw new Error(CI);
  }
  _handleSessionDisconnect(e) {
    const r = e || "Session Disconnected";
    this._connected || (this._qrcodeModal && this._qrcodeModal.close(), VT(mb)),
      this._connected && (this._connected = !1),
      this._handshakeId && (this._handshakeId = 0),
      this._handshakeTopic && (this._handshakeTopic = ""),
      this._peerId && (this._peerId = ""),
      this._eventManager.trigger({
        event: "disconnect",
        params: [
          {
            message: r,
          },
        ],
      }),
      this._removeStorageSession(),
      this.transportClose();
  }
  _handleSessionResponse(e, r) {
    r
      ? r.approved
        ? (this._connected
            ? (r.chainId && (this.chainId = r.chainId),
              r.accounts && (this.accounts = r.accounts),
              this._eventManager.trigger({
                event: "session_update",
                params: [
                  {
                    chainId: this.chainId,
                    accounts: this.accounts,
                  },
                ],
              }))
            : ((this._connected = !0),
              r.chainId && (this.chainId = r.chainId),
              r.accounts && (this.accounts = r.accounts),
              r.peerId && !this.peerId && (this.peerId = r.peerId),
              r.peerMeta && !this.peerMeta && (this.peerMeta = r.peerMeta),
              this._eventManager.trigger({
                event: "connect",
                params: [
                  {
                    peerId: this.peerId,
                    peerMeta: this.peerMeta,
                    chainId: this.chainId,
                    accounts: this.accounts,
                  },
                ],
              })),
          this._manageStorageSession())
        : this._handleSessionDisconnect(e)
      : this._handleSessionDisconnect(e);
  }
  async _handleIncomingMessages(e) {
    if (![this.clientId, this.handshakeTopic].includes(e.topic)) return;
    let n;
    try {
      n = JSON.parse(e.payload);
    } catch {
      return;
    }
    const i = await this._decrypt(n);
    i && this._eventManager.trigger(i);
  }
  _subscribeToSessionRequest() {
    this._transport.subscribe(this.handshakeTopic);
  }
  _subscribeToResponse(e, r) {
    this.on(`response:${e}`, r);
  }
  _subscribeToSessionResponse(e, r) {
    this._subscribeToResponse(e, (n, i) => {
      if (n) {
        this._handleSessionResponse(n.message);
        return;
      }
      Ch(i)
        ? this._handleSessionResponse(r, i.result)
        : i.error && i.error.message
        ? this._handleSessionResponse(i.error.message)
        : this._handleSessionResponse(r);
    });
  }
  _subscribeToCallResponse(e) {
    return new Promise((r, n) => {
      this._subscribeToResponse(e, (i, a) => {
        if (i) {
          n(i);
          return;
        }
        Ch(a)
          ? r(a.result)
          : a.error && a.error.message
          ? n(a.error)
          : n(new Error(CI));
      });
    });
  }
  _subscribeToInternalEvents() {
    this.on("display_uri", () => {
      this._qrcodeModal &&
        this._qrcodeModal.open(
          this.uri,
          () => {
            this._eventManager.trigger({
              event: "modal_closed",
              params: [],
            });
          },
          this._qrcodeModalOptions
        );
    }),
      this.on("connect", () => {
        this._qrcodeModal && this._qrcodeModal.close();
      }),
      this.on("call_request_sent", (e, r) => {
        const { request: n } = r.params[0];
        if (bj() && this._signingMethods.includes(n.method)) {
          const i = qT(mb);
          i && (window.location.href = i.href);
        }
      }),
      this.on("wc_sessionRequest", (e, r) => {
        e &&
          this._eventManager.trigger({
            event: "error",
            params: [
              {
                code: "SESSION_REQUEST_ERROR",
                message: e.toString(),
              },
            ],
          }),
          (this.handshakeId = r.id),
          (this.peerId = r.params[0].peerId),
          (this.peerMeta = r.params[0].peerMeta);
        const n = Object.assign(Object.assign({}, r), {
          method: "session_request",
        });
        this._eventManager.trigger(n);
      }),
      this.on("wc_sessionUpdate", (e, r) => {
        e && this._handleSessionResponse(e.message),
          this._handleSessionResponse("Session disconnected", r.params[0]);
      });
  }
  _initTransport() {
    this._transport.on("message", (e) => this._handleIncomingMessages(e)),
      this._transport.on("open", () =>
        this._eventManager.trigger({
          event: "transport_open",
          params: [],
        })
      ),
      this._transport.on("close", () =>
        this._eventManager.trigger({
          event: "transport_close",
          params: [],
        })
      ),
      this._transport.on("error", () =>
        this._eventManager.trigger({
          event: "transport_error",
          params: ["Websocket connection failed"],
        })
      ),
      this._transport.open();
  }
  _formatUri() {
    const e = this.protocol,
      r = this.handshakeTopic,
      n = this.version,
      i = encodeURIComponent(this.bridge),
      a = this.key;
    return `${e}:${r}@${n}?bridge=${i}&key=${a}`;
  }
  _parseUri(e) {
    const r = n4e(e);
    if (r.protocol === this.protocol) {
      if (!r.handshakeTopic)
        throw Error("Invalid or missing handshakeTopic parameter value");
      const n = r.handshakeTopic;
      if (!r.bridge)
        throw Error("Invalid or missing bridge url parameter value");
      const i = decodeURIComponent(r.bridge);
      if (!r.key) throw Error("Invalid or missing key parameter value");
      const a = r.key;
      return {
        handshakeTopic: n,
        bridge: i,
        key: a,
      };
    } else throw new Error(v4e);
  }
  async _generateKey() {
    return this._cryptoLib ? await this._cryptoLib.generateKey() : null;
  }
  async _encrypt(e) {
    const r = this._key;
    return this._cryptoLib && r ? await this._cryptoLib.encrypt(e, r) : null;
  }
  async _decrypt(e) {
    const r = this._key;
    return this._cryptoLib && r ? await this._cryptoLib.decrypt(e, r) : null;
  }
  _getStorageSession() {
    let e = null;
    return this._sessionStorage && (e = this._sessionStorage.getSession()), e;
  }
  _setStorageSession() {
    this._sessionStorage && this._sessionStorage.setSession(this.session);
  }
  _removeStorageSession() {
    this._sessionStorage && this._sessionStorage.removeSession();
  }
  _manageStorageSession() {
    this._connected ? this._setStorageSession() : this._removeStorageSession();
  }
  _registerPushServer(e) {
    if (!e.url || typeof e.url != "string")
      throw Error("Invalid or missing pushServerOpts.url parameter value");
    if (!e.type || typeof e.type != "string")
      throw Error("Invalid or missing pushServerOpts.type parameter value");
    if (!e.token || typeof e.token != "string")
      throw Error("Invalid or missing pushServerOpts.token parameter value");
    const r = {
      bridge: this.bridge,
      topic: this.clientId,
      type: e.type,
      token: e.token,
      peerName: "",
      language: e.language || "",
    };
    this.on("connect", async (n, i) => {
      if (n) throw n;
      if (e.peerMeta) {
        const a = i.params[0].peerMeta.name;
        r.peerName = a;
      }
      try {
        if (
          !(
            await (
              await fetch(`${e.url}/new`, {
                method: "POST",
                headers: {
                  Accept: "application/json",
                  "Content-Type": "application/json",
                },
                body: JSON.stringify(r),
              })
            ).json()
          ).success
        )
          throw Error("Failed to register in Push Server");
      } catch {
        throw Error("Failed to register in Push Server");
      }
    });
  }
}
function P4e(t) {
  return Ad.getBrowerCrypto().getRandomValues(new Uint8Array(t));
}
const Wj = 256,
  jj = Wj,
  N4e = Wj,
  ll = "AES-CBC",
  B4e = `SHA-${jj}`,
  _4 = "HMAC",
  D4e = "encrypt",
  O4e = "decrypt",
  F4e = "sign",
  L4e = "verify";
function $4e(t) {
  return t === ll
    ? {
        length: jj,
        name: ll,
      }
    : {
        hash: {
          name: B4e,
        },
        name: _4,
      };
}
function U4e(t) {
  return t === ll ? [D4e, O4e] : [F4e, L4e];
}
async function XT(t, e = ll) {
  return Ad.getSubtleCrypto().importKey("raw", t, $4e(e), !0, U4e(e));
}
async function W4e(t, e, r) {
  const n = Ad.getSubtleCrypto(),
    i = await XT(e, ll),
    a = await n.encrypt(
      {
        iv: t,
        name: ll,
      },
      i,
      r
    );
  return new Uint8Array(a);
}
async function j4e(t, e, r) {
  const n = Ad.getSubtleCrypto(),
    i = await XT(e, ll),
    a = await n.decrypt(
      {
        iv: t,
        name: ll,
      },
      i,
      r
    );
  return new Uint8Array(a);
}
async function H4e(t, e) {
  const r = Ad.getSubtleCrypto(),
    n = await XT(t, _4),
    i = await r.sign(
      {
        length: N4e,
        name: _4,
      },
      n,
      e
    );
  return new Uint8Array(i);
}
function z4e(t, e, r) {
  return W4e(t, e, r);
}
function q4e(t, e, r) {
  return j4e(t, e, r);
}
async function Hj(t, e) {
  return await H4e(t, e);
}
var eC = {
  exports: {},
};
eC.exports;
(function (t) {
  (function (e, r) {
    function n(C, l) {
      if (!C) throw new Error(l || "Assertion failed");
    }
    function i(C, l) {
      C.super_ = l;
      var p = function () {};
      (p.prototype = l.prototype),
        (C.prototype = new p()),
        (C.prototype.constructor = C);
    }
    function a(C, l, p) {
      if (a.isBN(C)) return C;
      (this.negative = 0),
        (this.words = null),
        (this.length = 0),
        (this.red = null),
        C !== null &&
          ((l === "le" || l === "be") && ((p = l), (l = 10)),
          this._init(C || 0, l || 10, p || "be"));
    }
    typeof e == "object" ? (e.exports = a) : (r.BN = a),
      (a.BN = a),
      (a.wordSize = 26);
    var s;
    try {
      s = Pu.Buffer;
    } catch {}
    (a.isBN = function (l) {
      return l instanceof a
        ? !0
        : l !== null &&
            typeof l == "object" &&
            l.constructor.wordSize === a.wordSize &&
            Array.isArray(l.words);
    }),
      (a.max = function (l, p) {
        return l.cmp(p) > 0 ? l : p;
      }),
      (a.min = function (l, p) {
        return l.cmp(p) < 0 ? l : p;
      }),
      (a.prototype._init = function (l, p, y) {
        if (typeof l == "number") return this._initNumber(l, p, y);
        if (typeof l == "object") return this._initArray(l, p, y);
        p === "hex" && (p = 16),
          n(p === (p | 0) && p >= 2 && p <= 36),
          (l = l.toString().replace(/\s+/g, ""));
        var h = 0;
        l[0] === "-" && h++,
          p === 16 ? this._parseHex(l, h) : this._parseBase(l, p, h),
          l[0] === "-" && (this.negative = 1),
          this.strip(),
          y === "le" && this._initArray(this.toArray(), p, y);
      }),
      (a.prototype._initNumber = function (l, p, y) {
        l < 0 && ((this.negative = 1), (l = -l)),
          l < 67108864
            ? ((this.words = [l & 67108863]), (this.length = 1))
            : l < 4503599627370496
            ? ((this.words = [l & 67108863, (l / 67108864) & 67108863]),
              (this.length = 2))
            : (n(l < 9007199254740992),
              (this.words = [l & 67108863, (l / 67108864) & 67108863, 1]),
              (this.length = 3)),
          y === "le" && this._initArray(this.toArray(), p, y);
      }),
      (a.prototype._initArray = function (l, p, y) {
        if ((n(typeof l.length == "number"), l.length <= 0))
          return (this.words = [0]), (this.length = 1), this;
        (this.length = Math.ceil(l.length / 3)),
          (this.words = new Array(this.length));
        for (var h = 0; h < this.length; h++) this.words[h] = 0;
        var g,
          T,
          R = 0;
        if (y === "be")
          for (h = l.length - 1, g = 0; h >= 0; h -= 3)
            (T = l[h] | (l[h - 1] << 8) | (l[h - 2] << 16)),
              (this.words[g] |= (T << R) & 67108863),
              (this.words[g + 1] = (T >>> (26 - R)) & 67108863),
              (R += 24),
              R >= 26 && ((R -= 26), g++);
        else if (y === "le")
          for (h = 0, g = 0; h < l.length; h += 3)
            (T = l[h] | (l[h + 1] << 8) | (l[h + 2] << 16)),
              (this.words[g] |= (T << R) & 67108863),
              (this.words[g + 1] = (T >>> (26 - R)) & 67108863),
              (R += 24),
              R >= 26 && ((R -= 26), g++);
        return this.strip();
      });
    function o(C, l, p) {
      for (var y = 0, h = Math.min(C.length, p), g = l; g < h; g++) {
        var T = C.charCodeAt(g) - 48;
        (y <<= 4),
          T >= 49 && T <= 54
            ? (y |= T - 49 + 10)
            : T >= 17 && T <= 22
            ? (y |= T - 17 + 10)
            : (y |= T & 15);
      }
      return y;
    }
    a.prototype._parseHex = function (l, p) {
      (this.length = Math.ceil((l.length - p) / 6)),
        (this.words = new Array(this.length));
      for (var y = 0; y < this.length; y++) this.words[y] = 0;
      var h,
        g,
        T = 0;
      for (y = l.length - 6, h = 0; y >= p; y -= 6)
        (g = o(l, y, y + 6)),
          (this.words[h] |= (g << T) & 67108863),
          (this.words[h + 1] |= (g >>> (26 - T)) & 4194303),
          (T += 24),
          T >= 26 && ((T -= 26), h++);
      y + 6 !== p &&
        ((g = o(l, p, y + 6)),
        (this.words[h] |= (g << T) & 67108863),
        (this.words[h + 1] |= (g >>> (26 - T)) & 4194303)),
        this.strip();
    };
    function c(C, l, p, y) {
      for (var h = 0, g = Math.min(C.length, p), T = l; T < g; T++) {
        var R = C.charCodeAt(T) - 48;
        (h *= y),
          R >= 49
            ? (h += R - 49 + 10)
            : R >= 17
            ? (h += R - 17 + 10)
            : (h += R);
      }
      return h;
    }
    (a.prototype._parseBase = function (l, p, y) {
      (this.words = [0]), (this.length = 1);
      for (var h = 0, g = 1; g <= 67108863; g *= p) h++;
      h--, (g = (g / p) | 0);
      for (
        var T = l.length - y,
          R = T % h,
          x = Math.min(T, T - R) + y,
          f = 0,
          _ = y;
        _ < x;
        _ += h
      )
        (f = c(l, _, _ + h, p)),
          this.imuln(g),
          this.words[0] + f < 67108864 ? (this.words[0] += f) : this._iaddn(f);
      if (R !== 0) {
        var P = 1;
        for (f = c(l, _, l.length, p), _ = 0; _ < R; _++) P *= p;
        this.imuln(P),
          this.words[0] + f < 67108864 ? (this.words[0] += f) : this._iaddn(f);
      }
    }),
      (a.prototype.copy = function (l) {
        l.words = new Array(this.length);
        for (var p = 0; p < this.length; p++) l.words[p] = this.words[p];
        (l.length = this.length),
          (l.negative = this.negative),
          (l.red = this.red);
      }),
      (a.prototype.clone = function () {
        var l = new a(null);
        return this.copy(l), l;
      }),
      (a.prototype._expand = function (l) {
        for (; this.length < l; ) this.words[this.length++] = 0;
        return this;
      }),
      (a.prototype.strip = function () {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }),
      (a.prototype._normSign = function () {
        return (
          this.length === 1 && this.words[0] === 0 && (this.negative = 0), this
        );
      }),
      (a.prototype.inspect = function () {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      });
    var u = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000",
      ],
      d = [
        0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
      ],
      m = [
        0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607,
        16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536,
        11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101,
        5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368,
        20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875,
        60466176,
      ];
    (a.prototype.toString = function (l, p) {
      (l = l || 10), (p = p | 0 || 1);
      var y;
      if (l === 16 || l === "hex") {
        y = "";
        for (var h = 0, g = 0, T = 0; T < this.length; T++) {
          var R = this.words[T],
            x = (((R << h) | g) & 16777215).toString(16);
          (g = (R >>> (24 - h)) & 16777215),
            g !== 0 || T !== this.length - 1
              ? (y = u[6 - x.length] + x + y)
              : (y = x + y),
            (h += 2),
            h >= 26 && ((h -= 26), T--);
        }
        for (g !== 0 && (y = g.toString(16) + y); y.length % p !== 0; )
          y = "0" + y;
        return this.negative !== 0 && (y = "-" + y), y;
      }
      if (l === (l | 0) && l >= 2 && l <= 36) {
        var f = d[l],
          _ = m[l];
        y = "";
        var P = this.clone();
        for (P.negative = 0; !P.isZero(); ) {
          var M = P.modn(_).toString(l);
          (P = P.idivn(_)),
            P.isZero() ? (y = M + y) : (y = u[f - M.length] + M + y);
        }
        for (this.isZero() && (y = "0" + y); y.length % p !== 0; ) y = "0" + y;
        return this.negative !== 0 && (y = "-" + y), y;
      }
      n(!1, "Base should be between 2 and 36");
    }),
      (a.prototype.toNumber = function () {
        var l = this.words[0];
        return (
          this.length === 2
            ? (l += this.words[1] * 67108864)
            : this.length === 3 && this.words[2] === 1
            ? (l += 4503599627370496 + this.words[1] * 67108864)
            : this.length > 2 &&
              n(!1, "Number can only safely store up to 53 bits"),
          this.negative !== 0 ? -l : l
        );
      }),
      (a.prototype.toJSON = function () {
        return this.toString(16);
      }),
      (a.prototype.toBuffer = function (l, p) {
        return n(typeof s < "u"), this.toArrayLike(s, l, p);
      }),
      (a.prototype.toArray = function (l, p) {
        return this.toArrayLike(Array, l, p);
      }),
      (a.prototype.toArrayLike = function (l, p, y) {
        var h = this.byteLength(),
          g = y || Math.max(1, h);
        n(h <= g, "byte array longer than desired length"),
          n(g > 0, "Requested array length <= 0"),
          this.strip();
        var T = p === "le",
          R = new l(g),
          x,
          f,
          _ = this.clone();
        if (T) {
          for (f = 0; !_.isZero(); f++)
            (x = _.andln(255)), _.iushrn(8), (R[f] = x);
          for (; f < g; f++) R[f] = 0;
        } else {
          for (f = 0; f < g - h; f++) R[f] = 0;
          for (f = 0; !_.isZero(); f++)
            (x = _.andln(255)), _.iushrn(8), (R[g - f - 1] = x);
        }
        return R;
      }),
      Math.clz32
        ? (a.prototype._countBits = function (l) {
            return 32 - Math.clz32(l);
          })
        : (a.prototype._countBits = function (l) {
            var p = l,
              y = 0;
            return (
              p >= 4096 && ((y += 13), (p >>>= 13)),
              p >= 64 && ((y += 7), (p >>>= 7)),
              p >= 8 && ((y += 4), (p >>>= 4)),
              p >= 2 && ((y += 2), (p >>>= 2)),
              y + p
            );
          }),
      (a.prototype._zeroBits = function (l) {
        if (l === 0) return 26;
        var p = l,
          y = 0;
        return (
          p & 8191 || ((y += 13), (p >>>= 13)),
          p & 127 || ((y += 7), (p >>>= 7)),
          p & 15 || ((y += 4), (p >>>= 4)),
          p & 3 || ((y += 2), (p >>>= 2)),
          p & 1 || y++,
          y
        );
      }),
      (a.prototype.bitLength = function () {
        var l = this.words[this.length - 1],
          p = this._countBits(l);
        return (this.length - 1) * 26 + p;
      });
    function v(C) {
      for (var l = new Array(C.bitLength()), p = 0; p < l.length; p++) {
        var y = (p / 26) | 0,
          h = p % 26;
        l[p] = (C.words[y] & (1 << h)) >>> h;
      }
      return l;
    }
    (a.prototype.zeroBits = function () {
      if (this.isZero()) return 0;
      for (var l = 0, p = 0; p < this.length; p++) {
        var y = this._zeroBits(this.words[p]);
        if (((l += y), y !== 26)) break;
      }
      return l;
    }),
      (a.prototype.byteLength = function () {
        return Math.ceil(this.bitLength() / 8);
      }),
      (a.prototype.toTwos = function (l) {
        return this.negative !== 0
          ? this.abs().inotn(l).iaddn(1)
          : this.clone();
      }),
      (a.prototype.fromTwos = function (l) {
        return this.testn(l - 1) ? this.notn(l).iaddn(1).ineg() : this.clone();
      }),
      (a.prototype.isNeg = function () {
        return this.negative !== 0;
      }),
      (a.prototype.neg = function () {
        return this.clone().ineg();
      }),
      (a.prototype.ineg = function () {
        return this.isZero() || (this.negative ^= 1), this;
      }),
      (a.prototype.iuor = function (l) {
        for (; this.length < l.length; ) this.words[this.length++] = 0;
        for (var p = 0; p < l.length; p++)
          this.words[p] = this.words[p] | l.words[p];
        return this.strip();
      }),
      (a.prototype.ior = function (l) {
        return n((this.negative | l.negative) === 0), this.iuor(l);
      }),
      (a.prototype.or = function (l) {
        return this.length > l.length
          ? this.clone().ior(l)
          : l.clone().ior(this);
      }),
      (a.prototype.uor = function (l) {
        return this.length > l.length
          ? this.clone().iuor(l)
          : l.clone().iuor(this);
      }),
      (a.prototype.iuand = function (l) {
        var p;
        this.length > l.length ? (p = l) : (p = this);
        for (var y = 0; y < p.length; y++)
          this.words[y] = this.words[y] & l.words[y];
        return (this.length = p.length), this.strip();
      }),
      (a.prototype.iand = function (l) {
        return n((this.negative | l.negative) === 0), this.iuand(l);
      }),
      (a.prototype.and = function (l) {
        return this.length > l.length
          ? this.clone().iand(l)
          : l.clone().iand(this);
      }),
      (a.prototype.uand = function (l) {
        return this.length > l.length
          ? this.clone().iuand(l)
          : l.clone().iuand(this);
      }),
      (a.prototype.iuxor = function (l) {
        var p, y;
        this.length > l.length ? ((p = this), (y = l)) : ((p = l), (y = this));
        for (var h = 0; h < y.length; h++)
          this.words[h] = p.words[h] ^ y.words[h];
        if (this !== p) for (; h < p.length; h++) this.words[h] = p.words[h];
        return (this.length = p.length), this.strip();
      }),
      (a.prototype.ixor = function (l) {
        return n((this.negative | l.negative) === 0), this.iuxor(l);
      }),
      (a.prototype.xor = function (l) {
        return this.length > l.length
          ? this.clone().ixor(l)
          : l.clone().ixor(this);
      }),
      (a.prototype.uxor = function (l) {
        return this.length > l.length
          ? this.clone().iuxor(l)
          : l.clone().iuxor(this);
      }),
      (a.prototype.inotn = function (l) {
        n(typeof l == "number" && l >= 0);
        var p = Math.ceil(l / 26) | 0,
          y = l % 26;
        this._expand(p), y > 0 && p--;
        for (var h = 0; h < p; h++) this.words[h] = ~this.words[h] & 67108863;
        return (
          y > 0 && (this.words[h] = ~this.words[h] & (67108863 >> (26 - y))),
          this.strip()
        );
      }),
      (a.prototype.notn = function (l) {
        return this.clone().inotn(l);
      }),
      (a.prototype.setn = function (l, p) {
        n(typeof l == "number" && l >= 0);
        var y = (l / 26) | 0,
          h = l % 26;
        return (
          this._expand(y + 1),
          p
            ? (this.words[y] = this.words[y] | (1 << h))
            : (this.words[y] = this.words[y] & ~(1 << h)),
          this.strip()
        );
      }),
      (a.prototype.iadd = function (l) {
        var p;
        if (this.negative !== 0 && l.negative === 0)
          return (
            (this.negative = 0),
            (p = this.isub(l)),
            (this.negative ^= 1),
            this._normSign()
          );
        if (this.negative === 0 && l.negative !== 0)
          return (
            (l.negative = 0),
            (p = this.isub(l)),
            (l.negative = 1),
            p._normSign()
          );
        var y, h;
        this.length > l.length ? ((y = this), (h = l)) : ((y = l), (h = this));
        for (var g = 0, T = 0; T < h.length; T++)
          (p = (y.words[T] | 0) + (h.words[T] | 0) + g),
            (this.words[T] = p & 67108863),
            (g = p >>> 26);
        for (; g !== 0 && T < y.length; T++)
          (p = (y.words[T] | 0) + g),
            (this.words[T] = p & 67108863),
            (g = p >>> 26);
        if (((this.length = y.length), g !== 0))
          (this.words[this.length] = g), this.length++;
        else if (y !== this)
          for (; T < y.length; T++) this.words[T] = y.words[T];
        return this;
      }),
      (a.prototype.add = function (l) {
        var p;
        return l.negative !== 0 && this.negative === 0
          ? ((l.negative = 0), (p = this.sub(l)), (l.negative ^= 1), p)
          : l.negative === 0 && this.negative !== 0
          ? ((this.negative = 0), (p = l.sub(this)), (this.negative = 1), p)
          : this.length > l.length
          ? this.clone().iadd(l)
          : l.clone().iadd(this);
      }),
      (a.prototype.isub = function (l) {
        if (l.negative !== 0) {
          l.negative = 0;
          var p = this.iadd(l);
          return (l.negative = 1), p._normSign();
        } else if (this.negative !== 0)
          return (
            (this.negative = 0),
            this.iadd(l),
            (this.negative = 1),
            this._normSign()
          );
        var y = this.cmp(l);
        if (y === 0)
          return (
            (this.negative = 0), (this.length = 1), (this.words[0] = 0), this
          );
        var h, g;
        y > 0 ? ((h = this), (g = l)) : ((h = l), (g = this));
        for (var T = 0, R = 0; R < g.length; R++)
          (p = (h.words[R] | 0) - (g.words[R] | 0) + T),
            (T = p >> 26),
            (this.words[R] = p & 67108863);
        for (; T !== 0 && R < h.length; R++)
          (p = (h.words[R] | 0) + T),
            (T = p >> 26),
            (this.words[R] = p & 67108863);
        if (T === 0 && R < h.length && h !== this)
          for (; R < h.length; R++) this.words[R] = h.words[R];
        return (
          (this.length = Math.max(this.length, R)),
          h !== this && (this.negative = 1),
          this.strip()
        );
      }),
      (a.prototype.sub = function (l) {
        return this.clone().isub(l);
      });
    function E(C, l, p) {
      p.negative = l.negative ^ C.negative;
      var y = (C.length + l.length) | 0;
      (p.length = y), (y = (y - 1) | 0);
      var h = C.words[0] | 0,
        g = l.words[0] | 0,
        T = h * g,
        R = T & 67108863,
        x = (T / 67108864) | 0;
      p.words[0] = R;
      for (var f = 1; f < y; f++) {
        for (
          var _ = x >>> 26,
            P = x & 67108863,
            M = Math.min(f, l.length - 1),
            D = Math.max(0, f - C.length + 1);
          D <= M;
          D++
        ) {
          var q = (f - D) | 0;
          (h = C.words[q] | 0),
            (g = l.words[D] | 0),
            (T = h * g + P),
            (_ += (T / 67108864) | 0),
            (P = T & 67108863);
        }
        (p.words[f] = P | 0), (x = _ | 0);
      }
      return x !== 0 ? (p.words[f] = x | 0) : p.length--, p.strip();
    }
    var A = function (l, p, y) {
      var h = l.words,
        g = p.words,
        T = y.words,
        R = 0,
        x,
        f,
        _,
        P = h[0] | 0,
        M = P & 8191,
        D = P >>> 13,
        q = h[1] | 0,
        B = q & 8191,
        H = q >>> 13,
        Q = h[2] | 0,
        Z = Q & 8191,
        te = Q >>> 13,
        Te = h[3] | 0,
        K = Te & 8191,
        G = Te >>> 13,
        he = h[4] | 0,
        se = he & 8191,
        pe = he >>> 13,
        Y = h[5] | 0,
        $ = Y & 8191,
        W = Y >>> 13,
        re = h[6] | 0,
        ee = re & 8191,
        ce = re >>> 13,
        Ce = h[7] | 0,
        me = Ce & 8191,
        ge = Ce >>> 13,
        it = h[8] | 0,
        ve = it & 8191,
        z = it >>> 13,
        U = h[9] | 0,
        L = U & 8191,
        J = U >>> 13,
        fe = g[0] | 0,
        ie = fe & 8191,
        le = fe >>> 13,
        nt = g[1] | 0,
        Ee = nt & 8191,
        we = nt >>> 13,
        ft = g[2] | 0,
        xe = ft & 8191,
        Pe = ft >>> 13,
        hr = g[3] | 0,
        Ne = hr & 8191,
        Me = hr >>> 13,
        _r = g[4] | 0,
        Be = _r & 8191,
        De = _r >>> 13,
        pr = g[5] | 0,
        Oe = pr & 8191,
        Fe = pr >>> 13,
        mr = g[6] | 0,
        Le = mr & 8191,
        Ie = mr >>> 13,
        At = g[7] | 0,
        Ae = At & 8191,
        Re = At >>> 13,
        Er = g[8] | 0,
        $e = Er & 8191,
        Ue = Er >>> 13,
        Mr = g[9] | 0,
        We = Mr & 8191,
        je = Mr >>> 13;
      (y.negative = l.negative ^ p.negative),
        (y.length = 19),
        (x = Math.imul(M, ie)),
        (f = Math.imul(M, le)),
        (f = (f + Math.imul(D, ie)) | 0),
        (_ = Math.imul(D, le));
      var ur = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (ur >>> 26)) | 0),
        (ur &= 67108863),
        (x = Math.imul(B, ie)),
        (f = Math.imul(B, le)),
        (f = (f + Math.imul(H, ie)) | 0),
        (_ = Math.imul(H, le)),
        (x = (x + Math.imul(M, Ee)) | 0),
        (f = (f + Math.imul(M, we)) | 0),
        (f = (f + Math.imul(D, Ee)) | 0),
        (_ = (_ + Math.imul(D, we)) | 0);
      var mt = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (mt >>> 26)) | 0),
        (mt &= 67108863),
        (x = Math.imul(Z, ie)),
        (f = Math.imul(Z, le)),
        (f = (f + Math.imul(te, ie)) | 0),
        (_ = Math.imul(te, le)),
        (x = (x + Math.imul(B, Ee)) | 0),
        (f = (f + Math.imul(B, we)) | 0),
        (f = (f + Math.imul(H, Ee)) | 0),
        (_ = (_ + Math.imul(H, we)) | 0),
        (x = (x + Math.imul(M, xe)) | 0),
        (f = (f + Math.imul(M, Pe)) | 0),
        (f = (f + Math.imul(D, xe)) | 0),
        (_ = (_ + Math.imul(D, Pe)) | 0);
      var yt = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (yt >>> 26)) | 0),
        (yt &= 67108863),
        (x = Math.imul(K, ie)),
        (f = Math.imul(K, le)),
        (f = (f + Math.imul(G, ie)) | 0),
        (_ = Math.imul(G, le)),
        (x = (x + Math.imul(Z, Ee)) | 0),
        (f = (f + Math.imul(Z, we)) | 0),
        (f = (f + Math.imul(te, Ee)) | 0),
        (_ = (_ + Math.imul(te, we)) | 0),
        (x = (x + Math.imul(B, xe)) | 0),
        (f = (f + Math.imul(B, Pe)) | 0),
        (f = (f + Math.imul(H, xe)) | 0),
        (_ = (_ + Math.imul(H, Pe)) | 0),
        (x = (x + Math.imul(M, Ne)) | 0),
        (f = (f + Math.imul(M, Me)) | 0),
        (f = (f + Math.imul(D, Ne)) | 0),
        (_ = (_ + Math.imul(D, Me)) | 0);
      var rr = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (rr >>> 26)) | 0),
        (rr &= 67108863),
        (x = Math.imul(se, ie)),
        (f = Math.imul(se, le)),
        (f = (f + Math.imul(pe, ie)) | 0),
        (_ = Math.imul(pe, le)),
        (x = (x + Math.imul(K, Ee)) | 0),
        (f = (f + Math.imul(K, we)) | 0),
        (f = (f + Math.imul(G, Ee)) | 0),
        (_ = (_ + Math.imul(G, we)) | 0),
        (x = (x + Math.imul(Z, xe)) | 0),
        (f = (f + Math.imul(Z, Pe)) | 0),
        (f = (f + Math.imul(te, xe)) | 0),
        (_ = (_ + Math.imul(te, Pe)) | 0),
        (x = (x + Math.imul(B, Ne)) | 0),
        (f = (f + Math.imul(B, Me)) | 0),
        (f = (f + Math.imul(H, Ne)) | 0),
        (_ = (_ + Math.imul(H, Me)) | 0),
        (x = (x + Math.imul(M, Be)) | 0),
        (f = (f + Math.imul(M, De)) | 0),
        (f = (f + Math.imul(D, Be)) | 0),
        (_ = (_ + Math.imul(D, De)) | 0);
      var nr = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (nr >>> 26)) | 0),
        (nr &= 67108863),
        (x = Math.imul($, ie)),
        (f = Math.imul($, le)),
        (f = (f + Math.imul(W, ie)) | 0),
        (_ = Math.imul(W, le)),
        (x = (x + Math.imul(se, Ee)) | 0),
        (f = (f + Math.imul(se, we)) | 0),
        (f = (f + Math.imul(pe, Ee)) | 0),
        (_ = (_ + Math.imul(pe, we)) | 0),
        (x = (x + Math.imul(K, xe)) | 0),
        (f = (f + Math.imul(K, Pe)) | 0),
        (f = (f + Math.imul(G, xe)) | 0),
        (_ = (_ + Math.imul(G, Pe)) | 0),
        (x = (x + Math.imul(Z, Ne)) | 0),
        (f = (f + Math.imul(Z, Me)) | 0),
        (f = (f + Math.imul(te, Ne)) | 0),
        (_ = (_ + Math.imul(te, Me)) | 0),
        (x = (x + Math.imul(B, Be)) | 0),
        (f = (f + Math.imul(B, De)) | 0),
        (f = (f + Math.imul(H, Be)) | 0),
        (_ = (_ + Math.imul(H, De)) | 0),
        (x = (x + Math.imul(M, Oe)) | 0),
        (f = (f + Math.imul(M, Fe)) | 0),
        (f = (f + Math.imul(D, Oe)) | 0),
        (_ = (_ + Math.imul(D, Fe)) | 0);
      var ir = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (ir >>> 26)) | 0),
        (ir &= 67108863),
        (x = Math.imul(ee, ie)),
        (f = Math.imul(ee, le)),
        (f = (f + Math.imul(ce, ie)) | 0),
        (_ = Math.imul(ce, le)),
        (x = (x + Math.imul($, Ee)) | 0),
        (f = (f + Math.imul($, we)) | 0),
        (f = (f + Math.imul(W, Ee)) | 0),
        (_ = (_ + Math.imul(W, we)) | 0),
        (x = (x + Math.imul(se, xe)) | 0),
        (f = (f + Math.imul(se, Pe)) | 0),
        (f = (f + Math.imul(pe, xe)) | 0),
        (_ = (_ + Math.imul(pe, Pe)) | 0),
        (x = (x + Math.imul(K, Ne)) | 0),
        (f = (f + Math.imul(K, Me)) | 0),
        (f = (f + Math.imul(G, Ne)) | 0),
        (_ = (_ + Math.imul(G, Me)) | 0),
        (x = (x + Math.imul(Z, Be)) | 0),
        (f = (f + Math.imul(Z, De)) | 0),
        (f = (f + Math.imul(te, Be)) | 0),
        (_ = (_ + Math.imul(te, De)) | 0),
        (x = (x + Math.imul(B, Oe)) | 0),
        (f = (f + Math.imul(B, Fe)) | 0),
        (f = (f + Math.imul(H, Oe)) | 0),
        (_ = (_ + Math.imul(H, Fe)) | 0),
        (x = (x + Math.imul(M, Le)) | 0),
        (f = (f + Math.imul(M, Ie)) | 0),
        (f = (f + Math.imul(D, Le)) | 0),
        (_ = (_ + Math.imul(D, Ie)) | 0);
      var ar = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (ar >>> 26)) | 0),
        (ar &= 67108863),
        (x = Math.imul(me, ie)),
        (f = Math.imul(me, le)),
        (f = (f + Math.imul(ge, ie)) | 0),
        (_ = Math.imul(ge, le)),
        (x = (x + Math.imul(ee, Ee)) | 0),
        (f = (f + Math.imul(ee, we)) | 0),
        (f = (f + Math.imul(ce, Ee)) | 0),
        (_ = (_ + Math.imul(ce, we)) | 0),
        (x = (x + Math.imul($, xe)) | 0),
        (f = (f + Math.imul($, Pe)) | 0),
        (f = (f + Math.imul(W, xe)) | 0),
        (_ = (_ + Math.imul(W, Pe)) | 0),
        (x = (x + Math.imul(se, Ne)) | 0),
        (f = (f + Math.imul(se, Me)) | 0),
        (f = (f + Math.imul(pe, Ne)) | 0),
        (_ = (_ + Math.imul(pe, Me)) | 0),
        (x = (x + Math.imul(K, Be)) | 0),
        (f = (f + Math.imul(K, De)) | 0),
        (f = (f + Math.imul(G, Be)) | 0),
        (_ = (_ + Math.imul(G, De)) | 0),
        (x = (x + Math.imul(Z, Oe)) | 0),
        (f = (f + Math.imul(Z, Fe)) | 0),
        (f = (f + Math.imul(te, Oe)) | 0),
        (_ = (_ + Math.imul(te, Fe)) | 0),
        (x = (x + Math.imul(B, Le)) | 0),
        (f = (f + Math.imul(B, Ie)) | 0),
        (f = (f + Math.imul(H, Le)) | 0),
        (_ = (_ + Math.imul(H, Ie)) | 0),
        (x = (x + Math.imul(M, Ae)) | 0),
        (f = (f + Math.imul(M, Re)) | 0),
        (f = (f + Math.imul(D, Ae)) | 0),
        (_ = (_ + Math.imul(D, Re)) | 0);
      var sr = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (sr >>> 26)) | 0),
        (sr &= 67108863),
        (x = Math.imul(ve, ie)),
        (f = Math.imul(ve, le)),
        (f = (f + Math.imul(z, ie)) | 0),
        (_ = Math.imul(z, le)),
        (x = (x + Math.imul(me, Ee)) | 0),
        (f = (f + Math.imul(me, we)) | 0),
        (f = (f + Math.imul(ge, Ee)) | 0),
        (_ = (_ + Math.imul(ge, we)) | 0),
        (x = (x + Math.imul(ee, xe)) | 0),
        (f = (f + Math.imul(ee, Pe)) | 0),
        (f = (f + Math.imul(ce, xe)) | 0),
        (_ = (_ + Math.imul(ce, Pe)) | 0),
        (x = (x + Math.imul($, Ne)) | 0),
        (f = (f + Math.imul($, Me)) | 0),
        (f = (f + Math.imul(W, Ne)) | 0),
        (_ = (_ + Math.imul(W, Me)) | 0),
        (x = (x + Math.imul(se, Be)) | 0),
        (f = (f + Math.imul(se, De)) | 0),
        (f = (f + Math.imul(pe, Be)) | 0),
        (_ = (_ + Math.imul(pe, De)) | 0),
        (x = (x + Math.imul(K, Oe)) | 0),
        (f = (f + Math.imul(K, Fe)) | 0),
        (f = (f + Math.imul(G, Oe)) | 0),
        (_ = (_ + Math.imul(G, Fe)) | 0),
        (x = (x + Math.imul(Z, Le)) | 0),
        (f = (f + Math.imul(Z, Ie)) | 0),
        (f = (f + Math.imul(te, Le)) | 0),
        (_ = (_ + Math.imul(te, Ie)) | 0),
        (x = (x + Math.imul(B, Ae)) | 0),
        (f = (f + Math.imul(B, Re)) | 0),
        (f = (f + Math.imul(H, Ae)) | 0),
        (_ = (_ + Math.imul(H, Re)) | 0),
        (x = (x + Math.imul(M, $e)) | 0),
        (f = (f + Math.imul(M, Ue)) | 0),
        (f = (f + Math.imul(D, $e)) | 0),
        (_ = (_ + Math.imul(D, Ue)) | 0);
      var Ir = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (Ir >>> 26)) | 0),
        (Ir &= 67108863),
        (x = Math.imul(L, ie)),
        (f = Math.imul(L, le)),
        (f = (f + Math.imul(J, ie)) | 0),
        (_ = Math.imul(J, le)),
        (x = (x + Math.imul(ve, Ee)) | 0),
        (f = (f + Math.imul(ve, we)) | 0),
        (f = (f + Math.imul(z, Ee)) | 0),
        (_ = (_ + Math.imul(z, we)) | 0),
        (x = (x + Math.imul(me, xe)) | 0),
        (f = (f + Math.imul(me, Pe)) | 0),
        (f = (f + Math.imul(ge, xe)) | 0),
        (_ = (_ + Math.imul(ge, Pe)) | 0),
        (x = (x + Math.imul(ee, Ne)) | 0),
        (f = (f + Math.imul(ee, Me)) | 0),
        (f = (f + Math.imul(ce, Ne)) | 0),
        (_ = (_ + Math.imul(ce, Me)) | 0),
        (x = (x + Math.imul($, Be)) | 0),
        (f = (f + Math.imul($, De)) | 0),
        (f = (f + Math.imul(W, Be)) | 0),
        (_ = (_ + Math.imul(W, De)) | 0),
        (x = (x + Math.imul(se, Oe)) | 0),
        (f = (f + Math.imul(se, Fe)) | 0),
        (f = (f + Math.imul(pe, Oe)) | 0),
        (_ = (_ + Math.imul(pe, Fe)) | 0),
        (x = (x + Math.imul(K, Le)) | 0),
        (f = (f + Math.imul(K, Ie)) | 0),
        (f = (f + Math.imul(G, Le)) | 0),
        (_ = (_ + Math.imul(G, Ie)) | 0),
        (x = (x + Math.imul(Z, Ae)) | 0),
        (f = (f + Math.imul(Z, Re)) | 0),
        (f = (f + Math.imul(te, Ae)) | 0),
        (_ = (_ + Math.imul(te, Re)) | 0),
        (x = (x + Math.imul(B, $e)) | 0),
        (f = (f + Math.imul(B, Ue)) | 0),
        (f = (f + Math.imul(H, $e)) | 0),
        (_ = (_ + Math.imul(H, Ue)) | 0),
        (x = (x + Math.imul(M, We)) | 0),
        (f = (f + Math.imul(M, je)) | 0),
        (f = (f + Math.imul(D, We)) | 0),
        (_ = (_ + Math.imul(D, je)) | 0);
      var Rr = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (Rr >>> 26)) | 0),
        (Rr &= 67108863),
        (x = Math.imul(L, Ee)),
        (f = Math.imul(L, we)),
        (f = (f + Math.imul(J, Ee)) | 0),
        (_ = Math.imul(J, we)),
        (x = (x + Math.imul(ve, xe)) | 0),
        (f = (f + Math.imul(ve, Pe)) | 0),
        (f = (f + Math.imul(z, xe)) | 0),
        (_ = (_ + Math.imul(z, Pe)) | 0),
        (x = (x + Math.imul(me, Ne)) | 0),
        (f = (f + Math.imul(me, Me)) | 0),
        (f = (f + Math.imul(ge, Ne)) | 0),
        (_ = (_ + Math.imul(ge, Me)) | 0),
        (x = (x + Math.imul(ee, Be)) | 0),
        (f = (f + Math.imul(ee, De)) | 0),
        (f = (f + Math.imul(ce, Be)) | 0),
        (_ = (_ + Math.imul(ce, De)) | 0),
        (x = (x + Math.imul($, Oe)) | 0),
        (f = (f + Math.imul($, Fe)) | 0),
        (f = (f + Math.imul(W, Oe)) | 0),
        (_ = (_ + Math.imul(W, Fe)) | 0),
        (x = (x + Math.imul(se, Le)) | 0),
        (f = (f + Math.imul(se, Ie)) | 0),
        (f = (f + Math.imul(pe, Le)) | 0),
        (_ = (_ + Math.imul(pe, Ie)) | 0),
        (x = (x + Math.imul(K, Ae)) | 0),
        (f = (f + Math.imul(K, Re)) | 0),
        (f = (f + Math.imul(G, Ae)) | 0),
        (_ = (_ + Math.imul(G, Re)) | 0),
        (x = (x + Math.imul(Z, $e)) | 0),
        (f = (f + Math.imul(Z, Ue)) | 0),
        (f = (f + Math.imul(te, $e)) | 0),
        (_ = (_ + Math.imul(te, Ue)) | 0),
        (x = (x + Math.imul(B, We)) | 0),
        (f = (f + Math.imul(B, je)) | 0),
        (f = (f + Math.imul(H, We)) | 0),
        (_ = (_ + Math.imul(H, je)) | 0);
      var Pr = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (Pr >>> 26)) | 0),
        (Pr &= 67108863),
        (x = Math.imul(L, xe)),
        (f = Math.imul(L, Pe)),
        (f = (f + Math.imul(J, xe)) | 0),
        (_ = Math.imul(J, Pe)),
        (x = (x + Math.imul(ve, Ne)) | 0),
        (f = (f + Math.imul(ve, Me)) | 0),
        (f = (f + Math.imul(z, Ne)) | 0),
        (_ = (_ + Math.imul(z, Me)) | 0),
        (x = (x + Math.imul(me, Be)) | 0),
        (f = (f + Math.imul(me, De)) | 0),
        (f = (f + Math.imul(ge, Be)) | 0),
        (_ = (_ + Math.imul(ge, De)) | 0),
        (x = (x + Math.imul(ee, Oe)) | 0),
        (f = (f + Math.imul(ee, Fe)) | 0),
        (f = (f + Math.imul(ce, Oe)) | 0),
        (_ = (_ + Math.imul(ce, Fe)) | 0),
        (x = (x + Math.imul($, Le)) | 0),
        (f = (f + Math.imul($, Ie)) | 0),
        (f = (f + Math.imul(W, Le)) | 0),
        (_ = (_ + Math.imul(W, Ie)) | 0),
        (x = (x + Math.imul(se, Ae)) | 0),
        (f = (f + Math.imul(se, Re)) | 0),
        (f = (f + Math.imul(pe, Ae)) | 0),
        (_ = (_ + Math.imul(pe, Re)) | 0),
        (x = (x + Math.imul(K, $e)) | 0),
        (f = (f + Math.imul(K, Ue)) | 0),
        (f = (f + Math.imul(G, $e)) | 0),
        (_ = (_ + Math.imul(G, Ue)) | 0),
        (x = (x + Math.imul(Z, We)) | 0),
        (f = (f + Math.imul(Z, je)) | 0),
        (f = (f + Math.imul(te, We)) | 0),
        (_ = (_ + Math.imul(te, je)) | 0);
      var Nr = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (Nr >>> 26)) | 0),
        (Nr &= 67108863),
        (x = Math.imul(L, Ne)),
        (f = Math.imul(L, Me)),
        (f = (f + Math.imul(J, Ne)) | 0),
        (_ = Math.imul(J, Me)),
        (x = (x + Math.imul(ve, Be)) | 0),
        (f = (f + Math.imul(ve, De)) | 0),
        (f = (f + Math.imul(z, Be)) | 0),
        (_ = (_ + Math.imul(z, De)) | 0),
        (x = (x + Math.imul(me, Oe)) | 0),
        (f = (f + Math.imul(me, Fe)) | 0),
        (f = (f + Math.imul(ge, Oe)) | 0),
        (_ = (_ + Math.imul(ge, Fe)) | 0),
        (x = (x + Math.imul(ee, Le)) | 0),
        (f = (f + Math.imul(ee, Ie)) | 0),
        (f = (f + Math.imul(ce, Le)) | 0),
        (_ = (_ + Math.imul(ce, Ie)) | 0),
        (x = (x + Math.imul($, Ae)) | 0),
        (f = (f + Math.imul($, Re)) | 0),
        (f = (f + Math.imul(W, Ae)) | 0),
        (_ = (_ + Math.imul(W, Re)) | 0),
        (x = (x + Math.imul(se, $e)) | 0),
        (f = (f + Math.imul(se, Ue)) | 0),
        (f = (f + Math.imul(pe, $e)) | 0),
        (_ = (_ + Math.imul(pe, Ue)) | 0),
        (x = (x + Math.imul(K, We)) | 0),
        (f = (f + Math.imul(K, je)) | 0),
        (f = (f + Math.imul(G, We)) | 0),
        (_ = (_ + Math.imul(G, je)) | 0);
      var Br = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (Br >>> 26)) | 0),
        (Br &= 67108863),
        (x = Math.imul(L, Be)),
        (f = Math.imul(L, De)),
        (f = (f + Math.imul(J, Be)) | 0),
        (_ = Math.imul(J, De)),
        (x = (x + Math.imul(ve, Oe)) | 0),
        (f = (f + Math.imul(ve, Fe)) | 0),
        (f = (f + Math.imul(z, Oe)) | 0),
        (_ = (_ + Math.imul(z, Fe)) | 0),
        (x = (x + Math.imul(me, Le)) | 0),
        (f = (f + Math.imul(me, Ie)) | 0),
        (f = (f + Math.imul(ge, Le)) | 0),
        (_ = (_ + Math.imul(ge, Ie)) | 0),
        (x = (x + Math.imul(ee, Ae)) | 0),
        (f = (f + Math.imul(ee, Re)) | 0),
        (f = (f + Math.imul(ce, Ae)) | 0),
        (_ = (_ + Math.imul(ce, Re)) | 0),
        (x = (x + Math.imul($, $e)) | 0),
        (f = (f + Math.imul($, Ue)) | 0),
        (f = (f + Math.imul(W, $e)) | 0),
        (_ = (_ + Math.imul(W, Ue)) | 0),
        (x = (x + Math.imul(se, We)) | 0),
        (f = (f + Math.imul(se, je)) | 0),
        (f = (f + Math.imul(pe, We)) | 0),
        (_ = (_ + Math.imul(pe, je)) | 0);
      var Dr = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (Dr >>> 26)) | 0),
        (Dr &= 67108863),
        (x = Math.imul(L, Oe)),
        (f = Math.imul(L, Fe)),
        (f = (f + Math.imul(J, Oe)) | 0),
        (_ = Math.imul(J, Fe)),
        (x = (x + Math.imul(ve, Le)) | 0),
        (f = (f + Math.imul(ve, Ie)) | 0),
        (f = (f + Math.imul(z, Le)) | 0),
        (_ = (_ + Math.imul(z, Ie)) | 0),
        (x = (x + Math.imul(me, Ae)) | 0),
        (f = (f + Math.imul(me, Re)) | 0),
        (f = (f + Math.imul(ge, Ae)) | 0),
        (_ = (_ + Math.imul(ge, Re)) | 0),
        (x = (x + Math.imul(ee, $e)) | 0),
        (f = (f + Math.imul(ee, Ue)) | 0),
        (f = (f + Math.imul(ce, $e)) | 0),
        (_ = (_ + Math.imul(ce, Ue)) | 0),
        (x = (x + Math.imul($, We)) | 0),
        (f = (f + Math.imul($, je)) | 0),
        (f = (f + Math.imul(W, We)) | 0),
        (_ = (_ + Math.imul(W, je)) | 0);
      var Or = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (Or >>> 26)) | 0),
        (Or &= 67108863),
        (x = Math.imul(L, Le)),
        (f = Math.imul(L, Ie)),
        (f = (f + Math.imul(J, Le)) | 0),
        (_ = Math.imul(J, Ie)),
        (x = (x + Math.imul(ve, Ae)) | 0),
        (f = (f + Math.imul(ve, Re)) | 0),
        (f = (f + Math.imul(z, Ae)) | 0),
        (_ = (_ + Math.imul(z, Re)) | 0),
        (x = (x + Math.imul(me, $e)) | 0),
        (f = (f + Math.imul(me, Ue)) | 0),
        (f = (f + Math.imul(ge, $e)) | 0),
        (_ = (_ + Math.imul(ge, Ue)) | 0),
        (x = (x + Math.imul(ee, We)) | 0),
        (f = (f + Math.imul(ee, je)) | 0),
        (f = (f + Math.imul(ce, We)) | 0),
        (_ = (_ + Math.imul(ce, je)) | 0);
      var Fr = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (Fr >>> 26)) | 0),
        (Fr &= 67108863),
        (x = Math.imul(L, Ae)),
        (f = Math.imul(L, Re)),
        (f = (f + Math.imul(J, Ae)) | 0),
        (_ = Math.imul(J, Re)),
        (x = (x + Math.imul(ve, $e)) | 0),
        (f = (f + Math.imul(ve, Ue)) | 0),
        (f = (f + Math.imul(z, $e)) | 0),
        (_ = (_ + Math.imul(z, Ue)) | 0),
        (x = (x + Math.imul(me, We)) | 0),
        (f = (f + Math.imul(me, je)) | 0),
        (f = (f + Math.imul(ge, We)) | 0),
        (_ = (_ + Math.imul(ge, je)) | 0);
      var Lr = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (Lr >>> 26)) | 0),
        (Lr &= 67108863),
        (x = Math.imul(L, $e)),
        (f = Math.imul(L, Ue)),
        (f = (f + Math.imul(J, $e)) | 0),
        (_ = Math.imul(J, Ue)),
        (x = (x + Math.imul(ve, We)) | 0),
        (f = (f + Math.imul(ve, je)) | 0),
        (f = (f + Math.imul(z, We)) | 0),
        (_ = (_ + Math.imul(z, je)) | 0);
      var bn = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      (R = (((_ + (f >>> 13)) | 0) + (bn >>> 26)) | 0),
        (bn &= 67108863),
        (x = Math.imul(L, We)),
        (f = Math.imul(L, je)),
        (f = (f + Math.imul(J, We)) | 0),
        (_ = Math.imul(J, je));
      var vn = (((R + x) | 0) + ((f & 8191) << 13)) | 0;
      return (
        (R = (((_ + (f >>> 13)) | 0) + (vn >>> 26)) | 0),
        (vn &= 67108863),
        (T[0] = ur),
        (T[1] = mt),
        (T[2] = yt),
        (T[3] = rr),
        (T[4] = nr),
        (T[5] = ir),
        (T[6] = ar),
        (T[7] = sr),
        (T[8] = Ir),
        (T[9] = Rr),
        (T[10] = Pr),
        (T[11] = Nr),
        (T[12] = Br),
        (T[13] = Dr),
        (T[14] = Or),
        (T[15] = Fr),
        (T[16] = Lr),
        (T[17] = bn),
        (T[18] = vn),
        R !== 0 && ((T[19] = R), y.length++),
        y
      );
    };
    Math.imul || (A = E);
    function I(C, l, p) {
      (p.negative = l.negative ^ C.negative), (p.length = C.length + l.length);
      for (var y = 0, h = 0, g = 0; g < p.length - 1; g++) {
        var T = h;
        h = 0;
        for (
          var R = y & 67108863,
            x = Math.min(g, l.length - 1),
            f = Math.max(0, g - C.length + 1);
          f <= x;
          f++
        ) {
          var _ = g - f,
            P = C.words[_] | 0,
            M = l.words[f] | 0,
            D = P * M,
            q = D & 67108863;
          (T = (T + ((D / 67108864) | 0)) | 0),
            (q = (q + R) | 0),
            (R = q & 67108863),
            (T = (T + (q >>> 26)) | 0),
            (h += T >>> 26),
            (T &= 67108863);
        }
        (p.words[g] = R), (y = T), (T = h);
      }
      return y !== 0 ? (p.words[g] = y) : p.length--, p.strip();
    }
    function b(C, l, p) {
      var y = new w();
      return y.mulp(C, l, p);
    }
    a.prototype.mulTo = function (l, p) {
      var y,
        h = this.length + l.length;
      return (
        this.length === 10 && l.length === 10
          ? (y = A(this, l, p))
          : h < 63
          ? (y = E(this, l, p))
          : h < 1024
          ? (y = I(this, l, p))
          : (y = b(this, l, p)),
        y
      );
    };
    function w(C, l) {
      (this.x = C), (this.y = l);
    }
    (w.prototype.makeRBT = function (l) {
      for (
        var p = new Array(l), y = a.prototype._countBits(l) - 1, h = 0;
        h < l;
        h++
      )
        p[h] = this.revBin(h, y, l);
      return p;
    }),
      (w.prototype.revBin = function (l, p, y) {
        if (l === 0 || l === y - 1) return l;
        for (var h = 0, g = 0; g < p; g++)
          (h |= (l & 1) << (p - g - 1)), (l >>= 1);
        return h;
      }),
      (w.prototype.permute = function (l, p, y, h, g, T) {
        for (var R = 0; R < T; R++) (h[R] = p[l[R]]), (g[R] = y[l[R]]);
      }),
      (w.prototype.transform = function (l, p, y, h, g, T) {
        this.permute(T, l, p, y, h, g);
        for (var R = 1; R < g; R <<= 1)
          for (
            var x = R << 1,
              f = Math.cos((2 * Math.PI) / x),
              _ = Math.sin((2 * Math.PI) / x),
              P = 0;
            P < g;
            P += x
          )
            for (var M = f, D = _, q = 0; q < R; q++) {
              var B = y[P + q],
                H = h[P + q],
                Q = y[P + q + R],
                Z = h[P + q + R],
                te = M * Q - D * Z;
              (Z = M * Z + D * Q),
                (Q = te),
                (y[P + q] = B + Q),
                (h[P + q] = H + Z),
                (y[P + q + R] = B - Q),
                (h[P + q + R] = H - Z),
                q !== x &&
                  ((te = f * M - _ * D), (D = f * D + _ * M), (M = te));
            }
      }),
      (w.prototype.guessLen13b = function (l, p) {
        var y = Math.max(p, l) | 1,
          h = y & 1,
          g = 0;
        for (y = (y / 2) | 0; y; y = y >>> 1) g++;
        return 1 << (g + 1 + h);
      }),
      (w.prototype.conjugate = function (l, p, y) {
        if (!(y <= 1))
          for (var h = 0; h < y / 2; h++) {
            var g = l[h];
            (l[h] = l[y - h - 1]),
              (l[y - h - 1] = g),
              (g = p[h]),
              (p[h] = -p[y - h - 1]),
              (p[y - h - 1] = -g);
          }
      }),
      (w.prototype.normalize13b = function (l, p) {
        for (var y = 0, h = 0; h < p / 2; h++) {
          var g =
            Math.round(l[2 * h + 1] / p) * 8192 + Math.round(l[2 * h] / p) + y;
          (l[h] = g & 67108863),
            g < 67108864 ? (y = 0) : (y = (g / 67108864) | 0);
        }
        return l;
      }),
      (w.prototype.convert13b = function (l, p, y, h) {
        for (var g = 0, T = 0; T < p; T++)
          (g = g + (l[T] | 0)),
            (y[2 * T] = g & 8191),
            (g = g >>> 13),
            (y[2 * T + 1] = g & 8191),
            (g = g >>> 13);
        for (T = 2 * p; T < h; ++T) y[T] = 0;
        n(g === 0), n((g & -8192) === 0);
      }),
      (w.prototype.stub = function (l) {
        for (var p = new Array(l), y = 0; y < l; y++) p[y] = 0;
        return p;
      }),
      (w.prototype.mulp = function (l, p, y) {
        var h = 2 * this.guessLen13b(l.length, p.length),
          g = this.makeRBT(h),
          T = this.stub(h),
          R = new Array(h),
          x = new Array(h),
          f = new Array(h),
          _ = new Array(h),
          P = new Array(h),
          M = new Array(h),
          D = y.words;
        (D.length = h),
          this.convert13b(l.words, l.length, R, h),
          this.convert13b(p.words, p.length, _, h),
          this.transform(R, T, x, f, h, g),
          this.transform(_, T, P, M, h, g);
        for (var q = 0; q < h; q++) {
          var B = x[q] * P[q] - f[q] * M[q];
          (f[q] = x[q] * M[q] + f[q] * P[q]), (x[q] = B);
        }
        return (
          this.conjugate(x, f, h),
          this.transform(x, f, D, T, h, g),
          this.conjugate(D, T, h),
          this.normalize13b(D, h),
          (y.negative = l.negative ^ p.negative),
          (y.length = l.length + p.length),
          y.strip()
        );
      }),
      (a.prototype.mul = function (l) {
        var p = new a(null);
        return (p.words = new Array(this.length + l.length)), this.mulTo(l, p);
      }),
      (a.prototype.mulf = function (l) {
        var p = new a(null);
        return (p.words = new Array(this.length + l.length)), b(this, l, p);
      }),
      (a.prototype.imul = function (l) {
        return this.clone().mulTo(l, this);
      }),
      (a.prototype.imuln = function (l) {
        n(typeof l == "number"), n(l < 67108864);
        for (var p = 0, y = 0; y < this.length; y++) {
          var h = (this.words[y] | 0) * l,
            g = (h & 67108863) + (p & 67108863);
          (p >>= 26),
            (p += (h / 67108864) | 0),
            (p += g >>> 26),
            (this.words[y] = g & 67108863);
        }
        return p !== 0 && ((this.words[y] = p), this.length++), this;
      }),
      (a.prototype.muln = function (l) {
        return this.clone().imuln(l);
      }),
      (a.prototype.sqr = function () {
        return this.mul(this);
      }),
      (a.prototype.isqr = function () {
        return this.imul(this.clone());
      }),
      (a.prototype.pow = function (l) {
        var p = v(l);
        if (p.length === 0) return new a(1);
        for (var y = this, h = 0; h < p.length && p[h] === 0; h++, y = y.sqr());
        if (++h < p.length)
          for (var g = y.sqr(); h < p.length; h++, g = g.sqr())
            p[h] !== 0 && (y = y.mul(g));
        return y;
      }),
      (a.prototype.iushln = function (l) {
        n(typeof l == "number" && l >= 0);
        var p = l % 26,
          y = (l - p) / 26,
          h = (67108863 >>> (26 - p)) << (26 - p),
          g;
        if (p !== 0) {
          var T = 0;
          for (g = 0; g < this.length; g++) {
            var R = this.words[g] & h,
              x = ((this.words[g] | 0) - R) << p;
            (this.words[g] = x | T), (T = R >>> (26 - p));
          }
          T && ((this.words[g] = T), this.length++);
        }
        if (y !== 0) {
          for (g = this.length - 1; g >= 0; g--)
            this.words[g + y] = this.words[g];
          for (g = 0; g < y; g++) this.words[g] = 0;
          this.length += y;
        }
        return this.strip();
      }),
      (a.prototype.ishln = function (l) {
        return n(this.negative === 0), this.iushln(l);
      }),
      (a.prototype.iushrn = function (l, p, y) {
        n(typeof l == "number" && l >= 0);
        var h;
        p ? (h = (p - (p % 26)) / 26) : (h = 0);
        var g = l % 26,
          T = Math.min((l - g) / 26, this.length),
          R = 67108863 ^ ((67108863 >>> g) << g),
          x = y;
        if (((h -= T), (h = Math.max(0, h)), x)) {
          for (var f = 0; f < T; f++) x.words[f] = this.words[f];
          x.length = T;
        }
        if (T !== 0)
          if (this.length > T)
            for (this.length -= T, f = 0; f < this.length; f++)
              this.words[f] = this.words[f + T];
          else (this.words[0] = 0), (this.length = 1);
        var _ = 0;
        for (f = this.length - 1; f >= 0 && (_ !== 0 || f >= h); f--) {
          var P = this.words[f] | 0;
          (this.words[f] = (_ << (26 - g)) | (P >>> g)), (_ = P & R);
        }
        return (
          x && _ !== 0 && (x.words[x.length++] = _),
          this.length === 0 && ((this.words[0] = 0), (this.length = 1)),
          this.strip()
        );
      }),
      (a.prototype.ishrn = function (l, p, y) {
        return n(this.negative === 0), this.iushrn(l, p, y);
      }),
      (a.prototype.shln = function (l) {
        return this.clone().ishln(l);
      }),
      (a.prototype.ushln = function (l) {
        return this.clone().iushln(l);
      }),
      (a.prototype.shrn = function (l) {
        return this.clone().ishrn(l);
      }),
      (a.prototype.ushrn = function (l) {
        return this.clone().iushrn(l);
      }),
      (a.prototype.testn = function (l) {
        n(typeof l == "number" && l >= 0);
        var p = l % 26,
          y = (l - p) / 26,
          h = 1 << p;
        if (this.length <= y) return !1;
        var g = this.words[y];
        return !!(g & h);
      }),
      (a.prototype.imaskn = function (l) {
        n(typeof l == "number" && l >= 0);
        var p = l % 26,
          y = (l - p) / 26;
        if (
          (n(this.negative === 0, "imaskn works only with positive numbers"),
          this.length <= y)
        )
          return this;
        if (
          (p !== 0 && y++, (this.length = Math.min(y, this.length)), p !== 0)
        ) {
          var h = 67108863 ^ ((67108863 >>> p) << p);
          this.words[this.length - 1] &= h;
        }
        return this.strip();
      }),
      (a.prototype.maskn = function (l) {
        return this.clone().imaskn(l);
      }),
      (a.prototype.iaddn = function (l) {
        return (
          n(typeof l == "number"),
          n(l < 67108864),
          l < 0
            ? this.isubn(-l)
            : this.negative !== 0
            ? this.length === 1 && (this.words[0] | 0) < l
              ? ((this.words[0] = l - (this.words[0] | 0)),
                (this.negative = 0),
                this)
              : ((this.negative = 0), this.isubn(l), (this.negative = 1), this)
            : this._iaddn(l)
        );
      }),
      (a.prototype._iaddn = function (l) {
        this.words[0] += l;
        for (var p = 0; p < this.length && this.words[p] >= 67108864; p++)
          (this.words[p] -= 67108864),
            p === this.length - 1
              ? (this.words[p + 1] = 1)
              : this.words[p + 1]++;
        return (this.length = Math.max(this.length, p + 1)), this;
      }),
      (a.prototype.isubn = function (l) {
        if ((n(typeof l == "number"), n(l < 67108864), l < 0))
          return this.iaddn(-l);
        if (this.negative !== 0)
          return (this.negative = 0), this.iaddn(l), (this.negative = 1), this;
        if (((this.words[0] -= l), this.length === 1 && this.words[0] < 0))
          (this.words[0] = -this.words[0]), (this.negative = 1);
        else
          for (var p = 0; p < this.length && this.words[p] < 0; p++)
            (this.words[p] += 67108864), (this.words[p + 1] -= 1);
        return this.strip();
      }),
      (a.prototype.addn = function (l) {
        return this.clone().iaddn(l);
      }),
      (a.prototype.subn = function (l) {
        return this.clone().isubn(l);
      }),
      (a.prototype.iabs = function () {
        return (this.negative = 0), this;
      }),
      (a.prototype.abs = function () {
        return this.clone().iabs();
      }),
      (a.prototype._ishlnsubmul = function (l, p, y) {
        var h = l.length + y,
          g;
        this._expand(h);
        var T,
          R = 0;
        for (g = 0; g < l.length; g++) {
          T = (this.words[g + y] | 0) + R;
          var x = (l.words[g] | 0) * p;
          (T -= x & 67108863),
            (R = (T >> 26) - ((x / 67108864) | 0)),
            (this.words[g + y] = T & 67108863);
        }
        for (; g < this.length - y; g++)
          (T = (this.words[g + y] | 0) + R),
            (R = T >> 26),
            (this.words[g + y] = T & 67108863);
        if (R === 0) return this.strip();
        for (n(R === -1), R = 0, g = 0; g < this.length; g++)
          (T = -(this.words[g] | 0) + R),
            (R = T >> 26),
            (this.words[g] = T & 67108863);
        return (this.negative = 1), this.strip();
      }),
      (a.prototype._wordDiv = function (l, p) {
        var y = this.length - l.length,
          h = this.clone(),
          g = l,
          T = g.words[g.length - 1] | 0,
          R = this._countBits(T);
        (y = 26 - R),
          y !== 0 &&
            ((g = g.ushln(y)), h.iushln(y), (T = g.words[g.length - 1] | 0));
        var x = h.length - g.length,
          f;
        if (p !== "mod") {
          (f = new a(null)),
            (f.length = x + 1),
            (f.words = new Array(f.length));
          for (var _ = 0; _ < f.length; _++) f.words[_] = 0;
        }
        var P = h.clone()._ishlnsubmul(g, 1, x);
        P.negative === 0 && ((h = P), f && (f.words[x] = 1));
        for (var M = x - 1; M >= 0; M--) {
          var D =
            (h.words[g.length + M] | 0) * 67108864 +
            (h.words[g.length + M - 1] | 0);
          for (
            D = Math.min((D / T) | 0, 67108863), h._ishlnsubmul(g, D, M);
            h.negative !== 0;

          )
            D--,
              (h.negative = 0),
              h._ishlnsubmul(g, 1, M),
              h.isZero() || (h.negative ^= 1);
          f && (f.words[M] = D);
        }
        return (
          f && f.strip(),
          h.strip(),
          p !== "div" && y !== 0 && h.iushrn(y),
          {
            div: f || null,
            mod: h,
          }
        );
      }),
      (a.prototype.divmod = function (l, p, y) {
        if ((n(!l.isZero()), this.isZero()))
          return {
            div: new a(0),
            mod: new a(0),
          };
        var h, g, T;
        return this.negative !== 0 && l.negative === 0
          ? ((T = this.neg().divmod(l, p)),
            p !== "mod" && (h = T.div.neg()),
            p !== "div" &&
              ((g = T.mod.neg()), y && g.negative !== 0 && g.iadd(l)),
            {
              div: h,
              mod: g,
            })
          : this.negative === 0 && l.negative !== 0
          ? ((T = this.divmod(l.neg(), p)),
            p !== "mod" && (h = T.div.neg()),
            {
              div: h,
              mod: T.mod,
            })
          : this.negative & l.negative
          ? ((T = this.neg().divmod(l.neg(), p)),
            p !== "div" &&
              ((g = T.mod.neg()), y && g.negative !== 0 && g.isub(l)),
            {
              div: T.div,
              mod: g,
            })
          : l.length > this.length || this.cmp(l) < 0
          ? {
              div: new a(0),
              mod: this,
            }
          : l.length === 1
          ? p === "div"
            ? {
                div: this.divn(l.words[0]),
                mod: null,
              }
            : p === "mod"
            ? {
                div: null,
                mod: new a(this.modn(l.words[0])),
              }
            : {
                div: this.divn(l.words[0]),
                mod: new a(this.modn(l.words[0])),
              }
          : this._wordDiv(l, p);
      }),
      (a.prototype.div = function (l) {
        return this.divmod(l, "div", !1).div;
      }),
      (a.prototype.mod = function (l) {
        return this.divmod(l, "mod", !1).mod;
      }),
      (a.prototype.umod = function (l) {
        return this.divmod(l, "mod", !0).mod;
      }),
      (a.prototype.divRound = function (l) {
        var p = this.divmod(l);
        if (p.mod.isZero()) return p.div;
        var y = p.div.negative !== 0 ? p.mod.isub(l) : p.mod,
          h = l.ushrn(1),
          g = l.andln(1),
          T = y.cmp(h);
        return T < 0 || (g === 1 && T === 0)
          ? p.div
          : p.div.negative !== 0
          ? p.div.isubn(1)
          : p.div.iaddn(1);
      }),
      (a.prototype.modn = function (l) {
        n(l <= 67108863);
        for (var p = (1 << 26) % l, y = 0, h = this.length - 1; h >= 0; h--)
          y = (p * y + (this.words[h] | 0)) % l;
        return y;
      }),
      (a.prototype.idivn = function (l) {
        n(l <= 67108863);
        for (var p = 0, y = this.length - 1; y >= 0; y--) {
          var h = (this.words[y] | 0) + p * 67108864;
          (this.words[y] = (h / l) | 0), (p = h % l);
        }
        return this.strip();
      }),
      (a.prototype.divn = function (l) {
        return this.clone().idivn(l);
      }),
      (a.prototype.egcd = function (l) {
        n(l.negative === 0), n(!l.isZero());
        var p = this,
          y = l.clone();
        p.negative !== 0 ? (p = p.umod(l)) : (p = p.clone());
        for (
          var h = new a(1), g = new a(0), T = new a(0), R = new a(1), x = 0;
          p.isEven() && y.isEven();

        )
          p.iushrn(1), y.iushrn(1), ++x;
        for (var f = y.clone(), _ = p.clone(); !p.isZero(); ) {
          for (var P = 0, M = 1; !(p.words[0] & M) && P < 26; ++P, M <<= 1);
          if (P > 0)
            for (p.iushrn(P); P-- > 0; )
              (h.isOdd() || g.isOdd()) && (h.iadd(f), g.isub(_)),
                h.iushrn(1),
                g.iushrn(1);
          for (var D = 0, q = 1; !(y.words[0] & q) && D < 26; ++D, q <<= 1);
          if (D > 0)
            for (y.iushrn(D); D-- > 0; )
              (T.isOdd() || R.isOdd()) && (T.iadd(f), R.isub(_)),
                T.iushrn(1),
                R.iushrn(1);
          p.cmp(y) >= 0
            ? (p.isub(y), h.isub(T), g.isub(R))
            : (y.isub(p), T.isub(h), R.isub(g));
        }
        return {
          a: T,
          b: R,
          gcd: y.iushln(x),
        };
      }),
      (a.prototype._invmp = function (l) {
        n(l.negative === 0), n(!l.isZero());
        var p = this,
          y = l.clone();
        p.negative !== 0 ? (p = p.umod(l)) : (p = p.clone());
        for (
          var h = new a(1), g = new a(0), T = y.clone();
          p.cmpn(1) > 0 && y.cmpn(1) > 0;

        ) {
          for (var R = 0, x = 1; !(p.words[0] & x) && R < 26; ++R, x <<= 1);
          if (R > 0)
            for (p.iushrn(R); R-- > 0; ) h.isOdd() && h.iadd(T), h.iushrn(1);
          for (var f = 0, _ = 1; !(y.words[0] & _) && f < 26; ++f, _ <<= 1);
          if (f > 0)
            for (y.iushrn(f); f-- > 0; ) g.isOdd() && g.iadd(T), g.iushrn(1);
          p.cmp(y) >= 0 ? (p.isub(y), h.isub(g)) : (y.isub(p), g.isub(h));
        }
        var P;
        return (
          p.cmpn(1) === 0 ? (P = h) : (P = g), P.cmpn(0) < 0 && P.iadd(l), P
        );
      }),
      (a.prototype.gcd = function (l) {
        if (this.isZero()) return l.abs();
        if (l.isZero()) return this.abs();
        var p = this.clone(),
          y = l.clone();
        (p.negative = 0), (y.negative = 0);
        for (var h = 0; p.isEven() && y.isEven(); h++) p.iushrn(1), y.iushrn(1);
        do {
          for (; p.isEven(); ) p.iushrn(1);
          for (; y.isEven(); ) y.iushrn(1);
          var g = p.cmp(y);
          if (g < 0) {
            var T = p;
            (p = y), (y = T);
          } else if (g === 0 || y.cmpn(1) === 0) break;
          p.isub(y);
        } while (!0);
        return y.iushln(h);
      }),
      (a.prototype.invm = function (l) {
        return this.egcd(l).a.umod(l);
      }),
      (a.prototype.isEven = function () {
        return (this.words[0] & 1) === 0;
      }),
      (a.prototype.isOdd = function () {
        return (this.words[0] & 1) === 1;
      }),
      (a.prototype.andln = function (l) {
        return this.words[0] & l;
      }),
      (a.prototype.bincn = function (l) {
        n(typeof l == "number");
        var p = l % 26,
          y = (l - p) / 26,
          h = 1 << p;
        if (this.length <= y)
          return this._expand(y + 1), (this.words[y] |= h), this;
        for (var g = h, T = y; g !== 0 && T < this.length; T++) {
          var R = this.words[T] | 0;
          (R += g), (g = R >>> 26), (R &= 67108863), (this.words[T] = R);
        }
        return g !== 0 && ((this.words[T] = g), this.length++), this;
      }),
      (a.prototype.isZero = function () {
        return this.length === 1 && this.words[0] === 0;
      }),
      (a.prototype.cmpn = function (l) {
        var p = l < 0;
        if (this.negative !== 0 && !p) return -1;
        if (this.negative === 0 && p) return 1;
        this.strip();
        var y;
        if (this.length > 1) y = 1;
        else {
          p && (l = -l), n(l <= 67108863, "Number is too big");
          var h = this.words[0] | 0;
          y = h === l ? 0 : h < l ? -1 : 1;
        }
        return this.negative !== 0 ? -y | 0 : y;
      }),
      (a.prototype.cmp = function (l) {
        if (this.negative !== 0 && l.negative === 0) return -1;
        if (this.negative === 0 && l.negative !== 0) return 1;
        var p = this.ucmp(l);
        return this.negative !== 0 ? -p | 0 : p;
      }),
      (a.prototype.ucmp = function (l) {
        if (this.length > l.length) return 1;
        if (this.length < l.length) return -1;
        for (var p = 0, y = this.length - 1; y >= 0; y--) {
          var h = this.words[y] | 0,
            g = l.words[y] | 0;
          if (h !== g) {
            h < g ? (p = -1) : h > g && (p = 1);
            break;
          }
        }
        return p;
      }),
      (a.prototype.gtn = function (l) {
        return this.cmpn(l) === 1;
      }),
      (a.prototype.gt = function (l) {
        return this.cmp(l) === 1;
      }),
      (a.prototype.gten = function (l) {
        return this.cmpn(l) >= 0;
      }),
      (a.prototype.gte = function (l) {
        return this.cmp(l) >= 0;
      }),
      (a.prototype.ltn = function (l) {
        return this.cmpn(l) === -1;
      }),
      (a.prototype.lt = function (l) {
        return this.cmp(l) === -1;
      }),
      (a.prototype.lten = function (l) {
        return this.cmpn(l) <= 0;
      }),
      (a.prototype.lte = function (l) {
        return this.cmp(l) <= 0;
      }),
      (a.prototype.eqn = function (l) {
        return this.cmpn(l) === 0;
      }),
      (a.prototype.eq = function (l) {
        return this.cmp(l) === 0;
      }),
      (a.red = function (l) {
        return new j(l);
      }),
      (a.prototype.toRed = function (l) {
        return (
          n(!this.red, "Already a number in reduction context"),
          n(this.negative === 0, "red works only with positives"),
          l.convertTo(this)._forceRed(l)
        );
      }),
      (a.prototype.fromRed = function () {
        return (
          n(this.red, "fromRed works only with numbers in reduction context"),
          this.red.convertFrom(this)
        );
      }),
      (a.prototype._forceRed = function (l) {
        return (this.red = l), this;
      }),
      (a.prototype.forceRed = function (l) {
        return (
          n(!this.red, "Already a number in reduction context"),
          this._forceRed(l)
        );
      }),
      (a.prototype.redAdd = function (l) {
        return (
          n(this.red, "redAdd works only with red numbers"),
          this.red.add(this, l)
        );
      }),
      (a.prototype.redIAdd = function (l) {
        return (
          n(this.red, "redIAdd works only with red numbers"),
          this.red.iadd(this, l)
        );
      }),
      (a.prototype.redSub = function (l) {
        return (
          n(this.red, "redSub works only with red numbers"),
          this.red.sub(this, l)
        );
      }),
      (a.prototype.redISub = function (l) {
        return (
          n(this.red, "redISub works only with red numbers"),
          this.red.isub(this, l)
        );
      }),
      (a.prototype.redShl = function (l) {
        return (
          n(this.red, "redShl works only with red numbers"),
          this.red.shl(this, l)
        );
      }),
      (a.prototype.redMul = function (l) {
        return (
          n(this.red, "redMul works only with red numbers"),
          this.red._verify2(this, l),
          this.red.mul(this, l)
        );
      }),
      (a.prototype.redIMul = function (l) {
        return (
          n(this.red, "redMul works only with red numbers"),
          this.red._verify2(this, l),
          this.red.imul(this, l)
        );
      }),
      (a.prototype.redSqr = function () {
        return (
          n(this.red, "redSqr works only with red numbers"),
          this.red._verify1(this),
          this.red.sqr(this)
        );
      }),
      (a.prototype.redISqr = function () {
        return (
          n(this.red, "redISqr works only with red numbers"),
          this.red._verify1(this),
          this.red.isqr(this)
        );
      }),
      (a.prototype.redSqrt = function () {
        return (
          n(this.red, "redSqrt works only with red numbers"),
          this.red._verify1(this),
          this.red.sqrt(this)
        );
      }),
      (a.prototype.redInvm = function () {
        return (
          n(this.red, "redInvm works only with red numbers"),
          this.red._verify1(this),
          this.red.invm(this)
        );
      }),
      (a.prototype.redNeg = function () {
        return (
          n(this.red, "redNeg works only with red numbers"),
          this.red._verify1(this),
          this.red.neg(this)
        );
      }),
      (a.prototype.redPow = function (l) {
        return (
          n(this.red && !l.red, "redPow(normalNum)"),
          this.red._verify1(this),
          this.red.pow(this, l)
        );
      });
    var S = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null,
    };
    function k(C, l) {
      (this.name = C),
        (this.p = new a(l, 16)),
        (this.n = this.p.bitLength()),
        (this.k = new a(1).iushln(this.n).isub(this.p)),
        (this.tmp = this._tmp());
    }
    (k.prototype._tmp = function () {
      var l = new a(null);
      return (l.words = new Array(Math.ceil(this.n / 13))), l;
    }),
      (k.prototype.ireduce = function (l) {
        var p = l,
          y;
        do
          this.split(p, this.tmp),
            (p = this.imulK(p)),
            (p = p.iadd(this.tmp)),
            (y = p.bitLength());
        while (y > this.n);
        var h = y < this.n ? -1 : p.ucmp(this.p);
        return (
          h === 0
            ? ((p.words[0] = 0), (p.length = 1))
            : h > 0
            ? p.isub(this.p)
            : p.strip(),
          p
        );
      }),
      (k.prototype.split = function (l, p) {
        l.iushrn(this.n, 0, p);
      }),
      (k.prototype.imulK = function (l) {
        return l.imul(this.k);
      });
    function N() {
      k.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    i(N, k),
      (N.prototype.split = function (l, p) {
        for (var y = 4194303, h = Math.min(l.length, 9), g = 0; g < h; g++)
          p.words[g] = l.words[g];
        if (((p.length = h), l.length <= 9)) {
          (l.words[0] = 0), (l.length = 1);
          return;
        }
        var T = l.words[9];
        for (p.words[p.length++] = T & y, g = 10; g < l.length; g++) {
          var R = l.words[g] | 0;
          (l.words[g - 10] = ((R & y) << 4) | (T >>> 22)), (T = R);
        }
        (T >>>= 22),
          (l.words[g - 10] = T),
          T === 0 && l.length > 10 ? (l.length -= 10) : (l.length -= 9);
      }),
      (N.prototype.imulK = function (l) {
        (l.words[l.length] = 0), (l.words[l.length + 1] = 0), (l.length += 2);
        for (var p = 0, y = 0; y < l.length; y++) {
          var h = l.words[y] | 0;
          (p += h * 977),
            (l.words[y] = p & 67108863),
            (p = h * 64 + ((p / 67108864) | 0));
        }
        return (
          l.words[l.length - 1] === 0 &&
            (l.length--, l.words[l.length - 1] === 0 && l.length--),
          l
        );
      });
    function O() {
      k.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    i(O, k);
    function F() {
      k.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    i(F, k);
    function V() {
      k.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    i(V, k),
      (V.prototype.imulK = function (l) {
        for (var p = 0, y = 0; y < l.length; y++) {
          var h = (l.words[y] | 0) * 19 + p,
            g = h & 67108863;
          (h >>>= 26), (l.words[y] = g), (p = h);
        }
        return p !== 0 && (l.words[l.length++] = p), l;
      }),
      (a._prime = function (l) {
        if (S[l]) return S[l];
        var p;
        if (l === "k256") p = new N();
        else if (l === "p224") p = new O();
        else if (l === "p192") p = new F();
        else if (l === "p25519") p = new V();
        else throw new Error("Unknown prime " + l);
        return (S[l] = p), p;
      });
    function j(C) {
      if (typeof C == "string") {
        var l = a._prime(C);
        (this.m = l.p), (this.prime = l);
      } else
        n(C.gtn(1), "modulus must be greater than 1"),
          (this.m = C),
          (this.prime = null);
    }
    (j.prototype._verify1 = function (l) {
      n(l.negative === 0, "red works only with positives"),
        n(l.red, "red works only with red numbers");
    }),
      (j.prototype._verify2 = function (l, p) {
        n((l.negative | p.negative) === 0, "red works only with positives"),
          n(l.red && l.red === p.red, "red works only with red numbers");
      }),
      (j.prototype.imod = function (l) {
        return this.prime
          ? this.prime.ireduce(l)._forceRed(this)
          : l.umod(this.m)._forceRed(this);
      }),
      (j.prototype.neg = function (l) {
        return l.isZero() ? l.clone() : this.m.sub(l)._forceRed(this);
      }),
      (j.prototype.add = function (l, p) {
        this._verify2(l, p);
        var y = l.add(p);
        return y.cmp(this.m) >= 0 && y.isub(this.m), y._forceRed(this);
      }),
      (j.prototype.iadd = function (l, p) {
        this._verify2(l, p);
        var y = l.iadd(p);
        return y.cmp(this.m) >= 0 && y.isub(this.m), y;
      }),
      (j.prototype.sub = function (l, p) {
        this._verify2(l, p);
        var y = l.sub(p);
        return y.cmpn(0) < 0 && y.iadd(this.m), y._forceRed(this);
      }),
      (j.prototype.isub = function (l, p) {
        this._verify2(l, p);
        var y = l.isub(p);
        return y.cmpn(0) < 0 && y.iadd(this.m), y;
      }),
      (j.prototype.shl = function (l, p) {
        return this._verify1(l), this.imod(l.ushln(p));
      }),
      (j.prototype.imul = function (l, p) {
        return this._verify2(l, p), this.imod(l.imul(p));
      }),
      (j.prototype.mul = function (l, p) {
        return this._verify2(l, p), this.imod(l.mul(p));
      }),
      (j.prototype.isqr = function (l) {
        return this.imul(l, l.clone());
      }),
      (j.prototype.sqr = function (l) {
        return this.mul(l, l);
      }),
      (j.prototype.sqrt = function (l) {
        if (l.isZero()) return l.clone();
        var p = this.m.andln(3);
        if ((n(p % 2 === 1), p === 3)) {
          var y = this.m.add(new a(1)).iushrn(2);
          return this.pow(l, y);
        }
        for (var h = this.m.subn(1), g = 0; !h.isZero() && h.andln(1) === 0; )
          g++, h.iushrn(1);
        n(!h.isZero());
        var T = new a(1).toRed(this),
          R = T.redNeg(),
          x = this.m.subn(1).iushrn(1),
          f = this.m.bitLength();
        for (f = new a(2 * f * f).toRed(this); this.pow(f, x).cmp(R) !== 0; )
          f.redIAdd(R);
        for (
          var _ = this.pow(f, h),
            P = this.pow(l, h.addn(1).iushrn(1)),
            M = this.pow(l, h),
            D = g;
          M.cmp(T) !== 0;

        ) {
          for (var q = M, B = 0; q.cmp(T) !== 0; B++) q = q.redSqr();
          n(B < D);
          var H = this.pow(_, new a(1).iushln(D - B - 1));
          (P = P.redMul(H)), (_ = H.redSqr()), (M = M.redMul(_)), (D = B);
        }
        return P;
      }),
      (j.prototype.invm = function (l) {
        var p = l._invmp(this.m);
        return p.negative !== 0
          ? ((p.negative = 0), this.imod(p).redNeg())
          : this.imod(p);
      }),
      (j.prototype.pow = function (l, p) {
        if (p.isZero()) return new a(1).toRed(this);
        if (p.cmpn(1) === 0) return l.clone();
        var y = 4,
          h = new Array(1 << y);
        (h[0] = new a(1).toRed(this)), (h[1] = l);
        for (var g = 2; g < h.length; g++) h[g] = this.mul(h[g - 1], l);
        var T = h[0],
          R = 0,
          x = 0,
          f = p.bitLength() % 26;
        for (f === 0 && (f = 26), g = p.length - 1; g >= 0; g--) {
          for (var _ = p.words[g], P = f - 1; P >= 0; P--) {
            var M = (_ >> P) & 1;
            if ((T !== h[0] && (T = this.sqr(T)), M === 0 && R === 0)) {
              x = 0;
              continue;
            }
            (R <<= 1),
              (R |= M),
              x++,
              !(x !== y && (g !== 0 || P !== 0)) &&
                ((T = this.mul(T, h[R])), (x = 0), (R = 0));
          }
          f = 26;
        }
        return T;
      }),
      (j.prototype.convertTo = function (l) {
        var p = l.umod(this.m);
        return p === l ? p.clone() : p;
      }),
      (j.prototype.convertFrom = function (l) {
        var p = l.clone();
        return (p.red = null), p;
      }),
      (a.mont = function (l) {
        return new X(l);
      });
    function X(C) {
      j.call(this, C),
        (this.shift = this.m.bitLength()),
        this.shift % 26 !== 0 && (this.shift += 26 - (this.shift % 26)),
        (this.r = new a(1).iushln(this.shift)),
        (this.r2 = this.imod(this.r.sqr())),
        (this.rinv = this.r._invmp(this.m)),
        (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
        (this.minv = this.minv.umod(this.r)),
        (this.minv = this.r.sub(this.minv));
    }
    i(X, j),
      (X.prototype.convertTo = function (l) {
        return this.imod(l.ushln(this.shift));
      }),
      (X.prototype.convertFrom = function (l) {
        var p = this.imod(l.mul(this.rinv));
        return (p.red = null), p;
      }),
      (X.prototype.imul = function (l, p) {
        if (l.isZero() || p.isZero())
          return (l.words[0] = 0), (l.length = 1), l;
        var y = l.imul(p),
          h = y.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
          g = y.isub(h).iushrn(this.shift),
          T = g;
        return (
          g.cmp(this.m) >= 0
            ? (T = g.isub(this.m))
            : g.cmpn(0) < 0 && (T = g.iadd(this.m)),
          T._forceRed(this)
        );
      }),
      (X.prototype.mul = function (l, p) {
        if (l.isZero() || p.isZero()) return new a(0)._forceRed(this);
        var y = l.mul(p),
          h = y.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
          g = y.isub(h).iushrn(this.shift),
          T = g;
        return (
          g.cmp(this.m) >= 0
            ? (T = g.isub(this.m))
            : g.cmpn(0) < 0 && (T = g.iadd(this.m)),
          T._forceRed(this)
        );
      }),
      (X.prototype.invm = function (l) {
        var p = this.imod(l._invmp(this.m).mul(this.r2));
        return p._forceRed(this);
      });
  })(t, ke);
})(eC);
eC.exports;
function E4(t) {
  return Wx(new Uint8Array(t));
}
function V4e(t) {
  return Qf(t).buffer;
}
var K4e = {};
(function (t) {
  const e = Ov,
    r = Fv,
    n = Lv,
    i = (b) => b == null;
  function a(b) {
    switch (b.arrayFormat) {
      case "index":
        return (w) => (S, k) => {
          const N = S.length;
          return k === void 0 ||
            (b.skipNull && k === null) ||
            (b.skipEmptyString && k === "")
            ? S
            : k === null
            ? [...S, [c(w, b), "[", N, "]"].join("")]
            : [...S, [c(w, b), "[", c(N, b), "]=", c(k, b)].join("")];
        };
      case "bracket":
        return (w) => (S, k) =>
          k === void 0 ||
          (b.skipNull && k === null) ||
          (b.skipEmptyString && k === "")
            ? S
            : k === null
            ? [...S, [c(w, b), "[]"].join("")]
            : [...S, [c(w, b), "[]=", c(k, b)].join("")];
      case "comma":
      case "separator":
        return (w) => (S, k) =>
          k == null || k.length === 0
            ? S
            : S.length === 0
            ? [[c(w, b), "=", c(k, b)].join("")]
            : [[S, c(k, b)].join(b.arrayFormatSeparator)];
      default:
        return (w) => (S, k) =>
          k === void 0 ||
          (b.skipNull && k === null) ||
          (b.skipEmptyString && k === "")
            ? S
            : k === null
            ? [...S, c(w, b)]
            : [...S, [c(w, b), "=", c(k, b)].join("")];
    }
  }
  function s(b) {
    let w;
    switch (b.arrayFormat) {
      case "index":
        return (S, k, N) => {
          if (
            ((w = /\[(\d*)\]$/.exec(S)), (S = S.replace(/\[\d*\]$/, "")), !w)
          ) {
            N[S] = k;
            return;
          }
          N[S] === void 0 && (N[S] = {}), (N[S][w[1]] = k);
        };
      case "bracket":
        return (S, k, N) => {
          if (((w = /(\[\])$/.exec(S)), (S = S.replace(/\[\]$/, "")), !w)) {
            N[S] = k;
            return;
          }
          if (N[S] === void 0) {
            N[S] = [k];
            return;
          }
          N[S] = [].concat(N[S], k);
        };
      case "comma":
      case "separator":
        return (S, k, N) => {
          const F =
            typeof k == "string" &&
            k.split("").indexOf(b.arrayFormatSeparator) > -1
              ? k.split(b.arrayFormatSeparator).map((V) => u(V, b))
              : k === null
              ? k
              : u(k, b);
          N[S] = F;
        };
      default:
        return (S, k, N) => {
          if (N[S] === void 0) {
            N[S] = k;
            return;
          }
          N[S] = [].concat(N[S], k);
        };
    }
  }
  function o(b) {
    if (typeof b != "string" || b.length !== 1)
      throw new TypeError(
        "arrayFormatSeparator must be single character string"
      );
  }
  function c(b, w) {
    return w.encode ? (w.strict ? e(b) : encodeURIComponent(b)) : b;
  }
  function u(b, w) {
    return w.decode ? r(b) : b;
  }
  function d(b) {
    return Array.isArray(b)
      ? b.sort()
      : typeof b == "object"
      ? d(Object.keys(b))
          .sort((w, S) => Number(w) - Number(S))
          .map((w) => b[w])
      : b;
  }
  function m(b) {
    const w = b.indexOf("#");
    return w !== -1 && (b = b.slice(0, w)), b;
  }
  function v(b) {
    let w = "";
    const S = b.indexOf("#");
    return S !== -1 && (w = b.slice(S)), w;
  }
  function E(b) {
    b = m(b);
    const w = b.indexOf("?");
    return w === -1 ? "" : b.slice(w + 1);
  }
  function A(b, w) {
    return (
      w.parseNumbers &&
      !Number.isNaN(Number(b)) &&
      typeof b == "string" &&
      b.trim() !== ""
        ? (b = Number(b))
        : w.parseBooleans &&
          b !== null &&
          (b.toLowerCase() === "true" || b.toLowerCase() === "false") &&
          (b = b.toLowerCase() === "true"),
      b
    );
  }
  function I(b, w) {
    (w = Object.assign(
      {
        decode: !0,
        sort: !0,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: !1,
        parseBooleans: !1,
      },
      w
    )),
      o(w.arrayFormatSeparator);
    const S = s(w),
      k = Object.create(null);
    if (typeof b != "string" || ((b = b.trim().replace(/^[?#&]/, "")), !b))
      return k;
    for (const N of b.split("&")) {
      let [O, F] = n(w.decode ? N.replace(/\+/g, " ") : N, "=");
      (F =
        F === void 0
          ? null
          : ["comma", "separator"].includes(w.arrayFormat)
          ? F
          : u(F, w)),
        S(u(O, w), F, k);
    }
    for (const N of Object.keys(k)) {
      const O = k[N];
      if (typeof O == "object" && O !== null)
        for (const F of Object.keys(O)) O[F] = A(O[F], w);
      else k[N] = A(O, w);
    }
    return w.sort === !1
      ? k
      : (w.sort === !0
          ? Object.keys(k).sort()
          : Object.keys(k).sort(w.sort)
        ).reduce((N, O) => {
          const F = k[O];
          return (
            F && typeof F == "object" && !Array.isArray(F)
              ? (N[O] = d(F))
              : (N[O] = F),
            N
          );
        }, Object.create(null));
  }
  (t.extract = E),
    (t.parse = I),
    (t.stringify = (b, w) => {
      if (!b) return "";
      (w = Object.assign(
        {
          encode: !0,
          strict: !0,
          arrayFormat: "none",
          arrayFormatSeparator: ",",
        },
        w
      )),
        o(w.arrayFormatSeparator);
      const S = (F) =>
          (w.skipNull && i(b[F])) || (w.skipEmptyString && b[F] === ""),
        k = a(w),
        N = {};
      for (const F of Object.keys(b)) S(F) || (N[F] = b[F]);
      const O = Object.keys(N);
      return (
        w.sort !== !1 && O.sort(w.sort),
        O.map((F) => {
          const V = b[F];
          return V === void 0
            ? ""
            : V === null
            ? c(F, w)
            : Array.isArray(V)
            ? V.reduce(k(F), []).join("&")
            : c(F, w) + "=" + c(V, w);
        })
          .filter((F) => F.length > 0)
          .join("&")
      );
    }),
    (t.parseUrl = (b, w) => {
      w = Object.assign(
        {
          decode: !0,
        },
        w
      );
      const [S, k] = n(b, "#");
      return Object.assign(
        {
          url: S.split("?")[0] || "",
          query: I(E(b), w),
        },
        w && w.parseFragmentIdentifier && k
          ? {
              fragmentIdentifier: u(k, w),
            }
          : {}
      );
    }),
    (t.stringifyUrl = (b, w) => {
      w = Object.assign(
        {
          encode: !0,
          strict: !0,
        },
        w
      );
      const S = m(b.url).split("?")[0] || "",
        k = t.extract(b.url),
        N = t.parse(k, {
          sort: !1,
        }),
        O = Object.assign(N, b.query);
      let F = t.stringify(O, w);
      F && (F = `?${F}`);
      let V = v(b.url);
      return (
        b.fragmentIdentifier && (V = `#${c(b.fragmentIdentifier, w)}`),
        `${S}${F}${V}`
      );
    });
})(K4e);
async function zj(t) {
  const e = (t || 256) / 8,
    r = P4e(e);
  return V4e(Wx(r));
}
async function qj(t, e) {
  const r = of(t.data),
    n = of(t.iv),
    i = of(t.hmac),
    a = sf(i, !1),
    s = Nj(r, n),
    o = await Hj(e, s),
    c = sf(o, !1);
  return cl(a) === cl(c);
}
async function G4e(t, e, r) {
  const n = Qf(E4(e)),
    i = r || (await zj(128)),
    a = Qf(E4(i)),
    s = sf(a, !1),
    o = JSON.stringify(t),
    c = C_e(o),
    u = await z4e(a, n, c),
    d = sf(u, !1),
    m = Nj(u, a),
    v = await Hj(n, m),
    E = sf(v, !1);
  return {
    data: d,
    hmac: E,
    iv: s,
  };
}
async function Z4e(t, e) {
  const r = Qf(E4(e));
  if (!r) throw new Error("Missing key: required for decryption");
  if (!(await qj(t, r))) return null;
  const i = of(t.data),
    a = of(t.iv),
    s = await q4e(a, r, i),
    o = E_e(s);
  let c;
  try {
    c = JSON.parse(o);
  } catch {
    return null;
  }
  return c;
}
const J4e = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      decrypt: Z4e,
      encrypt: G4e,
      generateKey: zj,
      verifyHmac: qj,
    },
    Symbol.toStringTag,
    {
      value: "Module",
    }
  )
);
class Q4e extends R4e {
  constructor(e, r) {
    super({
      cryptoLib: J4e,
      connectorOpts: e,
      pushServerOpts: r,
    });
  }
}
const Y4e = Pt(h_e);
var x1 = {},
  X4e = function () {
    return (
      typeof Promise == "function" &&
      Promise.prototype &&
      Promise.prototype.then
    );
  },
  Vj = {},
  _l = {},
  e8e = {}.toString,
  tC =
    Array.isArray ||
    function (t) {
      return e8e.call(t) == "[object Array]";
    },
  t8e = tC;
function r8e() {
  try {
    var t = new Uint8Array(1);
    return (
      (t.__proto__ = {
        __proto__: Uint8Array.prototype,
        foo: function () {
          return 42;
        },
      }),
      t.foo() === 42
    );
  } catch {
    return !1;
  }
}
It.TYPED_ARRAY_SUPPORT = r8e();
var kI = It.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
function It(t, e, r) {
  return !It.TYPED_ARRAY_SUPPORT && !(this instanceof It)
    ? new It(t, e, r)
    : typeof t == "number"
    ? Kj(this, t)
    : l8e(this, t, e, r);
}
It.TYPED_ARRAY_SUPPORT &&
  ((It.prototype.__proto__ = Uint8Array.prototype),
  (It.__proto__ = Uint8Array),
  typeof Symbol < "u" &&
    Symbol.species &&
    It[Symbol.species] === It &&
    Object.defineProperty(It, Symbol.species, {
      value: null,
      configurable: !0,
      enumerable: !1,
      writable: !1,
    }));
function rC(t) {
  if (t >= kI)
    throw new RangeError(
      "Attempt to allocate Buffer larger than maximum size: 0x" +
        kI.toString(16) +
        " bytes"
    );
  return t | 0;
}
function n8e(t) {
  return t !== t;
}
function Yf(t, e) {
  var r;
  return (
    It.TYPED_ARRAY_SUPPORT
      ? ((r = new Uint8Array(e)), (r.__proto__ = It.prototype))
      : ((r = t), r === null && (r = new It(e)), (r.length = e)),
    r
  );
}
function Kj(t, e) {
  var r = Yf(t, e < 0 ? 0 : rC(e) | 0);
  if (!It.TYPED_ARRAY_SUPPORT) for (var n = 0; n < e; ++n) r[n] = 0;
  return r;
}
function i8e(t, e) {
  var r = Zj(e) | 0,
    n = Yf(t, r),
    i = n.write(e);
  return i !== r && (n = n.slice(0, i)), n;
}
function T4(t, e) {
  for (
    var r = e.length < 0 ? 0 : rC(e.length) | 0, n = Yf(t, r), i = 0;
    i < r;
    i += 1
  )
    n[i] = e[i] & 255;
  return n;
}
function a8e(t, e, r, n) {
  if (r < 0 || e.byteLength < r)
    throw new RangeError("'offset' is out of bounds");
  if (e.byteLength < r + (n || 0))
    throw new RangeError("'length' is out of bounds");
  var i;
  return (
    r === void 0 && n === void 0
      ? (i = new Uint8Array(e))
      : n === void 0
      ? (i = new Uint8Array(e, r))
      : (i = new Uint8Array(e, r, n)),
    It.TYPED_ARRAY_SUPPORT ? (i.__proto__ = It.prototype) : (i = T4(t, i)),
    i
  );
}
function s8e(t, e) {
  if (It.isBuffer(e)) {
    var r = rC(e.length) | 0,
      n = Yf(t, r);
    return n.length === 0 || e.copy(n, 0, 0, r), n;
  }
  if (e) {
    if (
      (typeof ArrayBuffer < "u" && e.buffer instanceof ArrayBuffer) ||
      "length" in e
    )
      return typeof e.length != "number" || n8e(e.length) ? Yf(t, 0) : T4(t, e);
    if (e.type === "Buffer" && Array.isArray(e.data)) return T4(t, e.data);
  }
  throw new TypeError(
    "First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object."
  );
}
function Gj(t, e) {
  e = e || 1 / 0;
  for (var r, n = t.length, i = null, a = [], s = 0; s < n; ++s) {
    if (((r = t.charCodeAt(s)), r > 55295 && r < 57344)) {
      if (!i) {
        if (r > 56319) {
          (e -= 3) > -1 && a.push(239, 191, 189);
          continue;
        } else if (s + 1 === n) {
          (e -= 3) > -1 && a.push(239, 191, 189);
          continue;
        }
        i = r;
        continue;
      }
      if (r < 56320) {
        (e -= 3) > -1 && a.push(239, 191, 189), (i = r);
        continue;
      }
      r = (((i - 55296) << 10) | (r - 56320)) + 65536;
    } else i && (e -= 3) > -1 && a.push(239, 191, 189);
    if (((i = null), r < 128)) {
      if ((e -= 1) < 0) break;
      a.push(r);
    } else if (r < 2048) {
      if ((e -= 2) < 0) break;
      a.push((r >> 6) | 192, (r & 63) | 128);
    } else if (r < 65536) {
      if ((e -= 3) < 0) break;
      a.push((r >> 12) | 224, ((r >> 6) & 63) | 128, (r & 63) | 128);
    } else if (r < 1114112) {
      if ((e -= 4) < 0) break;
      a.push(
        (r >> 18) | 240,
        ((r >> 12) & 63) | 128,
        ((r >> 6) & 63) | 128,
        (r & 63) | 128
      );
    } else throw new Error("Invalid code point");
  }
  return a;
}
function Zj(t) {
  if (It.isBuffer(t)) return t.length;
  if (
    typeof ArrayBuffer < "u" &&
    typeof ArrayBuffer.isView == "function" &&
    (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)
  )
    return t.byteLength;
  typeof t != "string" && (t = "" + t);
  var e = t.length;
  return e === 0 ? 0 : Gj(t).length;
}
function o8e(t, e, r, n) {
  for (var i = 0; i < n && !(i + r >= e.length || i >= t.length); ++i)
    e[i + r] = t[i];
  return i;
}
function c8e(t, e, r, n) {
  return o8e(Gj(e, t.length - r), t, r, n);
}
function l8e(t, e, r, n) {
  if (typeof e == "number")
    throw new TypeError('"value" argument must not be a number');
  return typeof ArrayBuffer < "u" && e instanceof ArrayBuffer
    ? a8e(t, e, r, n)
    : typeof e == "string"
    ? i8e(t, e)
    : s8e(t, e);
}
It.prototype.write = function (e, r, n) {
  r === void 0
    ? ((n = this.length), (r = 0))
    : n === void 0 && typeof r == "string"
    ? ((n = this.length), (r = 0))
    : isFinite(r) && ((r = r | 0), isFinite(n) ? (n = n | 0) : (n = void 0));
  var i = this.length - r;
  if (
    ((n === void 0 || n > i) && (n = i),
    (e.length > 0 && (n < 0 || r < 0)) || r > this.length)
  )
    throw new RangeError("Attempt to write outside buffer bounds");
  return c8e(this, e, r, n);
};
It.prototype.slice = function (e, r) {
  var n = this.length;
  (e = ~~e),
    (r = r === void 0 ? n : ~~r),
    e < 0 ? ((e += n), e < 0 && (e = 0)) : e > n && (e = n),
    r < 0 ? ((r += n), r < 0 && (r = 0)) : r > n && (r = n),
    r < e && (r = e);
  var i;
  if (It.TYPED_ARRAY_SUPPORT)
    (i = this.subarray(e, r)), (i.__proto__ = It.prototype);
  else {
    var a = r - e;
    i = new It(a, void 0);
    for (var s = 0; s < a; ++s) i[s] = this[s + e];
  }
  return i;
};
It.prototype.copy = function (e, r, n, i) {
  if (
    (n || (n = 0),
    !i && i !== 0 && (i = this.length),
    r >= e.length && (r = e.length),
    r || (r = 0),
    i > 0 && i < n && (i = n),
    i === n || e.length === 0 || this.length === 0)
  )
    return 0;
  if (r < 0) throw new RangeError("targetStart out of bounds");
  if (n < 0 || n >= this.length)
    throw new RangeError("sourceStart out of bounds");
  if (i < 0) throw new RangeError("sourceEnd out of bounds");
  i > this.length && (i = this.length),
    e.length - r < i - n && (i = e.length - r + n);
  var a = i - n,
    s;
  if (this === e && n < r && r < i)
    for (s = a - 1; s >= 0; --s) e[s + r] = this[s + n];
  else if (a < 1e3 || !It.TYPED_ARRAY_SUPPORT)
    for (s = 0; s < a; ++s) e[s + r] = this[s + n];
  else Uint8Array.prototype.set.call(e, this.subarray(n, n + a), r);
  return a;
};
It.prototype.fill = function (e, r, n) {
  if (typeof e == "string") {
    if (
      (typeof r == "string"
        ? ((r = 0), (n = this.length))
        : typeof n == "string" && (n = this.length),
      e.length === 1)
    ) {
      var i = e.charCodeAt(0);
      i < 256 && (e = i);
    }
  } else typeof e == "number" && (e = e & 255);
  if (r < 0 || this.length < r || this.length < n)
    throw new RangeError("Out of range index");
  if (n <= r) return this;
  (r = r >>> 0), (n = n === void 0 ? this.length : n >>> 0), e || (e = 0);
  var a;
  if (typeof e == "number") for (a = r; a < n; ++a) this[a] = e;
  else {
    var s = It.isBuffer(e) ? e : new It(e),
      o = s.length;
    for (a = 0; a < n - r; ++a) this[a + r] = s[a % o];
  }
  return this;
};
It.concat = function (e, r) {
  if (!t8e(e))
    throw new TypeError('"list" argument must be an Array of Buffers');
  if (e.length === 0) return Yf(null, 0);
  var n;
  if (r === void 0) for (r = 0, n = 0; n < e.length; ++n) r += e[n].length;
  var i = Kj(null, r),
    a = 0;
  for (n = 0; n < e.length; ++n) {
    var s = e[n];
    if (!It.isBuffer(s))
      throw new TypeError('"list" argument must be an Array of Buffers');
    s.copy(i, a), (a += s.length);
  }
  return i;
};
It.byteLength = Zj;
It.prototype._isBuffer = !0;
It.isBuffer = function (e) {
  return !!(e != null && e._isBuffer);
};
_l.alloc = function (t) {
  var e = new It(t);
  return e.fill(0), e;
};
_l.from = function (t) {
  return new It(t);
};
var wa = {},
  nC,
  u8e = [
    0, 26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655,
    733, 815, 901, 991, 1085, 1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921,
    2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706,
  ];
wa.getSymbolSize = function (e) {
  if (!e) throw new Error('"version" cannot be null or undefined');
  if (e < 1 || e > 40)
    throw new Error('"version" should be in range from 1 to 40');
  return e * 4 + 17;
};
wa.getSymbolTotalCodewords = function (e) {
  return u8e[e];
};
wa.getBCHDigit = function (t) {
  for (var e = 0; t !== 0; ) e++, (t >>>= 1);
  return e;
};
wa.setToSJISFunction = function (e) {
  if (typeof e != "function")
    throw new Error('"toSJISFunc" is not a valid function.');
  nC = e;
};
wa.isKanjiModeEnabled = function () {
  return typeof nC < "u";
};
wa.toSJIS = function (e) {
  return nC(e);
};
var jx = {};
(function (t) {
  (t.L = {
    bit: 1,
  }),
    (t.M = {
      bit: 0,
    }),
    (t.Q = {
      bit: 3,
    }),
    (t.H = {
      bit: 2,
    });
  function e(r) {
    if (typeof r != "string") throw new Error("Param is not a string");
    var n = r.toLowerCase();
    switch (n) {
      case "l":
      case "low":
        return t.L;
      case "m":
      case "medium":
        return t.M;
      case "q":
      case "quartile":
        return t.Q;
      case "h":
      case "high":
        return t.H;
      default:
        throw new Error("Unknown EC Level: " + r);
    }
  }
  (t.isValid = function (n) {
    return n && typeof n.bit < "u" && n.bit >= 0 && n.bit < 4;
  }),
    (t.from = function (n, i) {
      if (t.isValid(n)) return n;
      try {
        return e(n);
      } catch {
        return i;
      }
    });
})(jx);
function Jj() {
  (this.buffer = []), (this.length = 0);
}
Jj.prototype = {
  get: function (t) {
    var e = Math.floor(t / 8);
    return ((this.buffer[e] >>> (7 - (t % 8))) & 1) === 1;
  },
  put: function (t, e) {
    for (var r = 0; r < e; r++) this.putBit(((t >>> (e - r - 1)) & 1) === 1);
  },
  getLengthInBits: function () {
    return this.length;
  },
  putBit: function (t) {
    var e = Math.floor(this.length / 8);
    this.buffer.length <= e && this.buffer.push(0),
      t && (this.buffer[e] |= 128 >>> this.length % 8),
      this.length++;
  },
};
var f8e = Jj,
  SI = _l;
function w1(t) {
  if (!t || t < 1)
    throw new Error("BitMatrix size must be defined and greater than 0");
  (this.size = t),
    (this.data = SI.alloc(t * t)),
    (this.reservedBit = SI.alloc(t * t));
}
w1.prototype.set = function (t, e, r, n) {
  var i = t * this.size + e;
  (this.data[i] = r), n && (this.reservedBit[i] = !0);
};
w1.prototype.get = function (t, e) {
  return this.data[t * this.size + e];
};
w1.prototype.xor = function (t, e, r) {
  this.data[t * this.size + e] ^= r;
};
w1.prototype.isReserved = function (t, e) {
  return this.reservedBit[t * this.size + e];
};
var d8e = w1,
  Qj = {};
(function (t) {
  var e = wa.getSymbolSize;
  (t.getRowColCoords = function (n) {
    if (n === 1) return [];
    for (
      var i = Math.floor(n / 7) + 2,
        a = e(n),
        s = a === 145 ? 26 : Math.ceil((a - 13) / (2 * i - 2)) * 2,
        o = [a - 7],
        c = 1;
      c < i - 1;
      c++
    )
      o[c] = o[c - 1] - s;
    return o.push(6), o.reverse();
  }),
    (t.getPositions = function (n) {
      for (
        var i = [], a = t.getRowColCoords(n), s = a.length, o = 0;
        o < s;
        o++
      )
        for (var c = 0; c < s; c++)
          (o === 0 && c === 0) ||
            (o === 0 && c === s - 1) ||
            (o === s - 1 && c === 0) ||
            i.push([a[o], a[c]]);
      return i;
    });
})(Qj);
var Yj = {},
  h8e = wa.getSymbolSize,
  MI = 7;
Yj.getPositions = function (e) {
  var r = h8e(e);
  return [
    [0, 0],
    [r - MI, 0],
    [0, r - MI],
  ];
};
var Xj = {};
(function (t) {
  t.Patterns = {
    PATTERN000: 0,
    PATTERN001: 1,
    PATTERN010: 2,
    PATTERN011: 3,
    PATTERN100: 4,
    PATTERN101: 5,
    PATTERN110: 6,
    PATTERN111: 7,
  };
  var e = {
    N1: 3,
    N2: 3,
    N3: 40,
    N4: 10,
  };
  (t.isValid = function (i) {
    return i != null && i !== "" && !isNaN(i) && i >= 0 && i <= 7;
  }),
    (t.from = function (i) {
      return t.isValid(i) ? parseInt(i, 10) : void 0;
    }),
    (t.getPenaltyN1 = function (i) {
      for (
        var a = i.size, s = 0, o = 0, c = 0, u = null, d = null, m = 0;
        m < a;
        m++
      ) {
        (o = c = 0), (u = d = null);
        for (var v = 0; v < a; v++) {
          var E = i.get(m, v);
          E === u ? o++ : (o >= 5 && (s += e.N1 + (o - 5)), (u = E), (o = 1)),
            (E = i.get(v, m)),
            E === d ? c++ : (c >= 5 && (s += e.N1 + (c - 5)), (d = E), (c = 1));
        }
        o >= 5 && (s += e.N1 + (o - 5)), c >= 5 && (s += e.N1 + (c - 5));
      }
      return s;
    }),
    (t.getPenaltyN2 = function (i) {
      for (var a = i.size, s = 0, o = 0; o < a - 1; o++)
        for (var c = 0; c < a - 1; c++) {
          var u =
            i.get(o, c) +
            i.get(o, c + 1) +
            i.get(o + 1, c) +
            i.get(o + 1, c + 1);
          (u === 4 || u === 0) && s++;
        }
      return s * e.N2;
    }),
    (t.getPenaltyN3 = function (i) {
      for (var a = i.size, s = 0, o = 0, c = 0, u = 0; u < a; u++) {
        o = c = 0;
        for (var d = 0; d < a; d++)
          (o = ((o << 1) & 2047) | i.get(u, d)),
            d >= 10 && (o === 1488 || o === 93) && s++,
            (c = ((c << 1) & 2047) | i.get(d, u)),
            d >= 10 && (c === 1488 || c === 93) && s++;
      }
      return s * e.N3;
    }),
    (t.getPenaltyN4 = function (i) {
      for (var a = 0, s = i.data.length, o = 0; o < s; o++) a += i.data[o];
      var c = Math.abs(Math.ceil((a * 100) / s / 5) - 10);
      return c * e.N4;
    });
  function r(n, i, a) {
    switch (n) {
      case t.Patterns.PATTERN000:
        return (i + a) % 2 === 0;
      case t.Patterns.PATTERN001:
        return i % 2 === 0;
      case t.Patterns.PATTERN010:
        return a % 3 === 0;
      case t.Patterns.PATTERN011:
        return (i + a) % 3 === 0;
      case t.Patterns.PATTERN100:
        return (Math.floor(i / 2) + Math.floor(a / 3)) % 2 === 0;
      case t.Patterns.PATTERN101:
        return ((i * a) % 2) + ((i * a) % 3) === 0;
      case t.Patterns.PATTERN110:
        return (((i * a) % 2) + ((i * a) % 3)) % 2 === 0;
      case t.Patterns.PATTERN111:
        return (((i * a) % 3) + ((i + a) % 2)) % 2 === 0;
      default:
        throw new Error("bad maskPattern:" + n);
    }
  }
  (t.applyMask = function (i, a) {
    for (var s = a.size, o = 0; o < s; o++)
      for (var c = 0; c < s; c++) a.isReserved(c, o) || a.xor(c, o, r(i, c, o));
  }),
    (t.getBestMask = function (i, a) {
      for (
        var s = Object.keys(t.Patterns).length, o = 0, c = 1 / 0, u = 0;
        u < s;
        u++
      ) {
        a(u), t.applyMask(u, i);
        var d =
          t.getPenaltyN1(i) +
          t.getPenaltyN2(i) +
          t.getPenaltyN3(i) +
          t.getPenaltyN4(i);
        t.applyMask(u, i), d < c && ((c = d), (o = u));
      }
      return o;
    });
})(Xj);
var Hx = {},
  kc = jx,
  Ay = [
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 4, 1, 2, 4, 4, 2, 4, 4, 4, 2,
    4, 6, 5, 2, 4, 6, 6, 2, 5, 8, 8, 4, 5, 8, 8, 4, 5, 8, 11, 4, 8, 10, 11, 4,
    9, 12, 16, 4, 9, 16, 16, 6, 10, 12, 18, 6, 10, 17, 16, 6, 11, 16, 19, 6, 13,
    18, 21, 7, 14, 21, 25, 8, 16, 20, 25, 8, 17, 23, 25, 9, 17, 23, 34, 9, 18,
    25, 30, 10, 20, 27, 32, 12, 21, 29, 35, 12, 23, 34, 37, 12, 25, 34, 40, 13,
    26, 35, 42, 14, 28, 38, 45, 15, 29, 40, 48, 16, 31, 43, 51, 17, 33, 45, 54,
    18, 35, 48, 57, 19, 37, 51, 60, 19, 38, 53, 63, 20, 40, 56, 66, 21, 43, 59,
    70, 22, 45, 62, 74, 24, 47, 65, 77, 25, 49, 68, 81,
  ],
  ky = [
    7, 10, 13, 17, 10, 16, 22, 28, 15, 26, 36, 44, 20, 36, 52, 64, 26, 48, 72,
    88, 36, 64, 96, 112, 40, 72, 108, 130, 48, 88, 132, 156, 60, 110, 160, 192,
    72, 130, 192, 224, 80, 150, 224, 264, 96, 176, 260, 308, 104, 198, 288, 352,
    120, 216, 320, 384, 132, 240, 360, 432, 144, 280, 408, 480, 168, 308, 448,
    532, 180, 338, 504, 588, 196, 364, 546, 650, 224, 416, 600, 700, 224, 442,
    644, 750, 252, 476, 690, 816, 270, 504, 750, 900, 300, 560, 810, 960, 312,
    588, 870, 1050, 336, 644, 952, 1110, 360, 700, 1020, 1200, 390, 728, 1050,
    1260, 420, 784, 1140, 1350, 450, 812, 1200, 1440, 480, 868, 1290, 1530, 510,
    924, 1350, 1620, 540, 980, 1440, 1710, 570, 1036, 1530, 1800, 570, 1064,
    1590, 1890, 600, 1120, 1680, 1980, 630, 1204, 1770, 2100, 660, 1260, 1860,
    2220, 720, 1316, 1950, 2310, 750, 1372, 2040, 2430,
  ];
Hx.getBlocksCount = function (e, r) {
  switch (r) {
    case kc.L:
      return Ay[(e - 1) * 4 + 0];
    case kc.M:
      return Ay[(e - 1) * 4 + 1];
    case kc.Q:
      return Ay[(e - 1) * 4 + 2];
    case kc.H:
      return Ay[(e - 1) * 4 + 3];
    default:
      return;
  }
};
Hx.getTotalCodewordsCount = function (e, r) {
  switch (r) {
    case kc.L:
      return ky[(e - 1) * 4 + 0];
    case kc.M:
      return ky[(e - 1) * 4 + 1];
    case kc.Q:
      return ky[(e - 1) * 4 + 2];
    case kc.H:
      return ky[(e - 1) * 4 + 3];
    default:
      return;
  }
};
var eH = {},
  zx = {},
  tH = _l,
  Jh = tH.alloc(512),
  gb = tH.alloc(256);
(function () {
  for (var e = 1, r = 0; r < 255; r++)
    (Jh[r] = e), (gb[e] = r), (e <<= 1), e & 256 && (e ^= 285);
  for (r = 255; r < 512; r++) Jh[r] = Jh[r - 255];
})();
zx.log = function (e) {
  if (e < 1) throw new Error("log(" + e + ")");
  return gb[e];
};
zx.exp = function (e) {
  return Jh[e];
};
zx.mul = function (e, r) {
  return e === 0 || r === 0 ? 0 : Jh[gb[e] + gb[r]];
};
(function (t) {
  var e = _l,
    r = zx;
  (t.mul = function (i, a) {
    for (var s = e.alloc(i.length + a.length - 1), o = 0; o < i.length; o++)
      for (var c = 0; c < a.length; c++) s[o + c] ^= r.mul(i[o], a[c]);
    return s;
  }),
    (t.mod = function (i, a) {
      for (var s = e.from(i); s.length - a.length >= 0; ) {
        for (var o = s[0], c = 0; c < a.length; c++) s[c] ^= r.mul(a[c], o);
        for (var u = 0; u < s.length && s[u] === 0; ) u++;
        s = s.slice(u);
      }
      return s;
    }),
    (t.generateECPolynomial = function (i) {
      for (var a = e.from([1]), s = 0; s < i; s++) a = t.mul(a, [1, r.exp(s)]);
      return a;
    });
})(eH);
var rH = {};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function (t) {
  var e = Wm,
    r = gv,
    n =
      typeof Symbol == "function" && typeof Symbol.for == "function"
        ? Symbol.for("nodejs.util.inspect.custom")
        : null;
  (t.Buffer = o), (t.SlowBuffer = S), (t.INSPECT_MAX_BYTES = 50);
  var i = 2147483647;
  (t.kMaxLength = i),
    (o.TYPED_ARRAY_SUPPORT = a()),
    !o.TYPED_ARRAY_SUPPORT &&
      typeof console < "u" &&
      typeof console.error == "function" &&
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
  function a() {
    try {
      var Y = new Uint8Array(1),
        $ = {
          foo: function () {
            return 42;
          },
        };
      return (
        Object.setPrototypeOf($, Uint8Array.prototype),
        Object.setPrototypeOf(Y, $),
        Y.foo() === 42
      );
    } catch {
      return !1;
    }
  }
  Object.defineProperty(o.prototype, "parent", {
    enumerable: !0,
    get: function () {
      if (o.isBuffer(this)) return this.buffer;
    },
  }),
    Object.defineProperty(o.prototype, "offset", {
      enumerable: !0,
      get: function () {
        if (o.isBuffer(this)) return this.byteOffset;
      },
    });
  function s(Y) {
    if (Y > i)
      throw new RangeError(
        'The value "' + Y + '" is invalid for option "size"'
      );
    var $ = new Uint8Array(Y);
    return Object.setPrototypeOf($, o.prototype), $;
  }
  function o(Y, $, W) {
    if (typeof Y == "number") {
      if (typeof $ == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return m(Y);
    }
    return c(Y, $, W);
  }
  o.poolSize = 8192;
  function c(Y, $, W) {
    if (typeof Y == "string") return v(Y, $);
    if (ArrayBuffer.isView(Y)) return A(Y);
    if (Y == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
          typeof Y
      );
    if (
      he(Y, ArrayBuffer) ||
      (Y && he(Y.buffer, ArrayBuffer)) ||
      (typeof SharedArrayBuffer < "u" &&
        (he(Y, SharedArrayBuffer) || (Y && he(Y.buffer, SharedArrayBuffer))))
    )
      return I(Y, $, W);
    if (typeof Y == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    var re = Y.valueOf && Y.valueOf();
    if (re != null && re !== Y) return o.from(re, $, W);
    var ee = b(Y);
    if (ee) return ee;
    if (
      typeof Symbol < "u" &&
      Symbol.toPrimitive != null &&
      typeof Y[Symbol.toPrimitive] == "function"
    )
      return o.from(Y[Symbol.toPrimitive]("string"), $, W);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
        typeof Y
    );
  }
  (o.from = function (Y, $, W) {
    return c(Y, $, W);
  }),
    Object.setPrototypeOf(o.prototype, Uint8Array.prototype),
    Object.setPrototypeOf(o, Uint8Array);
  function u(Y) {
    if (typeof Y != "number")
      throw new TypeError('"size" argument must be of type number');
    if (Y < 0)
      throw new RangeError(
        'The value "' + Y + '" is invalid for option "size"'
      );
  }
  function d(Y, $, W) {
    return (
      u(Y),
      Y <= 0
        ? s(Y)
        : $ !== void 0
        ? typeof W == "string"
          ? s(Y).fill($, W)
          : s(Y).fill($)
        : s(Y)
    );
  }
  o.alloc = function (Y, $, W) {
    return d(Y, $, W);
  };
  function m(Y) {
    return u(Y), s(Y < 0 ? 0 : w(Y) | 0);
  }
  (o.allocUnsafe = function (Y) {
    return m(Y);
  }),
    (o.allocUnsafeSlow = function (Y) {
      return m(Y);
    });
  function v(Y, $) {
    if (((typeof $ != "string" || $ === "") && ($ = "utf8"), !o.isEncoding($)))
      throw new TypeError("Unknown encoding: " + $);
    var W = k(Y, $) | 0,
      re = s(W),
      ee = re.write(Y, $);
    return ee !== W && (re = re.slice(0, ee)), re;
  }
  function E(Y) {
    for (
      var $ = Y.length < 0 ? 0 : w(Y.length) | 0, W = s($), re = 0;
      re < $;
      re += 1
    )
      W[re] = Y[re] & 255;
    return W;
  }
  function A(Y) {
    if (he(Y, Uint8Array)) {
      var $ = new Uint8Array(Y);
      return I($.buffer, $.byteOffset, $.byteLength);
    }
    return E(Y);
  }
  function I(Y, $, W) {
    if ($ < 0 || Y.byteLength < $)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (Y.byteLength < $ + (W || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    var re;
    return (
      $ === void 0 && W === void 0
        ? (re = new Uint8Array(Y))
        : W === void 0
        ? (re = new Uint8Array(Y, $))
        : (re = new Uint8Array(Y, $, W)),
      Object.setPrototypeOf(re, o.prototype),
      re
    );
  }
  function b(Y) {
    if (o.isBuffer(Y)) {
      var $ = w(Y.length) | 0,
        W = s($);
      return W.length === 0 || Y.copy(W, 0, 0, $), W;
    }
    if (Y.length !== void 0)
      return typeof Y.length != "number" || se(Y.length) ? s(0) : E(Y);
    if (Y.type === "Buffer" && Array.isArray(Y.data)) return E(Y.data);
  }
  function w(Y) {
    if (Y >= i)
      throw new RangeError(
        "Attempt to allocate Buffer larger than maximum size: 0x" +
          i.toString(16) +
          " bytes"
      );
    return Y | 0;
  }
  function S(Y) {
    return +Y != Y && (Y = 0), o.alloc(+Y);
  }
  (o.isBuffer = function ($) {
    return $ != null && $._isBuffer === !0 && $ !== o.prototype;
  }),
    (o.compare = function ($, W) {
      if (
        (he($, Uint8Array) && ($ = o.from($, $.offset, $.byteLength)),
        he(W, Uint8Array) && (W = o.from(W, W.offset, W.byteLength)),
        !o.isBuffer($) || !o.isBuffer(W))
      )
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      if ($ === W) return 0;
      for (
        var re = $.length, ee = W.length, ce = 0, Ce = Math.min(re, ee);
        ce < Ce;
        ++ce
      )
        if ($[ce] !== W[ce]) {
          (re = $[ce]), (ee = W[ce]);
          break;
        }
      return re < ee ? -1 : ee < re ? 1 : 0;
    }),
    (o.isEncoding = function ($) {
      switch (String($).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return !0;
        default:
          return !1;
      }
    }),
    (o.concat = function ($, W) {
      if (!Array.isArray($))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if ($.length === 0) return o.alloc(0);
      var re;
      if (W === void 0)
        for (W = 0, re = 0; re < $.length; ++re) W += $[re].length;
      var ee = o.allocUnsafe(W),
        ce = 0;
      for (re = 0; re < $.length; ++re) {
        var Ce = $[re];
        if (he(Ce, Uint8Array))
          ce + Ce.length > ee.length
            ? o.from(Ce).copy(ee, ce)
            : Uint8Array.prototype.set.call(ee, Ce, ce);
        else if (o.isBuffer(Ce)) Ce.copy(ee, ce);
        else throw new TypeError('"list" argument must be an Array of Buffers');
        ce += Ce.length;
      }
      return ee;
    });
  function k(Y, $) {
    if (o.isBuffer(Y)) return Y.length;
    if (ArrayBuffer.isView(Y) || he(Y, ArrayBuffer)) return Y.byteLength;
    if (typeof Y != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
          typeof Y
      );
    var W = Y.length,
      re = arguments.length > 2 && arguments[2] === !0;
    if (!re && W === 0) return 0;
    for (var ee = !1; ; )
      switch ($) {
        case "ascii":
        case "latin1":
        case "binary":
          return W;
        case "utf8":
        case "utf-8":
          return Z(Y).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return W * 2;
        case "hex":
          return W >>> 1;
        case "base64":
          return K(Y).length;
        default:
          if (ee) return re ? -1 : Z(Y).length;
          ($ = ("" + $).toLowerCase()), (ee = !0);
      }
  }
  o.byteLength = k;
  function N(Y, $, W) {
    var re = !1;
    if (
      (($ === void 0 || $ < 0) && ($ = 0),
      $ > this.length ||
        ((W === void 0 || W > this.length) && (W = this.length), W <= 0) ||
        ((W >>>= 0), ($ >>>= 0), W <= $))
    )
      return "";
    for (Y || (Y = "utf8"); ; )
      switch (Y) {
        case "hex":
          return f(this, $, W);
        case "utf8":
        case "utf-8":
          return h(this, $, W);
        case "ascii":
          return R(this, $, W);
        case "latin1":
        case "binary":
          return x(this, $, W);
        case "base64":
          return y(this, $, W);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return _(this, $, W);
        default:
          if (re) throw new TypeError("Unknown encoding: " + Y);
          (Y = (Y + "").toLowerCase()), (re = !0);
      }
  }
  o.prototype._isBuffer = !0;
  function O(Y, $, W) {
    var re = Y[$];
    (Y[$] = Y[W]), (Y[W] = re);
  }
  (o.prototype.swap16 = function () {
    var $ = this.length;
    if ($ % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (var W = 0; W < $; W += 2) O(this, W, W + 1);
    return this;
  }),
    (o.prototype.swap32 = function () {
      var $ = this.length;
      if ($ % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (var W = 0; W < $; W += 4) O(this, W, W + 3), O(this, W + 1, W + 2);
      return this;
    }),
    (o.prototype.swap64 = function () {
      var $ = this.length;
      if ($ % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (var W = 0; W < $; W += 8)
        O(this, W, W + 7),
          O(this, W + 1, W + 6),
          O(this, W + 2, W + 5),
          O(this, W + 3, W + 4);
      return this;
    }),
    (o.prototype.toString = function () {
      var $ = this.length;
      return $ === 0
        ? ""
        : arguments.length === 0
        ? h(this, 0, $)
        : N.apply(this, arguments);
    }),
    (o.prototype.toLocaleString = o.prototype.toString),
    (o.prototype.equals = function ($) {
      if (!o.isBuffer($)) throw new TypeError("Argument must be a Buffer");
      return this === $ ? !0 : o.compare(this, $) === 0;
    }),
    (o.prototype.inspect = function () {
      var $ = "",
        W = t.INSPECT_MAX_BYTES;
      return (
        ($ = this.toString("hex", 0, W)
          .replace(/(.{2})/g, "$1 ")
          .trim()),
        this.length > W && ($ += " ... "),
        "<Buffer " + $ + ">"
      );
    }),
    n && (o.prototype[n] = o.prototype.inspect),
    (o.prototype.compare = function ($, W, re, ee, ce) {
      if (
        (he($, Uint8Array) && ($ = o.from($, $.offset, $.byteLength)),
        !o.isBuffer($))
      )
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
            typeof $
        );
      if (
        (W === void 0 && (W = 0),
        re === void 0 && (re = $ ? $.length : 0),
        ee === void 0 && (ee = 0),
        ce === void 0 && (ce = this.length),
        W < 0 || re > $.length || ee < 0 || ce > this.length)
      )
        throw new RangeError("out of range index");
      if (ee >= ce && W >= re) return 0;
      if (ee >= ce) return -1;
      if (W >= re) return 1;
      if (((W >>>= 0), (re >>>= 0), (ee >>>= 0), (ce >>>= 0), this === $))
        return 0;
      for (
        var Ce = ce - ee,
          me = re - W,
          ge = Math.min(Ce, me),
          it = this.slice(ee, ce),
          ve = $.slice(W, re),
          z = 0;
        z < ge;
        ++z
      )
        if (it[z] !== ve[z]) {
          (Ce = it[z]), (me = ve[z]);
          break;
        }
      return Ce < me ? -1 : me < Ce ? 1 : 0;
    });
  function F(Y, $, W, re, ee) {
    if (Y.length === 0) return -1;
    if (
      (typeof W == "string"
        ? ((re = W), (W = 0))
        : W > 2147483647
        ? (W = 2147483647)
        : W < -2147483648 && (W = -2147483648),
      (W = +W),
      se(W) && (W = ee ? 0 : Y.length - 1),
      W < 0 && (W = Y.length + W),
      W >= Y.length)
    ) {
      if (ee) return -1;
      W = Y.length - 1;
    } else if (W < 0)
      if (ee) W = 0;
      else return -1;
    if ((typeof $ == "string" && ($ = o.from($, re)), o.isBuffer($)))
      return $.length === 0 ? -1 : V(Y, $, W, re, ee);
    if (typeof $ == "number")
      return (
        ($ = $ & 255),
        typeof Uint8Array.prototype.indexOf == "function"
          ? ee
            ? Uint8Array.prototype.indexOf.call(Y, $, W)
            : Uint8Array.prototype.lastIndexOf.call(Y, $, W)
          : V(Y, [$], W, re, ee)
      );
    throw new TypeError("val must be string, number or Buffer");
  }
  function V(Y, $, W, re, ee) {
    var ce = 1,
      Ce = Y.length,
      me = $.length;
    if (
      re !== void 0 &&
      ((re = String(re).toLowerCase()),
      re === "ucs2" || re === "ucs-2" || re === "utf16le" || re === "utf-16le")
    ) {
      if (Y.length < 2 || $.length < 2) return -1;
      (ce = 2), (Ce /= 2), (me /= 2), (W /= 2);
    }
    function ge(L, J) {
      return ce === 1 ? L[J] : L.readUInt16BE(J * ce);
    }
    var it;
    if (ee) {
      var ve = -1;
      for (it = W; it < Ce; it++)
        if (ge(Y, it) === ge($, ve === -1 ? 0 : it - ve)) {
          if ((ve === -1 && (ve = it), it - ve + 1 === me)) return ve * ce;
        } else ve !== -1 && (it -= it - ve), (ve = -1);
    } else
      for (W + me > Ce && (W = Ce - me), it = W; it >= 0; it--) {
        for (var z = !0, U = 0; U < me; U++)
          if (ge(Y, it + U) !== ge($, U)) {
            z = !1;
            break;
          }
        if (z) return it;
      }
    return -1;
  }
  (o.prototype.includes = function ($, W, re) {
    return this.indexOf($, W, re) !== -1;
  }),
    (o.prototype.indexOf = function ($, W, re) {
      return F(this, $, W, re, !0);
    }),
    (o.prototype.lastIndexOf = function ($, W, re) {
      return F(this, $, W, re, !1);
    });
  function j(Y, $, W, re) {
    W = Number(W) || 0;
    var ee = Y.length - W;
    re ? ((re = Number(re)), re > ee && (re = ee)) : (re = ee);
    var ce = $.length;
    re > ce / 2 && (re = ce / 2);
    for (var Ce = 0; Ce < re; ++Ce) {
      var me = parseInt($.substr(Ce * 2, 2), 16);
      if (se(me)) return Ce;
      Y[W + Ce] = me;
    }
    return Ce;
  }
  function X(Y, $, W, re) {
    return G(Z($, Y.length - W), Y, W, re);
  }
  function C(Y, $, W, re) {
    return G(te($), Y, W, re);
  }
  function l(Y, $, W, re) {
    return G(K($), Y, W, re);
  }
  function p(Y, $, W, re) {
    return G(Te($, Y.length - W), Y, W, re);
  }
  (o.prototype.write = function ($, W, re, ee) {
    if (W === void 0) (ee = "utf8"), (re = this.length), (W = 0);
    else if (re === void 0 && typeof W == "string")
      (ee = W), (re = this.length), (W = 0);
    else if (isFinite(W))
      (W = W >>> 0),
        isFinite(re)
          ? ((re = re >>> 0), ee === void 0 && (ee = "utf8"))
          : ((ee = re), (re = void 0));
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    var ce = this.length - W;
    if (
      ((re === void 0 || re > ce) && (re = ce),
      ($.length > 0 && (re < 0 || W < 0)) || W > this.length)
    )
      throw new RangeError("Attempt to write outside buffer bounds");
    ee || (ee = "utf8");
    for (var Ce = !1; ; )
      switch (ee) {
        case "hex":
          return j(this, $, W, re);
        case "utf8":
        case "utf-8":
          return X(this, $, W, re);
        case "ascii":
        case "latin1":
        case "binary":
          return C(this, $, W, re);
        case "base64":
          return l(this, $, W, re);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return p(this, $, W, re);
        default:
          if (Ce) throw new TypeError("Unknown encoding: " + ee);
          (ee = ("" + ee).toLowerCase()), (Ce = !0);
      }
  }),
    (o.prototype.toJSON = function () {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0),
      };
    });
  function y(Y, $, W) {
    return $ === 0 && W === Y.length
      ? e.fromByteArray(Y)
      : e.fromByteArray(Y.slice($, W));
  }
  function h(Y, $, W) {
    W = Math.min(Y.length, W);
    for (var re = [], ee = $; ee < W; ) {
      var ce = Y[ee],
        Ce = null,
        me = ce > 239 ? 4 : ce > 223 ? 3 : ce > 191 ? 2 : 1;
      if (ee + me <= W) {
        var ge, it, ve, z;
        switch (me) {
          case 1:
            ce < 128 && (Ce = ce);
            break;
          case 2:
            (ge = Y[ee + 1]),
              (ge & 192) === 128 &&
                ((z = ((ce & 31) << 6) | (ge & 63)), z > 127 && (Ce = z));
            break;
          case 3:
            (ge = Y[ee + 1]),
              (it = Y[ee + 2]),
              (ge & 192) === 128 &&
                (it & 192) === 128 &&
                ((z = ((ce & 15) << 12) | ((ge & 63) << 6) | (it & 63)),
                z > 2047 && (z < 55296 || z > 57343) && (Ce = z));
            break;
          case 4:
            (ge = Y[ee + 1]),
              (it = Y[ee + 2]),
              (ve = Y[ee + 3]),
              (ge & 192) === 128 &&
                (it & 192) === 128 &&
                (ve & 192) === 128 &&
                ((z =
                  ((ce & 15) << 18) |
                  ((ge & 63) << 12) |
                  ((it & 63) << 6) |
                  (ve & 63)),
                z > 65535 && z < 1114112 && (Ce = z));
        }
      }
      Ce === null
        ? ((Ce = 65533), (me = 1))
        : Ce > 65535 &&
          ((Ce -= 65536),
          re.push(((Ce >>> 10) & 1023) | 55296),
          (Ce = 56320 | (Ce & 1023))),
        re.push(Ce),
        (ee += me);
    }
    return T(re);
  }
  var g = 4096;
  function T(Y) {
    var $ = Y.length;
    if ($ <= g) return String.fromCharCode.apply(String, Y);
    for (var W = "", re = 0; re < $; )
      W += String.fromCharCode.apply(String, Y.slice(re, (re += g)));
    return W;
  }
  function R(Y, $, W) {
    var re = "";
    W = Math.min(Y.length, W);
    for (var ee = $; ee < W; ++ee) re += String.fromCharCode(Y[ee] & 127);
    return re;
  }
  function x(Y, $, W) {
    var re = "";
    W = Math.min(Y.length, W);
    for (var ee = $; ee < W; ++ee) re += String.fromCharCode(Y[ee]);
    return re;
  }
  function f(Y, $, W) {
    var re = Y.length;
    (!$ || $ < 0) && ($ = 0), (!W || W < 0 || W > re) && (W = re);
    for (var ee = "", ce = $; ce < W; ++ce) ee += pe[Y[ce]];
    return ee;
  }
  function _(Y, $, W) {
    for (var re = Y.slice($, W), ee = "", ce = 0; ce < re.length - 1; ce += 2)
      ee += String.fromCharCode(re[ce] + re[ce + 1] * 256);
    return ee;
  }
  o.prototype.slice = function ($, W) {
    var re = this.length;
    ($ = ~~$),
      (W = W === void 0 ? re : ~~W),
      $ < 0 ? (($ += re), $ < 0 && ($ = 0)) : $ > re && ($ = re),
      W < 0 ? ((W += re), W < 0 && (W = 0)) : W > re && (W = re),
      W < $ && (W = $);
    var ee = this.subarray($, W);
    return Object.setPrototypeOf(ee, o.prototype), ee;
  };
  function P(Y, $, W) {
    if (Y % 1 !== 0 || Y < 0) throw new RangeError("offset is not uint");
    if (Y + $ > W)
      throw new RangeError("Trying to access beyond buffer length");
  }
  (o.prototype.readUintLE = o.prototype.readUIntLE =
    function ($, W, re) {
      ($ = $ >>> 0), (W = W >>> 0), re || P($, W, this.length);
      for (var ee = this[$], ce = 1, Ce = 0; ++Ce < W && (ce *= 256); )
        ee += this[$ + Ce] * ce;
      return ee;
    }),
    (o.prototype.readUintBE = o.prototype.readUIntBE =
      function ($, W, re) {
        ($ = $ >>> 0), (W = W >>> 0), re || P($, W, this.length);
        for (var ee = this[$ + --W], ce = 1; W > 0 && (ce *= 256); )
          ee += this[$ + --W] * ce;
        return ee;
      }),
    (o.prototype.readUint8 = o.prototype.readUInt8 =
      function ($, W) {
        return ($ = $ >>> 0), W || P($, 1, this.length), this[$];
      }),
    (o.prototype.readUint16LE = o.prototype.readUInt16LE =
      function ($, W) {
        return (
          ($ = $ >>> 0), W || P($, 2, this.length), this[$] | (this[$ + 1] << 8)
        );
      }),
    (o.prototype.readUint16BE = o.prototype.readUInt16BE =
      function ($, W) {
        return (
          ($ = $ >>> 0), W || P($, 2, this.length), (this[$] << 8) | this[$ + 1]
        );
      }),
    (o.prototype.readUint32LE = o.prototype.readUInt32LE =
      function ($, W) {
        return (
          ($ = $ >>> 0),
          W || P($, 4, this.length),
          (this[$] | (this[$ + 1] << 8) | (this[$ + 2] << 16)) +
            this[$ + 3] * 16777216
        );
      }),
    (o.prototype.readUint32BE = o.prototype.readUInt32BE =
      function ($, W) {
        return (
          ($ = $ >>> 0),
          W || P($, 4, this.length),
          this[$] * 16777216 +
            ((this[$ + 1] << 16) | (this[$ + 2] << 8) | this[$ + 3])
        );
      }),
    (o.prototype.readIntLE = function ($, W, re) {
      ($ = $ >>> 0), (W = W >>> 0), re || P($, W, this.length);
      for (var ee = this[$], ce = 1, Ce = 0; ++Ce < W && (ce *= 256); )
        ee += this[$ + Ce] * ce;
      return (ce *= 128), ee >= ce && (ee -= Math.pow(2, 8 * W)), ee;
    }),
    (o.prototype.readIntBE = function ($, W, re) {
      ($ = $ >>> 0), (W = W >>> 0), re || P($, W, this.length);
      for (var ee = W, ce = 1, Ce = this[$ + --ee]; ee > 0 && (ce *= 256); )
        Ce += this[$ + --ee] * ce;
      return (ce *= 128), Ce >= ce && (Ce -= Math.pow(2, 8 * W)), Ce;
    }),
    (o.prototype.readInt8 = function ($, W) {
      return (
        ($ = $ >>> 0),
        W || P($, 1, this.length),
        this[$] & 128 ? (255 - this[$] + 1) * -1 : this[$]
      );
    }),
    (o.prototype.readInt16LE = function ($, W) {
      ($ = $ >>> 0), W || P($, 2, this.length);
      var re = this[$] | (this[$ + 1] << 8);
      return re & 32768 ? re | 4294901760 : re;
    }),
    (o.prototype.readInt16BE = function ($, W) {
      ($ = $ >>> 0), W || P($, 2, this.length);
      var re = this[$ + 1] | (this[$] << 8);
      return re & 32768 ? re | 4294901760 : re;
    }),
    (o.prototype.readInt32LE = function ($, W) {
      return (
        ($ = $ >>> 0),
        W || P($, 4, this.length),
        this[$] | (this[$ + 1] << 8) | (this[$ + 2] << 16) | (this[$ + 3] << 24)
      );
    }),
    (o.prototype.readInt32BE = function ($, W) {
      return (
        ($ = $ >>> 0),
        W || P($, 4, this.length),
        (this[$] << 24) | (this[$ + 1] << 16) | (this[$ + 2] << 8) | this[$ + 3]
      );
    }),
    (o.prototype.readFloatLE = function ($, W) {
      return (
        ($ = $ >>> 0), W || P($, 4, this.length), r.read(this, $, !0, 23, 4)
      );
    }),
    (o.prototype.readFloatBE = function ($, W) {
      return (
        ($ = $ >>> 0), W || P($, 4, this.length), r.read(this, $, !1, 23, 4)
      );
    }),
    (o.prototype.readDoubleLE = function ($, W) {
      return (
        ($ = $ >>> 0), W || P($, 8, this.length), r.read(this, $, !0, 52, 8)
      );
    }),
    (o.prototype.readDoubleBE = function ($, W) {
      return (
        ($ = $ >>> 0), W || P($, 8, this.length), r.read(this, $, !1, 52, 8)
      );
    });
  function M(Y, $, W, re, ee, ce) {
    if (!o.isBuffer(Y))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if ($ > ee || $ < ce)
      throw new RangeError('"value" argument is out of bounds');
    if (W + re > Y.length) throw new RangeError("Index out of range");
  }
  (o.prototype.writeUintLE = o.prototype.writeUIntLE =
    function ($, W, re, ee) {
      if ((($ = +$), (W = W >>> 0), (re = re >>> 0), !ee)) {
        var ce = Math.pow(2, 8 * re) - 1;
        M(this, $, W, re, ce, 0);
      }
      var Ce = 1,
        me = 0;
      for (this[W] = $ & 255; ++me < re && (Ce *= 256); )
        this[W + me] = ($ / Ce) & 255;
      return W + re;
    }),
    (o.prototype.writeUintBE = o.prototype.writeUIntBE =
      function ($, W, re, ee) {
        if ((($ = +$), (W = W >>> 0), (re = re >>> 0), !ee)) {
          var ce = Math.pow(2, 8 * re) - 1;
          M(this, $, W, re, ce, 0);
        }
        var Ce = re - 1,
          me = 1;
        for (this[W + Ce] = $ & 255; --Ce >= 0 && (me *= 256); )
          this[W + Ce] = ($ / me) & 255;
        return W + re;
      }),
    (o.prototype.writeUint8 = o.prototype.writeUInt8 =
      function ($, W, re) {
        return (
          ($ = +$),
          (W = W >>> 0),
          re || M(this, $, W, 1, 255, 0),
          (this[W] = $ & 255),
          W + 1
        );
      }),
    (o.prototype.writeUint16LE = o.prototype.writeUInt16LE =
      function ($, W, re) {
        return (
          ($ = +$),
          (W = W >>> 0),
          re || M(this, $, W, 2, 65535, 0),
          (this[W] = $ & 255),
          (this[W + 1] = $ >>> 8),
          W + 2
        );
      }),
    (o.prototype.writeUint16BE = o.prototype.writeUInt16BE =
      function ($, W, re) {
        return (
          ($ = +$),
          (W = W >>> 0),
          re || M(this, $, W, 2, 65535, 0),
          (this[W] = $ >>> 8),
          (this[W + 1] = $ & 255),
          W + 2
        );
      }),
    (o.prototype.writeUint32LE = o.prototype.writeUInt32LE =
      function ($, W, re) {
        return (
          ($ = +$),
          (W = W >>> 0),
          re || M(this, $, W, 4, 4294967295, 0),
          (this[W + 3] = $ >>> 24),
          (this[W + 2] = $ >>> 16),
          (this[W + 1] = $ >>> 8),
          (this[W] = $ & 255),
          W + 4
        );
      }),
    (o.prototype.writeUint32BE = o.prototype.writeUInt32BE =
      function ($, W, re) {
        return (
          ($ = +$),
          (W = W >>> 0),
          re || M(this, $, W, 4, 4294967295, 0),
          (this[W] = $ >>> 24),
          (this[W + 1] = $ >>> 16),
          (this[W + 2] = $ >>> 8),
          (this[W + 3] = $ & 255),
          W + 4
        );
      }),
    (o.prototype.writeIntLE = function ($, W, re, ee) {
      if ((($ = +$), (W = W >>> 0), !ee)) {
        var ce = Math.pow(2, 8 * re - 1);
        M(this, $, W, re, ce - 1, -ce);
      }
      var Ce = 0,
        me = 1,
        ge = 0;
      for (this[W] = $ & 255; ++Ce < re && (me *= 256); )
        $ < 0 && ge === 0 && this[W + Ce - 1] !== 0 && (ge = 1),
          (this[W + Ce] = ((($ / me) >> 0) - ge) & 255);
      return W + re;
    }),
    (o.prototype.writeIntBE = function ($, W, re, ee) {
      if ((($ = +$), (W = W >>> 0), !ee)) {
        var ce = Math.pow(2, 8 * re - 1);
        M(this, $, W, re, ce - 1, -ce);
      }
      var Ce = re - 1,
        me = 1,
        ge = 0;
      for (this[W + Ce] = $ & 255; --Ce >= 0 && (me *= 256); )
        $ < 0 && ge === 0 && this[W + Ce + 1] !== 0 && (ge = 1),
          (this[W + Ce] = ((($ / me) >> 0) - ge) & 255);
      return W + re;
    }),
    (o.prototype.writeInt8 = function ($, W, re) {
      return (
        ($ = +$),
        (W = W >>> 0),
        re || M(this, $, W, 1, 127, -128),
        $ < 0 && ($ = 255 + $ + 1),
        (this[W] = $ & 255),
        W + 1
      );
    }),
    (o.prototype.writeInt16LE = function ($, W, re) {
      return (
        ($ = +$),
        (W = W >>> 0),
        re || M(this, $, W, 2, 32767, -32768),
        (this[W] = $ & 255),
        (this[W + 1] = $ >>> 8),
        W + 2
      );
    }),
    (o.prototype.writeInt16BE = function ($, W, re) {
      return (
        ($ = +$),
        (W = W >>> 0),
        re || M(this, $, W, 2, 32767, -32768),
        (this[W] = $ >>> 8),
        (this[W + 1] = $ & 255),
        W + 2
      );
    }),
    (o.prototype.writeInt32LE = function ($, W, re) {
      return (
        ($ = +$),
        (W = W >>> 0),
        re || M(this, $, W, 4, 2147483647, -2147483648),
        (this[W] = $ & 255),
        (this[W + 1] = $ >>> 8),
        (this[W + 2] = $ >>> 16),
        (this[W + 3] = $ >>> 24),
        W + 4
      );
    }),
    (o.prototype.writeInt32BE = function ($, W, re) {
      return (
        ($ = +$),
        (W = W >>> 0),
        re || M(this, $, W, 4, 2147483647, -2147483648),
        $ < 0 && ($ = 4294967295 + $ + 1),
        (this[W] = $ >>> 24),
        (this[W + 1] = $ >>> 16),
        (this[W + 2] = $ >>> 8),
        (this[W + 3] = $ & 255),
        W + 4
      );
    });
  function D(Y, $, W, re, ee, ce) {
    if (W + re > Y.length) throw new RangeError("Index out of range");
    if (W < 0) throw new RangeError("Index out of range");
  }
  function q(Y, $, W, re, ee) {
    return (
      ($ = +$),
      (W = W >>> 0),
      ee || D(Y, $, W, 4),
      r.write(Y, $, W, re, 23, 4),
      W + 4
    );
  }
  (o.prototype.writeFloatLE = function ($, W, re) {
    return q(this, $, W, !0, re);
  }),
    (o.prototype.writeFloatBE = function ($, W, re) {
      return q(this, $, W, !1, re);
    });
  function B(Y, $, W, re, ee) {
    return (
      ($ = +$),
      (W = W >>> 0),
      ee || D(Y, $, W, 8),
      r.write(Y, $, W, re, 52, 8),
      W + 8
    );
  }
  (o.prototype.writeDoubleLE = function ($, W, re) {
    return B(this, $, W, !0, re);
  }),
    (o.prototype.writeDoubleBE = function ($, W, re) {
      return B(this, $, W, !1, re);
    }),
    (o.prototype.copy = function ($, W, re, ee) {
      if (!o.isBuffer($)) throw new TypeError("argument should be a Buffer");
      if (
        (re || (re = 0),
        !ee && ee !== 0 && (ee = this.length),
        W >= $.length && (W = $.length),
        W || (W = 0),
        ee > 0 && ee < re && (ee = re),
        ee === re || $.length === 0 || this.length === 0)
      )
        return 0;
      if (W < 0) throw new RangeError("targetStart out of bounds");
      if (re < 0 || re >= this.length)
        throw new RangeError("Index out of range");
      if (ee < 0) throw new RangeError("sourceEnd out of bounds");
      ee > this.length && (ee = this.length),
        $.length - W < ee - re && (ee = $.length - W + re);
      var ce = ee - re;
      return (
        this === $ && typeof Uint8Array.prototype.copyWithin == "function"
          ? this.copyWithin(W, re, ee)
          : Uint8Array.prototype.set.call($, this.subarray(re, ee), W),
        ce
      );
    }),
    (o.prototype.fill = function ($, W, re, ee) {
      if (typeof $ == "string") {
        if (
          (typeof W == "string"
            ? ((ee = W), (W = 0), (re = this.length))
            : typeof re == "string" && ((ee = re), (re = this.length)),
          ee !== void 0 && typeof ee != "string")
        )
          throw new TypeError("encoding must be a string");
        if (typeof ee == "string" && !o.isEncoding(ee))
          throw new TypeError("Unknown encoding: " + ee);
        if ($.length === 1) {
          var ce = $.charCodeAt(0);
          ((ee === "utf8" && ce < 128) || ee === "latin1") && ($ = ce);
        }
      } else
        typeof $ == "number"
          ? ($ = $ & 255)
          : typeof $ == "boolean" && ($ = Number($));
      if (W < 0 || this.length < W || this.length < re)
        throw new RangeError("Out of range index");
      if (re <= W) return this;
      (W = W >>> 0),
        (re = re === void 0 ? this.length : re >>> 0),
        $ || ($ = 0);
      var Ce;
      if (typeof $ == "number") for (Ce = W; Ce < re; ++Ce) this[Ce] = $;
      else {
        var me = o.isBuffer($) ? $ : o.from($, ee),
          ge = me.length;
        if (ge === 0)
          throw new TypeError(
            'The value "' + $ + '" is invalid for argument "value"'
          );
        for (Ce = 0; Ce < re - W; ++Ce) this[Ce + W] = me[Ce % ge];
      }
      return this;
    });
  var H = /[^+/0-9A-Za-z-_]/g;
  function Q(Y) {
    if (((Y = Y.split("=")[0]), (Y = Y.trim().replace(H, "")), Y.length < 2))
      return "";
    for (; Y.length % 4 !== 0; ) Y = Y + "=";
    return Y;
  }
  function Z(Y, $) {
    $ = $ || 1 / 0;
    for (var W, re = Y.length, ee = null, ce = [], Ce = 0; Ce < re; ++Ce) {
      if (((W = Y.charCodeAt(Ce)), W > 55295 && W < 57344)) {
        if (!ee) {
          if (W > 56319) {
            ($ -= 3) > -1 && ce.push(239, 191, 189);
            continue;
          } else if (Ce + 1 === re) {
            ($ -= 3) > -1 && ce.push(239, 191, 189);
            continue;
          }
          ee = W;
          continue;
        }
        if (W < 56320) {
          ($ -= 3) > -1 && ce.push(239, 191, 189), (ee = W);
          continue;
        }
        W = (((ee - 55296) << 10) | (W - 56320)) + 65536;
      } else ee && ($ -= 3) > -1 && ce.push(239, 191, 189);
      if (((ee = null), W < 128)) {
        if (($ -= 1) < 0) break;
        ce.push(W);
      } else if (W < 2048) {
        if (($ -= 2) < 0) break;
        ce.push((W >> 6) | 192, (W & 63) | 128);
      } else if (W < 65536) {
        if (($ -= 3) < 0) break;
        ce.push((W >> 12) | 224, ((W >> 6) & 63) | 128, (W & 63) | 128);
      } else if (W < 1114112) {
        if (($ -= 4) < 0) break;
        ce.push(
          (W >> 18) | 240,
          ((W >> 12) & 63) | 128,
          ((W >> 6) & 63) | 128,
          (W & 63) | 128
        );
      } else throw new Error("Invalid code point");
    }
    return ce;
  }
  function te(Y) {
    for (var $ = [], W = 0; W < Y.length; ++W) $.push(Y.charCodeAt(W) & 255);
    return $;
  }
  function Te(Y, $) {
    for (var W, re, ee, ce = [], Ce = 0; Ce < Y.length && !(($ -= 2) < 0); ++Ce)
      (W = Y.charCodeAt(Ce)),
        (re = W >> 8),
        (ee = W % 256),
        ce.push(ee),
        ce.push(re);
    return ce;
  }
  function K(Y) {
    return e.toByteArray(Q(Y));
  }
  function G(Y, $, W, re) {
    for (var ee = 0; ee < re && !(ee + W >= $.length || ee >= Y.length); ++ee)
      $[ee + W] = Y[ee];
    return ee;
  }
  function he(Y, $) {
    return (
      Y instanceof $ ||
      (Y != null &&
        Y.constructor != null &&
        Y.constructor.name != null &&
        Y.constructor.name === $.name)
    );
  }
  function se(Y) {
    return Y !== Y;
  }
  var pe = (function () {
    for (var Y = "0123456789abcdef", $ = new Array(256), W = 0; W < 16; ++W)
      for (var re = W * 16, ee = 0; ee < 16; ++ee) $[re + ee] = Y[W] + Y[ee];
    return $;
  })();
})(rH);
var II = _l,
  nH = eH,
  p8e = rH.Buffer;
function iC(t) {
  (this.genPoly = void 0),
    (this.degree = t),
    this.degree && this.initialize(this.degree);
}
iC.prototype.initialize = function (e) {
  (this.degree = e), (this.genPoly = nH.generateECPolynomial(this.degree));
};
iC.prototype.encode = function (e) {
  if (!this.genPoly) throw new Error("Encoder not initialized");
  var r = II.alloc(this.degree),
    n = p8e.concat([e, r], e.length + this.degree),
    i = nH.mod(n, this.genPoly),
    a = this.degree - i.length;
  if (a > 0) {
    var s = II.alloc(this.degree);
    return i.copy(s, a), s;
  }
  return i;
};
var m8e = iC,
  iH = {},
  El = {},
  aC = {};
aC.isValid = function (e) {
  return !isNaN(e) && e >= 1 && e <= 40;
};
var xo = {},
  aH = "[0-9]+",
  y8e = "[A-Z $%*+\\-./:]+",
  pm =
    "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
pm = pm.replace(/u/g, "\\u");
var g8e =
  "(?:(?![A-Z0-9 $%*+\\-./:]|" +
  pm +
  `)(?:.|[\r
]))+`;
xo.KANJI = new RegExp(pm, "g");
xo.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
xo.BYTE = new RegExp(g8e, "g");
xo.NUMERIC = new RegExp(aH, "g");
xo.ALPHANUMERIC = new RegExp(y8e, "g");
var b8e = new RegExp("^" + pm + "$"),
  v8e = new RegExp("^" + aH + "$"),
  x8e = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
xo.testKanji = function (e) {
  return b8e.test(e);
};
xo.testNumeric = function (e) {
  return v8e.test(e);
};
xo.testAlphanumeric = function (e) {
  return x8e.test(e);
};
(function (t) {
  var e = aC,
    r = xo;
  (t.NUMERIC = {
    id: "Numeric",
    bit: 1,
    ccBits: [10, 12, 14],
  }),
    (t.ALPHANUMERIC = {
      id: "Alphanumeric",
      bit: 2,
      ccBits: [9, 11, 13],
    }),
    (t.BYTE = {
      id: "Byte",
      bit: 4,
      ccBits: [8, 16, 16],
    }),
    (t.KANJI = {
      id: "Kanji",
      bit: 8,
      ccBits: [8, 10, 12],
    }),
    (t.MIXED = {
      bit: -1,
    }),
    (t.getCharCountIndicator = function (a, s) {
      if (!a.ccBits) throw new Error("Invalid mode: " + a);
      if (!e.isValid(s)) throw new Error("Invalid version: " + s);
      return s >= 1 && s < 10
        ? a.ccBits[0]
        : s < 27
        ? a.ccBits[1]
        : a.ccBits[2];
    }),
    (t.getBestModeForData = function (a) {
      return r.testNumeric(a)
        ? t.NUMERIC
        : r.testAlphanumeric(a)
        ? t.ALPHANUMERIC
        : r.testKanji(a)
        ? t.KANJI
        : t.BYTE;
    }),
    (t.toString = function (a) {
      if (a && a.id) return a.id;
      throw new Error("Invalid mode");
    }),
    (t.isValid = function (a) {
      return a && a.bit && a.ccBits;
    });
  function n(i) {
    if (typeof i != "string") throw new Error("Param is not a string");
    var a = i.toLowerCase();
    switch (a) {
      case "numeric":
        return t.NUMERIC;
      case "alphanumeric":
        return t.ALPHANUMERIC;
      case "kanji":
        return t.KANJI;
      case "byte":
        return t.BYTE;
      default:
        throw new Error("Unknown mode: " + i);
    }
  }
  t.from = function (a, s) {
    if (t.isValid(a)) return a;
    try {
      return n(a);
    } catch {
      return s;
    }
  };
})(El);
(function (t) {
  var e = wa,
    r = Hx,
    n = jx,
    i = El,
    a = aC,
    s = tC,
    o = 7973,
    c = e.getBCHDigit(o);
  function u(E, A, I) {
    for (var b = 1; b <= 40; b++) if (A <= t.getCapacity(b, I, E)) return b;
  }
  function d(E, A) {
    return i.getCharCountIndicator(E, A) + 4;
  }
  function m(E, A) {
    var I = 0;
    return (
      E.forEach(function (b) {
        var w = d(b.mode, A);
        I += w + b.getBitsLength();
      }),
      I
    );
  }
  function v(E, A) {
    for (var I = 1; I <= 40; I++) {
      var b = m(E, I);
      if (b <= t.getCapacity(I, A, i.MIXED)) return I;
    }
  }
  (t.from = function (A, I) {
    return a.isValid(A) ? parseInt(A, 10) : I;
  }),
    (t.getCapacity = function (A, I, b) {
      if (!a.isValid(A)) throw new Error("Invalid QR Code version");
      typeof b > "u" && (b = i.BYTE);
      var w = e.getSymbolTotalCodewords(A),
        S = r.getTotalCodewordsCount(A, I),
        k = (w - S) * 8;
      if (b === i.MIXED) return k;
      var N = k - d(b, A);
      switch (b) {
        case i.NUMERIC:
          return Math.floor((N / 10) * 3);
        case i.ALPHANUMERIC:
          return Math.floor((N / 11) * 2);
        case i.KANJI:
          return Math.floor(N / 13);
        case i.BYTE:
        default:
          return Math.floor(N / 8);
      }
    }),
    (t.getBestVersionForData = function (A, I) {
      var b,
        w = n.from(I, n.M);
      if (s(A)) {
        if (A.length > 1) return v(A, w);
        if (A.length === 0) return 1;
        b = A[0];
      } else b = A;
      return u(b.mode, b.getLength(), w);
    }),
    (t.getEncodedBits = function (A) {
      if (!a.isValid(A) || A < 7) throw new Error("Invalid QR Code version");
      for (var I = A << 12; e.getBCHDigit(I) - c >= 0; )
        I ^= o << (e.getBCHDigit(I) - c);
      return (A << 12) | I;
    });
})(iH);
var sH = {},
  C4 = wa,
  oH = 1335,
  w8e = 21522,
  RI = C4.getBCHDigit(oH);
sH.getEncodedBits = function (e, r) {
  for (var n = (e.bit << 3) | r, i = n << 10; C4.getBCHDigit(i) - RI >= 0; )
    i ^= oH << (C4.getBCHDigit(i) - RI);
  return ((n << 10) | i) ^ w8e;
};
var cH = {},
  _8e = El;
function Xf(t) {
  (this.mode = _8e.NUMERIC), (this.data = t.toString());
}
Xf.getBitsLength = function (e) {
  return 10 * Math.floor(e / 3) + (e % 3 ? (e % 3) * 3 + 1 : 0);
};
Xf.prototype.getLength = function () {
  return this.data.length;
};
Xf.prototype.getBitsLength = function () {
  return Xf.getBitsLength(this.data.length);
};
Xf.prototype.write = function (e) {
  var r, n, i;
  for (r = 0; r + 3 <= this.data.length; r += 3)
    (n = this.data.substr(r, 3)), (i = parseInt(n, 10)), e.put(i, 10);
  var a = this.data.length - r;
  a > 0 &&
    ((n = this.data.substr(r)), (i = parseInt(n, 10)), e.put(i, a * 3 + 1));
};
var E8e = Xf,
  T8e = El,
  B5 = [
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    " ",
    "$",
    "%",
    "*",
    "+",
    "-",
    ".",
    "/",
    ":",
  ];
function ed(t) {
  (this.mode = T8e.ALPHANUMERIC), (this.data = t);
}
ed.getBitsLength = function (e) {
  return 11 * Math.floor(e / 2) + 6 * (e % 2);
};
ed.prototype.getLength = function () {
  return this.data.length;
};
ed.prototype.getBitsLength = function () {
  return ed.getBitsLength(this.data.length);
};
ed.prototype.write = function (e) {
  var r;
  for (r = 0; r + 2 <= this.data.length; r += 2) {
    var n = B5.indexOf(this.data[r]) * 45;
    (n += B5.indexOf(this.data[r + 1])), e.put(n, 11);
  }
  this.data.length % 2 && e.put(B5.indexOf(this.data[r]), 6);
};
var C8e = ed,
  A8e = _l,
  k8e = El;
function td(t) {
  (this.mode = k8e.BYTE), (this.data = A8e.from(t));
}
td.getBitsLength = function (e) {
  return e * 8;
};
td.prototype.getLength = function () {
  return this.data.length;
};
td.prototype.getBitsLength = function () {
  return td.getBitsLength(this.data.length);
};
td.prototype.write = function (t) {
  for (var e = 0, r = this.data.length; e < r; e++) t.put(this.data[e], 8);
};
var S8e = td,
  M8e = El,
  I8e = wa;
function rd(t) {
  (this.mode = M8e.KANJI), (this.data = t);
}
rd.getBitsLength = function (e) {
  return e * 13;
};
rd.prototype.getLength = function () {
  return this.data.length;
};
rd.prototype.getBitsLength = function () {
  return rd.getBitsLength(this.data.length);
};
rd.prototype.write = function (t) {
  var e;
  for (e = 0; e < this.data.length; e++) {
    var r = I8e.toSJIS(this.data[e]);
    if (r >= 33088 && r <= 40956) r -= 33088;
    else if (r >= 57408 && r <= 60351) r -= 49472;
    else
      throw new Error(
        "Invalid SJIS character: " +
          this.data[e] +
          `
Make sure your charset is UTF-8`
      );
    (r = ((r >>> 8) & 255) * 192 + (r & 255)), t.put(r, 13);
  }
};
var R8e = rd,
  lH = {
    exports: {},
  };
(function (t) {
  var e = {
    single_source_shortest_paths: function (r, n, i) {
      var a = {},
        s = {};
      s[n] = 0;
      var o = e.PriorityQueue.make();
      o.push(n, 0);
      for (var c, u, d, m, v, E, A, I, b; !o.empty(); ) {
        (c = o.pop()), (u = c.value), (m = c.cost), (v = r[u] || {});
        for (d in v)
          v.hasOwnProperty(d) &&
            ((E = v[d]),
            (A = m + E),
            (I = s[d]),
            (b = typeof s[d] > "u"),
            (b || I > A) && ((s[d] = A), o.push(d, A), (a[d] = u)));
      }
      if (typeof i < "u" && typeof s[i] > "u") {
        var w = ["Could not find a path from ", n, " to ", i, "."].join("");
        throw new Error(w);
      }
      return a;
    },
    extract_shortest_path_from_predecessor_list: function (r, n) {
      for (var i = [], a = n; a; ) i.push(a), r[a], (a = r[a]);
      return i.reverse(), i;
    },
    find_path: function (r, n, i) {
      var a = e.single_source_shortest_paths(r, n, i);
      return e.extract_shortest_path_from_predecessor_list(a, i);
    },
    PriorityQueue: {
      make: function (r) {
        var n = e.PriorityQueue,
          i = {},
          a;
        r = r || {};
        for (a in n) n.hasOwnProperty(a) && (i[a] = n[a]);
        return (i.queue = []), (i.sorter = r.sorter || n.default_sorter), i;
      },
      default_sorter: function (r, n) {
        return r.cost - n.cost;
      },
      push: function (r, n) {
        var i = {
          value: r,
          cost: n,
        };
        this.queue.push(i), this.queue.sort(this.sorter);
      },
      pop: function () {
        return this.queue.shift();
      },
      empty: function () {
        return this.queue.length === 0;
      },
    },
  };
  t.exports = e;
})(lH);
var P8e = lH.exports;
(function (t) {
  var e = El,
    r = E8e,
    n = C8e,
    i = S8e,
    a = R8e,
    s = xo,
    o = wa,
    c = P8e;
  function u(w) {
    return unescape(encodeURIComponent(w)).length;
  }
  function d(w, S, k) {
    for (var N = [], O; (O = w.exec(k)) !== null; )
      N.push({
        data: O[0],
        index: O.index,
        mode: S,
        length: O[0].length,
      });
    return N;
  }
  function m(w) {
    var S = d(s.NUMERIC, e.NUMERIC, w),
      k = d(s.ALPHANUMERIC, e.ALPHANUMERIC, w),
      N,
      O;
    o.isKanjiModeEnabled()
      ? ((N = d(s.BYTE, e.BYTE, w)), (O = d(s.KANJI, e.KANJI, w)))
      : ((N = d(s.BYTE_KANJI, e.BYTE, w)), (O = []));
    var F = S.concat(k, N, O);
    return F.sort(function (V, j) {
      return V.index - j.index;
    }).map(function (V) {
      return {
        data: V.data,
        mode: V.mode,
        length: V.length,
      };
    });
  }
  function v(w, S) {
    switch (S) {
      case e.NUMERIC:
        return r.getBitsLength(w);
      case e.ALPHANUMERIC:
        return n.getBitsLength(w);
      case e.KANJI:
        return a.getBitsLength(w);
      case e.BYTE:
        return i.getBitsLength(w);
    }
  }
  function E(w) {
    return w.reduce(function (S, k) {
      var N = S.length - 1 >= 0 ? S[S.length - 1] : null;
      return N && N.mode === k.mode
        ? ((S[S.length - 1].data += k.data), S)
        : (S.push(k), S);
    }, []);
  }
  function A(w) {
    for (var S = [], k = 0; k < w.length; k++) {
      var N = w[k];
      switch (N.mode) {
        case e.NUMERIC:
          S.push([
            N,
            {
              data: N.data,
              mode: e.ALPHANUMERIC,
              length: N.length,
            },
            {
              data: N.data,
              mode: e.BYTE,
              length: N.length,
            },
          ]);
          break;
        case e.ALPHANUMERIC:
          S.push([
            N,
            {
              data: N.data,
              mode: e.BYTE,
              length: N.length,
            },
          ]);
          break;
        case e.KANJI:
          S.push([
            N,
            {
              data: N.data,
              mode: e.BYTE,
              length: u(N.data),
            },
          ]);
          break;
        case e.BYTE:
          S.push([
            {
              data: N.data,
              mode: e.BYTE,
              length: u(N.data),
            },
          ]);
      }
    }
    return S;
  }
  function I(w, S) {
    for (
      var k = {},
        N = {
          start: {},
        },
        O = ["start"],
        F = 0;
      F < w.length;
      F++
    ) {
      for (var V = w[F], j = [], X = 0; X < V.length; X++) {
        var C = V[X],
          l = "" + F + X;
        j.push(l),
          (k[l] = {
            node: C,
            lastCount: 0,
          }),
          (N[l] = {});
        for (var p = 0; p < O.length; p++) {
          var y = O[p];
          k[y] && k[y].node.mode === C.mode
            ? ((N[y][l] =
                v(k[y].lastCount + C.length, C.mode) -
                v(k[y].lastCount, C.mode)),
              (k[y].lastCount += C.length))
            : (k[y] && (k[y].lastCount = C.length),
              (N[y][l] =
                v(C.length, C.mode) + 4 + e.getCharCountIndicator(C.mode, S)));
        }
      }
      O = j;
    }
    for (p = 0; p < O.length; p++) N[O[p]].end = 0;
    return {
      map: N,
      table: k,
    };
  }
  function b(w, S) {
    var k,
      N = e.getBestModeForData(w);
    if (((k = e.from(S, N)), k !== e.BYTE && k.bit < N.bit))
      throw new Error(
        '"' +
          w +
          '" cannot be encoded with mode ' +
          e.toString(k) +
          `.
 Suggested mode is: ` +
          e.toString(N)
      );
    switch ((k === e.KANJI && !o.isKanjiModeEnabled() && (k = e.BYTE), k)) {
      case e.NUMERIC:
        return new r(w);
      case e.ALPHANUMERIC:
        return new n(w);
      case e.KANJI:
        return new a(w);
      case e.BYTE:
        return new i(w);
    }
  }
  (t.fromArray = function (S) {
    return S.reduce(function (k, N) {
      return (
        typeof N == "string"
          ? k.push(b(N, null))
          : N.data && k.push(b(N.data, N.mode)),
        k
      );
    }, []);
  }),
    (t.fromString = function (S, k) {
      for (
        var N = m(S, o.isKanjiModeEnabled()),
          O = A(N),
          F = I(O, k),
          V = c.find_path(F.map, "start", "end"),
          j = [],
          X = 1;
        X < V.length - 1;
        X++
      )
        j.push(F.table[V[X]].node);
      return t.fromArray(E(j));
    }),
    (t.rawSplit = function (S) {
      return t.fromArray(m(S, o.isKanjiModeEnabled()));
    });
})(cH);
var PI = _l,
  qx = wa,
  D5 = jx,
  N8e = f8e,
  B8e = d8e,
  D8e = Qj,
  O8e = Yj,
  A4 = Xj,
  k4 = Hx,
  F8e = m8e,
  bb = iH,
  L8e = sH,
  $8e = El,
  O5 = cH,
  U8e = tC;
function W8e(t, e) {
  for (var r = t.size, n = O8e.getPositions(e), i = 0; i < n.length; i++)
    for (var a = n[i][0], s = n[i][1], o = -1; o <= 7; o++)
      if (!(a + o <= -1 || r <= a + o))
        for (var c = -1; c <= 7; c++)
          s + c <= -1 ||
            r <= s + c ||
            ((o >= 0 && o <= 6 && (c === 0 || c === 6)) ||
            (c >= 0 && c <= 6 && (o === 0 || o === 6)) ||
            (o >= 2 && o <= 4 && c >= 2 && c <= 4)
              ? t.set(a + o, s + c, !0, !0)
              : t.set(a + o, s + c, !1, !0));
}
function j8e(t) {
  for (var e = t.size, r = 8; r < e - 8; r++) {
    var n = r % 2 === 0;
    t.set(r, 6, n, !0), t.set(6, r, n, !0);
  }
}
function H8e(t, e) {
  for (var r = D8e.getPositions(e), n = 0; n < r.length; n++)
    for (var i = r[n][0], a = r[n][1], s = -2; s <= 2; s++)
      for (var o = -2; o <= 2; o++)
        s === -2 || s === 2 || o === -2 || o === 2 || (s === 0 && o === 0)
          ? t.set(i + s, a + o, !0, !0)
          : t.set(i + s, a + o, !1, !0);
}
function z8e(t, e) {
  for (var r = t.size, n = bb.getEncodedBits(e), i, a, s, o = 0; o < 18; o++)
    (i = Math.floor(o / 3)),
      (a = (o % 3) + r - 8 - 3),
      (s = ((n >> o) & 1) === 1),
      t.set(i, a, s, !0),
      t.set(a, i, s, !0);
}
function F5(t, e, r) {
  var n = t.size,
    i = L8e.getEncodedBits(e, r),
    a,
    s;
  for (a = 0; a < 15; a++)
    (s = ((i >> a) & 1) === 1),
      a < 6
        ? t.set(a, 8, s, !0)
        : a < 8
        ? t.set(a + 1, 8, s, !0)
        : t.set(n - 15 + a, 8, s, !0),
      a < 8
        ? t.set(8, n - a - 1, s, !0)
        : a < 9
        ? t.set(8, 15 - a - 1 + 1, s, !0)
        : t.set(8, 15 - a - 1, s, !0);
  t.set(n - 8, 8, 1, !0);
}
function q8e(t, e) {
  for (
    var r = t.size, n = -1, i = r - 1, a = 7, s = 0, o = r - 1;
    o > 0;
    o -= 2
  )
    for (o === 6 && o--; ; ) {
      for (var c = 0; c < 2; c++)
        if (!t.isReserved(i, o - c)) {
          var u = !1;
          s < e.length && (u = ((e[s] >>> a) & 1) === 1),
            t.set(i, o - c, u),
            a--,
            a === -1 && (s++, (a = 7));
        }
      if (((i += n), i < 0 || r <= i)) {
        (i -= n), (n = -n);
        break;
      }
    }
}
function V8e(t, e, r) {
  var n = new N8e();
  r.forEach(function (u) {
    n.put(u.mode.bit, 4),
      n.put(u.getLength(), $8e.getCharCountIndicator(u.mode, t)),
      u.write(n);
  });
  var i = qx.getSymbolTotalCodewords(t),
    a = k4.getTotalCodewordsCount(t, e),
    s = (i - a) * 8;
  for (
    n.getLengthInBits() + 4 <= s && n.put(0, 4);
    n.getLengthInBits() % 8 !== 0;

  )
    n.putBit(0);
  for (var o = (s - n.getLengthInBits()) / 8, c = 0; c < o; c++)
    n.put(c % 2 ? 17 : 236, 8);
  return K8e(n, t, e);
}
function K8e(t, e, r) {
  for (
    var n = qx.getSymbolTotalCodewords(e),
      i = k4.getTotalCodewordsCount(e, r),
      a = n - i,
      s = k4.getBlocksCount(e, r),
      o = n % s,
      c = s - o,
      u = Math.floor(n / s),
      d = Math.floor(a / s),
      m = d + 1,
      v = u - d,
      E = new F8e(v),
      A = 0,
      I = new Array(s),
      b = new Array(s),
      w = 0,
      S = PI.from(t.buffer),
      k = 0;
    k < s;
    k++
  ) {
    var N = k < c ? d : m;
    (I[k] = S.slice(A, A + N)),
      (b[k] = E.encode(I[k])),
      (A += N),
      (w = Math.max(w, N));
  }
  var O = PI.alloc(n),
    F = 0,
    V,
    j;
  for (V = 0; V < w; V++)
    for (j = 0; j < s; j++) V < I[j].length && (O[F++] = I[j][V]);
  for (V = 0; V < v; V++) for (j = 0; j < s; j++) O[F++] = b[j][V];
  return O;
}
function G8e(t, e, r, n) {
  var i;
  if (U8e(t)) i = O5.fromArray(t);
  else if (typeof t == "string") {
    var a = e;
    if (!a) {
      var s = O5.rawSplit(t);
      a = bb.getBestVersionForData(s, r);
    }
    i = O5.fromString(t, a || 40);
  } else throw new Error("Invalid data");
  var o = bb.getBestVersionForData(i, r);
  if (!o)
    throw new Error("The amount of data is too big to be stored in a QR Code");
  if (!e) e = o;
  else if (e < o)
    throw new Error(
      `
The chosen QR Code version cannot contain this amount of data.
Minimum version required to store current data is: ` +
        o +
        `.
`
    );
  var c = V8e(e, r, i),
    u = qx.getSymbolSize(e),
    d = new B8e(u);
  return (
    W8e(d, e),
    j8e(d),
    H8e(d, e),
    F5(d, r, 0),
    e >= 7 && z8e(d, e),
    q8e(d, c),
    isNaN(n) && (n = A4.getBestMask(d, F5.bind(null, d, r))),
    A4.applyMask(n, d),
    F5(d, r, n),
    {
      modules: d,
      version: e,
      errorCorrectionLevel: r,
      maskPattern: n,
      segments: i,
    }
  );
}
Vj.create = function (e, r) {
  if (typeof e > "u" || e === "") throw new Error("No input text");
  var n = D5.M,
    i,
    a;
  return (
    typeof r < "u" &&
      ((n = D5.from(r.errorCorrectionLevel, D5.M)),
      (i = bb.from(r.version)),
      (a = A4.from(r.maskPattern)),
      r.toSJISFunc && qx.setToSJISFunction(r.toSJISFunc)),
    G8e(e, i, n, a)
  );
};
var uH = {},
  sC = {};
(function (t) {
  function e(r) {
    if ((typeof r == "number" && (r = r.toString()), typeof r != "string"))
      throw new Error("Color should be defined as hex string");
    var n = r.slice().replace("#", "").split("");
    if (n.length < 3 || n.length === 5 || n.length > 8)
      throw new Error("Invalid hex color: " + r);
    (n.length === 3 || n.length === 4) &&
      (n = Array.prototype.concat.apply(
        [],
        n.map(function (a) {
          return [a, a];
        })
      )),
      n.length === 6 && n.push("F", "F");
    var i = parseInt(n.join(""), 16);
    return {
      r: (i >> 24) & 255,
      g: (i >> 16) & 255,
      b: (i >> 8) & 255,
      a: i & 255,
      hex: "#" + n.slice(0, 6).join(""),
    };
  }
  (t.getOptions = function (n) {
    n || (n = {}), n.color || (n.color = {});
    var i =
        typeof n.margin > "u" || n.margin === null || n.margin < 0
          ? 4
          : n.margin,
      a = n.width && n.width >= 21 ? n.width : void 0,
      s = n.scale || 4;
    return {
      width: a,
      scale: a ? 4 : s,
      margin: i,
      color: {
        dark: e(n.color.dark || "#000000ff"),
        light: e(n.color.light || "#ffffffff"),
      },
      type: n.type,
      rendererOpts: n.rendererOpts || {},
    };
  }),
    (t.getScale = function (n, i) {
      return i.width && i.width >= n + i.margin * 2
        ? i.width / (n + i.margin * 2)
        : i.scale;
    }),
    (t.getImageWidth = function (n, i) {
      var a = t.getScale(n, i);
      return Math.floor((n + i.margin * 2) * a);
    }),
    (t.qrToImageData = function (n, i, a) {
      for (
        var s = i.modules.size,
          o = i.modules.data,
          c = t.getScale(s, a),
          u = Math.floor((s + a.margin * 2) * c),
          d = a.margin * c,
          m = [a.color.light, a.color.dark],
          v = 0;
        v < u;
        v++
      )
        for (var E = 0; E < u; E++) {
          var A = (v * u + E) * 4,
            I = a.color.light;
          if (v >= d && E >= d && v < u - d && E < u - d) {
            var b = Math.floor((v - d) / c),
              w = Math.floor((E - d) / c);
            I = m[o[b * s + w] ? 1 : 0];
          }
          (n[A++] = I.r), (n[A++] = I.g), (n[A++] = I.b), (n[A] = I.a);
        }
    });
})(sC);
(function (t) {
  var e = sC;
  function r(i, a, s) {
    i.clearRect(0, 0, a.width, a.height),
      a.style || (a.style = {}),
      (a.height = s),
      (a.width = s),
      (a.style.height = s + "px"),
      (a.style.width = s + "px");
  }
  function n() {
    try {
      return document.createElement("canvas");
    } catch {
      throw new Error("You need to specify a canvas element");
    }
  }
  (t.render = function (a, s, o) {
    var c = o,
      u = s;
    typeof c > "u" && (!s || !s.getContext) && ((c = s), (s = void 0)),
      s || (u = n()),
      (c = e.getOptions(c));
    var d = e.getImageWidth(a.modules.size, c),
      m = u.getContext("2d"),
      v = m.createImageData(d, d);
    return (
      e.qrToImageData(v.data, a, c), r(m, u, d), m.putImageData(v, 0, 0), u
    );
  }),
    (t.renderToDataURL = function (a, s, o) {
      var c = o;
      typeof c > "u" && (!s || !s.getContext) && ((c = s), (s = void 0)),
        c || (c = {});
      var u = t.render(a, s, c),
        d = c.type || "image/png",
        m = c.rendererOpts || {};
      return u.toDataURL(d, m.quality);
    });
})(uH);
var fH = {},
  Z8e = sC;
function NI(t, e) {
  var r = t.a / 255,
    n = e + '="' + t.hex + '"';
  return r < 1 ? n + " " + e + '-opacity="' + r.toFixed(2).slice(1) + '"' : n;
}
function L5(t, e, r) {
  var n = t + e;
  return typeof r < "u" && (n += " " + r), n;
}
function J8e(t, e, r) {
  for (var n = "", i = 0, a = !1, s = 0, o = 0; o < t.length; o++) {
    var c = Math.floor(o % e),
      u = Math.floor(o / e);
    !c && !a && (a = !0),
      t[o]
        ? (s++,
          (o > 0 && c > 0 && t[o - 1]) ||
            ((n += a ? L5("M", c + r, 0.5 + u + r) : L5("m", i, 0)),
            (i = 0),
            (a = !1)),
          (c + 1 < e && t[o + 1]) || ((n += L5("h", s)), (s = 0)))
        : i++;
  }
  return n;
}
fH.render = function (e, r, n) {
  var i = Z8e.getOptions(r),
    a = e.modules.size,
    s = e.modules.data,
    o = a + i.margin * 2,
    c = i.color.light.a
      ? "<path " +
        NI(i.color.light, "fill") +
        ' d="M0 0h' +
        o +
        "v" +
        o +
        'H0z"/>'
      : "",
    u =
      "<path " +
      NI(i.color.dark, "stroke") +
      ' d="' +
      J8e(s, a, i.margin) +
      '"/>',
    d = 'viewBox="0 0 ' + o + " " + o + '"',
    m = i.width ? 'width="' + i.width + '" height="' + i.width + '" ' : "",
    v =
      '<svg xmlns="http://www.w3.org/2000/svg" ' +
      m +
      d +
      ' shape-rendering="crispEdges">' +
      c +
      u +
      `</svg>
`;
  return typeof n == "function" && n(null, v), v;
};
var Q8e = X4e,
  S4 = Vj,
  dH = uH,
  Y8e = fH;
function oC(t, e, r, n, i) {
  var a = [].slice.call(arguments, 1),
    s = a.length,
    o = typeof a[s - 1] == "function";
  if (!o && !Q8e()) throw new Error("Callback required as last argument");
  if (o) {
    if (s < 2) throw new Error("Too few arguments provided");
    s === 2
      ? ((i = r), (r = e), (e = n = void 0))
      : s === 3 &&
        (e.getContext && typeof i > "u"
          ? ((i = n), (n = void 0))
          : ((i = n), (n = r), (r = e), (e = void 0)));
  } else {
    if (s < 1) throw new Error("Too few arguments provided");
    return (
      s === 1
        ? ((r = e), (e = n = void 0))
        : s === 2 && !e.getContext && ((n = r), (r = e), (e = void 0)),
      new Promise(function (u, d) {
        try {
          var m = S4.create(r, n);
          u(t(m, e, n));
        } catch (v) {
          d(v);
        }
      })
    );
  }
  try {
    var c = S4.create(r, n);
    i(null, t(c, e, n));
  } catch (u) {
    i(u);
  }
}
x1.create = S4.create;
x1.toCanvas = oC.bind(null, dH.render);
x1.toDataURL = oC.bind(null, dH.renderToDataURL);
x1.toString = oC.bind(null, function (t, e, r) {
  return Y8e.render(t, r);
});
var X8e = function () {
    var t = document.getSelection();
    if (!t.rangeCount) return function () {};
    for (var e = document.activeElement, r = [], n = 0; n < t.rangeCount; n++)
      r.push(t.getRangeAt(n));
    switch (e.tagName.toUpperCase()) {
      case "INPUT":
      case "TEXTAREA":
        e.blur();
        break;
      default:
        e = null;
        break;
    }
    return (
      t.removeAllRanges(),
      function () {
        t.type === "Caret" && t.removeAllRanges(),
          t.rangeCount ||
            r.forEach(function (i) {
              t.addRange(i);
            }),
          e && e.focus();
      }
    );
  },
  eEe = X8e,
  BI = {
    "text/plain": "Text",
    "text/html": "Url",
    default: "Text",
  },
  tEe = "Copy to clipboard: #{key}, Enter";
function rEe(t) {
  var e = (/mac os x/i.test(navigator.userAgent) ? "⌘" : "Ctrl") + "+C";
  return t.replace(/#{\s*key\s*}/g, e);
}
function nEe(t, e) {
  var r,
    n,
    i,
    a,
    s,
    o,
    c = !1;
  e || (e = {}), (r = e.debug || !1);
  try {
    (i = eEe()),
      (a = document.createRange()),
      (s = document.getSelection()),
      (o = document.createElement("span")),
      (o.textContent = t),
      (o.ariaHidden = "true"),
      (o.style.all = "unset"),
      (o.style.position = "fixed"),
      (o.style.top = 0),
      (o.style.clip = "rect(0, 0, 0, 0)"),
      (o.style.whiteSpace = "pre"),
      (o.style.webkitUserSelect = "text"),
      (o.style.MozUserSelect = "text"),
      (o.style.msUserSelect = "text"),
      (o.style.userSelect = "text"),
      o.addEventListener("copy", function (d) {
        if ((d.stopPropagation(), e.format))
          if ((d.preventDefault(), typeof d.clipboardData > "u")) {
            r && console.warn("unable to use e.clipboardData"),
              r && console.warn("trying IE specific stuff"),
              window.clipboardData.clearData();
            var m = BI[e.format] || BI.default;
            window.clipboardData.setData(m, t);
          } else
            d.clipboardData.clearData(), d.clipboardData.setData(e.format, t);
        e.onCopy && (d.preventDefault(), e.onCopy(d.clipboardData));
      }),
      document.body.appendChild(o),
      a.selectNodeContents(o),
      s.addRange(a);
    var u = document.execCommand("copy");
    if (!u) throw new Error("copy command was unsuccessful");
    c = !0;
  } catch (d) {
    r && console.error("unable to copy using execCommand: ", d),
      r && console.warn("trying IE specific stuff");
    try {
      window.clipboardData.setData(e.format || "text", t),
        e.onCopy && e.onCopy(window.clipboardData),
        (c = !0);
    } catch (m) {
      r && console.error("unable to copy using clipboardData: ", m),
        r && console.error("falling back to prompt"),
        (n = rEe("message" in e ? e.message : tEe)),
        window.prompt(n, t);
    }
  } finally {
    s &&
      (typeof s.removeRange == "function"
        ? s.removeRange(a)
        : s.removeAllRanges()),
      o && document.body.removeChild(o),
      i();
  }
  return c;
}
var iEe = nEe,
  ht,
  Qh,
  cC,
  hH,
  DI,
  lC,
  pH,
  Wo = {},
  Vx = [],
  aEe = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord/i;
function $o(t, e) {
  for (var r in e) t[r] = e[r];
  return t;
}
function mH(t) {
  var e = t.parentNode;
  e && e.removeChild(t);
}
function tc(t, e, r) {
  var n,
    i = arguments,
    a = {};
  for (n in e) n !== "key" && n !== "ref" && (a[n] = e[n]);
  if (arguments.length > 3)
    for (r = [r], n = 3; n < arguments.length; n++) r.push(i[n]);
  if (
    (r != null && (a.children = r),
    typeof t == "function" && t.defaultProps != null)
  )
    for (n in t.defaultProps) a[n] === void 0 && (a[n] = t.defaultProps[n]);
  return vb(t, a, e && e.key, e && e.ref, null);
}
function vb(t, e, r, n, i) {
  var a = {
    type: t,
    props: e,
    key: r,
    ref: n,
    __k: null,
    __: null,
    __b: 0,
    __e: null,
    __d: void 0,
    __c: null,
    constructor: void 0,
    __v: i,
  };
  return i == null && (a.__v = a), ht.vnode && ht.vnode(a), a;
}
function yH() {
  return {};
}
function _1(t) {
  return t.children;
}
function gs(t, e) {
  (this.props = t), (this.context = e);
}
function mm(t, e) {
  if (e == null) return t.__ ? mm(t.__, t.__.__k.indexOf(t) + 1) : null;
  for (var r; e < t.__k.length; e++)
    if ((r = t.__k[e]) != null && r.__e != null) return r.__e;
  return typeof t.type == "function" ? mm(t) : null;
}
function gH(t) {
  var e, r;
  if ((t = t.__) != null && t.__c != null) {
    for (t.__e = t.__c.base = null, e = 0; e < t.__k.length; e++)
      if ((r = t.__k[e]) != null && r.__e != null) {
        t.__e = t.__c.base = r.__e;
        break;
      }
    return gH(t);
  }
}
function ig(t) {
  ((!t.__d && (t.__d = !0) && Qh.push(t) && !cC++) ||
    DI !== ht.debounceRendering) &&
    ((DI = ht.debounceRendering) || hH)(sEe);
}
function sEe() {
  for (var t; (cC = Qh.length); )
    (t = Qh.sort(function (e, r) {
      return e.__v.__b - r.__v.__b;
    })),
      (Qh = []),
      t.some(function (e) {
        var r, n, i, a, s, o, c;
        e.__d &&
          ((o = (s = (r = e).__v).__e),
          (c = r.__P) &&
            ((n = []),
            ((i = $o({}, s)).__v = i),
            (a = uC(
              c,
              s,
              i,
              r.__n,
              c.ownerSVGElement !== void 0,
              null,
              n,
              o ?? mm(s)
            )),
            vH(n, s),
            a != o && gH(s)));
      });
}
function bH(t, e, r, n, i, a, s, o, c) {
  var u,
    d,
    m,
    v,
    E,
    A,
    I,
    b = (r && r.__k) || Vx,
    w = b.length;
  if (
    (o == Wo && (o = a != null ? a[0] : w ? mm(r, 0) : null),
    (u = 0),
    (e.__k = Vc(e.__k, function (S) {
      if (S != null) {
        if (
          ((S.__ = e),
          (S.__b = e.__b + 1),
          (m = b[u]) === null || (m && S.key == m.key && S.type === m.type))
        )
          b[u] = void 0;
        else
          for (d = 0; d < w; d++) {
            if ((m = b[d]) && S.key == m.key && S.type === m.type) {
              b[d] = void 0;
              break;
            }
            m = null;
          }
        if (
          ((v = uC(t, S, (m = m || Wo), n, i, a, s, o, c)),
          (d = S.ref) &&
            m.ref != d &&
            (I || (I = []),
            m.ref && I.push(m.ref, null, S),
            I.push(d, S.__c || v, S)),
          v != null)
        ) {
          var k;
          if ((A == null && (A = v), S.__d !== void 0))
            (k = S.__d), (S.__d = void 0);
          else if (a == m || v != o || v.parentNode == null) {
            e: if (o == null || o.parentNode !== t)
              t.appendChild(v), (k = null);
            else {
              for (E = o, d = 0; (E = E.nextSibling) && d < w; d += 2)
                if (E == v) break e;
              t.insertBefore(v, o), (k = o);
            }
            e.type == "option" && (t.value = "");
          }
          (o = k !== void 0 ? k : v.nextSibling),
            typeof e.type == "function" && (e.__d = o);
        } else o && m.__e == o && o.parentNode != t && (o = mm(m));
      }
      return u++, S;
    })),
    (e.__e = A),
    a != null && typeof e.type != "function")
  )
    for (u = a.length; u--; ) a[u] != null && mH(a[u]);
  for (u = w; u--; ) b[u] != null && Yh(b[u], b[u]);
  if (I) for (u = 0; u < I.length; u++) xH(I[u], I[++u], I[++u]);
}
function Vc(t, e, r) {
  if ((r == null && (r = []), t == null || typeof t == "boolean"))
    e && r.push(e(null));
  else if (Array.isArray(t)) for (var n = 0; n < t.length; n++) Vc(t[n], e, r);
  else
    r.push(
      e
        ? e(
            typeof t == "string" || typeof t == "number"
              ? vb(null, t, null, null, t)
              : t.__e != null || t.__c != null
              ? vb(t.type, t.props, t.key, null, t.__v)
              : t
          )
        : t
    );
  return r;
}
function oEe(t, e, r, n, i) {
  var a;
  for (a in r)
    a === "children" || a === "key" || a in e || xb(t, a, null, r[a], n);
  for (a in e)
    (i && typeof e[a] != "function") ||
      a === "children" ||
      a === "key" ||
      a === "value" ||
      a === "checked" ||
      r[a] === e[a] ||
      xb(t, a, e[a], r[a], n);
}
function OI(t, e, r) {
  e[0] === "-"
    ? t.setProperty(e, r)
    : (t[e] = typeof r == "number" && aEe.test(e) === !1 ? r + "px" : r ?? "");
}
function xb(t, e, r, n, i) {
  var a, s, o, c, u;
  if (
    (i
      ? e === "className" && (e = "class")
      : e === "class" && (e = "className"),
    e === "style")
  )
    if (((a = t.style), typeof r == "string")) a.cssText = r;
    else {
      if ((typeof n == "string" && ((a.cssText = ""), (n = null)), n))
        for (c in n) (r && c in r) || OI(a, c, "");
      if (r) for (u in r) (n && r[u] === n[u]) || OI(a, u, r[u]);
    }
  else
    e[0] === "o" && e[1] === "n"
      ? ((s = e !== (e = e.replace(/Capture$/, ""))),
        (o = e.toLowerCase()),
        (e = (o in t ? o : e).slice(2)),
        r
          ? (n || t.addEventListener(e, FI, s), ((t.l || (t.l = {}))[e] = r))
          : t.removeEventListener(e, FI, s))
      : e !== "list" &&
        e !== "tagName" &&
        e !== "form" &&
        e !== "type" &&
        e !== "size" &&
        !i &&
        e in t
      ? (t[e] = r ?? "")
      : typeof r != "function" &&
        e !== "dangerouslySetInnerHTML" &&
        (e !== (e = e.replace(/^xlink:?/, ""))
          ? r == null || r === !1
            ? t.removeAttributeNS(
                "http://www.w3.org/1999/xlink",
                e.toLowerCase()
              )
            : t.setAttributeNS(
                "http://www.w3.org/1999/xlink",
                e.toLowerCase(),
                r
              )
          : r == null || (r === !1 && !/^ar/.test(e))
          ? t.removeAttribute(e)
          : t.setAttribute(e, r));
}
function FI(t) {
  this.l[t.type](ht.event ? ht.event(t) : t);
}
function uC(t, e, r, n, i, a, s, o, c) {
  var u,
    d,
    m,
    v,
    E,
    A,
    I,
    b,
    w,
    S,
    k = e.type;
  if (e.constructor !== void 0) return null;
  (u = ht.__b) && u(e);
  try {
    e: if (typeof k == "function") {
      if (
        ((b = e.props),
        (w = (u = k.contextType) && n[u.__c]),
        (S = u ? (w ? w.props.value : u.__) : n),
        r.__c
          ? (I = (d = e.__c = r.__c).__ = d.__E)
          : ("prototype" in k && k.prototype.render
              ? (e.__c = d = new k(b, S))
              : ((e.__c = d = new gs(b, S)),
                (d.constructor = k),
                (d.render = lEe)),
            w && w.sub(d),
            (d.props = b),
            d.state || (d.state = {}),
            (d.context = S),
            (d.__n = n),
            (m = d.__d = !0),
            (d.__h = [])),
        d.__s == null && (d.__s = d.state),
        k.getDerivedStateFromProps != null &&
          (d.__s == d.state && (d.__s = $o({}, d.__s)),
          $o(d.__s, k.getDerivedStateFromProps(b, d.__s))),
        (v = d.props),
        (E = d.state),
        m)
      )
        k.getDerivedStateFromProps == null &&
          d.componentWillMount != null &&
          d.componentWillMount(),
          d.componentDidMount != null && d.__h.push(d.componentDidMount);
      else {
        if (
          (k.getDerivedStateFromProps == null &&
            b !== v &&
            d.componentWillReceiveProps != null &&
            d.componentWillReceiveProps(b, S),
          (!d.__e &&
            d.shouldComponentUpdate != null &&
            d.shouldComponentUpdate(b, d.__s, S) === !1) ||
            (e.__v === r.__v && !d.__))
        ) {
          for (
            d.props = b,
              d.state = d.__s,
              e.__v !== r.__v && (d.__d = !1),
              d.__v = e,
              e.__e = r.__e,
              e.__k = r.__k,
              d.__h.length && s.push(d),
              u = 0;
            u < e.__k.length;
            u++
          )
            e.__k[u] && (e.__k[u].__ = e);
          break e;
        }
        d.componentWillUpdate != null && d.componentWillUpdate(b, d.__s, S),
          d.componentDidUpdate != null &&
            d.__h.push(function () {
              d.componentDidUpdate(v, E, A);
            });
      }
      (d.context = S),
        (d.props = b),
        (d.state = d.__s),
        (u = ht.__r) && u(e),
        (d.__d = !1),
        (d.__v = e),
        (d.__P = t),
        (u = d.render(d.props, d.state, d.context)),
        (e.__k =
          u != null && u.type == _1 && u.key == null
            ? u.props.children
            : Array.isArray(u)
            ? u
            : [u]),
        d.getChildContext != null && (n = $o($o({}, n), d.getChildContext())),
        m ||
          d.getSnapshotBeforeUpdate == null ||
          (A = d.getSnapshotBeforeUpdate(v, E)),
        bH(t, e, r, n, i, a, s, o, c),
        (d.base = e.__e),
        d.__h.length && s.push(d),
        I && (d.__E = d.__ = null),
        (d.__e = !1);
    } else
      a == null && e.__v === r.__v
        ? ((e.__k = r.__k), (e.__e = r.__e))
        : (e.__e = cEe(r.__e, e, r, n, i, a, s, c));
    (u = ht.diffed) && u(e);
  } catch (N) {
    (e.__v = null), ht.__e(N, e, r);
  }
  return e.__e;
}
function vH(t, e) {
  ht.__c && ht.__c(e, t),
    t.some(function (r) {
      try {
        (t = r.__h),
          (r.__h = []),
          t.some(function (n) {
            n.call(r);
          });
      } catch (n) {
        ht.__e(n, r.__v);
      }
    });
}
function cEe(t, e, r, n, i, a, s, o) {
  var c,
    u,
    d,
    m,
    v,
    E = r.props,
    A = e.props;
  if (((i = e.type === "svg" || i), a != null)) {
    for (c = 0; c < a.length; c++)
      if (
        (u = a[c]) != null &&
        ((e.type === null ? u.nodeType === 3 : u.localName === e.type) ||
          t == u)
      ) {
        (t = u), (a[c] = null);
        break;
      }
  }
  if (t == null) {
    if (e.type === null) return document.createTextNode(A);
    (t = i
      ? document.createElementNS("http://www.w3.org/2000/svg", e.type)
      : document.createElement(
          e.type,
          A.is && {
            is: A.is,
          }
        )),
      (a = null),
      (o = !1);
  }
  if (e.type === null) E !== A && t.data != A && (t.data = A);
  else {
    if (
      (a != null && (a = Vx.slice.call(t.childNodes)),
      (d = (E = r.props || Wo).dangerouslySetInnerHTML),
      (m = A.dangerouslySetInnerHTML),
      !o)
    ) {
      if (E === Wo)
        for (E = {}, v = 0; v < t.attributes.length; v++)
          E[t.attributes[v].name] = t.attributes[v].value;
      (m || d) &&
        ((m && d && m.__html == d.__html) ||
          (t.innerHTML = (m && m.__html) || ""));
    }
    oEe(t, A, E, i, o),
      m
        ? (e.__k = [])
        : ((e.__k = e.props.children),
          bH(t, e, r, n, e.type !== "foreignObject" && i, a, s, Wo, o)),
      o ||
        ("value" in A &&
          (c = A.value) !== void 0 &&
          c !== t.value &&
          xb(t, "value", c, E.value, !1),
        "checked" in A &&
          (c = A.checked) !== void 0 &&
          c !== t.checked &&
          xb(t, "checked", c, E.checked, !1));
  }
  return t;
}
function xH(t, e, r) {
  try {
    typeof t == "function" ? t(e) : (t.current = e);
  } catch (n) {
    ht.__e(n, r);
  }
}
function Yh(t, e, r) {
  var n, i, a;
  if (
    (ht.unmount && ht.unmount(t),
    (n = t.ref) && ((n.current && n.current !== t.__e) || xH(n, null, e)),
    r || typeof t.type == "function" || (r = (i = t.__e) != null),
    (t.__e = t.__d = void 0),
    (n = t.__c) != null)
  ) {
    if (n.componentWillUnmount)
      try {
        n.componentWillUnmount();
      } catch (s) {
        ht.__e(s, e);
      }
    n.base = n.__P = null;
  }
  if ((n = t.__k)) for (a = 0; a < n.length; a++) n[a] && Yh(n[a], e, r);
  i != null && mH(i);
}
function lEe(t, e, r) {
  return this.constructor(t, r);
}
function ym(t, e, r) {
  var n, i, a;
  ht.__ && ht.__(t, e),
    (i = (n = r === lC) ? null : (r && r.__k) || e.__k),
    (t = tc(_1, null, [t])),
    (a = []),
    uC(
      e,
      ((n ? e : r || e).__k = t),
      i || Wo,
      Wo,
      e.ownerSVGElement !== void 0,
      r && !n ? [r] : i ? null : Vx.slice.call(e.childNodes),
      a,
      r || Wo,
      n
    ),
    vH(a, t);
}
function wH(t, e) {
  ym(t, e, lC);
}
function uEe(t, e) {
  var r, n;
  for (n in ((e = $o($o({}, t.props), e)),
  arguments.length > 2 && (e.children = Vx.slice.call(arguments, 2)),
  (r = {}),
  e))
    n !== "key" && n !== "ref" && (r[n] = e[n]);
  return vb(t.type, r, e.key || t.key, e.ref || t.ref, null);
}
function _H(t) {
  var e = {},
    r = {
      __c: "__cC" + pH++,
      __: t,
      Consumer: function (n, i) {
        return n.children(i);
      },
      Provider: function (n) {
        var i,
          a = this;
        return (
          this.getChildContext ||
            ((i = []),
            (this.getChildContext = function () {
              return (e[r.__c] = a), e;
            }),
            (this.shouldComponentUpdate = function (s) {
              a.props.value !== s.value &&
                i.some(function (o) {
                  (o.context = s.value), ig(o);
                });
            }),
            (this.sub = function (s) {
              i.push(s);
              var o = s.componentWillUnmount;
              s.componentWillUnmount = function () {
                i.splice(i.indexOf(s), 1), o && o.call(s);
              };
            })),
          n.children
        );
      },
    };
  return (r.Consumer.contextType = r), (r.Provider.__ = r), r;
}
(ht = {
  __e: function (t, e) {
    for (var r, n; (e = e.__); )
      if ((r = e.__c) && !r.__)
        try {
          if (
            (r.constructor &&
              r.constructor.getDerivedStateFromError != null &&
              ((n = !0), r.setState(r.constructor.getDerivedStateFromError(t))),
            r.componentDidCatch != null && ((n = !0), r.componentDidCatch(t)),
            n)
          )
            return ig((r.__E = r));
        } catch (i) {
          t = i;
        }
    throw t;
  },
}),
  (gs.prototype.setState = function (t, e) {
    var r;
    (r = this.__s !== this.state ? this.__s : (this.__s = $o({}, this.state))),
      typeof t == "function" && (t = t(r, this.props)),
      t && $o(r, t),
      t != null && this.__v && (e && this.__h.push(e), ig(this));
  }),
  (gs.prototype.forceUpdate = function (t) {
    this.__v && ((this.__e = !0), t && this.__h.push(t), ig(this));
  }),
  (gs.prototype.render = _1),
  (Qh = []),
  (cC = 0),
  (hH =
    typeof Promise == "function"
      ? Promise.prototype.then.bind(Promise.resolve())
      : setTimeout),
  (lC = Wo),
  (pH = 0);
var Ku,
  Ui,
  LI,
  nd = 0,
  M4 = [],
  $I = ht.__r,
  UI = ht.diffed,
  WI = ht.__c,
  jI = ht.unmount;
function Ld(t, e) {
  ht.__h && ht.__h(Ui, t, nd || e), (nd = 0);
  var r =
    Ui.__H ||
    (Ui.__H = {
      __: [],
      __h: [],
    });
  return t >= r.__.length && r.__.push({}), r.__[t];
}
function fC(t) {
  return (nd = 1), dC(MH, t);
}
function dC(t, e, r) {
  var n = Ld(Ku++, 2);
  return (
    n.__c ||
      ((n.__c = Ui),
      (n.__ = [
        r ? r(e) : MH(void 0, e),
        function (i) {
          var a = t(n.__[0], i);
          n.__[0] !== a && ((n.__[0] = a), n.__c.setState({}));
        },
      ])),
    n.__
  );
}
function EH(t, e) {
  var r = Ld(Ku++, 3);
  !ht.__s && pC(r.__H, e) && ((r.__ = t), (r.__H = e), Ui.__H.__h.push(r));
}
function hC(t, e) {
  var r = Ld(Ku++, 4);
  !ht.__s && pC(r.__H, e) && ((r.__ = t), (r.__H = e), Ui.__h.push(r));
}
function TH(t) {
  return (
    (nd = 5),
    Kx(function () {
      return {
        current: t,
      };
    }, [])
  );
}
function CH(t, e, r) {
  (nd = 6),
    hC(
      function () {
        typeof t == "function" ? t(e()) : t && (t.current = e());
      },
      r == null ? r : r.concat(t)
    );
}
function Kx(t, e) {
  var r = Ld(Ku++, 7);
  return pC(r.__H, e) ? ((r.__H = e), (r.__h = t), (r.__ = t())) : r.__;
}
function AH(t, e) {
  return (
    (nd = 8),
    Kx(function () {
      return t;
    }, e)
  );
}
function kH(t) {
  var e = Ui.context[t.__c],
    r = Ld(Ku++, 9);
  return (
    (r.__c = t),
    e ? (r.__ == null && ((r.__ = !0), e.sub(Ui)), e.props.value) : t.__
  );
}
function SH(t, e) {
  ht.useDebugValue && ht.useDebugValue(e ? e(t) : t);
}
function fEe(t) {
  var e = Ld(Ku++, 10),
    r = fC();
  return (
    (e.__ = t),
    Ui.componentDidCatch ||
      (Ui.componentDidCatch = function (n) {
        e.__ && e.__(n), r[1](n);
      }),
    [
      r[0],
      function () {
        r[1](void 0);
      },
    ]
  );
}
function dEe() {
  M4.some(function (t) {
    if (t.__P)
      try {
        t.__H.__h.forEach(I4), t.__H.__h.forEach(R4), (t.__H.__h = []);
      } catch (e) {
        return (t.__H.__h = []), ht.__e(e, t.__v), !0;
      }
  }),
    (M4 = []);
}
function I4(t) {
  t.t && t.t();
}
function R4(t) {
  var e = t.__();
  typeof e == "function" && (t.t = e);
}
function pC(t, e) {
  return (
    !t ||
    e.some(function (r, n) {
      return r !== t[n];
    })
  );
}
function MH(t, e) {
  return typeof e == "function" ? e(t) : e;
}
(ht.__r = function (t) {
  $I && $I(t),
    (Ku = 0),
    (Ui = t.__c).__H &&
      (Ui.__H.__h.forEach(I4), Ui.__H.__h.forEach(R4), (Ui.__H.__h = []));
}),
  (ht.diffed = function (t) {
    UI && UI(t);
    var e = t.__c;
    if (e) {
      var r = e.__H;
      r &&
        r.__h.length &&
        ((M4.push(e) !== 1 && LI === ht.requestAnimationFrame) ||
          (
            (LI = ht.requestAnimationFrame) ||
            function (n) {
              var i,
                a = function () {
                  clearTimeout(s), cancelAnimationFrame(i), setTimeout(n);
                },
                s = setTimeout(a, 100);
              typeof window < "u" && (i = requestAnimationFrame(a));
            }
          )(dEe));
    }
  }),
  (ht.__c = function (t, e) {
    e.some(function (r) {
      try {
        r.__h.forEach(I4),
          (r.__h = r.__h.filter(function (n) {
            return !n.__ || R4(n);
          }));
      } catch (n) {
        e.some(function (i) {
          i.__h && (i.__h = []);
        }),
          (e = []),
          ht.__e(n, r.__v);
      }
    }),
      WI && WI(t, e);
  }),
  (ht.unmount = function (t) {
    jI && jI(t);
    var e = t.__c;
    if (e) {
      var r = e.__H;
      if (r)
        try {
          r.__.forEach(function (n) {
            return n.t && n.t();
          });
        } catch (n) {
          ht.__e(n, e.__v);
        }
    }
  });
function mC(t, e) {
  for (var r in e) t[r] = e[r];
  return t;
}
function P4(t, e) {
  for (var r in t) if (r !== "__source" && !(r in e)) return !0;
  for (var n in e) if (n !== "__source" && t[n] !== e[n]) return !0;
  return !1;
}
var IH = (function (t) {
  var e, r;
  function n(i) {
    var a;
    return ((a = t.call(this, i) || this).isPureReactComponent = !0), a;
  }
  return (
    (r = t),
    ((e = n).prototype = Object.create(r.prototype)),
    (e.prototype.constructor = e),
    (e.__proto__ = r),
    (n.prototype.shouldComponentUpdate = function (i, a) {
      return P4(this.props, i) || P4(this.state, a);
    }),
    n
  );
})(gs);
function RH(t, e) {
  function r(i) {
    var a = this.props.ref,
      s = a == i.ref;
    return (
      !s && a && (a.call ? a(null) : (a.current = null)),
      e ? !e(this.props, i) || !s : P4(this.props, i)
    );
  }
  function n(i) {
    return (this.shouldComponentUpdate = r), tc(t, mC({}, i));
  }
  return (
    (n.prototype.isReactComponent = !0),
    (n.displayName = "Memo(" + (t.displayName || t.name) + ")"),
    (n.t = !0),
    n
  );
}
var HI = ht.__b;
function PH(t) {
  function e(r) {
    var n = mC({}, r);
    return delete n.ref, t(n, r.ref);
  }
  return (
    (e.prototype.isReactComponent = e.t = !0),
    (e.displayName = "ForwardRef(" + (t.displayName || t.name) + ")"),
    e
  );
}
ht.__b = function (t) {
  t.type && t.type.t && t.ref && ((t.props.ref = t.ref), (t.ref = null)),
    HI && HI(t);
};
var zI = function (t, e) {
    return t
      ? Vc(t).reduce(function (r, n, i) {
          return r.concat(e(n, i));
        }, [])
      : null;
  },
  NH = {
    map: zI,
    forEach: zI,
    count: function (t) {
      return t ? Vc(t).length : 0;
    },
    only: function (t) {
      if ((t = Vc(t)).length !== 1)
        throw new Error("Children.only() expects only one child.");
      return t[0];
    },
    toArray: Vc,
  },
  hEe = ht.__e;
function BH(t) {
  return (
    t && (((t = mC({}, t)).__c = null), (t.__k = t.__k && t.__k.map(BH))), t
  );
}
function wb() {
  (this.__u = 0), (this.o = null), (this.__b = null);
}
function DH(t) {
  var e = t.__.__c;
  return e && e.u && e.u(t);
}
function OH(t) {
  var e, r, n;
  function i(a) {
    if (
      (e ||
        (e = t()).then(
          function (s) {
            r = s.default || s;
          },
          function (s) {
            n = s;
          }
        ),
      n)
    )
      throw n;
    if (!r) throw e;
    return tc(r, a);
  }
  return (i.displayName = "Lazy"), (i.t = !0), i;
}
function L0() {
  (this.i = null), (this.l = null);
}
(ht.__e = function (t, e, r) {
  if (t.then) {
    for (var n, i = e; (i = i.__); )
      if ((n = i.__c) && n.__c) return n.__c(t, e.__c);
  }
  hEe(t, e, r);
}),
  ((wb.prototype = new gs()).__c = function (t, e) {
    var r = this;
    r.o == null && (r.o = []), r.o.push(e);
    var n = DH(r.__v),
      i = !1,
      a = function () {
        i || ((i = !0), n ? n(s) : s());
      };
    (e.__c = e.componentWillUnmount),
      (e.componentWillUnmount = function () {
        a(), e.__c && e.__c();
      });
    var s = function () {
      var o;
      if (!--r.__u)
        for (
          r.__v.__k[0] = r.state.u,
            r.setState({
              u: (r.__b = null),
            });
          (o = r.o.pop());

        )
          o.forceUpdate();
    };
    r.__u++ ||
      r.setState({
        u: (r.__b = r.__v.__k[0]),
      }),
      t.then(a, a);
  }),
  (wb.prototype.render = function (t, e) {
    return (
      this.__b && ((this.__v.__k[0] = BH(this.__b)), (this.__b = null)),
      [tc(gs, null, e.u ? null : t.children), e.u && t.fallback]
    );
  });
var qI = function (t, e, r) {
  if (
    (++r[1] === r[0] && t.l.delete(e),
    t.props.revealOrder && (t.props.revealOrder[0] !== "t" || !t.l.size))
  )
    for (r = t.i; r; ) {
      for (; r.length > 3; ) r.pop()();
      if (r[1] < r[0]) break;
      t.i = r = r[2];
    }
};
((L0.prototype = new gs()).u = function (t) {
  var e = this,
    r = DH(e.__v),
    n = e.l.get(t);
  return (
    n[0]++,
    function (i) {
      var a = function () {
        e.props.revealOrder ? (n.push(i), qI(e, t, n)) : i();
      };
      r ? r(a) : a();
    }
  );
}),
  (L0.prototype.render = function (t) {
    (this.i = null), (this.l = new Map());
    var e = Vc(t.children);
    t.revealOrder && t.revealOrder[0] === "b" && e.reverse();
    for (var r = e.length; r--; ) this.l.set(e[r], (this.i = [1, 0, this.i]));
    return t.children;
  }),
  (L0.prototype.componentDidUpdate = L0.prototype.componentDidMount =
    function () {
      var t = this;
      t.l.forEach(function (e, r) {
        qI(t, r, e);
      });
    });
var pEe = (function () {
  function t() {}
  var e = t.prototype;
  return (
    (e.getChildContext = function () {
      return this.props.context;
    }),
    (e.render = function (r) {
      return r.children;
    }),
    t
  );
})();
function mEe(t) {
  var e = this,
    r = t.container,
    n = tc(
      pEe,
      {
        context: e.context,
      },
      t.vnode
    );
  return (
    e.s &&
      e.s !== r &&
      (e.v.parentNode && e.s.removeChild(e.v), Yh(e.h), (e.p = !1)),
    t.vnode
      ? e.p
        ? ((r.__k = e.__k), ym(n, r), (e.__k = r.__k))
        : ((e.v = document.createTextNode("")),
          wH("", r),
          r.appendChild(e.v),
          (e.p = !0),
          (e.s = r),
          ym(n, r, e.v),
          (e.__k = e.v.__k))
      : e.p && (e.v.parentNode && e.s.removeChild(e.v), Yh(e.h)),
    (e.h = n),
    (e.componentWillUnmount = function () {
      e.v.parentNode && e.s.removeChild(e.v), Yh(e.h);
    }),
    null
  );
}
function FH(t, e) {
  return tc(mEe, {
    vnode: t,
    container: e,
  });
}
var VI =
  /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
gs.prototype.isReactComponent = {};
var LH =
  (typeof Symbol < "u" && Symbol.for && Symbol.for("react.element")) || 60103;
function N4(t, e, r) {
  if (e.__k == null) for (; e.firstChild; ) e.removeChild(e.firstChild);
  return ym(t, e), typeof r == "function" && r(), t ? t.__c : null;
}
function yEe(t, e, r) {
  return wH(t, e), typeof r == "function" && r(), t ? t.__c : null;
}
var KI = ht.event;
function $5(t, e) {
  t["UNSAFE_" + e] &&
    !t[e] &&
    Object.defineProperty(t, e, {
      configurable: !1,
      get: function () {
        return this["UNSAFE_" + e];
      },
      set: function (r) {
        this["UNSAFE_" + e] = r;
      },
    });
}
ht.event = function (t) {
  KI && (t = KI(t)), (t.persist = function () {});
  var e = !1,
    r = !1,
    n = t.stopPropagation;
  t.stopPropagation = function () {
    n.call(t), (e = !0);
  };
  var i = t.preventDefault;
  return (
    (t.preventDefault = function () {
      i.call(t), (r = !0);
    }),
    (t.isPropagationStopped = function () {
      return e;
    }),
    (t.isDefaultPrevented = function () {
      return r;
    }),
    (t.nativeEvent = t)
  );
};
var GI = {
    configurable: !0,
    get: function () {
      return this.class;
    },
  },
  ZI = ht.vnode;
ht.vnode = function (t) {
  t.$$typeof = LH;
  var e = t.type,
    r = t.props;
  if (e) {
    if (
      (r.class != r.className &&
        ((GI.enumerable = "className" in r),
        r.className != null && (r.class = r.className),
        Object.defineProperty(r, "className", GI)),
      typeof e != "function")
    ) {
      var n, i, a;
      for (a in (r.defaultValue &&
        r.value !== void 0 &&
        (r.value || r.value === 0 || (r.value = r.defaultValue),
        delete r.defaultValue),
      Array.isArray(r.value) &&
        r.multiple &&
        e === "select" &&
        (Vc(r.children).forEach(function (s) {
          r.value.indexOf(s.props.value) != -1 && (s.props.selected = !0);
        }),
        delete r.value),
      r))
        if ((n = VI.test(a))) break;
      if (n)
        for (a in ((i = t.props = {}), r))
          i[VI.test(a) ? a.replace(/[A-Z0-9]/, "-$&").toLowerCase() : a] = r[a];
    }
    (function (s) {
      var o = t.type,
        c = t.props;
      if (c && typeof o == "string") {
        var u = {};
        for (var d in c)
          /^on(Ani|Tra|Tou)/.test(d) &&
            ((c[d.toLowerCase()] = c[d]), delete c[d]),
            (u[d.toLowerCase()] = d);
        if (
          (u.ondoubleclick &&
            ((c.ondblclick = c[u.ondoubleclick]), delete c[u.ondoubleclick]),
          u.onbeforeinput &&
            ((c.onbeforeinput = c[u.onbeforeinput]), delete c[u.onbeforeinput]),
          u.onchange &&
            (o === "textarea" ||
              (o.toLowerCase() === "input" && !/^fil|che|ra/i.test(c.type))))
        ) {
          var m = u.oninput || "oninput";
          c[m] || ((c[m] = c[u.onchange]), delete c[u.onchange]);
        }
      }
    })(),
      typeof e == "function" &&
        !e.m &&
        e.prototype &&
        ($5(e.prototype, "componentWillMount"),
        $5(e.prototype, "componentWillReceiveProps"),
        $5(e.prototype, "componentWillUpdate"),
        (e.m = !0));
  }
  ZI && ZI(t);
};
var gEe = "16.8.0";
function $H(t) {
  return tc.bind(null, t);
}
function yC(t) {
  return !!t && t.$$typeof === LH;
}
function UH(t) {
  return yC(t) ? uEe.apply(null, arguments) : t;
}
function WH(t) {
  return !!t.__k && (ym(null, t), !0);
}
function jH(t) {
  return (t && (t.base || (t.nodeType === 1 && t))) || null;
}
var HH = function (t, e) {
  return t(e);
};
const bEe = {
    useState: fC,
    useReducer: dC,
    useEffect: EH,
    useLayoutEffect: hC,
    useRef: TH,
    useImperativeHandle: CH,
    useMemo: Kx,
    useCallback: AH,
    useContext: kH,
    useDebugValue: SH,
    version: "16.8.0",
    Children: NH,
    render: N4,
    hydrate: N4,
    unmountComponentAtNode: WH,
    createPortal: FH,
    createElement: tc,
    createContext: _H,
    createFactory: $H,
    cloneElement: UH,
    createRef: yH,
    Fragment: _1,
    isValidElement: yC,
    findDOMNode: jH,
    Component: gs,
    PureComponent: IH,
    memo: RH,
    forwardRef: PH,
    unstable_batchedUpdates: HH,
    Suspense: wb,
    SuspenseList: L0,
    lazy: OH,
  },
  vEe = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        Children: NH,
        Component: gs,
        Fragment: _1,
        PureComponent: IH,
        Suspense: wb,
        SuspenseList: L0,
        cloneElement: UH,
        createContext: _H,
        createElement: tc,
        createFactory: $H,
        createPortal: FH,
        createRef: yH,
        default: bEe,
        findDOMNode: jH,
        forwardRef: PH,
        hydrate: yEe,
        isValidElement: yC,
        lazy: OH,
        memo: RH,
        render: N4,
        unmountComponentAtNode: WH,
        unstable_batchedUpdates: HH,
        useCallback: AH,
        useContext: kH,
        useDebugValue: SH,
        useEffect: EH,
        useErrorBoundary: fEe,
        useImperativeHandle: CH,
        useLayoutEffect: hC,
        useMemo: Kx,
        useReducer: dC,
        useRef: TH,
        useState: fC,
        version: gEe,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  xEe = Pt(vEe);
function zH(t) {
  return t && typeof t == "object" && "default" in t ? t.default : t;
}
var Ei = Y4e,
  qH = zH(x1),
  wEe = zH(iEe),
  Xe = xEe;
function _Ee(t) {
  qH.toString(t, {
    type: "terminal",
  }).then(console.log);
}
var EEe = `:root {
  --animation-duration: 300ms;
}

@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

@keyframes fadeOut {
  from {
    opacity: 1;
  }
  to {
    opacity: 0;
  }
}

.animated {
  animation-duration: var(--animation-duration);
  animation-fill-mode: both;
}

.fadeIn {
  animation-name: fadeIn;
}

.fadeOut {
  animation-name: fadeOut;
}

#walletconnect-wrapper {
  -webkit-user-select: none;
  align-items: center;
  display: flex;
  height: 100%;
  justify-content: center;
  left: 0;
  pointer-events: none;
  position: fixed;
  top: 0;
  user-select: none;
  width: 100%;
  z-index: 99999999999999;
}

.walletconnect-modal__headerLogo {
  height: 21px;
}

.walletconnect-modal__header p {
  color: #ffffff;
  font-size: 20px;
  font-weight: 600;
  margin: 0;
  align-items: flex-start;
  display: flex;
  flex: 1;
  margin-left: 5px;
}

.walletconnect-modal__close__wrapper {
  position: absolute;
  top: 0px;
  right: 0px;
  z-index: 10000;
  background: white;
  border-radius: 26px;
  padding: 6px;
  box-sizing: border-box;
  width: 26px;
  height: 26px;
  cursor: pointer;
}

.walletconnect-modal__close__icon {
  position: relative;
  top: 7px;
  right: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  transform: rotate(45deg);
}

.walletconnect-modal__close__line1 {
  position: absolute;
  width: 100%;
  border: 1px solid rgb(48, 52, 59);
}

.walletconnect-modal__close__line2 {
  position: absolute;
  width: 100%;
  border: 1px solid rgb(48, 52, 59);
  transform: rotate(90deg);
}

.walletconnect-qrcode__base {
  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
  background: rgba(37, 41, 46, 0.95);
  height: 100%;
  left: 0;
  pointer-events: auto;
  position: fixed;
  top: 0;
  transition: 0.4s cubic-bezier(0.19, 1, 0.22, 1);
  width: 100%;
  will-change: opacity;
  padding: 40px;
  box-sizing: border-box;
}

.walletconnect-qrcode__text {
  color: rgba(60, 66, 82, 0.6);
  font-size: 16px;
  font-weight: 600;
  letter-spacing: 0;
  line-height: 1.1875em;
  margin: 10px 0 20px 0;
  text-align: center;
  width: 100%;
}

@media only screen and (max-width: 768px) {
  .walletconnect-qrcode__text {
    font-size: 4vw;
  }
}

@media only screen and (max-width: 320px) {
  .walletconnect-qrcode__text {
    font-size: 14px;
  }
}

.walletconnect-qrcode__image {
  width: calc(100% - 30px);
  box-sizing: border-box;
  cursor: none;
  margin: 0 auto;
}

.walletconnect-qrcode__notification {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  font-size: 16px;
  padding: 16px 20px;
  border-radius: 16px;
  text-align: center;
  transition: all 0.1s ease-in-out;
  background: white;
  color: black;
  margin-bottom: -60px;
  opacity: 0;
}

.walletconnect-qrcode__notification.notification__show {
  opacity: 1;
}

@media only screen and (max-width: 768px) {
  .walletconnect-modal__header {
    height: 130px;
  }
  .walletconnect-modal__base {
    overflow: auto;
  }
}

@media only screen and (min-device-width: 415px) and (max-width: 768px) {
  #content {
    max-width: 768px;
    box-sizing: border-box;
  }
}

@media only screen and (min-width: 375px) and (max-width: 415px) {
  #content {
    max-width: 414px;
    box-sizing: border-box;
  }
}

@media only screen and (min-width: 320px) and (max-width: 375px) {
  #content {
    max-width: 375px;
    box-sizing: border-box;
  }
}

@media only screen and (max-width: 320px) {
  #content {
    max-width: 320px;
    box-sizing: border-box;
  }
}

.walletconnect-modal__base {
  -webkit-font-smoothing: antialiased;
  background: #ffffff;
  border-radius: 24px;
  box-shadow: 0 10px 50px 5px rgba(0, 0, 0, 0.4);
  font-family: ui-rounded, "SF Pro Rounded", "SF Pro Text", medium-content-sans-serif-font,
    -apple-system, BlinkMacSystemFont, ui-sans-serif, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell,
    "Open Sans", "Helvetica Neue", sans-serif;
  margin-top: 41px;
  padding: 24px 24px 22px;
  pointer-events: auto;
  position: relative;
  text-align: center;
  transition: 0.4s cubic-bezier(0.19, 1, 0.22, 1);
  will-change: transform;
  overflow: visible;
  transform: translateY(-50%);
  top: 50%;
  max-width: 500px;
  margin: auto;
}

@media only screen and (max-width: 320px) {
  .walletconnect-modal__base {
    padding: 24px 12px;
  }
}

.walletconnect-modal__base .hidden {
  transform: translateY(150%);
  transition: 0.125s cubic-bezier(0.4, 0, 1, 1);
}

.walletconnect-modal__header {
  align-items: center;
  display: flex;
  height: 26px;
  left: 0;
  justify-content: space-between;
  position: absolute;
  top: -42px;
  width: 100%;
}

.walletconnect-modal__base .wc-logo {
  align-items: center;
  display: flex;
  height: 26px;
  margin-top: 15px;
  padding-bottom: 15px;
  pointer-events: auto;
}

.walletconnect-modal__base .wc-logo div {
  background-color: #3399ff;
  height: 21px;
  margin-right: 5px;
  mask-image: url("images/wc-logo.svg") center no-repeat;
  width: 32px;
}

.walletconnect-modal__base .wc-logo p {
  color: #ffffff;
  font-size: 20px;
  font-weight: 600;
  margin: 0;
}

.walletconnect-modal__base h2 {
  color: rgba(60, 66, 82, 0.6);
  font-size: 16px;
  font-weight: 600;
  letter-spacing: 0;
  line-height: 1.1875em;
  margin: 0 0 19px 0;
  text-align: center;
  width: 100%;
}

.walletconnect-modal__base__row {
  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
  align-items: center;
  border-radius: 20px;
  cursor: pointer;
  display: flex;
  height: 56px;
  justify-content: space-between;
  padding: 0 15px;
  position: relative;
  margin: 0px 0px 8px;
  text-align: left;
  transition: 0.15s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  will-change: transform;
  text-decoration: none;
}

.walletconnect-modal__base__row:hover {
  background: rgba(60, 66, 82, 0.06);
}

.walletconnect-modal__base__row:active {
  background: rgba(60, 66, 82, 0.06);
  transform: scale(0.975);
  transition: 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

.walletconnect-modal__base__row__h3 {
  color: #25292e;
  font-size: 20px;
  font-weight: 700;
  margin: 0;
  padding-bottom: 3px;
}

.walletconnect-modal__base__row__right {
  align-items: center;
  display: flex;
  justify-content: center;
}

.walletconnect-modal__base__row__right__app-icon {
  border-radius: 8px;
  height: 34px;
  margin: 0 11px 2px 0;
  width: 34px;
  background-size: 100%;
  box-shadow: 0 4px 12px 0 rgba(37, 41, 46, 0.25);
}

.walletconnect-modal__base__row__right__caret {
  height: 18px;
  opacity: 0.3;
  transition: 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  width: 8px;
  will-change: opacity;
}

.walletconnect-modal__base__row:hover .caret,
.walletconnect-modal__base__row:active .caret {
  opacity: 0.6;
}

.walletconnect-modal__mobile__toggle {
  width: 80%;
  display: flex;
  margin: 0 auto;
  position: relative;
  overflow: hidden;
  border-radius: 8px;
  margin-bottom: 18px;
  background: #d4d5d9;
}

.walletconnect-modal__single_wallet {
  display: flex;
  justify-content: center;
  margin-top: 7px;
  margin-bottom: 18px;
}

.walletconnect-modal__single_wallet a {
  cursor: pointer;
  color: rgb(64, 153, 255);
  font-size: 21px;
  font-weight: 800;
  text-decoration: none !important;
  margin: 0 auto;
}

.walletconnect-modal__mobile__toggle_selector {
  width: calc(50% - 8px);
  background: white;
  position: absolute;
  border-radius: 5px;
  height: calc(100% - 8px);
  top: 4px;
  transition: all 0.2s ease-in-out;
  transform: translate3d(4px, 0, 0);
}

.walletconnect-modal__mobile__toggle.right__selected .walletconnect-modal__mobile__toggle_selector {
  transform: translate3d(calc(100% + 12px), 0, 0);
}

.walletconnect-modal__mobile__toggle a {
  font-size: 12px;
  width: 50%;
  text-align: center;
  padding: 8px;
  margin: 0;
  font-weight: 600;
  z-index: 1;
}

.walletconnect-modal__footer {
  display: flex;
  justify-content: center;
  margin-top: 20px;
}

@media only screen and (max-width: 768px) {
  .walletconnect-modal__footer {
    margin-top: 5vw;
  }
}

.walletconnect-modal__footer a {
  cursor: pointer;
  color: #898d97;
  font-size: 15px;
  margin: 0 auto;
}

@media only screen and (max-width: 320px) {
  .walletconnect-modal__footer a {
    font-size: 14px;
  }
}

.walletconnect-connect__buttons__wrapper {
  max-height: 44vh;
}

.walletconnect-connect__buttons__wrapper__android {
  margin: 50% 0;
}

.walletconnect-connect__buttons__wrapper__wrap {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  margin: 10px 0;
}

@media only screen and (min-width: 768px) {
  .walletconnect-connect__buttons__wrapper__wrap {
    margin-top: 40px;
  }
}

.walletconnect-connect__button {
  background-color: rgb(64, 153, 255);
  padding: 12px;
  border-radius: 8px;
  text-decoration: none;
  color: rgb(255, 255, 255);
  font-weight: 500;
}

.walletconnect-connect__button__icon_anchor {
  cursor: pointer;
  display: flex;
  justify-content: flex-start;
  align-items: center;
  margin: 8px;
  width: 42px;
  justify-self: center;
  flex-direction: column;
  text-decoration: none !important;
}

@media only screen and (max-width: 320px) {
  .walletconnect-connect__button__icon_anchor {
    margin: 4px;
  }
}

.walletconnect-connect__button__icon {
  border-radius: 10px;
  height: 42px;
  margin: 0;
  width: 42px;
  background-size: cover !important;
  box-shadow: 0 4px 12px 0 rgba(37, 41, 46, 0.25);
}

.walletconnect-connect__button__text {
  color: #424952;
  font-size: 2.7vw;
  text-decoration: none !important;
  padding: 0;
  margin-top: 1.8vw;
  font-weight: 600;
}

@media only screen and (min-width: 768px) {
  .walletconnect-connect__button__text {
    font-size: 16px;
    margin-top: 12px;
  }
}

.walletconnect-search__input {
  border: none;
  background: #d4d5d9;
  border-style: none;
  padding: 8px 16px;
  outline: none;
  font-style: normal;
  font-stretch: normal;
  font-size: 16px;
  font-style: normal;
  font-stretch: normal;
  line-height: normal;
  letter-spacing: normal;
  text-align: left;
  border-radius: 8px;
  width: calc(100% - 16px);
  margin: 0;
  margin-bottom: 8px;
}
`;
typeof Symbol < "u" &&
  (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")));
typeof Symbol < "u" &&
  (Symbol.asyncIterator ||
    (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")));
function TEe(t, e) {
  try {
    var r = t();
  } catch (n) {
    return e(n);
  }
  return r && r.then ? r.then(void 0, e) : r;
}
var CEe =
    "data:image/svg+xml,%3Csvg height='185' viewBox='0 0 300 185' width='300' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='m61.4385429 36.2562612c48.9112241-47.8881663 128.2119871-47.8881663 177.1232091 0l5.886545 5.7634174c2.445561 2.3944081 2.445561 6.2765112 0 8.6709204l-20.136695 19.715503c-1.222781 1.1972051-3.2053 1.1972051-4.428081 0l-8.100584-7.9311479c-34.121692-33.4079817-89.443886-33.4079817-123.5655788 0l-8.6750562 8.4936051c-1.2227816 1.1972041-3.205301 1.1972041-4.4280806 0l-20.1366949-19.7155031c-2.4455612-2.3944092-2.4455612-6.2765122 0-8.6709204zm218.7677961 40.7737449 17.921697 17.546897c2.445549 2.3943969 2.445563 6.2764769.000031 8.6708899l-80.810171 79.121134c-2.445544 2.394426-6.410582 2.394453-8.85616.000062-.00001-.00001-.000022-.000022-.000032-.000032l-57.354143-56.154572c-.61139-.598602-1.60265-.598602-2.21404 0-.000004.000004-.000007.000008-.000011.000011l-57.3529212 56.154531c-2.4455368 2.394432-6.4105755 2.394472-8.8561612.000087-.0000143-.000014-.0000296-.000028-.0000449-.000044l-80.81241943-79.122185c-2.44556021-2.394408-2.44556021-6.2765115 0-8.6709197l17.92172963-17.5468673c2.4455602-2.3944082 6.4105989-2.3944082 8.8561602 0l57.3549775 56.155357c.6113908.598602 1.602649.598602 2.2140398 0 .0000092-.000009.0000174-.000017.0000265-.000024l57.3521031-56.155333c2.445505-2.3944633 6.410544-2.3945531 8.856161-.0002.000034.0000336.000068.0000673.000101.000101l57.354902 56.155432c.61139.598601 1.60265.598601 2.21404 0l57.353975-56.1543249c2.445561-2.3944092 6.410599-2.3944092 8.85616 0z' fill='%233b99fc'/%3E%3C/svg%3E",
  AEe = "WalletConnect",
  kEe = 300,
  SEe = "rgb(64, 153, 255)",
  VH = "walletconnect-wrapper",
  JI = "walletconnect-style-sheet",
  KH = "walletconnect-qrcode-modal",
  MEe = "walletconnect-qrcode-close",
  GH = "walletconnect-qrcode-text",
  IEe = "walletconnect-connect-button";
function REe(t) {
  return Xe.createElement(
    "div",
    {
      className: "walletconnect-modal__header",
    },
    Xe.createElement("img", {
      src: CEe,
      className: "walletconnect-modal__headerLogo",
    }),
    Xe.createElement("p", null, AEe),
    Xe.createElement(
      "div",
      {
        className: "walletconnect-modal__close__wrapper",
        onClick: t.onClose,
      },
      Xe.createElement(
        "div",
        {
          id: MEe,
          className: "walletconnect-modal__close__icon",
        },
        Xe.createElement("div", {
          className: "walletconnect-modal__close__line1",
        }),
        Xe.createElement("div", {
          className: "walletconnect-modal__close__line2",
        })
      )
    )
  );
}
function PEe(t) {
  return Xe.createElement(
    "a",
    {
      className: "walletconnect-connect__button",
      href: t.href,
      id: IEe + "-" + t.name,
      onClick: t.onClick,
      rel: "noopener noreferrer",
      style: {
        backgroundColor: t.color,
      },
      target: "_blank",
    },
    t.name
  );
}
var NEe =
  "data:image/svg+xml,%3Csvg fill='none' height='18' viewBox='0 0 8 18' width='8' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath clip-rule='evenodd' d='m.586301.213898c-.435947.33907-.5144813.967342-.175411 1.403292l4.87831 6.27212c.28087.36111.28087.86677 0 1.22788l-4.878311 6.27211c-.33907.436-.260536 1.0642.175412 1.4033.435949.3391 1.064219.2605 1.403289-.1754l4.87832-6.2721c.84259-1.08336.84259-2.60034 0-3.68367l-4.87832-6.27212c-.33907-.4359474-.96734-.514482-1.403289-.175412z' fill='%233c4252' fill-rule='evenodd'/%3E%3C/svg%3E";
function BEe(t) {
  var e = t.color,
    r = t.href,
    n = t.name,
    i = t.logo,
    a = t.onClick;
  return Xe.createElement(
    "a",
    {
      className: "walletconnect-modal__base__row",
      href: r,
      onClick: a,
      rel: "noopener noreferrer",
      target: "_blank",
    },
    Xe.createElement(
      "h3",
      {
        className: "walletconnect-modal__base__row__h3",
      },
      n
    ),
    Xe.createElement(
      "div",
      {
        className: "walletconnect-modal__base__row__right",
      },
      Xe.createElement("div", {
        className: "walletconnect-modal__base__row__right__app-icon",
        style: {
          background: "url('" + i + "') " + e,
          backgroundSize: "100%",
        },
      }),
      Xe.createElement("img", {
        src: NEe,
        className: "walletconnect-modal__base__row__right__caret",
      })
    )
  );
}
function DEe(t) {
  var e = t.color,
    r = t.href,
    n = t.name,
    i = t.logo,
    a = t.onClick,
    s = window.innerWidth < 768 ? (n.length > 8 ? 2.5 : 2.7) + "vw" : "inherit";
  return Xe.createElement(
    "a",
    {
      className: "walletconnect-connect__button__icon_anchor",
      href: r,
      onClick: a,
      rel: "noopener noreferrer",
      target: "_blank",
    },
    Xe.createElement("div", {
      className: "walletconnect-connect__button__icon",
      style: {
        background: "url('" + i + "') " + e,
        backgroundSize: "100%",
      },
    }),
    Xe.createElement(
      "div",
      {
        style: {
          fontSize: s,
        },
        className: "walletconnect-connect__button__text",
      },
      n
    )
  );
}
var OEe = 5,
  U5 = 12;
function FEe(t) {
  var e = Ei.isAndroid(),
    r = Xe.useState(""),
    n = r[0],
    i = r[1],
    a = Xe.useState(""),
    s = a[0],
    o = a[1],
    c = Xe.useState(1),
    u = c[0],
    d = c[1],
    m = s
      ? t.links.filter(function (N) {
          return N.name.toLowerCase().includes(s.toLowerCase());
        })
      : t.links,
    v = t.errorMessage,
    E = s || m.length > OEe,
    A = Math.ceil(m.length / U5),
    I = [(u - 1) * U5 + 1, u * U5],
    b = m.length
      ? m.filter(function (N, O) {
          return O + 1 >= I[0] && O + 1 <= I[1];
        })
      : [],
    w = !e && A > 1,
    S = void 0;
  function k(N) {
    i(N.target.value),
      clearTimeout(S),
      N.target.value
        ? (S = setTimeout(function () {
            o(N.target.value), d(1);
          }, 1e3))
        : (i(""), o(""), d(1));
  }
  return Xe.createElement(
    "div",
    null,
    Xe.createElement(
      "p",
      {
        id: GH,
        className: "walletconnect-qrcode__text",
      },
      e ? t.text.connect_mobile_wallet : t.text.choose_preferred_wallet
    ),
    !e &&
      Xe.createElement("input", {
        className: "walletconnect-search__input",
        placeholder: "Search",
        value: n,
        onChange: k,
      }),
    Xe.createElement(
      "div",
      {
        className:
          "walletconnect-connect__buttons__wrapper" +
          (e ? "__android" : E && m.length ? "__wrap" : ""),
      },
      e
        ? Xe.createElement(PEe, {
            name: t.text.connect,
            color: SEe,
            href: t.uri,
            onClick: Xe.useCallback(function () {
              Ei.saveMobileLinkInfo({
                name: "Unknown",
                href: t.uri,
              });
            }, []),
          })
        : b.length
        ? b.map(function (N) {
            var O = N.color,
              F = N.name,
              V = N.shortName,
              j = N.logo,
              X = Ei.formatIOSMobile(t.uri, N),
              C = Xe.useCallback(
                function () {
                  Ei.saveMobileLinkInfo({
                    name: F,
                    href: X,
                  });
                },
                [b]
              );
            return E
              ? Xe.createElement(DEe, {
                  color: O,
                  href: X,
                  name: V || F,
                  logo: j,
                  onClick: C,
                })
              : Xe.createElement(BEe, {
                  color: O,
                  href: X,
                  name: F,
                  logo: j,
                  onClick: C,
                });
          })
        : Xe.createElement(
            Xe.Fragment,
            null,
            Xe.createElement(
              "p",
              null,
              v.length
                ? t.errorMessage
                : t.links.length && !m.length
                ? t.text.no_wallets_found
                : t.text.loading
            )
          )
    ),
    w &&
      Xe.createElement(
        "div",
        {
          className: "walletconnect-modal__footer",
        },
        Array(A)
          .fill(0)
          .map(function (N, O) {
            var F = O + 1,
              V = u === F;
            return Xe.createElement(
              "a",
              {
                style: {
                  margin: "auto 10px",
                  fontWeight: V ? "bold" : "normal",
                },
                onClick: function () {
                  return d(F);
                },
              },
              F
            );
          })
      )
  );
}
function LEe(t) {
  var e = !!t.message.trim();
  return Xe.createElement(
    "div",
    {
      className:
        "walletconnect-qrcode__notification" + (e ? " notification__show" : ""),
    },
    t.message
  );
}
var $Ee = function (t) {
  try {
    var e = "";
    return Promise.resolve(
      qH.toString(t, {
        margin: 0,
        type: "svg",
      })
    ).then(function (r) {
      return (
        typeof r == "string" &&
          (e = r.replace("<svg", '<svg class="walletconnect-qrcode__image"')),
        e
      );
    });
  } catch (r) {
    return Promise.reject(r);
  }
};
function UEe(t) {
  var e = Xe.useState(""),
    r = e[0],
    n = e[1],
    i = Xe.useState(""),
    a = i[0],
    s = i[1];
  Xe.useEffect(function () {
    try {
      return Promise.resolve($Ee(t.uri)).then(function (c) {
        s(c);
      });
    } catch (c) {
      Promise.reject(c);
    }
  }, []);
  var o = function () {
    var c = wEe(t.uri);
    c
      ? (n(t.text.copied_to_clipboard),
        setInterval(function () {
          return n("");
        }, 1200))
      : (n("Error"),
        setInterval(function () {
          return n("");
        }, 1200));
  };
  return Xe.createElement(
    "div",
    null,
    Xe.createElement(
      "p",
      {
        id: GH,
        className: "walletconnect-qrcode__text",
      },
      t.text.scan_qrcode_with_wallet
    ),
    Xe.createElement("div", {
      dangerouslySetInnerHTML: {
        __html: a,
      },
    }),
    Xe.createElement(
      "div",
      {
        className: "walletconnect-modal__footer",
      },
      Xe.createElement(
        "a",
        {
          onClick: o,
        },
        t.text.copy_to_clipboard
      )
    ),
    Xe.createElement(LEe, {
      message: r,
    })
  );
}
function WEe(t) {
  var e = Ei.isAndroid(),
    r = Ei.isMobile(),
    n = r
      ? t.qrcodeModalOptions && t.qrcodeModalOptions.mobileLinks
        ? t.qrcodeModalOptions.mobileLinks
        : void 0
      : t.qrcodeModalOptions && t.qrcodeModalOptions.desktopLinks
      ? t.qrcodeModalOptions.desktopLinks
      : void 0,
    i = Xe.useState(!1),
    a = i[0],
    s = i[1],
    o = Xe.useState(!1),
    c = o[0],
    u = o[1],
    d = Xe.useState(!r),
    m = d[0],
    v = d[1],
    E = {
      mobile: r,
      text: t.text,
      uri: t.uri,
      qrcodeModalOptions: t.qrcodeModalOptions,
    },
    A = Xe.useState(""),
    I = A[0],
    b = A[1],
    w = Xe.useState(!1),
    S = w[0],
    k = w[1],
    N = Xe.useState([]),
    O = N[0],
    F = N[1],
    V = Xe.useState(""),
    j = V[0],
    X = V[1],
    C = function () {
      c ||
        a ||
        (n && !n.length) ||
        O.length > 0 ||
        Xe.useEffect(function () {
          var p = function () {
            try {
              if (e) return Promise.resolve();
              s(!0);
              var y = TEe(
                function () {
                  var h =
                    t.qrcodeModalOptions && t.qrcodeModalOptions.registryUrl
                      ? t.qrcodeModalOptions.registryUrl
                      : Ei.getWalletRegistryUrl();
                  return Promise.resolve(fetch(h)).then(function (g) {
                    return Promise.resolve(g.json()).then(function (T) {
                      var R = T.listings,
                        x = r ? "mobile" : "desktop",
                        f = Ei.getMobileLinkRegistry(
                          Ei.formatMobileRegistry(R, x),
                          n
                        );
                      s(!1),
                        u(!0),
                        X(f.length ? "" : t.text.no_supported_wallets),
                        F(f);
                      var _ = f.length === 1;
                      _ && (b(Ei.formatIOSMobile(t.uri, f[0])), v(!0)), k(_);
                    });
                  });
                },
                function (h) {
                  s(!1),
                    u(!0),
                    X(t.text.something_went_wrong),
                    console.error(h);
                }
              );
              return Promise.resolve(
                y && y.then ? y.then(function () {}) : void 0
              );
            } catch (h) {
              return Promise.reject(h);
            }
          };
          p();
        });
    };
  C();
  var l = r ? m : !m;
  return Xe.createElement(
    "div",
    {
      id: KH,
      className: "walletconnect-qrcode__base animated fadeIn",
    },
    Xe.createElement(
      "div",
      {
        className: "walletconnect-modal__base",
      },
      Xe.createElement(REe, {
        onClose: t.onClose,
      }),
      S && m
        ? Xe.createElement(
            "div",
            {
              className: "walletconnect-modal__single_wallet",
            },
            Xe.createElement(
              "a",
              {
                onClick: function () {
                  return Ei.saveMobileLinkInfo({
                    name: O[0].name,
                    href: I,
                  });
                },
                href: I,
                rel: "noopener noreferrer",
                target: "_blank",
              },
              t.text.connect_with + " " + (S ? O[0].name : "") + " ›"
            )
          )
        : e || a || (!a && O.length)
        ? Xe.createElement(
            "div",
            {
              className:
                "walletconnect-modal__mobile__toggle" +
                (l ? " right__selected" : ""),
            },
            Xe.createElement("div", {
              className: "walletconnect-modal__mobile__toggle_selector",
            }),
            r
              ? Xe.createElement(
                  Xe.Fragment,
                  null,
                  Xe.createElement(
                    "a",
                    {
                      onClick: function () {
                        return v(!1), C();
                      },
                    },
                    t.text.mobile
                  ),
                  Xe.createElement(
                    "a",
                    {
                      onClick: function () {
                        return v(!0);
                      },
                    },
                    t.text.qrcode
                  )
                )
              : Xe.createElement(
                  Xe.Fragment,
                  null,
                  Xe.createElement(
                    "a",
                    {
                      onClick: function () {
                        return v(!0);
                      },
                    },
                    t.text.qrcode
                  ),
                  Xe.createElement(
                    "a",
                    {
                      onClick: function () {
                        return v(!1), C();
                      },
                    },
                    t.text.desktop
                  )
                )
          )
        : null,
      Xe.createElement(
        "div",
        null,
        m || (!e && !a && !O.length)
          ? Xe.createElement(UEe, Object.assign({}, E))
          : Xe.createElement(
              FEe,
              Object.assign({}, E, {
                links: O,
                errorMessage: j,
              })
            )
      )
    )
  );
}
var jEe = {
    choose_preferred_wallet: "Wähle bevorzugte Wallet",
    connect_mobile_wallet: "Verbinde mit Mobile Wallet",
    scan_qrcode_with_wallet:
      "Scanne den QR-code mit einer WalletConnect kompatiblen Wallet",
    connect: "Verbinden",
    qrcode: "QR-Code",
    mobile: "Mobile",
    desktop: "Desktop",
    copy_to_clipboard: "In die Zwischenablage kopieren",
    copied_to_clipboard: "In die Zwischenablage kopiert!",
    connect_with: "Verbinden mit Hilfe von",
    loading: "Laden...",
    something_went_wrong: "Etwas ist schief gelaufen",
    no_supported_wallets: "Es gibt noch keine unterstützten Wallet",
    no_wallets_found: "keine Wallet gefunden",
  },
  HEe = {
    choose_preferred_wallet: "Choose your preferred wallet",
    connect_mobile_wallet: "Connect to Mobile Wallet",
    scan_qrcode_with_wallet:
      "Scan QR code with a WalletConnect-compatible wallet",
    connect: "Connect",
    qrcode: "QR Code",
    mobile: "Mobile",
    desktop: "Desktop",
    copy_to_clipboard: "Copy to clipboard",
    copied_to_clipboard: "Copied to clipboard!",
    connect_with: "Connect with",
    loading: "Loading...",
    something_went_wrong: "Something went wrong",
    no_supported_wallets: "There are no supported wallets yet",
    no_wallets_found: "No wallets found",
  },
  zEe = {
    choose_preferred_wallet: "Elige tu billetera preferida",
    connect_mobile_wallet: "Conectar a billetera móvil",
    scan_qrcode_with_wallet:
      "Escanea el código QR con una billetera compatible con WalletConnect",
    connect: "Conectar",
    qrcode: "Código QR",
    mobile: "Móvil",
    desktop: "Desktop",
    copy_to_clipboard: "Copiar",
    copied_to_clipboard: "Copiado!",
    connect_with: "Conectar mediante",
    loading: "Cargando...",
    something_went_wrong: "Algo salió mal",
    no_supported_wallets: "Todavía no hay billeteras compatibles",
    no_wallets_found: "No se encontraron billeteras",
  },
  qEe = {
    choose_preferred_wallet: "Choisissez votre portefeuille préféré",
    connect_mobile_wallet: "Se connecter au portefeuille mobile",
    scan_qrcode_with_wallet:
      "Scannez le QR code avec un portefeuille compatible WalletConnect",
    connect: "Se connecter",
    qrcode: "QR Code",
    mobile: "Mobile",
    desktop: "Desktop",
    copy_to_clipboard: "Copier",
    copied_to_clipboard: "Copié!",
    connect_with: "Connectez-vous à l'aide de",
    loading: "Chargement...",
    something_went_wrong: "Quelque chose a mal tourné",
    no_supported_wallets: "Il n'y a pas encore de portefeuilles pris en charge",
    no_wallets_found: "Aucun portefeuille trouvé",
  },
  VEe = {
    choose_preferred_wallet: "원하는 지갑을 선택하세요",
    connect_mobile_wallet: "모바일 지갑과 연결",
    scan_qrcode_with_wallet: "WalletConnect 지원 지갑에서 QR코드를 스캔하세요",
    connect: "연결",
    qrcode: "QR 코드",
    mobile: "모바일",
    desktop: "데스크탑",
    copy_to_clipboard: "클립보드에 복사",
    copied_to_clipboard: "클립보드에 복사되었습니다!",
    connect_with: "와 연결하다",
    loading: "로드 중...",
    something_went_wrong: "문제가 발생했습니다.",
    no_supported_wallets: "아직 지원되는 지갑이 없습니다",
    no_wallets_found: "지갑을 찾을 수 없습니다",
  },
  KEe = {
    choose_preferred_wallet: "Escolha sua carteira preferida",
    connect_mobile_wallet: "Conectar-se à carteira móvel",
    scan_qrcode_with_wallet:
      "Ler o código QR com uma carteira compatível com WalletConnect",
    connect: "Conectar",
    qrcode: "Código QR",
    mobile: "Móvel",
    desktop: "Desktop",
    copy_to_clipboard: "Copiar",
    copied_to_clipboard: "Copiado!",
    connect_with: "Ligar por meio de",
    loading: "Carregamento...",
    something_went_wrong: "Algo correu mal",
    no_supported_wallets: "Ainda não há carteiras suportadas",
    no_wallets_found: "Nenhuma carteira encontrada",
  },
  GEe = {
    choose_preferred_wallet: "选择你的钱包",
    connect_mobile_wallet: "连接至移动端钱包",
    scan_qrcode_with_wallet: "使用兼容 WalletConnect 的钱包扫描二维码",
    connect: "连接",
    qrcode: "二维码",
    mobile: "移动",
    desktop: "桌面",
    copy_to_clipboard: "复制到剪贴板",
    copied_to_clipboard: "复制到剪贴板成功！",
    connect_with: "通过以下方式连接",
    loading: "正在加载...",
    something_went_wrong: "出了问题",
    no_supported_wallets: "目前还没有支持的钱包",
    no_wallets_found: "没有找到钱包",
  },
  ZEe = {
    choose_preferred_wallet: "کیف پول مورد نظر خود را انتخاب کنید",
    connect_mobile_wallet: "به کیف پول موبایل وصل شوید",
    scan_qrcode_with_wallet:
      "کد QR را با یک کیف پول سازگار با WalletConnect اسکن کنید",
    connect: "اتصال",
    qrcode: "کد QR",
    mobile: "سیار",
    desktop: "دسکتاپ",
    copy_to_clipboard: "کپی به کلیپ بورد",
    copied_to_clipboard: "در کلیپ بورد کپی شد!",
    connect_with: "ارتباط با",
    loading: "...بارگذاری",
    something_went_wrong: "مشکلی پیش آمد",
    no_supported_wallets: "هنوز هیچ کیف پول پشتیبانی شده ای وجود ندارد",
    no_wallets_found: "هیچ کیف پولی پیدا نشد",
  },
  QI = {
    de: jEe,
    en: HEe,
    es: zEe,
    fr: qEe,
    ko: VEe,
    pt: KEe,
    zh: GEe,
    fa: ZEe,
  };
function JEe() {
  var t = Ei.getDocumentOrThrow(),
    e = t.getElementById(JI);
  e && t.head.removeChild(e);
  var r = t.createElement("style");
  r.setAttribute("id", JI), (r.innerText = EEe), t.head.appendChild(r);
}
function QEe() {
  var t = Ei.getDocumentOrThrow(),
    e = t.createElement("div");
  return e.setAttribute("id", VH), t.body.appendChild(e), e;
}
function ZH() {
  var t = Ei.getDocumentOrThrow(),
    e = t.getElementById(KH);
  e &&
    ((e.className = e.className.replace("fadeIn", "fadeOut")),
    setTimeout(function () {
      var r = t.getElementById(VH);
      r && t.body.removeChild(r);
    }, kEe));
}
function YEe(t) {
  return function () {
    ZH(), t && t();
  };
}
function XEe() {
  var t = Ei.getNavigatorOrThrow().language.split("-")[0] || "en";
  return QI[t] || QI.en;
}
function eTe(t, e, r) {
  JEe();
  var n = QEe();
  Xe.render(
    Xe.createElement(WEe, {
      text: XEe(),
      uri: t,
      onClose: YEe(e),
      qrcodeModalOptions: r,
    }),
    n
  );
}
function tTe() {
  ZH();
}
var JH = function () {
  return (
    typeof process < "u" &&
    typeof process.versions < "u" &&
    typeof process.versions.node < "u"
  );
};
function rTe(t, e, r) {
  console.log(t), JH() ? _Ee(t) : eTe(t, e, r);
}
function nTe() {
  JH() || tTe();
}
var iTe = {
    open: rTe,
    close: nTe,
  },
  aTe = iTe;
const sTe = mn(aTe);
class oTe extends Rpe {
  constructor(e) {
    super(),
      (this.events = new F_e()),
      (this.accounts = []),
      (this.chainId = 1),
      (this.pending = !1),
      (this.bridge = "https://bridge.walletconnect.org"),
      (this.qrcode = !0),
      (this.qrcodeModalOptions = void 0),
      (this.opts = e),
      (this.chainId = (e == null ? void 0 : e.chainId) || this.chainId),
      (this.wc = this.register(e));
  }
  get connected() {
    return typeof this.wc < "u" && this.wc.connected;
  }
  get connecting() {
    return this.pending;
  }
  get connector() {
    return (this.wc = this.register(this.opts)), this.wc;
  }
  on(e, r) {
    this.events.on(e, r);
  }
  once(e, r) {
    this.events.once(e, r);
  }
  off(e, r) {
    this.events.off(e, r);
  }
  removeListener(e, r) {
    this.events.removeListener(e, r);
  }
  async open(e) {
    if (this.connected) {
      this.onOpen();
      return;
    }
    return new Promise((r, n) => {
      this.on("error", (i) => {
        n(i);
      }),
        this.on("open", () => {
          r();
        }),
        this.create(e);
    });
  }
  async close() {
    typeof this.wc > "u" ||
      (this.wc.connected && this.wc.killSession(), this.onClose());
  }
  async send(e) {
    (this.wc = this.register(this.opts)),
      this.connected || (await this.open()),
      this.sendPayload(e)
        .then((r) => this.events.emit("payload", r))
        .catch((r) => this.events.emit("payload", n4(e.id, r.message)));
  }
  register(e) {
    if (this.wc) return this.wc;
    (this.opts = e || this.opts),
      (this.bridge =
        e != null && e.connector
          ? e.connector.bridge
          : (e == null ? void 0 : e.bridge) ||
            "https://bridge.walletconnect.org"),
      (this.qrcode =
        typeof (e == null ? void 0 : e.qrcode) > "u" || e.qrcode !== !1),
      (this.chainId =
        typeof (e == null ? void 0 : e.chainId) < "u"
          ? e.chainId
          : this.chainId),
      (this.qrcodeModalOptions = e == null ? void 0 : e.qrcodeModalOptions);
    const r = {
      bridge: this.bridge,
      qrcodeModal: this.qrcode ? sTe : void 0,
      qrcodeModalOptions: this.qrcodeModalOptions,
      storageId: e == null ? void 0 : e.storageId,
      signingMethods: e == null ? void 0 : e.signingMethods,
      clientMeta: e == null ? void 0 : e.clientMeta,
    };
    if (
      ((this.wc =
        typeof (e == null ? void 0 : e.connector) < "u"
          ? e.connector
          : new Q4e(r)),
      typeof this.wc > "u")
    )
      throw new Error("Failed to register WalletConnect connector");
    return (
      this.wc.accounts.length && (this.accounts = this.wc.accounts),
      this.wc.chainId && (this.chainId = this.wc.chainId),
      this.registerConnectorEvents(),
      this.wc
    );
  }
  onOpen(e) {
    (this.pending = !1), e && (this.wc = e), this.events.emit("open");
  }
  onClose() {
    (this.pending = !1),
      this.wc && (this.wc = void 0),
      this.events.emit("close");
  }
  onError(e, r = "Failed or Rejected Request", n = -32e3, i) {
    const a = {
      id: e.id,
      jsonrpc: e.jsonrpc,
      error: {
        code: n,
        message: r,
      },
    };
    return (
      typeof i < "u" && (a.error.data = i), this.events.emit("payload", a), a
    );
  }
  create(e) {
    (this.wc = this.register(this.opts)),
      (this.chainId = e || this.chainId),
      !(this.connected || this.pending) &&
        ((this.pending = !0),
        this.registerConnectorEvents(),
        this.wc
          .createSession({
            chainId: this.chainId,
          })
          .then(() => this.events.emit("created"))
          .catch((r) => this.events.emit("error", r)));
  }
  registerConnectorEvents() {
    (this.wc = this.register(this.opts)),
      this.wc.on("connect", (e) => {
        var r, n;
        if (e) {
          this.events.emit("error", e);
          return;
        }
        (this.accounts =
          ((r = this.wc) === null || r === void 0 ? void 0 : r.accounts) || []),
          (this.chainId =
            ((n = this.wc) === null || n === void 0 ? void 0 : n.chainId) ||
            this.chainId),
          this.onOpen();
      }),
      this.wc.on("disconnect", (e) => {
        if (e) {
          this.events.emit("error", e);
          return;
        }
        this.onClose();
      }),
      this.wc.on("modal_closed", () => {
        this.events.emit("error", new Error("User closed modal"));
      }),
      this.wc.on("session_update", (e, r) => {
        const { accounts: n, chainId: i } = r.params[0];
        (!this.accounts || (n && this.accounts !== n)) &&
          ((this.accounts = n), this.events.emit("accountsChanged", n)),
          (!this.chainId || (i && this.chainId !== i)) &&
            ((this.chainId = i), this.events.emit("chainChanged", i));
      });
  }
  async sendPayload(e) {
    this.wc = this.register(this.opts);
    try {
      const r = await this.wc.unsafeSend(e);
      return this.sanitizeResponse(r);
    } catch (r) {
      return this.onError(e, r.message);
    }
  }
  sanitizeResponse(e) {
    return typeof e.error < "u" && typeof e.error.code > "u"
      ? n4(e.id, e.error.message, e.error.data)
      : e;
  }
}
class cTe {
  constructor(e) {
    (this.events = new d$()),
      (this.rpc = {
        infuraId: e == null ? void 0 : e.infuraId,
        custom: e == null ? void 0 : e.rpc,
      }),
      (this.signer = new E9(new oTe(e)));
    const r =
      this.signer.connection.chainId || (e == null ? void 0 : e.chainId) || 1;
    (this.http = this.setHttpProvider(r)), this.registerEventListeners();
  }
  get connected() {
    return this.signer.connection.connected;
  }
  get connector() {
    return this.signer.connection.connector;
  }
  get accounts() {
    return this.signer.connection.accounts;
  }
  get chainId() {
    return this.signer.connection.chainId;
  }
  get rpcUrl() {
    var e;
    return (
      ((e = this.http) === null || e === void 0 ? void 0 : e.connection).url ||
      ""
    );
  }
  async request(e) {
    switch (e.method) {
      case "eth_requestAccounts":
        return await this.connect(), this.signer.connection.accounts;
      case "eth_accounts":
        return this.signer.connection.accounts;
      case "eth_chainId":
        return this.signer.connection.chainId;
    }
    if (p_e.includes(e.method)) return this.signer.request(e);
    if (typeof this.http > "u")
      throw new Error(
        `Cannot request JSON-RPC method (${e.method}) without provided rpc url`
      );
    return this.http.request(e);
  }
  sendAsync(e, r) {
    this.request(e)
      .then((n) => r(null, n))
      .catch((n) => r(n, void 0));
  }
  async enable() {
    return await this.request({
      method: "eth_requestAccounts",
    });
  }
  async connect() {
    this.signer.connection.connected || (await this.signer.connect());
  }
  async disconnect() {
    this.signer.connection.connected && (await this.signer.disconnect());
  }
  on(e, r) {
    this.events.on(e, r);
  }
  once(e, r) {
    this.events.once(e, r);
  }
  removeListener(e, r) {
    this.events.removeListener(e, r);
  }
  off(e, r) {
    this.events.off(e, r);
  }
  get isWalletConnect() {
    return !0;
  }
  registerEventListeners() {
    this.signer.connection.on("accountsChanged", (e) => {
      this.events.emit("accountsChanged", e);
    }),
      this.signer.connection.on("chainChanged", (e) => {
        (this.http = this.setHttpProvider(e)),
          this.events.emit("chainChanged", e);
      }),
      this.signer.on("disconnect", () => {
        this.events.emit("disconnect");
      });
  }
  setHttpProvider(e) {
    const r = B_e(e, this.rpc);
    return typeof r > "u" ? void 0 : new E9(new T6e(r));
  }
}
function lTe(t, e) {
  h$(t, e), e.add(t);
}
function uTe(t, e, r) {
  if (!e.has(t))
    throw new TypeError("attempted to get private field on non-instance");
  return r;
}
const fTe = /(rainbow)/i;
var Sy = new WeakMap(),
  YI = new WeakSet();
class dTe extends $v {
  constructor(e) {
    super(e),
      lTe(this, YI),
      Dt(this, "id", "walletConnect"),
      Dt(this, "name", "WalletConnect"),
      Dt(this, "ready", !0),
      ob(this, Sy, {
        writable: !0,
        value: void 0,
      }),
      Dt(this, "onAccountsChanged", (r) => {
        r.length === 0
          ? this.emit("disconnect")
          : this.emit("change", {
              account: oa.getAddress(r[0]),
            });
      }),
      Dt(this, "onChainChanged", (r) => {
        const n = $f(r),
          i = this.isChainUnsupported(n);
        this.emit("change", {
          chain: {
            id: n,
            unsupported: i,
          },
        });
      }),
      Dt(this, "onDisconnect", () => {
        this.emit("disconnect");
      });
  }
  async connect() {
    try {
      var e, r, n;
      const i = this.getProvider(!0);
      i.on("accountsChanged", this.onAccountsChanged),
        i.on("chainChanged", this.onChainChanged),
        i.on("disconnect", this.onDisconnect);
      const a = await i.enable(),
        s = oa.getAddress(a[0]),
        o = await this.getChainId(),
        c = this.isChainUnsupported(o),
        u =
          (e =
            (r = i.connector) === null ||
            r === void 0 ||
            (n = r.peerMeta) === null ||
            n === void 0
              ? void 0
              : n.name) !== null && e !== void 0
            ? e
            : "";
      return (
        fTe.test(u) && (this.switchChain = uTe(this, YI, hTe)),
        {
          account: s,
          chain: {
            id: o,
            unsupported: c,
          },
          provider: new kf(i),
        }
      );
    } catch (i) {
      throw /user closed modal/i.test(i.message) ? new Uf() : i;
    }
  }
  async disconnect() {
    const e = this.getProvider();
    await e.disconnect(),
      e.removeListener("accountsChanged", this.onAccountsChanged),
      e.removeListener("chainChanged", this.onChainChanged),
      e.removeListener("disconnect", this.onDisconnect),
      typeof localStorage < "u" && localStorage.removeItem("walletconnect");
  }
  async getAccount() {
    const r = this.getProvider().accounts;
    return oa.getAddress(r[0]);
  }
  async getChainId() {
    const e = this.getProvider();
    return $f(e.chainId);
  }
  getProvider(e) {
    return (
      (!Zl(this, Sy) || e) && cb(this, Sy, new cTe(this.options)), Zl(this, Sy)
    );
  }
  async getSigner() {
    const e = this.getProvider(),
      r = await this.getAccount();
    return new kf(e).getSigner(r);
  }
  async isAuthorized() {
    try {
      return !!(await this.getAccount());
    } catch {
      return !1;
    }
  }
}
async function hTe(t) {
  const e = this.getProvider(),
    r = oa.hexValue(t);
  try {
    return (
      await e.request({
        method: "wallet_switchEthereumChain",
        params: [
          {
            chainId: r,
          },
        ],
      }),
      [...this.chains, ...QE].find((i) => i.id === t)
    );
  } catch (n) {
    const i = typeof n == "string" ? n : n == null ? void 0 : n.message;
    throw /user rejected request/i.test(i) ? new Uf() : new YE();
  }
}
function pTe() {
  const t = qm();
  return Je(t), sme();
}
function B4() {
  return (
    (B4 = Object.assign
      ? Object.assign.bind()
      : function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var r = arguments[e];
            for (var n in r) ({}).hasOwnProperty.call(r, n) && (t[n] = r[n]);
          }
          return t;
        }),
    B4.apply(null, arguments)
  );
}
function QH(t) {
  var e = Object.create(null);
  return function (r) {
    return e[r] === void 0 && (e[r] = t(r)), e[r];
  };
}
var mTe =
    /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/,
  yTe = QH(function (t) {
    return (
      mTe.test(t) ||
      (t.charCodeAt(0) === 111 &&
        t.charCodeAt(1) === 110 &&
        t.charCodeAt(2) < 91)
    );
  }),
  gTe = !1;
function bTe(t) {
  if (t.sheet) return t.sheet;
  for (var e = 0; e < document.styleSheets.length; e++)
    if (document.styleSheets[e].ownerNode === t) return document.styleSheets[e];
}
function vTe(t) {
  var e = document.createElement("style");
  return (
    e.setAttribute("data-emotion", t.key),
    t.nonce !== void 0 && e.setAttribute("nonce", t.nonce),
    e.appendChild(document.createTextNode("")),
    e.setAttribute("data-s", ""),
    e
  );
}
var xTe = (function () {
    function t(r) {
      var n = this;
      (this._insertTag = function (i) {
        var a;
        n.tags.length === 0
          ? n.insertionPoint
            ? (a = n.insertionPoint.nextSibling)
            : n.prepend
            ? (a = n.container.firstChild)
            : (a = n.before)
          : (a = n.tags[n.tags.length - 1].nextSibling),
          n.container.insertBefore(i, a),
          n.tags.push(i);
      }),
        (this.isSpeedy = r.speedy === void 0 ? !gTe : r.speedy),
        (this.tags = []),
        (this.ctr = 0),
        (this.nonce = r.nonce),
        (this.key = r.key),
        (this.container = r.container),
        (this.prepend = r.prepend),
        (this.insertionPoint = r.insertionPoint),
        (this.before = null);
    }
    var e = t.prototype;
    return (
      (e.hydrate = function (n) {
        n.forEach(this._insertTag);
      }),
      (e.insert = function (n) {
        this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 &&
          this._insertTag(vTe(this));
        var i = this.tags[this.tags.length - 1];
        if (this.isSpeedy) {
          var a = bTe(i);
          try {
            a.insertRule(n, a.cssRules.length);
          } catch {}
        } else i.appendChild(document.createTextNode(n));
        this.ctr++;
      }),
      (e.flush = function () {
        this.tags.forEach(function (n) {
          var i;
          return (i = n.parentNode) == null ? void 0 : i.removeChild(n);
        }),
          (this.tags = []),
          (this.ctr = 0);
      }),
      t
    );
  })(),
  ai = "-ms-",
  _b = "-moz-",
  Jt = "-webkit-",
  YH = "comm",
  gC = "rule",
  bC = "decl",
  wTe = "@import",
  XH = "@keyframes",
  _Te = "@layer",
  ETe = Math.abs,
  Gx = String.fromCharCode,
  TTe = Object.assign;
function CTe(t, e) {
  return Hn(t, 0) ^ 45
    ? (((((((e << 2) ^ Hn(t, 0)) << 2) ^ Hn(t, 1)) << 2) ^ Hn(t, 2)) << 2) ^
        Hn(t, 3)
    : 0;
}
function ez(t) {
  return t.trim();
}
function ATe(t, e) {
  return (t = e.exec(t)) ? t[0] : t;
}
function Qt(t, e, r) {
  return t.replace(e, r);
}
function D4(t, e) {
  return t.indexOf(e);
}
function Hn(t, e) {
  return t.charCodeAt(e) | 0;
}
function gm(t, e, r) {
  return t.slice(e, r);
}
function $s(t) {
  return t.length;
}
function vC(t) {
  return t.length;
}
function My(t, e) {
  return e.push(t), t;
}
function kTe(t, e) {
  return t.map(e).join("");
}
var Zx = 1,
  id = 1,
  tz = 0,
  Zi = 0,
  dn = 0,
  $d = "";
function Jx(t, e, r, n, i, a, s) {
  return {
    value: t,
    root: e,
    parent: r,
    type: n,
    props: i,
    children: a,
    line: Zx,
    column: id,
    length: s,
    return: "",
  };
}
function fh(t, e) {
  return TTe(
    Jx("", null, null, "", null, null, 0),
    t,
    {
      length: -t.length,
    },
    e
  );
}
function STe() {
  return dn;
}
function MTe() {
  return (
    (dn = Zi > 0 ? Hn($d, --Zi) : 0), id--, dn === 10 && ((id = 1), Zx--), dn
  );
}
function pa() {
  return (
    (dn = Zi < tz ? Hn($d, Zi++) : 0), id++, dn === 10 && ((id = 1), Zx++), dn
  );
}
function ao() {
  return Hn($d, Zi);
}
function ag() {
  return Zi;
}
function E1(t, e) {
  return gm($d, t, e);
}
function bm(t) {
  switch (t) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function rz(t) {
  return (Zx = id = 1), (tz = $s(($d = t))), (Zi = 0), [];
}
function nz(t) {
  return ($d = ""), t;
}
function sg(t) {
  return ez(E1(Zi - 1, O4(t === 91 ? t + 2 : t === 40 ? t + 1 : t)));
}
function ITe(t) {
  for (; (dn = ao()) && dn < 33; ) pa();
  return bm(t) > 2 || bm(dn) > 3 ? "" : " ";
}
function RTe(t, e) {
  for (
    ;
    --e &&
    pa() &&
    !(dn < 48 || dn > 102 || (dn > 57 && dn < 65) || (dn > 70 && dn < 97));

  );
  return E1(t, ag() + (e < 6 && ao() == 32 && pa() == 32));
}
function O4(t) {
  for (; pa(); )
    switch (dn) {
      case t:
        return Zi;
      case 34:
      case 39:
        t !== 34 && t !== 39 && O4(dn);
        break;
      case 40:
        t === 41 && O4(t);
        break;
      case 92:
        pa();
        break;
    }
  return Zi;
}
function PTe(t, e) {
  for (; pa() && t + dn !== 57; ) if (t + dn === 84 && ao() === 47) break;
  return "/*" + E1(e, Zi - 1) + "*" + Gx(t === 47 ? t : pa());
}
function NTe(t) {
  for (; !bm(ao()); ) pa();
  return E1(t, Zi);
}
function BTe(t) {
  return nz(og("", null, null, null, [""], (t = rz(t)), 0, [0], t));
}
function og(t, e, r, n, i, a, s, o, c) {
  for (
    var u = 0,
      d = 0,
      m = s,
      v = 0,
      E = 0,
      A = 0,
      I = 1,
      b = 1,
      w = 1,
      S = 0,
      k = "",
      N = i,
      O = a,
      F = n,
      V = k;
    b;

  )
    switch (((A = S), (S = pa()))) {
      case 40:
        if (A != 108 && Hn(V, m - 1) == 58) {
          D4((V += Qt(sg(S), "&", "&\f")), "&\f") != -1 && (w = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        V += sg(S);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        V += ITe(A);
        break;
      case 92:
        V += RTe(ag() - 1, 7);
        continue;
      case 47:
        switch (ao()) {
          case 42:
          case 47:
            My(DTe(PTe(pa(), ag()), e, r), c);
            break;
          default:
            V += "/";
        }
        break;
      case 123 * I:
        o[u++] = $s(V) * w;
      case 125 * I:
      case 59:
      case 0:
        switch (S) {
          case 0:
          case 125:
            b = 0;
          case 59 + d:
            w == -1 && (V = Qt(V, /\f/g, "")),
              E > 0 &&
                $s(V) - m &&
                My(
                  E > 32
                    ? eR(V + ";", n, r, m - 1)
                    : eR(Qt(V, " ", "") + ";", n, r, m - 2),
                  c
                );
            break;
          case 59:
            V += ";";
          default:
            if (
              (My((F = XI(V, e, r, u, d, i, o, k, (N = []), (O = []), m)), a),
              S === 123)
            )
              if (d === 0) og(V, e, F, F, N, a, m, o, O);
              else
                switch (v === 99 && Hn(V, 3) === 110 ? 100 : v) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    og(
                      t,
                      F,
                      F,
                      n && My(XI(t, F, F, 0, 0, i, o, k, i, (N = []), m), O),
                      i,
                      O,
                      m,
                      o,
                      n ? N : O
                    );
                    break;
                  default:
                    og(V, F, F, F, [""], O, 0, o, O);
                }
        }
        (u = d = E = 0), (I = w = 1), (k = V = ""), (m = s);
        break;
      case 58:
        (m = 1 + $s(V)), (E = A);
      default:
        if (I < 1) {
          if (S == 123) --I;
          else if (S == 125 && I++ == 0 && MTe() == 125) continue;
        }
        switch (((V += Gx(S)), S * I)) {
          case 38:
            w = d > 0 ? 1 : ((V += "\f"), -1);
            break;
          case 44:
            (o[u++] = ($s(V) - 1) * w), (w = 1);
            break;
          case 64:
            ao() === 45 && (V += sg(pa())),
              (v = ao()),
              (d = m = $s((k = V += NTe(ag())))),
              S++;
            break;
          case 45:
            A === 45 && $s(V) == 2 && (I = 0);
        }
    }
  return a;
}
function XI(t, e, r, n, i, a, s, o, c, u, d) {
  for (
    var m = i - 1, v = i === 0 ? a : [""], E = vC(v), A = 0, I = 0, b = 0;
    A < n;
    ++A
  )
    for (var w = 0, S = gm(t, m + 1, (m = ETe((I = s[A])))), k = t; w < E; ++w)
      (k = ez(I > 0 ? v[w] + " " + S : Qt(S, /&\f/g, v[w]))) && (c[b++] = k);
  return Jx(t, e, r, i === 0 ? gC : o, c, u, d);
}
function DTe(t, e, r) {
  return Jx(t, e, r, YH, Gx(STe()), gm(t, 2, -2), 0);
}
function eR(t, e, r, n) {
  return Jx(t, e, r, bC, gm(t, 0, n), gm(t, n + 1, -1), n);
}
function cf(t, e) {
  for (var r = "", n = vC(t), i = 0; i < n; i++) r += e(t[i], i, t, e) || "";
  return r;
}
function OTe(t, e, r, n) {
  switch (t.type) {
    case _Te:
      if (t.children.length) break;
    case wTe:
    case bC:
      return (t.return = t.return || t.value);
    case YH:
      return "";
    case XH:
      return (t.return = t.value + "{" + cf(t.children, n) + "}");
    case gC:
      t.value = t.props.join(",");
  }
  return $s((r = cf(t.children, n)))
    ? (t.return = t.value + "{" + r + "}")
    : "";
}
function FTe(t) {
  var e = vC(t);
  return function (r, n, i, a) {
    for (var s = "", o = 0; o < e; o++) s += t[o](r, n, i, a) || "";
    return s;
  };
}
function LTe(t) {
  return function (e) {
    e.root || ((e = e.return) && t(e));
  };
}
var $Te = function (e, r, n) {
    for (
      var i = 0, a = 0;
      (i = a), (a = ao()), i === 38 && a === 12 && (r[n] = 1), !bm(a);

    )
      pa();
    return E1(e, Zi);
  },
  UTe = function (e, r) {
    var n = -1,
      i = 44;
    do
      switch (bm(i)) {
        case 0:
          i === 38 && ao() === 12 && (r[n] = 1), (e[n] += $Te(Zi - 1, r, n));
          break;
        case 2:
          e[n] += sg(i);
          break;
        case 4:
          if (i === 44) {
            (e[++n] = ao() === 58 ? "&\f" : ""), (r[n] = e[n].length);
            break;
          }
        default:
          e[n] += Gx(i);
      }
    while ((i = pa()));
    return e;
  },
  WTe = function (e, r) {
    return nz(UTe(rz(e), r));
  },
  tR = new WeakMap(),
  jTe = function (e) {
    if (!(e.type !== "rule" || !e.parent || e.length < 1)) {
      for (
        var r = e.value,
          n = e.parent,
          i = e.column === n.column && e.line === n.line;
        n.type !== "rule";

      )
        if (((n = n.parent), !n)) return;
      if (
        !(e.props.length === 1 && r.charCodeAt(0) !== 58 && !tR.get(n)) &&
        !i
      ) {
        tR.set(e, !0);
        for (
          var a = [], s = WTe(r, a), o = n.props, c = 0, u = 0;
          c < s.length;
          c++
        )
          for (var d = 0; d < o.length; d++, u++)
            e.props[u] = a[c] ? s[c].replace(/&\f/g, o[d]) : o[d] + " " + s[c];
      }
    }
  },
  HTe = function (e) {
    if (e.type === "decl") {
      var r = e.value;
      r.charCodeAt(0) === 108 &&
        r.charCodeAt(2) === 98 &&
        ((e.return = ""), (e.value = ""));
    }
  };
function iz(t, e) {
  switch (CTe(t, e)) {
    case 5103:
      return Jt + "print-" + t + t;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return Jt + t + t;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return Jt + t + _b + t + ai + t + t;
    case 6828:
    case 4268:
      return Jt + t + ai + t + t;
    case 6165:
      return Jt + t + ai + "flex-" + t + t;
    case 5187:
      return (
        Jt + t + Qt(t, /(\w+).+(:[^]+)/, Jt + "box-$1$2" + ai + "flex-$1$2") + t
      );
    case 5443:
      return Jt + t + ai + "flex-item-" + Qt(t, /flex-|-self/, "") + t;
    case 4675:
      return (
        Jt +
        t +
        ai +
        "flex-line-pack" +
        Qt(t, /align-content|flex-|-self/, "") +
        t
      );
    case 5548:
      return Jt + t + ai + Qt(t, "shrink", "negative") + t;
    case 5292:
      return Jt + t + ai + Qt(t, "basis", "preferred-size") + t;
    case 6060:
      return (
        Jt +
        "box-" +
        Qt(t, "-grow", "") +
        Jt +
        t +
        ai +
        Qt(t, "grow", "positive") +
        t
      );
    case 4554:
      return Jt + Qt(t, /([^-])(transform)/g, "$1" + Jt + "$2") + t;
    case 6187:
      return (
        Qt(
          Qt(Qt(t, /(zoom-|grab)/, Jt + "$1"), /(image-set)/, Jt + "$1"),
          t,
          ""
        ) + t
      );
    case 5495:
    case 3959:
      return Qt(t, /(image-set\([^]*)/, Jt + "$1$`$1");
    case 4968:
      return (
        Qt(
          Qt(t, /(.+:)(flex-)?(.*)/, Jt + "box-pack:$3" + ai + "flex-pack:$3"),
          /s.+-b[^;]+/,
          "justify"
        ) +
        Jt +
        t +
        t
      );
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return Qt(t, /(.+)-inline(.+)/, Jt + "$1$2") + t;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if ($s(t) - 1 - e > 6)
        switch (Hn(t, e + 1)) {
          case 109:
            if (Hn(t, e + 4) !== 45) break;
          case 102:
            return (
              Qt(
                t,
                /(.+:)(.+)-([^]+)/,
                "$1" +
                  Jt +
                  "$2-$3$1" +
                  _b +
                  (Hn(t, e + 3) == 108 ? "$3" : "$2-$3")
              ) + t
            );
          case 115:
            return ~D4(t, "stretch")
              ? iz(Qt(t, "stretch", "fill-available"), e) + t
              : t;
        }
      break;
    case 4949:
      if (Hn(t, e + 1) !== 115) break;
    case 6444:
      switch (Hn(t, $s(t) - 3 - (~D4(t, "!important") && 10))) {
        case 107:
          return Qt(t, ":", ":" + Jt) + t;
        case 101:
          return (
            Qt(
              t,
              /(.+:)([^;!]+)(;|!.+)?/,
              "$1" +
                Jt +
                (Hn(t, 14) === 45 ? "inline-" : "") +
                "box$3$1" +
                Jt +
                "$2$3$1" +
                ai +
                "$2box$3"
            ) + t
          );
      }
      break;
    case 5936:
      switch (Hn(t, e + 11)) {
        case 114:
          return Jt + t + ai + Qt(t, /[svh]\w+-[tblr]{2}/, "tb") + t;
        case 108:
          return Jt + t + ai + Qt(t, /[svh]\w+-[tblr]{2}/, "tb-rl") + t;
        case 45:
          return Jt + t + ai + Qt(t, /[svh]\w+-[tblr]{2}/, "lr") + t;
      }
      return Jt + t + ai + t + t;
  }
  return t;
}
var zTe = function (e, r, n, i) {
    if (e.length > -1 && !e.return)
      switch (e.type) {
        case bC:
          e.return = iz(e.value, e.length);
          break;
        case XH:
          return cf(
            [
              fh(e, {
                value: Qt(e.value, "@", "@" + Jt),
              }),
            ],
            i
          );
        case gC:
          if (e.length)
            return kTe(e.props, function (a) {
              switch (ATe(a, /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  return cf(
                    [
                      fh(e, {
                        props: [Qt(a, /:(read-\w+)/, ":" + _b + "$1")],
                      }),
                    ],
                    i
                  );
                case "::placeholder":
                  return cf(
                    [
                      fh(e, {
                        props: [Qt(a, /:(plac\w+)/, ":" + Jt + "input-$1")],
                      }),
                      fh(e, {
                        props: [Qt(a, /:(plac\w+)/, ":" + _b + "$1")],
                      }),
                      fh(e, {
                        props: [Qt(a, /:(plac\w+)/, ai + "input-$1")],
                      }),
                    ],
                    i
                  );
              }
              return "";
            });
      }
  },
  qTe = [zTe],
  VTe = function (e) {
    var r = e.key;
    if (r === "css") {
      var n = document.querySelectorAll("style[data-emotion]:not([data-s])");
      Array.prototype.forEach.call(n, function (I) {
        var b = I.getAttribute("data-emotion");
        b.indexOf(" ") !== -1 &&
          (document.head.appendChild(I), I.setAttribute("data-s", ""));
      });
    }
    var i = e.stylisPlugins || qTe,
      a = {},
      s,
      o = [];
    (s = e.container || document.head),
      Array.prototype.forEach.call(
        document.querySelectorAll('style[data-emotion^="' + r + ' "]'),
        function (I) {
          for (
            var b = I.getAttribute("data-emotion").split(" "), w = 1;
            w < b.length;
            w++
          )
            a[b[w]] = !0;
          o.push(I);
        }
      );
    var c,
      u = [jTe, HTe];
    {
      var d,
        m = [
          OTe,
          LTe(function (I) {
            d.insert(I);
          }),
        ],
        v = FTe(u.concat(i, m)),
        E = function (b) {
          return cf(BTe(b), v);
        };
      c = function (b, w, S, k) {
        (d = S),
          E(b ? b + "{" + w.styles + "}" : w.styles),
          k && (A.inserted[w.name] = !0);
      };
    }
    var A = {
      key: r,
      sheet: new xTe({
        key: r,
        container: s,
        nonce: e.nonce,
        speedy: e.speedy,
        prepend: e.prepend,
        insertionPoint: e.insertionPoint,
      }),
      nonce: e.nonce,
      inserted: a,
      registered: {},
      insert: c,
    };
    return A.sheet.hydrate(o), A;
  },
  az = {
    exports: {},
  },
  tr = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var On = typeof Symbol == "function" && Symbol.for,
  xC = On ? Symbol.for("react.element") : 60103,
  wC = On ? Symbol.for("react.portal") : 60106,
  Qx = On ? Symbol.for("react.fragment") : 60107,
  Yx = On ? Symbol.for("react.strict_mode") : 60108,
  Xx = On ? Symbol.for("react.profiler") : 60114,
  ew = On ? Symbol.for("react.provider") : 60109,
  tw = On ? Symbol.for("react.context") : 60110,
  _C = On ? Symbol.for("react.async_mode") : 60111,
  rw = On ? Symbol.for("react.concurrent_mode") : 60111,
  nw = On ? Symbol.for("react.forward_ref") : 60112,
  iw = On ? Symbol.for("react.suspense") : 60113,
  KTe = On ? Symbol.for("react.suspense_list") : 60120,
  aw = On ? Symbol.for("react.memo") : 60115,
  sw = On ? Symbol.for("react.lazy") : 60116,
  GTe = On ? Symbol.for("react.block") : 60121,
  ZTe = On ? Symbol.for("react.fundamental") : 60117,
  JTe = On ? Symbol.for("react.responder") : 60118,
  QTe = On ? Symbol.for("react.scope") : 60119;
function _a(t) {
  if (typeof t == "object" && t !== null) {
    var e = t.$$typeof;
    switch (e) {
      case xC:
        switch (((t = t.type), t)) {
          case _C:
          case rw:
          case Qx:
          case Xx:
          case Yx:
          case iw:
            return t;
          default:
            switch (((t = t && t.$$typeof), t)) {
              case tw:
              case nw:
              case sw:
              case aw:
              case ew:
                return t;
              default:
                return e;
            }
        }
      case wC:
        return e;
    }
  }
}
function sz(t) {
  return _a(t) === rw;
}
tr.AsyncMode = _C;
tr.ConcurrentMode = rw;
tr.ContextConsumer = tw;
tr.ContextProvider = ew;
tr.Element = xC;
tr.ForwardRef = nw;
tr.Fragment = Qx;
tr.Lazy = sw;
tr.Memo = aw;
tr.Portal = wC;
tr.Profiler = Xx;
tr.StrictMode = Yx;
tr.Suspense = iw;
tr.isAsyncMode = function (t) {
  return sz(t) || _a(t) === _C;
};
tr.isConcurrentMode = sz;
tr.isContextConsumer = function (t) {
  return _a(t) === tw;
};
tr.isContextProvider = function (t) {
  return _a(t) === ew;
};
tr.isElement = function (t) {
  return typeof t == "object" && t !== null && t.$$typeof === xC;
};
tr.isForwardRef = function (t) {
  return _a(t) === nw;
};
tr.isFragment = function (t) {
  return _a(t) === Qx;
};
tr.isLazy = function (t) {
  return _a(t) === sw;
};
tr.isMemo = function (t) {
  return _a(t) === aw;
};
tr.isPortal = function (t) {
  return _a(t) === wC;
};
tr.isProfiler = function (t) {
  return _a(t) === Xx;
};
tr.isStrictMode = function (t) {
  return _a(t) === Yx;
};
tr.isSuspense = function (t) {
  return _a(t) === iw;
};
tr.isValidElementType = function (t) {
  return (
    typeof t == "string" ||
    typeof t == "function" ||
    t === Qx ||
    t === rw ||
    t === Xx ||
    t === Yx ||
    t === iw ||
    t === KTe ||
    (typeof t == "object" &&
      t !== null &&
      (t.$$typeof === sw ||
        t.$$typeof === aw ||
        t.$$typeof === ew ||
        t.$$typeof === tw ||
        t.$$typeof === nw ||
        t.$$typeof === ZTe ||
        t.$$typeof === JTe ||
        t.$$typeof === QTe ||
        t.$$typeof === GTe))
  );
};
tr.typeOf = _a;
az.exports = tr;
var YTe = az.exports,
  oz = YTe,
  XTe = {
    $$typeof: !0,
    render: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0,
  },
  eCe = {
    $$typeof: !0,
    compare: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0,
    type: !0,
  },
  cz = {};
cz[oz.ForwardRef] = XTe;
cz[oz.Memo] = eCe;
var tCe = !0;
function rCe(t, e, r) {
  var n = "";
  return (
    r.split(" ").forEach(function (i) {
      t[i] !== void 0 ? e.push(t[i] + ";") : i && (n += i + " ");
    }),
    n
  );
}
var lz = function (e, r, n) {
    var i = e.key + "-" + r.name;
    (n === !1 || tCe === !1) &&
      e.registered[i] === void 0 &&
      (e.registered[i] = r.styles);
  },
  nCe = function (e, r, n) {
    lz(e, r, n);
    var i = e.key + "-" + r.name;
    if (e.inserted[r.name] === void 0) {
      var a = r;
      do e.insert(r === a ? "." + i : "", a, e.sheet, !0), (a = a.next);
      while (a !== void 0);
    }
  };
function iCe(t) {
  for (var e = 0, r, n = 0, i = t.length; i >= 4; ++n, i -= 4)
    (r =
      (t.charCodeAt(n) & 255) |
      ((t.charCodeAt(++n) & 255) << 8) |
      ((t.charCodeAt(++n) & 255) << 16) |
      ((t.charCodeAt(++n) & 255) << 24)),
      (r = (r & 65535) * 1540483477 + (((r >>> 16) * 59797) << 16)),
      (r ^= r >>> 24),
      (e =
        ((r & 65535) * 1540483477 + (((r >>> 16) * 59797) << 16)) ^
        ((e & 65535) * 1540483477 + (((e >>> 16) * 59797) << 16)));
  switch (i) {
    case 3:
      e ^= (t.charCodeAt(n + 2) & 255) << 16;
    case 2:
      e ^= (t.charCodeAt(n + 1) & 255) << 8;
    case 1:
      (e ^= t.charCodeAt(n) & 255),
        (e = (e & 65535) * 1540483477 + (((e >>> 16) * 59797) << 16));
  }
  return (
    (e ^= e >>> 13),
    (e = (e & 65535) * 1540483477 + (((e >>> 16) * 59797) << 16)),
    ((e ^ (e >>> 15)) >>> 0).toString(36)
  );
}
var aCe = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    scale: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1,
  },
  sCe = !1,
  oCe = /[A-Z]|^ms/g,
  cCe = /_EMO_([^_]+?)_([^]*?)_EMO_/g,
  uz = function (e) {
    return e.charCodeAt(1) === 45;
  },
  rR = function (e) {
    return e != null && typeof e != "boolean";
  },
  W5 = QH(function (t) {
    return uz(t) ? t : t.replace(oCe, "-$&").toLowerCase();
  }),
  nR = function (e, r) {
    switch (e) {
      case "animation":
      case "animationName":
        if (typeof r == "string")
          return r.replace(cCe, function (n, i, a) {
            return (
              (Us = {
                name: i,
                styles: a,
                next: Us,
              }),
              i
            );
          });
    }
    return aCe[e] !== 1 && !uz(e) && typeof r == "number" && r !== 0
      ? r + "px"
      : r;
  },
  lCe =
    "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function vm(t, e, r) {
  if (r == null) return "";
  var n = r;
  if (n.__emotion_styles !== void 0) return n;
  switch (typeof r) {
    case "boolean":
      return "";
    case "object": {
      var i = r;
      if (i.anim === 1)
        return (
          (Us = {
            name: i.name,
            styles: i.styles,
            next: Us,
          }),
          i.name
        );
      var a = r;
      if (a.styles !== void 0) {
        var s = a.next;
        if (s !== void 0)
          for (; s !== void 0; )
            (Us = {
              name: s.name,
              styles: s.styles,
              next: Us,
            }),
              (s = s.next);
        var o = a.styles + ";";
        return o;
      }
      return uCe(t, e, r);
    }
    case "function": {
      if (t !== void 0) {
        var c = Us,
          u = r(t);
        return (Us = c), vm(t, e, u);
      }
      break;
    }
  }
  var d = r;
  if (e == null) return d;
  var m = e[d];
  return m !== void 0 ? m : d;
}
function uCe(t, e, r) {
  var n = "";
  if (Array.isArray(r))
    for (var i = 0; i < r.length; i++) n += vm(t, e, r[i]) + ";";
  else
    for (var a in r) {
      var s = r[a];
      if (typeof s != "object") {
        var o = s;
        e != null && e[o] !== void 0
          ? (n += a + "{" + e[o] + "}")
          : rR(o) && (n += W5(a) + ":" + nR(a, o) + ";");
      } else {
        if (a === "NO_COMPONENT_SELECTOR" && sCe) throw new Error(lCe);
        if (
          Array.isArray(s) &&
          typeof s[0] == "string" &&
          (e == null || e[s[0]] === void 0)
        )
          for (var c = 0; c < s.length; c++)
            rR(s[c]) && (n += W5(a) + ":" + nR(a, s[c]) + ";");
        else {
          var u = vm(t, e, s);
          switch (a) {
            case "animation":
            case "animationName": {
              n += W5(a) + ":" + u + ";";
              break;
            }
            default:
              n += a + "{" + u + "}";
          }
        }
      }
    }
  return n;
}
var iR = /label:\s*([^\s;{]+)\s*(;|$)/g,
  Us;
function fz(t, e, r) {
  if (
    t.length === 1 &&
    typeof t[0] == "object" &&
    t[0] !== null &&
    t[0].styles !== void 0
  )
    return t[0];
  var n = !0,
    i = "";
  Us = void 0;
  var a = t[0];
  if (a == null || a.raw === void 0) (n = !1), (i += vm(r, e, a));
  else {
    var s = a;
    i += s[0];
  }
  for (var o = 1; o < t.length; o++)
    if (((i += vm(r, e, t[o])), n)) {
      var c = a;
      i += c[o];
    }
  iR.lastIndex = 0;
  for (var u = "", d; (d = iR.exec(i)) !== null; ) u += "-" + d[1];
  var m = iCe(i) + u;
  return {
    name: m,
    styles: i,
    next: Us,
  };
}
var fCe = function (e) {
    return e();
  },
  dCe = J5.useInsertionEffect ? J5.useInsertionEffect : !1,
  hCe = dCe || fCe,
  dz = ye.createContext(
    typeof HTMLElement < "u"
      ? VTe({
          key: "css",
        })
      : null
  );
dz.Provider;
var pCe = function (e) {
    return ye.forwardRef(function (r, n) {
      var i = ye.useContext(dz);
      return e(r, i, n);
    });
  },
  mCe = ye.createContext({});
function yCe() {
  for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)
    e[r] = arguments[r];
  return fz(e);
}
var gCe = function () {
    var e = yCe.apply(void 0, arguments),
      r = "animation-" + e.name;
    return {
      name: r,
      styles: "@keyframes " + r + "{" + e.styles + "}",
      anim: 1,
      toString: function () {
        return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
      },
    };
  },
  bCe = yTe,
  vCe = function (e) {
    return e !== "theme";
  },
  aR = function (e) {
    return typeof e == "string" && e.charCodeAt(0) > 96 ? bCe : vCe;
  },
  sR = function (e, r, n) {
    var i;
    if (r) {
      var a = r.shouldForwardProp;
      i =
        e.__emotion_forwardProp && a
          ? function (s) {
              return e.__emotion_forwardProp(s) && a(s);
            }
          : a;
    }
    return typeof i != "function" && n && (i = e.__emotion_forwardProp), i;
  },
  xCe = !1,
  wCe = function (e) {
    var r = e.cache,
      n = e.serialized,
      i = e.isStringTag;
    return (
      lz(r, n, i),
      hCe(function () {
        return nCe(r, n, i);
      }),
      null
    );
  },
  _Ce = function t(e, r) {
    var n = e.__emotion_real === e,
      i = (n && e.__emotion_base) || e,
      a,
      s;
    r !== void 0 && ((a = r.label), (s = r.target));
    var o = sR(e, r, n),
      c = o || aR(i),
      u = !c("as");
    return function () {
      var d = arguments,
        m =
          n && e.__emotion_styles !== void 0 ? e.__emotion_styles.slice(0) : [];
      if (
        (a !== void 0 && m.push("label:" + a + ";"),
        d[0] == null || d[0].raw === void 0)
      )
        m.push.apply(m, d);
      else {
        m.push(d[0][0]);
        for (var v = d.length, E = 1; E < v; E++) m.push(d[E], d[0][E]);
      }
      var A = pCe(function (I, b, w) {
        var S = (u && I.as) || i,
          k = "",
          N = [],
          O = I;
        if (I.theme == null) {
          O = {};
          for (var F in I) O[F] = I[F];
          O.theme = ye.useContext(mCe);
        }
        typeof I.className == "string"
          ? (k = rCe(b.registered, N, I.className))
          : I.className != null && (k = I.className + " ");
        var V = fz(m.concat(N), b.registered, O);
        (k += b.key + "-" + V.name), s !== void 0 && (k += " " + s);
        var j = u && o === void 0 ? aR(S) : c,
          X = {};
        for (var C in I) (u && C === "as") || (j(C) && (X[C] = I[C]));
        return (
          (X.className = k),
          w && (X.ref = w),
          ye.createElement(
            ye.Fragment,
            null,
            ye.createElement(wCe, {
              cache: b,
              serialized: V,
              isStringTag: typeof S == "string",
            }),
            ye.createElement(S, X)
          )
        );
      });
      return (
        (A.displayName =
          a !== void 0
            ? a
            : "Styled(" +
              (typeof i == "string"
                ? i
                : i.displayName || i.name || "Component") +
              ")"),
        (A.defaultProps = e.defaultProps),
        (A.__emotion_real = A),
        (A.__emotion_base = i),
        (A.__emotion_styles = m),
        (A.__emotion_forwardProp = o),
        Object.defineProperty(A, "toString", {
          value: function () {
            return s === void 0 && xCe ? "NO_COMPONENT_SELECTOR" : "." + s;
          },
        }),
        (A.withComponent = function (I, b) {
          return t(
            I,
            B4({}, r, b, {
              shouldForwardProp: sR(A, b, !0),
            })
          ).apply(void 0, m);
        }),
        A
      );
    };
  },
  ECe = [
    "a",
    "abbr",
    "address",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "base",
    "bdi",
    "bdo",
    "big",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "col",
    "colgroup",
    "data",
    "datalist",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "div",
    "dl",
    "dt",
    "em",
    "embed",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "keygen",
    "label",
    "legend",
    "li",
    "link",
    "main",
    "map",
    "mark",
    "marquee",
    "menu",
    "menuitem",
    "meta",
    "meter",
    "nav",
    "noscript",
    "object",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "param",
    "picture",
    "pre",
    "progress",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "script",
    "section",
    "select",
    "small",
    "source",
    "span",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "title",
    "tr",
    "track",
    "u",
    "ul",
    "var",
    "video",
    "wbr",
    "circle",
    "clipPath",
    "defs",
    "ellipse",
    "foreignObject",
    "g",
    "image",
    "line",
    "linearGradient",
    "mask",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialGradient",
    "rect",
    "stop",
    "svg",
    "text",
    "tspan",
  ],
  Ts = _Ce.bind();
ECe.forEach(function (t) {
  Ts[t] = Ts(t);
});
var hz = {
    exports: {},
  },
  TCe = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50],
  },
  pz = {
    exports: {},
  },
  CCe = function (e) {
    return !e || typeof e == "string"
      ? !1
      : e instanceof Array ||
          Array.isArray(e) ||
          (e.length >= 0 &&
            (e.splice instanceof Function ||
              (Object.getOwnPropertyDescriptor(e, e.length - 1) &&
                e.constructor.name !== "String")));
  },
  ACe = CCe,
  kCe = Array.prototype.concat,
  SCe = Array.prototype.slice,
  oR = (pz.exports = function (e) {
    for (var r = [], n = 0, i = e.length; n < i; n++) {
      var a = e[n];
      ACe(a) ? (r = kCe.call(r, SCe.call(a))) : r.push(a);
    }
    return r;
  });
oR.wrap = function (t) {
  return function () {
    return t(oR(arguments));
  };
};
var MCe = pz.exports,
  Xh = TCe,
  T1 = MCe,
  mz = Object.hasOwnProperty,
  yz = Object.create(null);
for (var j5 in Xh) mz.call(Xh, j5) && (yz[Xh[j5]] = j5);
var la = (hz.exports = {
  to: {},
  get: {},
});
la.get = function (t) {
  var e = t.substring(0, 3).toLowerCase(),
    r,
    n;
  switch (e) {
    case "hsl":
      (r = la.get.hsl(t)), (n = "hsl");
      break;
    case "hwb":
      (r = la.get.hwb(t)), (n = "hwb");
      break;
    default:
      (r = la.get.rgb(t)), (n = "rgb");
      break;
  }
  return r
    ? {
        model: n,
        value: r,
      }
    : null;
};
la.get.rgb = function (t) {
  if (!t) return null;
  var e = /^#([a-f0-9]{3,4})$/i,
    r = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i,
    n =
      /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/,
    i =
      /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/,
    a = /^(\w+)$/,
    s = [0, 0, 0, 1],
    o,
    c,
    u;
  if ((o = t.match(r))) {
    for (u = o[2], o = o[1], c = 0; c < 3; c++) {
      var d = c * 2;
      s[c] = parseInt(o.slice(d, d + 2), 16);
    }
    u && (s[3] = parseInt(u, 16) / 255);
  } else if ((o = t.match(e))) {
    for (o = o[1], u = o[3], c = 0; c < 3; c++)
      s[c] = parseInt(o[c] + o[c], 16);
    u && (s[3] = parseInt(u + u, 16) / 255);
  } else if ((o = t.match(n))) {
    for (c = 0; c < 3; c++) s[c] = parseInt(o[c + 1], 0);
    o[4] &&
      (o[5] ? (s[3] = parseFloat(o[4]) * 0.01) : (s[3] = parseFloat(o[4])));
  } else if ((o = t.match(i))) {
    for (c = 0; c < 3; c++) s[c] = Math.round(parseFloat(o[c + 1]) * 2.55);
    o[4] &&
      (o[5] ? (s[3] = parseFloat(o[4]) * 0.01) : (s[3] = parseFloat(o[4])));
  } else
    return (o = t.match(a))
      ? o[1] === "transparent"
        ? [0, 0, 0, 0]
        : mz.call(Xh, o[1])
        ? ((s = Xh[o[1]]), (s[3] = 1), s)
        : null
      : null;
  for (c = 0; c < 3; c++) s[c] = Kc(s[c], 0, 255);
  return (s[3] = Kc(s[3], 0, 1)), s;
};
la.get.hsl = function (t) {
  if (!t) return null;
  var e =
      /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/,
    r = t.match(e);
  if (r) {
    var n = parseFloat(r[4]),
      i = ((parseFloat(r[1]) % 360) + 360) % 360,
      a = Kc(parseFloat(r[2]), 0, 100),
      s = Kc(parseFloat(r[3]), 0, 100),
      o = Kc(isNaN(n) ? 1 : n, 0, 1);
    return [i, a, s, o];
  }
  return null;
};
la.get.hwb = function (t) {
  if (!t) return null;
  var e =
      /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/,
    r = t.match(e);
  if (r) {
    var n = parseFloat(r[4]),
      i = ((parseFloat(r[1]) % 360) + 360) % 360,
      a = Kc(parseFloat(r[2]), 0, 100),
      s = Kc(parseFloat(r[3]), 0, 100),
      o = Kc(isNaN(n) ? 1 : n, 0, 1);
    return [i, a, s, o];
  }
  return null;
};
la.to.hex = function () {
  var t = T1(arguments);
  return (
    "#" +
    Iy(t[0]) +
    Iy(t[1]) +
    Iy(t[2]) +
    (t[3] < 1 ? Iy(Math.round(t[3] * 255)) : "")
  );
};
la.to.rgb = function () {
  var t = T1(arguments);
  return t.length < 4 || t[3] === 1
    ? "rgb(" +
        Math.round(t[0]) +
        ", " +
        Math.round(t[1]) +
        ", " +
        Math.round(t[2]) +
        ")"
    : "rgba(" +
        Math.round(t[0]) +
        ", " +
        Math.round(t[1]) +
        ", " +
        Math.round(t[2]) +
        ", " +
        t[3] +
        ")";
};
la.to.rgb.percent = function () {
  var t = T1(arguments),
    e = Math.round((t[0] / 255) * 100),
    r = Math.round((t[1] / 255) * 100),
    n = Math.round((t[2] / 255) * 100);
  return t.length < 4 || t[3] === 1
    ? "rgb(" + e + "%, " + r + "%, " + n + "%)"
    : "rgba(" + e + "%, " + r + "%, " + n + "%, " + t[3] + ")";
};
la.to.hsl = function () {
  var t = T1(arguments);
  return t.length < 4 || t[3] === 1
    ? "hsl(" + t[0] + ", " + t[1] + "%, " + t[2] + "%)"
    : "hsla(" + t[0] + ", " + t[1] + "%, " + t[2] + "%, " + t[3] + ")";
};
la.to.hwb = function () {
  var t = T1(arguments),
    e = "";
  return (
    t.length >= 4 && t[3] !== 1 && (e = ", " + t[3]),
    "hwb(" + t[0] + ", " + t[1] + "%, " + t[2] + "%" + e + ")"
  );
};
la.to.keyword = function (t) {
  return yz[t.slice(0, 3)];
};
function Kc(t, e, r) {
  return Math.min(Math.max(e, t), r);
}
function Iy(t) {
  var e = Math.round(t).toString(16).toUpperCase();
  return e.length < 2 ? "0" + e : e;
}
var ICe = hz.exports,
  RCe = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50],
  };
const xm = RCe,
  gz = {};
for (const t of Object.keys(xm)) gz[xm[t]] = t;
const ct = {
  rgb: {
    channels: 3,
    labels: "rgb",
  },
  hsl: {
    channels: 3,
    labels: "hsl",
  },
  hsv: {
    channels: 3,
    labels: "hsv",
  },
  hwb: {
    channels: 3,
    labels: "hwb",
  },
  cmyk: {
    channels: 4,
    labels: "cmyk",
  },
  xyz: {
    channels: 3,
    labels: "xyz",
  },
  lab: {
    channels: 3,
    labels: "lab",
  },
  lch: {
    channels: 3,
    labels: "lch",
  },
  hex: {
    channels: 1,
    labels: ["hex"],
  },
  keyword: {
    channels: 1,
    labels: ["keyword"],
  },
  ansi16: {
    channels: 1,
    labels: ["ansi16"],
  },
  ansi256: {
    channels: 1,
    labels: ["ansi256"],
  },
  hcg: {
    channels: 3,
    labels: ["h", "c", "g"],
  },
  apple: {
    channels: 3,
    labels: ["r16", "g16", "b16"],
  },
  gray: {
    channels: 1,
    labels: ["gray"],
  },
};
var bz = ct;
for (const t of Object.keys(ct)) {
  if (!("channels" in ct[t]))
    throw new Error("missing channels property: " + t);
  if (!("labels" in ct[t]))
    throw new Error("missing channel labels property: " + t);
  if (ct[t].labels.length !== ct[t].channels)
    throw new Error("channel and label counts mismatch: " + t);
  const { channels: e, labels: r } = ct[t];
  delete ct[t].channels,
    delete ct[t].labels,
    Object.defineProperty(ct[t], "channels", {
      value: e,
    }),
    Object.defineProperty(ct[t], "labels", {
      value: r,
    });
}
ct.rgb.hsl = function (t) {
  const e = t[0] / 255,
    r = t[1] / 255,
    n = t[2] / 255,
    i = Math.min(e, r, n),
    a = Math.max(e, r, n),
    s = a - i;
  let o, c;
  a === i
    ? (o = 0)
    : e === a
    ? (o = (r - n) / s)
    : r === a
    ? (o = 2 + (n - e) / s)
    : n === a && (o = 4 + (e - r) / s),
    (o = Math.min(o * 60, 360)),
    o < 0 && (o += 360);
  const u = (i + a) / 2;
  return (
    a === i ? (c = 0) : u <= 0.5 ? (c = s / (a + i)) : (c = s / (2 - a - i)),
    [o, c * 100, u * 100]
  );
};
ct.rgb.hsv = function (t) {
  let e, r, n, i, a;
  const s = t[0] / 255,
    o = t[1] / 255,
    c = t[2] / 255,
    u = Math.max(s, o, c),
    d = u - Math.min(s, o, c),
    m = function (v) {
      return (u - v) / 6 / d + 1 / 2;
    };
  return (
    d === 0
      ? ((i = 0), (a = 0))
      : ((a = d / u),
        (e = m(s)),
        (r = m(o)),
        (n = m(c)),
        s === u
          ? (i = n - r)
          : o === u
          ? (i = 1 / 3 + e - n)
          : c === u && (i = 2 / 3 + r - e),
        i < 0 ? (i += 1) : i > 1 && (i -= 1)),
    [i * 360, a * 100, u * 100]
  );
};
ct.rgb.hwb = function (t) {
  const e = t[0],
    r = t[1];
  let n = t[2];
  const i = ct.rgb.hsl(t)[0],
    a = (1 / 255) * Math.min(e, Math.min(r, n));
  return (
    (n = 1 - (1 / 255) * Math.max(e, Math.max(r, n))), [i, a * 100, n * 100]
  );
};
ct.rgb.cmyk = function (t) {
  const e = t[0] / 255,
    r = t[1] / 255,
    n = t[2] / 255,
    i = Math.min(1 - e, 1 - r, 1 - n),
    a = (1 - e - i) / (1 - i) || 0,
    s = (1 - r - i) / (1 - i) || 0,
    o = (1 - n - i) / (1 - i) || 0;
  return [a * 100, s * 100, o * 100, i * 100];
};
function PCe(t, e) {
  return (t[0] - e[0]) ** 2 + (t[1] - e[1]) ** 2 + (t[2] - e[2]) ** 2;
}
ct.rgb.keyword = function (t) {
  const e = gz[t];
  if (e) return e;
  let r = 1 / 0,
    n;
  for (const i of Object.keys(xm)) {
    const a = xm[i],
      s = PCe(t, a);
    s < r && ((r = s), (n = i));
  }
  return n;
};
ct.keyword.rgb = function (t) {
  return xm[t];
};
ct.rgb.xyz = function (t) {
  let e = t[0] / 255,
    r = t[1] / 255,
    n = t[2] / 255;
  (e = e > 0.04045 ? ((e + 0.055) / 1.055) ** 2.4 : e / 12.92),
    (r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92),
    (n = n > 0.04045 ? ((n + 0.055) / 1.055) ** 2.4 : n / 12.92);
  const i = e * 0.4124 + r * 0.3576 + n * 0.1805,
    a = e * 0.2126 + r * 0.7152 + n * 0.0722,
    s = e * 0.0193 + r * 0.1192 + n * 0.9505;
  return [i * 100, a * 100, s * 100];
};
ct.rgb.lab = function (t) {
  const e = ct.rgb.xyz(t);
  let r = e[0],
    n = e[1],
    i = e[2];
  (r /= 95.047),
    (n /= 100),
    (i /= 108.883),
    (r = r > 0.008856 ? r ** (1 / 3) : 7.787 * r + 16 / 116),
    (n = n > 0.008856 ? n ** (1 / 3) : 7.787 * n + 16 / 116),
    (i = i > 0.008856 ? i ** (1 / 3) : 7.787 * i + 16 / 116);
  const a = 116 * n - 16,
    s = 500 * (r - n),
    o = 200 * (n - i);
  return [a, s, o];
};
ct.hsl.rgb = function (t) {
  const e = t[0] / 360,
    r = t[1] / 100,
    n = t[2] / 100;
  let i, a, s;
  if (r === 0) return (s = n * 255), [s, s, s];
  n < 0.5 ? (i = n * (1 + r)) : (i = n + r - n * r);
  const o = 2 * n - i,
    c = [0, 0, 0];
  for (let u = 0; u < 3; u++)
    (a = e + (1 / 3) * -(u - 1)),
      a < 0 && a++,
      a > 1 && a--,
      6 * a < 1
        ? (s = o + (i - o) * 6 * a)
        : 2 * a < 1
        ? (s = i)
        : 3 * a < 2
        ? (s = o + (i - o) * (2 / 3 - a) * 6)
        : (s = o),
      (c[u] = s * 255);
  return c;
};
ct.hsl.hsv = function (t) {
  const e = t[0];
  let r = t[1] / 100,
    n = t[2] / 100,
    i = r;
  const a = Math.max(n, 0.01);
  (n *= 2), (r *= n <= 1 ? n : 2 - n), (i *= a <= 1 ? a : 2 - a);
  const s = (n + r) / 2,
    o = n === 0 ? (2 * i) / (a + i) : (2 * r) / (n + r);
  return [e, o * 100, s * 100];
};
ct.hsv.rgb = function (t) {
  const e = t[0] / 60,
    r = t[1] / 100;
  let n = t[2] / 100;
  const i = Math.floor(e) % 6,
    a = e - Math.floor(e),
    s = 255 * n * (1 - r),
    o = 255 * n * (1 - r * a),
    c = 255 * n * (1 - r * (1 - a));
  switch (((n *= 255), i)) {
    case 0:
      return [n, c, s];
    case 1:
      return [o, n, s];
    case 2:
      return [s, n, c];
    case 3:
      return [s, o, n];
    case 4:
      return [c, s, n];
    case 5:
      return [n, s, o];
  }
};
ct.hsv.hsl = function (t) {
  const e = t[0],
    r = t[1] / 100,
    n = t[2] / 100,
    i = Math.max(n, 0.01);
  let a, s;
  s = (2 - r) * n;
  const o = (2 - r) * i;
  return (
    (a = r * i),
    (a /= o <= 1 ? o : 2 - o),
    (a = a || 0),
    (s /= 2),
    [e, a * 100, s * 100]
  );
};
ct.hwb.rgb = function (t) {
  const e = t[0] / 360;
  let r = t[1] / 100,
    n = t[2] / 100;
  const i = r + n;
  let a;
  i > 1 && ((r /= i), (n /= i));
  const s = Math.floor(6 * e),
    o = 1 - n;
  (a = 6 * e - s), s & 1 && (a = 1 - a);
  const c = r + a * (o - r);
  let u, d, m;
  switch (s) {
    default:
    case 6:
    case 0:
      (u = o), (d = c), (m = r);
      break;
    case 1:
      (u = c), (d = o), (m = r);
      break;
    case 2:
      (u = r), (d = o), (m = c);
      break;
    case 3:
      (u = r), (d = c), (m = o);
      break;
    case 4:
      (u = c), (d = r), (m = o);
      break;
    case 5:
      (u = o), (d = r), (m = c);
      break;
  }
  return [u * 255, d * 255, m * 255];
};
ct.cmyk.rgb = function (t) {
  const e = t[0] / 100,
    r = t[1] / 100,
    n = t[2] / 100,
    i = t[3] / 100,
    a = 1 - Math.min(1, e * (1 - i) + i),
    s = 1 - Math.min(1, r * (1 - i) + i),
    o = 1 - Math.min(1, n * (1 - i) + i);
  return [a * 255, s * 255, o * 255];
};
ct.xyz.rgb = function (t) {
  const e = t[0] / 100,
    r = t[1] / 100,
    n = t[2] / 100;
  let i, a, s;
  return (
    (i = e * 3.2406 + r * -1.5372 + n * -0.4986),
    (a = e * -0.9689 + r * 1.8758 + n * 0.0415),
    (s = e * 0.0557 + r * -0.204 + n * 1.057),
    (i = i > 0.0031308 ? 1.055 * i ** (1 / 2.4) - 0.055 : i * 12.92),
    (a = a > 0.0031308 ? 1.055 * a ** (1 / 2.4) - 0.055 : a * 12.92),
    (s = s > 0.0031308 ? 1.055 * s ** (1 / 2.4) - 0.055 : s * 12.92),
    (i = Math.min(Math.max(0, i), 1)),
    (a = Math.min(Math.max(0, a), 1)),
    (s = Math.min(Math.max(0, s), 1)),
    [i * 255, a * 255, s * 255]
  );
};
ct.xyz.lab = function (t) {
  let e = t[0],
    r = t[1],
    n = t[2];
  (e /= 95.047),
    (r /= 100),
    (n /= 108.883),
    (e = e > 0.008856 ? e ** (1 / 3) : 7.787 * e + 16 / 116),
    (r = r > 0.008856 ? r ** (1 / 3) : 7.787 * r + 16 / 116),
    (n = n > 0.008856 ? n ** (1 / 3) : 7.787 * n + 16 / 116);
  const i = 116 * r - 16,
    a = 500 * (e - r),
    s = 200 * (r - n);
  return [i, a, s];
};
ct.lab.xyz = function (t) {
  const e = t[0],
    r = t[1],
    n = t[2];
  let i, a, s;
  (a = (e + 16) / 116), (i = r / 500 + a), (s = a - n / 200);
  const o = a ** 3,
    c = i ** 3,
    u = s ** 3;
  return (
    (a = o > 0.008856 ? o : (a - 16 / 116) / 7.787),
    (i = c > 0.008856 ? c : (i - 16 / 116) / 7.787),
    (s = u > 0.008856 ? u : (s - 16 / 116) / 7.787),
    (i *= 95.047),
    (a *= 100),
    (s *= 108.883),
    [i, a, s]
  );
};
ct.lab.lch = function (t) {
  const e = t[0],
    r = t[1],
    n = t[2];
  let i;
  (i = (Math.atan2(n, r) * 360) / 2 / Math.PI), i < 0 && (i += 360);
  const s = Math.sqrt(r * r + n * n);
  return [e, s, i];
};
ct.lch.lab = function (t) {
  const e = t[0],
    r = t[1],
    i = (t[2] / 360) * 2 * Math.PI,
    a = r * Math.cos(i),
    s = r * Math.sin(i);
  return [e, a, s];
};
ct.rgb.ansi16 = function (t, e = null) {
  const [r, n, i] = t;
  let a = e === null ? ct.rgb.hsv(t)[2] : e;
  if (((a = Math.round(a / 50)), a === 0)) return 30;
  let s =
    30 +
    ((Math.round(i / 255) << 2) |
      (Math.round(n / 255) << 1) |
      Math.round(r / 255));
  return a === 2 && (s += 60), s;
};
ct.hsv.ansi16 = function (t) {
  return ct.rgb.ansi16(ct.hsv.rgb(t), t[2]);
};
ct.rgb.ansi256 = function (t) {
  const e = t[0],
    r = t[1],
    n = t[2];
  return e === r && r === n
    ? e < 8
      ? 16
      : e > 248
      ? 231
      : Math.round(((e - 8) / 247) * 24) + 232
    : 16 +
        36 * Math.round((e / 255) * 5) +
        6 * Math.round((r / 255) * 5) +
        Math.round((n / 255) * 5);
};
ct.ansi16.rgb = function (t) {
  let e = t % 10;
  if (e === 0 || e === 7)
    return t > 50 && (e += 3.5), (e = (e / 10.5) * 255), [e, e, e];
  const r = (~~(t > 50) + 1) * 0.5,
    n = (e & 1) * r * 255,
    i = ((e >> 1) & 1) * r * 255,
    a = ((e >> 2) & 1) * r * 255;
  return [n, i, a];
};
ct.ansi256.rgb = function (t) {
  if (t >= 232) {
    const a = (t - 232) * 10 + 8;
    return [a, a, a];
  }
  t -= 16;
  let e;
  const r = (Math.floor(t / 36) / 5) * 255,
    n = (Math.floor((e = t % 36) / 6) / 5) * 255,
    i = ((e % 6) / 5) * 255;
  return [r, n, i];
};
ct.rgb.hex = function (t) {
  const r = (
    ((Math.round(t[0]) & 255) << 16) +
    ((Math.round(t[1]) & 255) << 8) +
    (Math.round(t[2]) & 255)
  )
    .toString(16)
    .toUpperCase();
  return "000000".substring(r.length) + r;
};
ct.hex.rgb = function (t) {
  const e = t.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
  if (!e) return [0, 0, 0];
  let r = e[0];
  e[0].length === 3 &&
    (r = r
      .split("")
      .map((o) => o + o)
      .join(""));
  const n = parseInt(r, 16),
    i = (n >> 16) & 255,
    a = (n >> 8) & 255,
    s = n & 255;
  return [i, a, s];
};
ct.rgb.hcg = function (t) {
  const e = t[0] / 255,
    r = t[1] / 255,
    n = t[2] / 255,
    i = Math.max(Math.max(e, r), n),
    a = Math.min(Math.min(e, r), n),
    s = i - a;
  let o, c;
  return (
    s < 1 ? (o = a / (1 - s)) : (o = 0),
    s <= 0
      ? (c = 0)
      : i === e
      ? (c = ((r - n) / s) % 6)
      : i === r
      ? (c = 2 + (n - e) / s)
      : (c = 4 + (e - r) / s),
    (c /= 6),
    (c %= 1),
    [c * 360, s * 100, o * 100]
  );
};
ct.hsl.hcg = function (t) {
  const e = t[1] / 100,
    r = t[2] / 100,
    n = r < 0.5 ? 2 * e * r : 2 * e * (1 - r);
  let i = 0;
  return n < 1 && (i = (r - 0.5 * n) / (1 - n)), [t[0], n * 100, i * 100];
};
ct.hsv.hcg = function (t) {
  const e = t[1] / 100,
    r = t[2] / 100,
    n = e * r;
  let i = 0;
  return n < 1 && (i = (r - n) / (1 - n)), [t[0], n * 100, i * 100];
};
ct.hcg.rgb = function (t) {
  const e = t[0] / 360,
    r = t[1] / 100,
    n = t[2] / 100;
  if (r === 0) return [n * 255, n * 255, n * 255];
  const i = [0, 0, 0],
    a = (e % 1) * 6,
    s = a % 1,
    o = 1 - s;
  let c = 0;
  switch (Math.floor(a)) {
    case 0:
      (i[0] = 1), (i[1] = s), (i[2] = 0);
      break;
    case 1:
      (i[0] = o), (i[1] = 1), (i[2] = 0);
      break;
    case 2:
      (i[0] = 0), (i[1] = 1), (i[2] = s);
      break;
    case 3:
      (i[0] = 0), (i[1] = o), (i[2] = 1);
      break;
    case 4:
      (i[0] = s), (i[1] = 0), (i[2] = 1);
      break;
    default:
      (i[0] = 1), (i[1] = 0), (i[2] = o);
  }
  return (
    (c = (1 - r) * n),
    [(r * i[0] + c) * 255, (r * i[1] + c) * 255, (r * i[2] + c) * 255]
  );
};
ct.hcg.hsv = function (t) {
  const e = t[1] / 100,
    r = t[2] / 100,
    n = e + r * (1 - e);
  let i = 0;
  return n > 0 && (i = e / n), [t[0], i * 100, n * 100];
};
ct.hcg.hsl = function (t) {
  const e = t[1] / 100,
    n = (t[2] / 100) * (1 - e) + 0.5 * e;
  let i = 0;
  return (
    n > 0 && n < 0.5
      ? (i = e / (2 * n))
      : n >= 0.5 && n < 1 && (i = e / (2 * (1 - n))),
    [t[0], i * 100, n * 100]
  );
};
ct.hcg.hwb = function (t) {
  const e = t[1] / 100,
    r = t[2] / 100,
    n = e + r * (1 - e);
  return [t[0], (n - e) * 100, (1 - n) * 100];
};
ct.hwb.hcg = function (t) {
  const e = t[1] / 100,
    n = 1 - t[2] / 100,
    i = n - e;
  let a = 0;
  return i < 1 && (a = (n - i) / (1 - i)), [t[0], i * 100, a * 100];
};
ct.apple.rgb = function (t) {
  return [(t[0] / 65535) * 255, (t[1] / 65535) * 255, (t[2] / 65535) * 255];
};
ct.rgb.apple = function (t) {
  return [(t[0] / 255) * 65535, (t[1] / 255) * 65535, (t[2] / 255) * 65535];
};
ct.gray.rgb = function (t) {
  return [(t[0] / 100) * 255, (t[0] / 100) * 255, (t[0] / 100) * 255];
};
ct.gray.hsl = function (t) {
  return [0, 0, t[0]];
};
ct.gray.hsv = ct.gray.hsl;
ct.gray.hwb = function (t) {
  return [0, 100, t[0]];
};
ct.gray.cmyk = function (t) {
  return [0, 0, 0, t[0]];
};
ct.gray.lab = function (t) {
  return [t[0], 0, 0];
};
ct.gray.hex = function (t) {
  const e = Math.round((t[0] / 100) * 255) & 255,
    n = ((e << 16) + (e << 8) + e).toString(16).toUpperCase();
  return "000000".substring(n.length) + n;
};
ct.rgb.gray = function (t) {
  return [((t[0] + t[1] + t[2]) / 3 / 255) * 100];
};
const Eb = bz;
function NCe() {
  const t = {},
    e = Object.keys(Eb);
  for (let r = e.length, n = 0; n < r; n++)
    t[e[n]] = {
      distance: -1,
      parent: null,
    };
  return t;
}
function BCe(t) {
  const e = NCe(),
    r = [t];
  for (e[t].distance = 0; r.length; ) {
    const n = r.pop(),
      i = Object.keys(Eb[n]);
    for (let a = i.length, s = 0; s < a; s++) {
      const o = i[s],
        c = e[o];
      c.distance === -1 &&
        ((c.distance = e[n].distance + 1), (c.parent = n), r.unshift(o));
    }
  }
  return e;
}
function DCe(t, e) {
  return function (r) {
    return e(t(r));
  };
}
function OCe(t, e) {
  const r = [e[t].parent, t];
  let n = Eb[e[t].parent][t],
    i = e[t].parent;
  for (; e[i].parent; )
    r.unshift(e[i].parent), (n = DCe(Eb[e[i].parent][i], n)), (i = e[i].parent);
  return (n.conversion = r), n;
}
var FCe = function (t) {
  const e = BCe(t),
    r = {},
    n = Object.keys(e);
  for (let i = n.length, a = 0; a < i; a++) {
    const s = n[a];
    e[s].parent !== null && (r[s] = OCe(s, e));
  }
  return r;
};
const F4 = bz,
  LCe = FCe,
  y0 = {},
  $Ce = Object.keys(F4);
function UCe(t) {
  const e = function (...r) {
    const n = r[0];
    return n == null ? n : (n.length > 1 && (r = n), t(r));
  };
  return "conversion" in t && (e.conversion = t.conversion), e;
}
function WCe(t) {
  const e = function (...r) {
    const n = r[0];
    if (n == null) return n;
    n.length > 1 && (r = n);
    const i = t(r);
    if (typeof i == "object")
      for (let a = i.length, s = 0; s < a; s++) i[s] = Math.round(i[s]);
    return i;
  };
  return "conversion" in t && (e.conversion = t.conversion), e;
}
$Ce.forEach((t) => {
  (y0[t] = {}),
    Object.defineProperty(y0[t], "channels", {
      value: F4[t].channels,
    }),
    Object.defineProperty(y0[t], "labels", {
      value: F4[t].labels,
    });
  const e = LCe(t);
  Object.keys(e).forEach((n) => {
    const i = e[n];
    (y0[t][n] = WCe(i)), (y0[t][n].raw = UCe(i));
  });
});
var jCe = y0;
const g0 = ICe,
  aa = jCe,
  vz = ["keyword", "gray", "hex"],
  L4 = {};
for (const t of Object.keys(aa)) L4[[...aa[t].labels].sort().join("")] = t;
const Tb = {};
function Rn(t, e) {
  if (!(this instanceof Rn)) return new Rn(t, e);
  if ((e && e in vz && (e = null), e && !(e in aa)))
    throw new Error("Unknown model: " + e);
  let r, n;
  if (t == null)
    (this.model = "rgb"), (this.color = [0, 0, 0]), (this.valpha = 1);
  else if (t instanceof Rn)
    (this.model = t.model),
      (this.color = [...t.color]),
      (this.valpha = t.valpha);
  else if (typeof t == "string") {
    const i = g0.get(t);
    if (i === null) throw new Error("Unable to parse color from string: " + t);
    (this.model = i.model),
      (n = aa[this.model].channels),
      (this.color = i.value.slice(0, n)),
      (this.valpha = typeof i.value[n] == "number" ? i.value[n] : 1);
  } else if (t.length > 0) {
    (this.model = e || "rgb"), (n = aa[this.model].channels);
    const i = Array.prototype.slice.call(t, 0, n);
    (this.color = $4(i, n)), (this.valpha = typeof t[n] == "number" ? t[n] : 1);
  } else if (typeof t == "number")
    (this.model = "rgb"),
      (this.color = [(t >> 16) & 255, (t >> 8) & 255, t & 255]),
      (this.valpha = 1);
  else {
    this.valpha = 1;
    const i = Object.keys(t);
    "alpha" in t &&
      (i.splice(i.indexOf("alpha"), 1),
      (this.valpha = typeof t.alpha == "number" ? t.alpha : 0));
    const a = i.sort().join("");
    if (!(a in L4))
      throw new Error(
        "Unable to parse color from object: " + JSON.stringify(t)
      );
    this.model = L4[a];
    const { labels: s } = aa[this.model],
      o = [];
    for (r = 0; r < s.length; r++) o.push(t[s[r]]);
    this.color = $4(o);
  }
  if (Tb[this.model])
    for (n = aa[this.model].channels, r = 0; r < n; r++) {
      const i = Tb[this.model][r];
      i && (this.color[r] = i(this.color[r]));
    }
  (this.valpha = Math.max(0, Math.min(1, this.valpha))),
    Object.freeze && Object.freeze(this);
}
Rn.prototype = {
  toString() {
    return this.string();
  },
  toJSON() {
    return this[this.model]();
  },
  string(t) {
    let e = this.model in g0.to ? this : this.rgb();
    e = e.round(typeof t == "number" ? t : 1);
    const r = e.valpha === 1 ? e.color : [...e.color, this.valpha];
    return g0.to[e.model](r);
  },
  percentString(t) {
    const e = this.rgb().round(typeof t == "number" ? t : 1),
      r = e.valpha === 1 ? e.color : [...e.color, this.valpha];
    return g0.to.rgb.percent(r);
  },
  array() {
    return this.valpha === 1 ? [...this.color] : [...this.color, this.valpha];
  },
  object() {
    const t = {},
      { channels: e } = aa[this.model],
      { labels: r } = aa[this.model];
    for (let n = 0; n < e; n++) t[r[n]] = this.color[n];
    return this.valpha !== 1 && (t.alpha = this.valpha), t;
  },
  unitArray() {
    const t = this.rgb().color;
    return (
      (t[0] /= 255),
      (t[1] /= 255),
      (t[2] /= 255),
      this.valpha !== 1 && t.push(this.valpha),
      t
    );
  },
  unitObject() {
    const t = this.rgb().object();
    return (
      (t.r /= 255),
      (t.g /= 255),
      (t.b /= 255),
      this.valpha !== 1 && (t.alpha = this.valpha),
      t
    );
  },
  round(t) {
    return (
      (t = Math.max(t || 0, 0)),
      new Rn([...this.color.map(zCe(t)), this.valpha], this.model)
    );
  },
  alpha(t) {
    return t !== void 0
      ? new Rn([...this.color, Math.max(0, Math.min(1, t))], this.model)
      : this.valpha;
  },
  red: Yr("rgb", 0, xn(255)),
  green: Yr("rgb", 1, xn(255)),
  blue: Yr("rgb", 2, xn(255)),
  hue: Yr(
    ["hsl", "hsv", "hsl", "hwb", "hcg"],
    0,
    (t) => ((t % 360) + 360) % 360
  ),
  saturationl: Yr("hsl", 1, xn(100)),
  lightness: Yr("hsl", 2, xn(100)),
  saturationv: Yr("hsv", 1, xn(100)),
  value: Yr("hsv", 2, xn(100)),
  chroma: Yr("hcg", 1, xn(100)),
  gray: Yr("hcg", 2, xn(100)),
  white: Yr("hwb", 1, xn(100)),
  wblack: Yr("hwb", 2, xn(100)),
  cyan: Yr("cmyk", 0, xn(100)),
  magenta: Yr("cmyk", 1, xn(100)),
  yellow: Yr("cmyk", 2, xn(100)),
  black: Yr("cmyk", 3, xn(100)),
  x: Yr("xyz", 0, xn(95.047)),
  y: Yr("xyz", 1, xn(100)),
  z: Yr("xyz", 2, xn(108.833)),
  l: Yr("lab", 0, xn(100)),
  a: Yr("lab", 1),
  b: Yr("lab", 2),
  keyword(t) {
    return t !== void 0 ? new Rn(t) : aa[this.model].keyword(this.color);
  },
  hex(t) {
    return t !== void 0 ? new Rn(t) : g0.to.hex(this.rgb().round().color);
  },
  hexa(t) {
    if (t !== void 0) return new Rn(t);
    const e = this.rgb().round().color;
    let r = Math.round(this.valpha * 255)
      .toString(16)
      .toUpperCase();
    return r.length === 1 && (r = "0" + r), g0.to.hex(e) + r;
  },
  rgbNumber() {
    const t = this.rgb().color;
    return ((t[0] & 255) << 16) | ((t[1] & 255) << 8) | (t[2] & 255);
  },
  luminosity() {
    const t = this.rgb().color,
      e = [];
    for (const [r, n] of t.entries()) {
      const i = n / 255;
      e[r] = i <= 0.04045 ? i / 12.92 : ((i + 0.055) / 1.055) ** 2.4;
    }
    return 0.2126 * e[0] + 0.7152 * e[1] + 0.0722 * e[2];
  },
  contrast(t) {
    const e = this.luminosity(),
      r = t.luminosity();
    return e > r ? (e + 0.05) / (r + 0.05) : (r + 0.05) / (e + 0.05);
  },
  level(t) {
    const e = this.contrast(t);
    return e >= 7 ? "AAA" : e >= 4.5 ? "AA" : "";
  },
  isDark() {
    const t = this.rgb().color;
    return (t[0] * 2126 + t[1] * 7152 + t[2] * 722) / 1e4 < 128;
  },
  isLight() {
    return !this.isDark();
  },
  negate() {
    const t = this.rgb();
    for (let e = 0; e < 3; e++) t.color[e] = 255 - t.color[e];
    return t;
  },
  lighten(t) {
    const e = this.hsl();
    return (e.color[2] += e.color[2] * t), e;
  },
  darken(t) {
    const e = this.hsl();
    return (e.color[2] -= e.color[2] * t), e;
  },
  saturate(t) {
    const e = this.hsl();
    return (e.color[1] += e.color[1] * t), e;
  },
  desaturate(t) {
    const e = this.hsl();
    return (e.color[1] -= e.color[1] * t), e;
  },
  whiten(t) {
    const e = this.hwb();
    return (e.color[1] += e.color[1] * t), e;
  },
  blacken(t) {
    const e = this.hwb();
    return (e.color[2] += e.color[2] * t), e;
  },
  grayscale() {
    const t = this.rgb().color,
      e = t[0] * 0.3 + t[1] * 0.59 + t[2] * 0.11;
    return Rn.rgb(e, e, e);
  },
  fade(t) {
    return this.alpha(this.valpha - this.valpha * t);
  },
  opaquer(t) {
    return this.alpha(this.valpha + this.valpha * t);
  },
  rotate(t) {
    const e = this.hsl();
    let r = e.color[0];
    return (r = (r + t) % 360), (r = r < 0 ? 360 + r : r), (e.color[0] = r), e;
  },
  mix(t, e) {
    if (!t || !t.rgb)
      throw new Error(
        'Argument to "mix" was not a Color instance, but rather an instance of ' +
          typeof t
      );
    const r = t.rgb(),
      n = this.rgb(),
      i = e === void 0 ? 0.5 : e,
      a = 2 * i - 1,
      s = r.alpha() - n.alpha(),
      o = ((a * s === -1 ? a : (a + s) / (1 + a * s)) + 1) / 2,
      c = 1 - o;
    return Rn.rgb(
      o * r.red() + c * n.red(),
      o * r.green() + c * n.green(),
      o * r.blue() + c * n.blue(),
      r.alpha() * i + n.alpha() * (1 - i)
    );
  },
};
for (const t of Object.keys(aa)) {
  if (vz.includes(t)) continue;
  const { channels: e } = aa[t];
  (Rn.prototype[t] = function (...r) {
    return this.model === t
      ? new Rn(this)
      : r.length > 0
      ? new Rn(r, t)
      : new Rn([...qCe(aa[this.model][t].raw(this.color)), this.valpha], t);
  }),
    (Rn[t] = function (...r) {
      let n = r[0];
      return typeof n == "number" && (n = $4(r, e)), new Rn(n, t);
    });
}
function HCe(t, e) {
  return Number(t.toFixed(e));
}
function zCe(t) {
  return function (e) {
    return HCe(e, t);
  };
}
function Yr(t, e, r) {
  t = Array.isArray(t) ? t : [t];
  for (const n of t) (Tb[n] || (Tb[n] = []))[e] = r;
  return (
    (t = t[0]),
    function (n) {
      let i;
      return n !== void 0
        ? (r && (n = r(n)), (i = this[t]()), (i.color[e] = n), i)
        : ((i = this[t]().color[e]), r && (i = r(i)), i);
    }
  );
}
function xn(t) {
  return function (e) {
    return Math.max(0, Math.min(t, e));
  };
}
function qCe(t) {
  return Array.isArray(t) ? t : [t];
}
function $4(t, e) {
  for (let r = 0; r < e; r++) typeof t[r] != "number" && (t[r] = 0);
  return t;
}
var VCe = Rn;
const Au = mn(VCe),
  KCe = "f9e23156ccfc6173c5267eaabf320fb692ffab1c2d572095a58091cbb67590cd";
function GCe(t) {
  return {
    id: t.chainId,
    name: t.name,
    rpcUrls: t.rpc,
    nativeCurrency: {
      name: t.nativeCurrency.name,
      symbol: t.nativeCurrency.symbol,
      decimals: t.nativeCurrency.decimals,
    },
    testnet: t.testnet,
    blockExplorers: t.explorers,
  };
}
const ZCe = {
    name: "thirdweb powered dApp",
  },
  JCe = ["metamask", "walletConnect", "walletLink"],
  QCe = (t) => {
    let {
      sdkOptions: e,
      supportedChains: r = HG,
      activeChain: n,
      walletConnectors: i = JCe,
      dAppMeta: a = ZCe,
      authConfig: s,
      storageInterface: o,
      queryClient: c,
      autoConnect: u = !0,
      children: d,
      thirdwebApiKey: m = KCe,
      alchemyApiKey: v,
      infuraApiKey: E,
      desiredChainId: A,
      chainRpc: I,
    } = t;
    const b = ye.useMemo(
        () =>
          !n || typeof n == "string" || typeof n == "number" ? r : [...r, n],
        [r, n]
      ),
      w = ye.useMemo(() => {
        var k, N;
        return n
          ? typeof n == "number"
            ? n
            : typeof n == "string"
            ? (N = r.find((O) => O.slug === n)) == null
              ? void 0
              : N.chainId
            : n.chainId
          : (k = r[0]) == null
          ? void 0
          : k.chainId;
      }, [n, r]),
      S = ye.useMemo(() => {
        const k = b.map(GCe),
          N = {
            ...b.reduce((V, j) => {
              try {
                V[j.chainId] = jG(j, {
                  thirdwebApiKey: m,
                  alchemyApiKey: v,
                  infuraApiKey: E,
                });
              } catch {
                console.warn("No viable rpc url for chain: ", j.slug),
                  (V[j.chainId] = "");
              }
              return V;
            }, {}),
          },
          O = {
            name: a.name,
            url: a.url || "",
            icons: [a.logoUrl || ""],
            description: a.description || "",
          },
          F = {
            appName: a.name,
            appLogoUrl: a.logoUrl,
            darkMode: a.isDarkMode,
          };
        return {
          autoConnect: u,
          connectorStorageKey: "tw:provider:connectors",
          connectors: (V) => {
            let { chainId: j } = V;
            return i
              .map((X) => {
                if (X instanceof $v) return X;
                if (
                  (typeof X == "string" &&
                    (X === "injected" || X === "metamask")) ||
                  (typeof X == "object" &&
                    (X.name === "injected" || X.name === "metamask"))
                )
                  return new m$({
                    options:
                      typeof X == "string"
                        ? {
                            shimDisconnect: !0,
                            shimChainChangedDisconnect: !0,
                          }
                        : X.options,
                    chains: k,
                  });
                if (
                  (typeof X == "string" && X === "walletConnect") ||
                  (typeof X == "object" && X.name === "walletConnect")
                )
                  return new dTe({
                    options:
                      typeof X == "string"
                        ? {
                            chainId: j,
                            rpc: N,
                            clientMeta: O,
                            qrcode: !0,
                          }
                        : {
                            chainId: j,
                            rpc: N,
                            clientMeta: O,
                            qrcode: !0,
                            ...X.options,
                          },
                    chains: k,
                  });
                if (
                  (typeof X == "string" &&
                    (X === "coinbase" || X === "walletLink")) ||
                  (typeof X == "object" &&
                    (X.name === "coinbase" || X.name === "walletLink"))
                ) {
                  const C = N[j || 1];
                  return new y6e({
                    chains: k,
                    options:
                      typeof X == "string"
                        ? {
                            ...F,
                            jsonRpcUrl: C,
                          }
                        : {
                            ...F,
                            jsonRpcUrl: C,
                            ...X.options,
                          },
                  });
                }
                return null;
              })
              .filter((X) => X !== null);
          },
        };
      }, [
        b,
        a.name,
        a.url,
        a.logoUrl,
        a.description,
        a.isDarkMode,
        u,
        m,
        v,
        E,
        i,
      ]);
    return de.jsx(lme, {
      ...S,
      children: de.jsx(YCe, {
        queryClient: c,
        sdkOptions: e,
        supportedChains: b,
        activeChain: w || A,
        storageInterface: o,
        authConfig: s,
        thirdwebApiKey: m,
        alchemyApiKey: v,
        infuraApiKey: E,
        children: d,
      }),
    });
  },
  YCe = (t) => {
    let { children: e, ...r } = t;
    const [n] = cme();
    return de.jsx(Kpe, {
      signer: n.data,
      ...r,
      children: e,
    });
  };
function XCe(t) {
  return upe();
}
function eAe() {
  const t = EC();
  return t ? t.toLowerCase().includes("android") : !1;
}
function tAe() {
  const t = EC();
  return t
    ? t.toLowerCase().includes("ios") ||
        (t.toLowerCase().includes("mac") && navigator.maxTouchPoints > 1)
    : !1;
}
function EC() {
  const t = XCe();
  return t != null && t.os ? t.os : void 0;
}
function rAe() {
  return EC() ? eAe() || tAe() : !1;
}
function nAe() {
  var c;
  const t = qm();
  Je(t);
  const [e, r] = pTe(),
    n =
      typeof window < "u" &&
      ((c = window.ethereum) == null ? void 0 : c.isMetaMask),
    i = rAe() && !n,
    a = e.data.connectors.find((u) => u.id === "injected"),
    s = e.data.connectors.find((u) => u.id === "walletConnect"),
    o = (i ? s : a) || a;
  return (
    Je(o),
    async () => {
      if (!n) {
        const u = `https://metamask.app.link/dapp/${window.location.toString()}`;
        return (
          window.open(u, "_blank"),
          Promise.resolve({
            error: new Error("metamask not injected"),
          })
        );
      }
      return await r(o);
    }
  );
}
globalThis.Buffer = vo.Buffer;
globalThis.Buffer = vo.Buffer;
const iAe = "https://gateway.ipfscdn.io/ipfs/",
  aAe = {
    gatewayUrl: iAe,
  };
function sAe(t) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : aAe;
  if (t)
    return t.startsWith("ipfs://") ? t.replace("ipfs://", e.gatewayUrl) : t;
}
async function oAe(t) {
  if (!t) return;
  const e = GG.getType(t);
  if (e) return e;
  const r = await fetch(t, {
    method: "HEAD",
  });
  if (r.ok && r.headers.has("content-type"))
    return r.headers.get("content-type") || void 0;
}
let H5;
function cAe(t) {
  return typeof window > "u" || !t || !t.startsWith("video/")
    ? ""
    : (H5 || (H5 = document.createElement("video")), H5.canPlayType(t));
}
function lAe(t) {
  return !!cAe(t);
}
let z5;
function uAe(t) {
  return typeof window > "u" || !t || !t.startsWith("audio/")
    ? ""
    : (z5 || (z5 = document.createElement("audio")), z5.canPlayType(t));
}
function fAe(t) {
  return !!uAe(t);
}
function xz(t) {
  return (e) => {
    t.forEach((r) => {
      typeof r == "function" ? r(e) : r != null && (r.current = e);
    });
  };
}
const dAe = (t) =>
    de.jsxs("svg", {
      width: "1em",
      height: "1em",
      viewBox: "0 0 32 32",
      ...t,
      children: [
        de.jsx("circle", {
          cx: "9",
          cy: "28.5",
          r: "1.5",
          fill: "currentColor",
        }),
        de.jsx("path", {
          fill: "currentColor",
          d: "M10 25H8v-4h2a2 2 0 0 0 0-4H8a2.002 2.002 0 0 0-2 2v.5H4V19a4.005 4.005 0 0 1 4-4h2a4 4 0 0 1 0 8Z",
        }),
        de.jsx("path", {
          fill: "currentColor",
          d: "m27.7 9.3l-7-7A.908.908 0 0 0 20 2H10a2.006 2.006 0 0 0-2 2v8h2V4h8v6a2.006 2.006 0 0 0 2 2h6v16H14v2h12a2.006 2.006 0 0 0 2-2V10a.91.91 0 0 0-.3-.7ZM20 10V4.4l5.6 5.6Z",
        }),
      ],
    }),
  hAe = (t) =>
    de.jsxs("svg", {
      width: "1em",
      height: "1em",
      viewBox: "0 0 32 32",
      ...t,
      children: [
        de.jsx("path", {
          fill: "currentColor",
          d: "M29 31a.999.999 0 0 1-.625-.22L23.65 27H20a1 1 0 0 1-1-1v-5a1 1 0 0 1 1-1h3.65l4.726-3.78A1 1 0 0 1 30 17v13a1 1 0 0 1-1 1Zm-8-6h3a1 1 0 0 1 .625.22L28 27.92v-8.84l-3.376 2.7A1 1 0 0 1 24 22h-3Z",
        }),
        de.jsx("path", {
          fill: "currentColor",
          d: "M16 28H8V4h8v6a2.006 2.006 0 0 0 2 2h6v3h2v-5a.91.91 0 0 0-.3-.7l-7-7A.909.909 0 0 0 18 2H8a2.006 2.006 0 0 0-2 2v24a2.006 2.006 0 0 0 2 2h8Zm2-23.6l5.6 5.6H18Z",
        }),
      ],
    }),
  pAe = (t) =>
    de.jsx("svg", {
      width: "1em",
      height: "1em",
      viewBox: "0 0 32 32",
      ...t,
      children: de.jsx("path", {
        fill: "currentColor",
        d: "M12 6h-2a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2zm10 0h-2a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2z",
      }),
    }),
  mAe = (t) =>
    de.jsx("svg", {
      width: "1em",
      height: "1em",
      viewBox: "0 0 32 32",
      ...t,
      children: de.jsx("path", {
        fill: "currentColor",
        d: "M7 28a1 1 0 0 1-1-1V5a1 1 0 0 1 1.482-.876l20 11a1 1 0 0 1 0 1.752l-20 11A1 1 0 0 1 7 28Z",
      }),
    }),
  yAe = ye.lazy(() =>
    Zt(() => import("./ModelViewer-1ba1b804.esm-D8WMuRRE.js"), [])
  ),
  TC = (t) => {
    let { onClick: e, isPlaying: r } = t;
    const [n, i] = ye.useState(!1),
      a = () => i(!0),
      s = () => i(!1),
      o = () => i(!1),
      c = () => i(!0);
    return de.jsx("button", {
      style: {
        position: "absolute",
        bottom: 0,
        right: 0,
        transform: "translate(-25%, -25%)",
        maxWidth: "32px",
        width: "8%",
        minWidth: "24px",
        aspectRatio: "1",
        zIndex: 3,
        backgroundColor: "#fff",
        color: "rgb(138, 147, 155)",
        display: "grid",
        placeItems: "center",
        borderRadius: "50%",
        border: "1px solid rgb(229, 232, 235)",
        cursor: "pointer",
        ...(n
          ? {
              color: "rgb(53, 56, 64)",
              boxShadow: "rgb(4 17 29 / 25%) 0px 0px 8px 0px",
            }
          : {}),
      },
      onClick: e,
      onMouseEnter: a,
      onMouseLeave: s,
      onMouseDown: o,
      onMouseUp: c,
      children: r
        ? de.jsx(pAe, {
            style: {
              width: "66%",
              height: "66%",
            },
          })
        : de.jsx(mAe, {
            style: {
              width: "66%",
              height: "66%",
            },
          }),
    });
  },
  wz = ku.forwardRef((t, e) => {
    let {
      src: r,
      alt: n,
      poster: i,
      requireInteraction: a,
      style: s,
      width: o,
      height: c,
      controls: u,
      ...d
    } = t;
    const m = ye.useRef(null),
      [v, E] = ye.useState(!a),
      [A, I] = ye.useState(!0);
    return (
      ye.useEffect(() => {
        if (m.current)
          if (v)
            try {
              m.current.play();
            } catch (b) {
              console.error("error playing video", b);
            }
          else
            try {
              m.current.pause(), (m.current.currentTime = 0);
            } catch (b) {
              console.error("error pausing video", b);
            }
      }, [v]),
      de.jsxs("div", {
        style: {
          position: "relative",
          ...s,
        },
        ...d,
        children: [
          de.jsx("video", {
            ref: xz([m, e]),
            src: r ?? void 0,
            poster: i ?? void 0,
            loop: !0,
            playsInline: !0,
            controlsList: "nodownload",
            muted: A,
            preload: i ? "metadata" : "auto",
            onCanPlay: () => {
              var b;
              v && ((b = m.current) == null || b.play());
            },
            width: o,
            height: c,
            controls: u,
            style: {
              height: "100%",
              width: "100%",
              objectFit: "contain",
              zIndex: 1,
              transition: "opacity .5s",
              opacity: i ? (v ? 1 : 0) : 1,
            },
          }),
          i &&
            de.jsx("img", {
              src: i,
              style: {
                objectFit: "contain",
                pointerEvents: "none",
                position: "absolute",
                width: "100%",
                height: "100%",
                zIndex: 2,
                transition: "opacity .5s",
                opacity: v ? 0 : 1,
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
              },
              alt: n,
            }),
          de.jsx(TC, {
            onClick: () => {
              E((b) => !b), I(!1);
            },
            isPlaying: v,
          }),
        ],
      })
    );
  });
wz.displayName = "VideoPlayer";
const _z = ku.forwardRef((t, e) => {
  let { src: r, alt: n, poster: i, style: a, height: s, width: o, ...c } = t;
  const u = ye.useRef(null),
    [d, m] = ye.useState(!1),
    [v, E] = ye.useState(!0);
  return (
    ye.useEffect(() => {
      u.current &&
        (d
          ? u.current.play()
          : (u.current.pause(), (u.current.currentTime = 0)));
    }, [d]),
    de.jsxs("div", {
      style: {
        position: "relative",
        ...a,
      },
      ...c,
      children: [
        i
          ? de.jsx("img", {
              height: s,
              width: o,
              src: i,
              style: {
                height: "100%",
                width: "100%",
                pointerEvents: "none",
                objectFit: "contain",
              },
              alt: n,
            })
          : de.jsx("div", {
              style: {
                width: "100%",
                height: "100%",
                display: "grid",
                placeItems: "center",
                pointerEvents: "none",
                backgroundColor: "#fff",
                color: "rgb(138, 147, 155)",
              },
              children: de.jsx(hAe, {
                style: {
                  height: "64px",
                  width: "64px",
                },
              }),
            }),
        de.jsx(TC, {
          onClick: () => {
            m((A) => !A), E(!1);
          },
          isPlaying: d,
        }),
        de.jsx("audio", {
          ref: xz([u, e]),
          src: r ?? void 0,
          loop: !0,
          playsInline: !0,
          muted: v,
          preload: "none",
          controlsList: "nodownload",
          style: {
            position: "absolute",
            opacity: 0,
            pointerEvents: "none",
            zIndex: -1,
            visibility: "hidden",
          },
        }),
      ],
    })
  );
});
_z.displayName = "AudioPlayer";
const Ez = ku.forwardRef((t, e) => {
  let { src: r, alt: n, poster: i, requireInteraction: a, style: s, ...o } = t;
  const [c, u] = ye.useState(!a);
  return de.jsxs("div", {
    style: {
      position: "relative",
      ...s,
    },
    ...o,
    children: [
      de.jsx("iframe", {
        src: c ? r ?? void 0 : void 0,
        ref: e,
        style: {
          objectFit: "contain",
          zIndex: 1,
          height: "100%",
          width: "100%",
          transition: "opacity .5s",
          opacity: i ? (c ? 1 : 0) : 1,
        },
        sandbox: "allow-scripts",
        allow:
          "accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture",
      }),
      i &&
        de.jsx("img", {
          src: i,
          style: {
            objectFit: "contain",
            pointerEvents: "none",
            position: "absolute",
            width: "100%",
            height: "100%",
            zIndex: 2,
            transition: "opacity .5s",
            opacity: c ? 0 : 1,
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
          },
          alt: n,
        }),
      de.jsx(TC, {
        onClick: () => {
          u((d) => !d);
        },
        isPlaying: c,
      }),
    ],
  });
});
Ez.displayName = "IframePlayer";
const Tz = ku.forwardRef((t, e) => {
  let { src: r, alt: n, style: i, ...a } = t;
  return de.jsx("div", {
    style: {
      position: "relative",
      ...i,
    },
    ...a,
    children: de.jsx("div", {
      style: {
        width: "100%",
        height: "100%",
        display: "grid",
        placeItems: "center",
        backgroundColor: "#fff",
        color: "rgb(138, 147, 155)",
      },
      children: de.jsxs("div", {
        style: {
          display: "flex",
          flexDirection: "column",
          gap: "8px",
          alignItems: "center",
          flexWrap: "nowrap",
        },
        children: [
          de.jsx(dAe, {
            style: {
              maxWidth: "128px",
              minWidth: "48px",
              width: "50%",
              aspectRatio: "1",
            },
          }),
          de.jsx("a", {
            rel: "noopener noreferrer",
            style: {
              textDecoration: "underline",
              color: "rgb(138, 147, 155)",
            },
            href: r ?? void 0,
            target: "_blank",
            ref: e,
            children: n || "File",
          }),
        ],
      }),
    }),
  });
});
Tz.displayName = "LinkPlayer";
const Cz = ku.forwardRef((t, e) => {
  let {
    src: r,
    poster: n,
    alt: i,
    requireInteraction: a = !1,
    width: s = "300px",
    height: o = "300px",
    style: c,
    mimeType: u,
    ...d
  } = t;
  const m = {
      objectFit: "contain",
      width: s,
      height: o,
      ...c,
    },
    v = cR(r ?? void 0, u),
    E = cR(n ?? void 0);
  if (v.mimeType) {
    if (v.mimeType === "text/html")
      return de.jsx(Ez, {
        style: m,
        src: v.url,
        poster: E.url,
        requireInteraction: a,
        ...d,
      });
    if (v.mimeType.startsWith("model"))
      return de.jsx(ye.Suspense, {
        fallback: n
          ? de.jsx("img", {
              style: m,
              src: n,
              alt: i,
              ref: e,
              ...d,
            })
          : null,
        children: de.jsx(yAe, {
          style: m,
          src: v.url || "",
          poster: n,
          alt: i,
          ...d,
        }),
      });
    if (lAe(v.mimeType))
      return de.jsx(wz, {
        style: m,
        src: v.url,
        poster: E.url,
        requireInteraction: a,
        ...d,
      });
    if (fAe(v.mimeType))
      return de.jsx(_z, {
        style: m,
        src: v.url,
        poster: E.url,
        requireInteraction: a,
        ...d,
      });
    if (v.mimeType.startsWith("image/"))
      return de.jsx("img", {
        style: m,
        src: v.url,
        alt: i,
        ref: e,
        ...d,
      });
  } else
    return de.jsx("img", {
      style: m,
      ...d,
      ref: e,
      alt: i,
    });
  return de.jsx(Tz, {
    style: m,
    src: v.url,
    alt: i,
    ref: e,
    ...d,
  });
});
Cz.displayName = "MediaRenderer";
function cR(t, e) {
  const r = ye.useMemo(() => sAe(t), [t]),
    n = $Z(["mime-type", r], () => oAe(r), {
      enabled: !!r && !e,
      initialData: e,
    });
  return {
    url: r,
    mimeType: n.data,
  };
}
const gAe = ku.forwardRef((t, e) => {
  var o;
  let {
    metadata: r,
    width: n = "300px",
    height: i = "300px",
    style: a,
    ...s
  } = t;
  return de.jsx(Cz, {
    src: r.animation_url || r.image,
    poster: r.image,
    alt: ((o = r.name) == null ? void 0 : o.toString()) || "",
    ref: e,
    width: n,
    height: i,
    style: {
      ...a,
    },
    ...s,
  });
});
gAe.displayName = "ThirdwebNftMedia";
Ts.div``;
const bAe = gCe({
  "0%": {
    transform: "rotate(0deg)",
  },
  "100%": {
    transform: "rotate(360deg)",
  },
});
Ts.div`
  display: inline-block;
  border-top: 2px solid currentcolor;
  border-right: 2px solid currentcolor;
  border-bottom-style: solid;
  border-left-style: solid;
  border-radius: 99999px;
  border-bottom-width: 2px;
  border-left-width: 2px;
  border-bottom-color: transparent;
  border-left-color: transparent;
  animation: 0.45s linear 0s infinite normal none running ${bAe};
  width: 0.75em;
  height: 0.75em;
  flex-shrink: 0;
`;
const Az = Ts.button`
  position: relative;
  border-radius: 0.5em;
  padding: 0.75em 1.25em;
  padding-right: ${(t) => (t.hasRightElement ? "0.75em" : "1.25em")};
  padding-left: ${(t) => (t.hasLeftElement ? "0.75em" : "1.25em")};
  font-size: 1em;
  font-weight: 600;
  letter-spacing: 0.5px;
  display: flex;
  gap: 0.5em;
  align-items: center;
  color: ${(t) => kz(t.theme.colors.accent)};
  border: 2px solid
    ${(t) => U4(t.theme.colors.accent)};
  &:hover {
    cursor: pointer;
  }
  &:disabled {
    cursor: not-allowed;
  }
  &:focus {
    position: relative;
    border-radius: 0.5em;
    outline: 0;
  }
  &:focus:after {
    content: "";
    position: absolute;
    top: -5px;
    right: -5px;
    bottom: -5px;
    left: -5px;
    border: 2px solid ${(t) => t.theme.colors.accent};
    border-radius: 11px;
  }
`;
function U4(t) {
  const e = Au(t);
  return e.hex() === "#000000"
    ? "#262627"
    : e.luminosity() < 0.2
    ? e.lighten(0.1).hex()
    : e.darken(0.1).hex();
}
function q5(t) {
  const e = Au(t);
  return e.hex() === "#000000"
    ? "#262627"
    : e.luminosity() < 0.2
    ? e.lighten(0.5).hex()
    : e.darken(0.5).hex();
}
function kz(t) {
  return Au(t).isDark() ? "#fff" : "#000";
}
Ts(Az)`
  background: ${(t) => t.theme.colors.accent};
  &:hover {
    background: ${(t) => U4(t.theme.colors.accent)};
    border-color: ${(t) => U4(t.theme.colors.accent)};
  }
  &:disabled {
    background: ${(t) => q5(t.theme.colors.accent)};
    border-color: ${(t) => q5(t.theme.colors.accent)};
    color: ${(t) => kz(q5(t.theme.colors.accent))};
  }
`;
Ts(Az)`
  background: transparent;
  &:hover {
    background: ${(t) => Au(t.theme.colors.background).alpha(0.5).hexa()};
  }
`;
Ts.svg`
  border-radius: 0.25em;
  flex-shrink: 0;
  ${(t) =>
    t.boxSize
      ? `width: ${t.boxSize};
    height: ${t.boxSize};`
      : ""}
`;
Ts.li`
  display: flex;
  padding: 0.75em 1em;
  align-items: center;
  gap: 0.5em;
  font-size: 1em;

  ${(t) =>
    t.isSelectable
      ? `&:hover,
  &[data-focus] {
    cursor: pointer;
    background: ${Au(t.theme.colors.text).alpha(0.15).hexa()};
  }`
      : ""}

  > svg {
    flex-shrink: 0;
  }
`;
Ts.ul`
  padding: 0;
  margin: 0;
  background: ${(t) => t.theme.colors.background};
  color: ${(t) => t.theme.colors.text};
  list-style: none;
  border-radius: 0.5em;
  overflow: hidden;
  position: relative;
  pointer-events: auto;
  &:focus {
    outline: 0;
  }
  &:after {
    content: "";
    position: absolute;
    border: 1px solid ${(t) => t.theme.colors.accent};
    border-radius: 0.5em;
    pointer-events: none;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
  }
`;
Ts.select`
  margin: -0.25em 0;
  background: ${(t) => Au(t.theme.colors.background).alpha(0.85).hexa()};
  color: ${(t) => t.theme.colors.text};
  border: 1px solid
    ${(t) => Au(t.theme.colors.text).alpha(0.25).hexa()};
  border-radius: 0.25em;
  padding: 0.25em;
  width: 100%;
  flex-shrink: 1;
  font-size: 1em;
  &:hover {
    cursor: pointer;
  }
  &:focus {
    outline: 2px solid ${(t) => t.theme.colors.accent};
  }
  &:disabled {
    cursor: not-allowed;
  }
`;
Ve.Mainnet + "",
  Ve.Goerli + "",
  Ve.Arbitrum + "",
  Ve.ArbitrumGoerli + "",
  Ve.Avalanche + "",
  Ve.AvalancheFujiTestnet + "",
  Ve.Fantom + "",
  Ve.FantomTestnet + "",
  Ve.Optimism + "",
  Ve.OptimismGoerli + "",
  Ve.Polygon + "",
  Ve.Mumbai + "",
  Ve.BinanceSmartChainMainnet + "",
  Ve.BinanceSmartChainTestnet + "",
  Ve.Hardhat + "",
  Ve.Localhost + "";
class vAe extends Map {
  constructor(e) {
    super(),
      Object.defineProperty(this, "maxSize", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.maxSize = e);
  }
  get(e) {
    const r = super.get(e);
    return super.has(e) && r !== void 0 && (this.delete(e), super.set(e, r)), r;
  }
  set(e, r) {
    if ((super.set(e, r), this.maxSize && this.size > this.maxSize)) {
      const n = this.keys().next().value;
      n && this.delete(n);
    }
    return this;
  }
}
let V5;
function xAe() {
  return V5 || (V5 = new TextEncoder()), V5;
}
function Sz(t, e = {}) {
  return !t || typeof t != "string"
    ? !1
    : e.strict
    ? /^0x[0-9a-fA-F]*$/.test(t)
    : t.startsWith("0x");
}
function wAe(t) {
  return Sz(t, {
    strict: !1,
  })
    ? Math.ceil((t.length - 2) / 2)
    : t.length;
}
function CC(t, { size: e }) {
  const r = wAe(t);
  if (r > e) throw new Error(`Size overflow: ${r} > ${e}`);
}
const To = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102,
};
function lR(t) {
  if (t >= To.zero && t <= To.nine) return t - To.zero;
  if (t >= To.A && t <= To.F) return t - (To.A - 10);
  if (t >= To.a && t <= To.f) return t - (To.a - 10);
}
function Mz(t, e = {}) {
  const { dir: r, size: n = 32 } = e;
  if (n === null) return t;
  const i = t.replace("0x", "");
  if (i.length > n * 2)
    throw new Error(`Size overflow: ${Math.ceil(i.length / 2)} > ${n}`);
  return `0x${i[r === "right" ? "padEnd" : "padStart"](n * 2, "0")}`;
}
function _Ae(t, e = {}) {
  e.size &&
    (CC(t, {
      size: e.size,
    }),
    (t = Mz(t, {
      dir: "right",
      size: e.size,
    })));
  let r = t.slice(2);
  r.length % 2 && (r = `0${r}`);
  const n = r.length / 2,
    i = new Uint8Array(n);
  for (let a = 0, s = 0; a < n; a++) {
    const o = lR(r.charCodeAt(s++)),
      c = lR(r.charCodeAt(s++));
    if (o === void 0 || c === void 0)
      throw new Error(`Invalid hex character: ${r}`);
    i[a] = o * 16 + c;
  }
  return i;
}
const EAe = Array.from(
  {
    length: 256,
  },
  (t, e) => e.toString(16).padStart(2, "0")
);
function TAe(t, e = {}) {
  let r = "";
  for (let i = 0; i < t.length; i++) r += EAe[t[i]];
  const n = `0x${r}`;
  return typeof e.size == "number"
    ? (CC(n, {
        size: e.size,
      }),
      Mz(n, {
        dir: "right",
        size: e.size,
      }))
    : n;
}
function CAe(t, { dir: e, size: r = 32 } = {}) {
  if (r === null) return t;
  if (t.length > r) throw new Error(`Size overflow: ${t.length} > ${r}`);
  const n = new Uint8Array(r);
  for (let i = 0; i < r; i++) {
    const a = e === "right";
    n[a ? i : r - i - 1] = t[a ? i : t.length - i - 1];
  }
  return n;
}
function AAe(t, e = {}) {
  const r = xAe().encode(t);
  return typeof e.size == "number"
    ? (CC(r, {
        size: e.size,
      }),
      CAe(r, {
        dir: "right",
        size: e.size,
      }))
    : r;
}
function kAe(t) {
  return (
    t instanceof Uint8Array ||
    (t != null && typeof t == "object" && t.constructor.name === "Uint8Array")
  );
}
function Iz(t, ...e) {
  if (!kAe(t)) throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length))
    throw new Error(
      `Uint8Array expected of length ${e}, not of length=${t.length}`
    );
}
function uR(t, e = !0) {
  if (t.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && t.finished) throw new Error("Hash#digest() has already been called");
}
function SAe(t, e) {
  Iz(t);
  const r = e.outputLen;
  if (t.length < r)
    throw new Error(
      `digestInto() expects output buffer of length at least ${r}`
    );
}
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const K5 = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength),
  Is = (t, e) => (t << (32 - e)) | (t >>> e);
new Uint8Array(new Uint32Array([287454020]).buffer)[0];
function MAe(t) {
  if (typeof t != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof t}`);
  return new Uint8Array(new TextEncoder().encode(t));
}
function Rz(t) {
  return typeof t == "string" && (t = MAe(t)), Iz(t), t;
}
class IAe {
  clone() {
    return this._cloneInto();
  }
}
function RAe(t) {
  const e = (n) => t().update(Rz(n)).digest(),
    r = t();
  return (
    (e.outputLen = r.outputLen),
    (e.blockLen = r.blockLen),
    (e.create = () => t()),
    e
  );
}
function PAe(t, e, r, n) {
  if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, r, n);
  const i = BigInt(32),
    a = BigInt(4294967295),
    s = Number((r >> i) & a),
    o = Number(r & a),
    c = n ? 4 : 0,
    u = n ? 0 : 4;
  t.setUint32(e + c, s, n), t.setUint32(e + u, o, n);
}
const NAe = (t, e, r) => (t & e) ^ (~t & r),
  BAe = (t, e, r) => (t & e) ^ (t & r) ^ (e & r);
class DAe extends IAe {
  constructor(e, r, n, i) {
    super(),
      (this.blockLen = e),
      (this.outputLen = r),
      (this.padOffset = n),
      (this.isLE = i),
      (this.finished = !1),
      (this.length = 0),
      (this.pos = 0),
      (this.destroyed = !1),
      (this.buffer = new Uint8Array(e)),
      (this.view = K5(this.buffer));
  }
  update(e) {
    uR(this);
    const { view: r, buffer: n, blockLen: i } = this;
    e = Rz(e);
    const a = e.length;
    for (let s = 0; s < a; ) {
      const o = Math.min(i - this.pos, a - s);
      if (o === i) {
        const c = K5(e);
        for (; i <= a - s; s += i) this.process(c, s);
        continue;
      }
      n.set(e.subarray(s, s + o), this.pos),
        (this.pos += o),
        (s += o),
        this.pos === i && (this.process(r, 0), (this.pos = 0));
    }
    return (this.length += e.length), this.roundClean(), this;
  }
  digestInto(e) {
    uR(this), SAe(e, this), (this.finished = !0);
    const { buffer: r, view: n, blockLen: i, isLE: a } = this;
    let { pos: s } = this;
    (r[s++] = 128),
      this.buffer.subarray(s).fill(0),
      this.padOffset > i - s && (this.process(n, 0), (s = 0));
    for (let m = s; m < i; m++) r[m] = 0;
    PAe(n, i - 8, BigInt(this.length * 8), a), this.process(n, 0);
    const o = K5(e),
      c = this.outputLen;
    if (c % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u = c / 4,
      d = this.get();
    if (u > d.length) throw new Error("_sha2: outputLen bigger than state");
    for (let m = 0; m < u; m++) o.setUint32(4 * m, d[m], a);
  }
  digest() {
    const { buffer: e, outputLen: r } = this;
    this.digestInto(e);
    const n = e.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const {
      blockLen: r,
      buffer: n,
      length: i,
      finished: a,
      destroyed: s,
      pos: o,
    } = this;
    return (
      (e.length = i),
      (e.pos = o),
      (e.finished = a),
      (e.destroyed = s),
      i % r && e.buffer.set(n),
      e
    );
  }
}
const OAe = new Uint32Array([
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
    2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
    1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
    264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711,
    113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
    1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
    3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
    1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424,
    2428436474, 2756734187, 3204031479, 3329325298,
  ]),
  lc = new Uint32Array([
    1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924,
    528734635, 1541459225,
  ]),
  uc = new Uint32Array(64);
class FAe extends DAe {
  constructor() {
    super(64, 32, 8, !1),
      (this.A = lc[0] | 0),
      (this.B = lc[1] | 0),
      (this.C = lc[2] | 0),
      (this.D = lc[3] | 0),
      (this.E = lc[4] | 0),
      (this.F = lc[5] | 0),
      (this.G = lc[6] | 0),
      (this.H = lc[7] | 0);
  }
  get() {
    const { A: e, B: r, C: n, D: i, E: a, F: s, G: o, H: c } = this;
    return [e, r, n, i, a, s, o, c];
  }
  set(e, r, n, i, a, s, o, c) {
    (this.A = e | 0),
      (this.B = r | 0),
      (this.C = n | 0),
      (this.D = i | 0),
      (this.E = a | 0),
      (this.F = s | 0),
      (this.G = o | 0),
      (this.H = c | 0);
  }
  process(e, r) {
    for (let m = 0; m < 16; m++, r += 4) uc[m] = e.getUint32(r, !1);
    for (let m = 16; m < 64; m++) {
      const v = uc[m - 15],
        E = uc[m - 2],
        A = Is(v, 7) ^ Is(v, 18) ^ (v >>> 3),
        I = Is(E, 17) ^ Is(E, 19) ^ (E >>> 10);
      uc[m] = (I + uc[m - 7] + A + uc[m - 16]) | 0;
    }
    let { A: n, B: i, C: a, D: s, E: o, F: c, G: u, H: d } = this;
    for (let m = 0; m < 64; m++) {
      const v = Is(o, 6) ^ Is(o, 11) ^ Is(o, 25),
        E = (d + v + NAe(o, c, u) + OAe[m] + uc[m]) | 0,
        I = ((Is(n, 2) ^ Is(n, 13) ^ Is(n, 22)) + BAe(n, i, a)) | 0;
      (d = u),
        (u = c),
        (c = o),
        (o = (s + E) | 0),
        (s = a),
        (a = i),
        (i = n),
        (n = (E + I) | 0);
    }
    (n = (n + this.A) | 0),
      (i = (i + this.B) | 0),
      (a = (a + this.C) | 0),
      (s = (s + this.D) | 0),
      (o = (o + this.E) | 0),
      (c = (c + this.F) | 0),
      (u = (u + this.G) | 0),
      (d = (d + this.H) | 0),
      this.set(n, i, a, s, o, c, u, d);
  }
  roundClean() {
    uc.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
const LAe = RAe(() => new FAe());
function $Ae(t, e) {
  const r = LAe(
    Sz(t, {
      strict: !1,
    })
      ? _Ae(t)
      : t
  );
  return TAe(r);
}
const G5 = new vAe(4096);
function UAe(t) {
  if (G5.has(t)) return G5.get(t);
  const e = $Ae(AAe(t)).slice(2, 34);
  return G5.set(t, e), e;
}
function WAe(t) {
  return t.split(".").length === 3;
}
function jAe(t) {
  const { clientId: e, secretKey: r, ...n } = t;
  let i = e;
  if (r)
    if (WAe(r)) {
      if (!e)
        throw new Error("clientId must be provided when using a JWT secretKey");
    } else i = UAe(r);
  if (!i) throw new Error("clientId or secretKey must be provided");
  return {
    ...n,
    clientId: i,
    secretKey: r,
  };
}
const HAe = "rpc.thirdweb.com",
  zAe = "social.thirdweb.com",
  qAe = "embedded-wallet.thirdweb.com",
  VAe = "pay.thirdweb.com",
  KAe = "storage.thirdweb.com",
  GAe = "bundler.thirdweb.com";
let ZAe = {
  rpc: HAe,
  inAppWallet: qAe,
  social: zAe,
  pay: VAe,
  storage: KAe,
  bundler: GAe,
};
const JAe = () => ZAe;
function QAe(t) {
  const e = JAe().rpc;
  return {
    id: t,
    rpc: `https://${t}.${e}`,
  };
}
const Pz = ye.createContext(),
  YAe = ({ children: t }) => {
    const e = jAe({
        clientId: "6bc9de9e531c711aaf275b72ea0e74a5",
        secretKey:
          "VqRoPZ-K-6bc9de9e531c711aaf275b72ea0e74a5-cvwUPAF3EgSrw68vT4hNPfqNWTpyGOE9wGFbXwPVxfV310g",
      }),
      r = {
        client: e,
        chain: QAe(11155111),
        address: "0x293e3F16b358F14329eb10cd5cF993E2abd53D45",
      };
    let n = Gpe(),
      i = nAe();
    const a = async (d) => {
        try {
          const m = await createCampaign({
            args: [
              n,
              d.title,
              d.description,
              d.target,
              new Date(d.deadline).getTime(),
              d.image,
            ],
          });
          console.log("contract call success", m);
        } catch (m) {
          console.log("contract call failure", m);
        }
      },
      s = async () => [
        ...[
          {
            owner: "0x1234567890abcdef1234567890abcdef12345678",
            title: "Clean Water Initiative",
            description:
              "A campaign to provide clean drinking water to rural areas.",
            target: Wr("5000000000000000000"),
            deadline: 1672531199,
            amountCollected: Wr("2500000000000000000"),
            image:
              "https://png.pngtree.com/thumb_back/fw800/background/20240506/pngtree-eerily-realistic-dark-forest-nature-wallpaper-in-8k-resolution-image_15725080.jpg ",
            pId: 0,
          },
          {
            owner: "0xabcdefabcdefabcdefabcdefabcdefabcdefabcd",
            title: "School Supplies for Kids",
            description:
              "Help provide school supplies to underprivileged children.",
            target: Wr("1000000000000000000"),
            deadline: 1675123199,
            amountCollected: Wr("500000000000000000"),
            image:
              "https://png.pngtree.com/thumb_back/fw800/background/20240506/pngtree-eerily-realistic-dark-forest-nature-wallpaper-in-8k-resolution-image_15725080.jpg",
            pId: 1,
          },
          {
            owner: "0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef",
            title: "Reforestation Project",
            description:
              "A project aimed at planting 10,000 trees in deforested areas.",
            target: Wr("20000000000000000000"),
            deadline: 1677715199,
            amountCollected: Wr("15000000000000000000"),
            image:
              "https://png.pngtree.com/thumb_back/fw800/background/20240506/pngtree-eerily-realistic-dark-forest-nature-wallpaper-in-8k-resolution-image_15725080.jpg",
            pId: 2,
          },
          {
            owner: "0xbeefbeefbeefbeefbeefbeefbeefbeefbeefbeef",
            title: "Animal Shelter Support",
            description:
              "Raising funds to build a new wing for the local animal shelter.",
            target: Wr("3000000000000000000"),
            deadline: 1680307199,
            amountCollected: Wr("1000000000000000000"),
            image:
              "https://png.pngtree.com/thumb_back/fw800/background/20240506/pngtree-eerily-realistic-dark-forest-nature-wallpaper-in-8k-resolution-image_15725080.jpg",
            pId: 3,
          },
          {
            owner: "0xabcdefabcdefabcdefabcdefabcdefabcdefaaaa",
            title: "Solar Energy for Schools",
            description:
              "Help install solar panels in schools to provide sustainable energy.",
            target: Wr("10000000000000000000"),
            deadline: 1682899199,
            amountCollected: Wr("3000000000000000000"),
            image:
              "https://png.pngtree.com/thumb_back/fw800/background/20240506/pngtree-eerily-realistic-dark-forest-nature-wallpaper-in-8k-resolution-image_15725080.jpg",
            pId: 4,
          },
          {
            owner: "0xfedcba09876543210987654321fedcba09876543",
            title: "Community Library Expansion",
            description:
              "Expanding the community library with more books and learning spaces.",
            target: Wr("2000000000000000000"),
            deadline: 1685491199,
            amountCollected: Wr("1500000000000000000"),
            image:
              "https://png.pngtree.com/thumb_back/fw800/background/20240506/pngtree-eerily-realistic-dark-forest-nature-wallpaper-in-8k-resolution-image_15725080.jpg",
            pId: 5,
          },
          {
            owner: "0xabcdefabcdefabcdefabcdefabcdefabcdefaaaa",
            title: "Healthcare Access for All",
            description:
              "Supporting underprivileged communities with access to basic healthcare services.",
            target: Wr("5000000000000000000"),
            deadline: 1688083199,
            amountCollected: Wr("2000000000000000000"),
            image:
              "https://png.pngtree.com/thumb_back/fw800/background/20240506/pngtree-eerily-realistic-dark-forest-nature-wallpaper-in-8k-resolution-image_15725080.jpg",
            pId: 6,
          },
        ],
      ],
      o = async () => [
        {
          owner: "0xabcdefabcdefabcdefabcdefabcdefabcdefaaaa",
          title: "Solar Energy for Schools",
          description:
            "Help install solar panels in schools to provide sustainable energy.",
          target: Wr("10000000000000000000"),
          deadline: 1682899199,
          amountCollected: Wr("3000000000000000000"),
          image:
            "https://png.pngtree.com/thumb_back/fw800/background/20240506/pngtree-eerily-realistic-dark-forest-nature-wallpaper-in-8k-resolution-image_15725080.jpg",
          pId: 4,
        },
        {
          owner: "0xabcdefabcdefabcdefabcdefabcdefabcdefaaaa",
          title: "Healthcare Access for All",
          description:
            "Supporting underprivileged communities with access to basic healthcare services.",
          target: Wr("5000000000000000000"),
          deadline: 1688083199,
          amountCollected: Wr("2000000000000000000"),
          image:
            "https://png.pngtree.com/thumb_back/fw800/background/20240506/pngtree-eerily-realistic-dark-forest-nature-wallpaper-in-8k-resolution-image_15725080.jpg",
          pId: 6,
        },
      ],
      c = async (d, m) =>
        await r.call("donateToCampaign", [d], {
          value: lv(m),
        }),
      u = async (d) => {
        const m = await r.call("getDonators", [d]),
          v = m[0].length,
          E = [];
        for (let A = 0; A < v; A++)
          E.push({
            donator: m[0][A],
            donation: Wr(m[1][A].toString()),
          });
        return E;
      };
    return de.jsx(Pz.Provider, {
      value: {
        address: n,
        contract: r,
        connect: i,
        createCampaign: a,
        getCampaigns: s,
        getUserCampaigns: o,
        donate: c,
        getDonations: u,
      },
      children: t,
    });
  },
  C1 = () => ye.useContext(Pz),
  XAe = () => {
    const t = ld(),
      [e, r] = ye.useState("dashboard"),
      [n, i] = ye.useState(!1),
      { connect: a, address: s } = C1();
    return de.jsxs("div", {
      className:
        "flex md:flex-row flex-col-reverse justify-between mb-[35px] gap-6",
      children: [
        de.jsxs("div", {
          className:
            "lg:flex-1 flex flex-row max-w-[458px] py-2 pl-4 pr-2 h-[52px] bg-[#1c1c24] rounded-[100px]",
          children: [
            de.jsx("input", {
              type: "text",
              placeholder: "Search for campaigns",
              className:
                "flex w-full font-epilogue font-normal text-[14px] placeholder:text-[#4b5264] text-white bg-transparent outline-none",
            }),
            de.jsx("div", {
              className:
                "w-[72px] h-full rounded-[20px] bg-[#4acd8d] flex justify-center items-center cursor-pointer",
              children: de.jsx("img", {
                src: gG,
                alt: "search",
                className: "w-[15px] h-[15px] object-contain",
              }),
            }),
          ],
        }),
        de.jsxs("div", {
          className: "sm:flex hidden flex-row justify-end gap-4",
          children: [
            de.jsx(Cb, {
              btnType: "button",
              title: s ? "Create a campaign" : "Connect",
              styles: s ? "bg-[#1dc071]" : "bg-[#8c6dfd]",
              handleClick: () => {
                s ? t("create-campaign") : a();
              },
            }),
            de.jsx(DN, {
              to: "/profile",
              children: de.jsx("div", {
                className:
                  "w-[52px] h-[52px] rounded-full bg-[#2c2f32] flex justify-center items-center cursor-pointer",
                children: de.jsx("img", {
                  src: "{thirdweb}",
                  alt: "user",
                  className: "w-[60%] h-[60%] object-contain",
                }),
              }),
            }),
          ],
        }),
        de.jsxs("div", {
          className: "sm:hidden flex justify-between items-center relative",
          children: [
            de.jsx("div", {
              className:
                "w-[40px] h-[40px] rounded-[10px] bg-[#2c2f32] flex justify-center items-center cursor-pointer",
              children: de.jsx("img", {
                src: fG,
                alt: "user",
                className: "w-[60%] h-[60%] object-contain",
              }),
            }),
            de.jsx("img", {
              src: bG,
              alt: "menu",
              className: "w-[34px] h-[34px] object-contain cursor-pointer",
              onClick: () => i((o) => !o),
            }),
            de.jsxs("div", {
              className: `absolute top-[60px] right-0 left-0 bg-[#1c1c24] z-10 shadow-secondary py-4 ${
                n ? "translate-y-0" : "-translate-y-[100vh]"
              } transition-all duration-700`,
              children: [
                de.jsx("ul", {
                  className: "mb-4",
                  children: LN.map((o) =>
                    de.jsxs(
                      "li",
                      {
                        className: `flex p-4 ${e === o.name && "bg-[#3a3a43]"}`,
                        onClick: () => {
                          r(o.name), i(!1), t(o.link);
                        },
                        children: [
                          de.jsx("img", {
                            src: o.imgUrl,
                            alt: o.name,
                            className: `w-[24px] h-[24px] object-contain ${
                              e === o.name ? "grayscale-0" : "grayscale"
                            }`,
                          }),
                          de.jsx("p", {
                            className: `ml-[20px] font-epilogue font-semibold text-[14px] ${
                              e === o.name ? "text-[#1dc071]" : "text-[#808191]"
                            }`,
                            children: o.name,
                          }),
                        ],
                      },
                      o.name
                    )
                  ),
                }),
                de.jsx("div", {
                  className: "flex mx-4",
                  children: de.jsx(Cb, {
                    btnType: "button",
                    title: s ? "Create a campaign" : "Connect",
                    styles: s ? "bg-[#1dc071]" : "bg-[#8c6dfd]",
                    handleClick: () => {
                      s ? t("create-campaign") : a();
                    },
                  }),
                }),
              ],
            }),
          ],
        }),
      ],
    });
  },
  Cb = ({ btnType: t, title: e, handleClick: r, styles: n }) =>
    de.jsx("button", {
      type: t,
      className: `font-epilogue font-semibold text-[16px] leading-[26px] text-white min-h-[52px] px-4 rounded-[10px] ${n}`,
      onClick: r,
      children: e,
    }),
  Rl = ({
    labelName: t,
    placeholder: e,
    inputType: r,
    isTextArea: n,
    value: i,
    handleChange: a,
  }) =>
    de.jsxs("label", {
      className: "flex-1 w-full flex flex-col",
      children: [
        t &&
          de.jsx("span", {
            className:
              "font-epilogue font-medium text-[14px] leading-[22px] text-[#808191] mb-[10px]",
            children: t,
          }),
        n
          ? de.jsx("textarea", {
              required: !0,
              value: i,
              onChange: a,
              rows: 10,
              placeholder: e,
              className:
                "py-[15px] sm:px-[25px] px-[15px] outline-none border-[1px] border-[#3a3a43] bg-transparent font-epilogue text-white text-[14px] placeholder:text-[#4b5264] rounded-[10px] sm:min-w-[300px]",
            })
          : de.jsx("input", {
              required: !0,
              value: i,
              onChange: a,
              type: r,
              step: "0.1",
              placeholder: e,
              className:
                "py-[15px] sm:px-[25px] px-[15px] outline-none border-[1px] border-[#3a3a43] bg-transparent font-epilogue text-white text-[14px] placeholder:text-[#4b5264] rounded-[10px] sm:min-w-[300px]",
            }),
      ],
    }),
  Nz = (t) =>
    ((new Date(t).getTime() - Date.now()) / (1e3 * 3600 * 24)).toFixed(0),
  eke = (t, e) => Math.round((e * 100) / t),
  tke = (t, e) => {
    const r = new Image();
    (r.src = t),
      r.complete && e(!0),
      (r.onload = () => e(!0)),
      (r.onerror = () => e(!1));
  },
  rke = ({
    owner: t,
    title: e,
    description: r,
    target: n,
    deadline: i,
    amountCollected: a,
    image: s,
    handleClick: o,
  }) => (
    Nz(i),
    de.jsxs("div", {
      className:
        "sm:w-[288px] w-full rounded-[15px] bg-[#1c1c24] cursor-pointer",
      onClick: o,
      children: [
        de.jsx("img", {
          src: s,
          alt: "fund",
          className: "w-full h-[158px] object-cover rounded-[15px]",
        }),
        de.jsxs("div", {
          className: "flex flex-col p-4",
          children: [
            de.jsxs("div", {
              className: "flex flex-row items-center mb-[18px]",
              children: [
                de.jsx("img", {
                  src: yG,
                  alt: "tag",
                  className: "w-[17px] h-[17px] object-contain",
                }),
                de.jsx("p", {
                  className:
                    "ml-[12px] mt-[2px] font-epilogue font-medium text-[12px] text-[#808191]",
                  children: "Education",
                }),
              ],
            }),
            de.jsxs("div", {
              className: "block",
              children: [
                de.jsx("h3", {
                  className:
                    "font-epilogue font-semibold text-[16px] text-white text-left leading-[26px] truncate",
                  children: e,
                }),
                de.jsx("p", {
                  className:
                    "mt-[5px] font-epilogue font-normal text-[#808191] text-left leading-[18px] truncate",
                  children: r,
                }),
              ],
            }),
            de.jsxs("div", {
              className: "flex justify-between flex-wrap mt-[15px] gap-2",
              children: [
                de.jsxs("div", {
                  className: "flex flex-col",
                  children: [
                    de.jsx("h4", {
                      className:
                        "font-epilogue font-semibold text-[14px] text-[#b2b3bd] leading-[22px]",
                      children: a,
                    }),
                    de.jsxs("p", {
                      className:
                        "mt-[3px] font-epilogue font-normal text-[12px] leading-[18px] text-[#808191] sm:max-w-[120px] truncate",
                      children: ["Raised of ", n],
                    }),
                  ],
                }),
                de.jsxs("div", {
                  className: "flex flex-col",
                  children: [
                    de.jsx("h4", {
                      className:
                        "font-epilogue font-semibold text-[14px] text-[#b2b3bd] leading-[22px]",
                      children: 100,
                    }),
                    de.jsx("p", {
                      className:
                        "mt-[3px] font-epilogue font-normal text-[12px] leading-[18px] text-[#808191] sm:max-w-[120px] truncate",
                      children: "Days Left",
                    }),
                  ],
                }),
              ],
            }),
            de.jsxs("div", {
              className: "flex items-center mt-[20px] gap-[12px]",
              children: [
                de.jsx("div", {
                  className:
                    "w-[30px] h-[30px] rounded-full flex justify-center items-center bg-[#13131a]",
                  children: de.jsx("img", {
                    src: FN,
                    alt: "user",
                    className: "w-1/2 h-1/2 object-contain",
                  }),
                }),
                de.jsxs("p", {
                  className:
                    "flex-1 font-epilogue font-normal text-[12px] text-[#808191] truncate",
                  children: [
                    "by ",
                    de.jsx("span", {
                      className: "text-[#b2b3bd]",
                      children: t,
                    }),
                  ],
                }),
              ],
            }),
          ],
        }),
      ],
    })
  ),
  Bz = ({ title: t, isLoading: e, campaigns: r }) => {
    const n = ld(),
      i = (a) => {
        n(`/campaign-details/${a.title}`, {
          state: a,
        });
      };
    return de.jsxs("div", {
      children: [
        de.jsxs("h1", {
          className:
            "font-epilogue font-semibold text-[18px] text-white text-left",
          children: [t, " (", r.length, ")"],
        }),
        de.jsxs("div", {
          className: "flex flex-wrap mt-[20px] gap-[26px]",
          children: [
            e &&
              de.jsx("img", {
                src: ON,
                alt: "loader",
                className: "w-[100px] h-[100px] object-contain",
              }),
            !e &&
              r.length === 0 &&
              de.jsx("p", {
                className:
                  "font-epilogue font-semibold text-[14px] leading-[30px] text-[#818183]",
                children: "You have not created any campigns yet",
              }),
            !e &&
              r.length > 0 &&
              r.map((a) =>
                de.jsx(
                  rke,
                  {
                    ...a,
                    handleClick: () => i(a),
                  },
                  oB()
                )
              ),
          ],
        }),
      ],
    });
  },
  Z5 = ({ title: t, value: e }) =>
    de.jsxs("div", {
      className: "flex flex-col items-center w-[150px]",
      children: [
        de.jsx("h4", {
          className:
            "font-epilogue font-bold text-[30px] text-white p-3 bg-[#1c1c24] rounded-t-[10px] w-full text-center truncate",
          children: e,
        }),
        de.jsx("p", {
          className:
            "font-epilogue font-normal text-[16px] text-[#808191] bg-[#28282e] px-3 py-2 w-full rouned-b-[10px] text-center",
          children: t,
        }),
      ],
    }),
  Dz = () =>
    de.jsxs("div", {
      className:
        "fixed inset-0 z-10 h-screen bg-[rgba(0,0,0,0.7)] flex items-center justify-center flex-col",
      children: [
        de.jsx("img", {
          src: ON,
          alt: "loader",
          className: "w-[100px] h-[100px] object-contain",
        }),
        de.jsxs("p", {
          className:
            "mt-[20px] font-epilogue font-bold text-[20px] text-white text-center",
          children: [
            "Transaction is in progress ",
            de.jsx("br", {}),
            " Please wait...",
          ],
        }),
      ],
    }),
  nke = () => {
    const [t, e] = ye.useState(!1),
      [r, n] = ye.useState([]),
      { address: i, contract: a, getCampaigns: s } = C1(),
      o = async () => {
        e(!0);
        const c = await s();
        n(c), e(!1);
      };
    return (
      ye.useEffect(() => {
        a && o();
      }, [i, a]),
      de.jsx(Bz, {
        title: "All Campaigns",
        isLoading: t,
        campaigns: r,
      })
    );
  },
  ike = () => {
    const [t, e] = ye.useState(!1),
      [r, n] = ye.useState([]),
      { address: i, contract: a, getUserCampaigns: s } = C1(),
      o = async () => {
        e(!0);
        const c = await s();
        n(c), e(!1);
      };
    return (
      ye.useEffect(() => {
        a && o();
      }, [i, a]),
      de.jsx(Bz, {
        title: "My Campaigns",
        isLoading: t,
        campaigns: r,
      })
    );
  },
  ake = () => {
    const t = ld(),
      [e, r] = ye.useState(!1),
      { createCampaign: n } = C1(),
      [i, a] = ye.useState({
        name: "",
        title: "",
        description: "",
        target: "",
        deadline: "",
        image: "",
      }),
      s = (c, u) => {
        a({
          ...i,
          [c]: u.target.value,
        });
      },
      o = async (c) => {
        c.preventDefault(),
          tke(i.image, async (u) => {
            u
              ? (r(!0),
                await n({
                  ...i,
                  target: ya(i.target, 18),
                }),
                r(!1),
                t("/"))
              : (alert("Provide valid image URL"),
                a({
                  ...i,
                  image: "",
                }));
          });
      };
    return de.jsxs("div", {
      className:
        "bg-[#1c1c24] flex justify-center items-center flex-col rounded-[10px] sm:p-10 p-4",
      children: [
        e && de.jsx(Dz, {}),
        de.jsx("div", {
          className:
            "flex justify-center items-center p-[16px] sm:min-w-[380px] bg-[#3a3a43] rounded-[10px]",
          children: de.jsx("h1", {
            className:
              "font-epilogue font-bold sm:text-[25px] text-[18px] leading-[38px] text-white",
            children: "Start a Campaign",
          }),
        }),
        de.jsxs("form", {
          onSubmit: o,
          className: "w-full mt-[65px] flex flex-col gap-[30px]",
          children: [
            de.jsxs("div", {
              className: "flex flex-wrap gap-[40px]",
              children: [
                de.jsx(Rl, {
                  labelName: "Your Name *",
                  placeholder: "John Doe",
                  inputType: "text",
                  value: i.name,
                  handleChange: (c) => s("name", c),
                }),
                de.jsx(Rl, {
                  labelName: "Campaign Title *",
                  placeholder: "Write a title",
                  inputType: "text",
                  value: i.title,
                  handleChange: (c) => s("title", c),
                }),
              ],
            }),
            de.jsx(Rl, {
              labelName: "Story *",
              placeholder: "Write your story",
              isTextArea: !0,
              value: i.description,
              handleChange: (c) => s("description", c),
            }),
            de.jsxs("div", {
              className: "flex flex-wrap gap-[40px]",
              children: [
                de.jsx(Rl, {
                  labelName: "Goal *",
                  placeholder: "ETH 0.50",
                  inputType: "text",
                  value: i.target,
                  handleChange: (c) => s("target", c),
                }),
                de.jsx(Rl, {
                  labelName: "End Date *",
                  placeholder: "End Date",
                  inputType: "date",
                  value: i.deadline,
                  handleChange: (c) => s("deadline", c),
                }),
              ],
            }),
            de.jsxs("div", {
              className: "flex flex-wrap gap-[40px]",
              children: [
                de.jsx(Rl, {
                  labelName: "Category *",
                  placeholder: "Select the category of your campaign",
                  inputType: "",
                  value: i.image,
                  handleChange: (c) => s("image", c),
                }),
                de.jsx(Rl, {
                  labelName: "Campaign image *",
                  placeholder: "Place image URL of your campaign",
                  inputType: "url",
                  value: i.image,
                  handleChange: (c) => s("image", c),
                }),
              ],
            }),
            de.jsxs("div", {
              className:
                "w-full flex justify-start items-center p-4 bg-[#8c6dfd] h-[120px] rounded-[10px]",
              children: [
                de.jsx("img", {
                  src: vG,
                  alt: "money",
                  className: "w-[40px] h-[40px] object-contain",
                }),
                de.jsx("h4", {
                  className:
                    "font-epilogue font-bold text-[25px] text-white ml-[20px]",
                  children: "You will get 100% of the raised amount",
                }),
              ],
            }),
            de.jsx("div", {
              className: "flex justify-center items-center mt-[40px]",
              children: de.jsx(Cb, {
                btnType: "submit",
                title: "Submit new campaign",
                styles: "bg-[#1dc071]",
              }),
            }),
          ],
        }),
      ],
    });
  },
  ske = () => {
    const { state: t } = Im(),
      e = ld(),
      { donate: r, getDonations: n, contract: i, address: a } = C1(),
      [s, o] = ye.useState(!1),
      [c, u] = ye.useState(""),
      [d, m] = ye.useState([]),
      v = Nz(t.deadline),
      E = async () => {
        const I = await n(t.pId);
        m(I);
      };
    ye.useEffect(() => {
      i && E();
    }, [i, a]);
    const A = async () => {
      o(!0), await r(t.pId, c), e("/"), o(!1);
    };
    return de.jsxs("div", {
      children: [
        s && de.jsx(Dz, {}),
        de.jsxs("div", {
          className: "w-full flex md:flex-row flex-col mt-10 gap-[30px]",
          children: [
            de.jsxs("div", {
              className: "flex-1 flex-col",
              children: [
                de.jsx("img", {
                  src: t.image,
                  alt: "campaign",
                  className: "w-full h-[410px] object-cover rounded-xl",
                }),
                de.jsx("div", {
                  className: "relative w-full h-[5px] bg-[#3a3a43] mt-2",
                  children: de.jsx("div", {
                    className: "absolute h-full bg-[#4acd8d]",
                    style: {
                      width: `${eke(t.target, t.amountCollected)}%`,
                      maxWidth: "100%",
                    },
                  }),
                }),
              ],
            }),
            de.jsxs("div", {
              className:
                "flex md:w-[150px] w-full flex-wrap justify-between gap-[30px]",
              children: [
                de.jsx(Z5, {
                  title: "Days Left",
                  value: v,
                }),
                de.jsx(Z5, {
                  title: `Raised of ${t.target}`,
                  value: t.amountCollected,
                }),
                de.jsx(Z5, {
                  title: "Total Backers",
                  value: d.length,
                }),
              ],
            }),
          ],
        }),
        de.jsxs("div", {
          className: "mt-[60px] flex lg:flex-row flex-col gap-5",
          children: [
            de.jsxs("div", {
              className: "flex-[2] flex flex-col gap-[40px]",
              children: [
                de.jsxs("div", {
                  children: [
                    de.jsx("h4", {
                      className:
                        "font-epilogue font-semibold text-[18px] text-white uppercase",
                      children: "Creator",
                    }),
                    de.jsxs("div", {
                      className:
                        "mt-[20px] flex flex-row items-center flex-wrap gap-[14px]",
                      children: [
                        de.jsx("div", {
                          className:
                            "w-[52px] h-[52px] flex items-center justify-center rounded-full bg-[#2c2f32] cursor-pointer",
                          children: de.jsx("img", {
                            src: FN,
                            alt: "user",
                            className: "w-[60%] h-[60%] object-contain",
                          }),
                        }),
                        de.jsxs("div", {
                          children: [
                            de.jsx("h4", {
                              className:
                                "font-epilogue font-semibold text-[14px] text-white break-all",
                              children: t.owner,
                            }),
                            de.jsx("p", {
                              className:
                                "mt-[4px] font-epilogue font-normal text-[12px] text-[#808191]",
                              children: "10 Campaigns",
                            }),
                          ],
                        }),
                      ],
                    }),
                  ],
                }),
                de.jsxs("div", {
                  children: [
                    de.jsx("h4", {
                      className:
                        "font-epilogue font-semibold text-[18px] text-white uppercase",
                      children: "Story",
                    }),
                    de.jsx("div", {
                      className: "mt-[20px]",
                      children: de.jsx("p", {
                        className:
                          "font-epilogue font-normal text-[16px] text-[#808191] leading-[26px] text-justify",
                        children: t.description,
                      }),
                    }),
                  ],
                }),
                de.jsxs("div", {
                  children: [
                    de.jsx("h4", {
                      className:
                        "font-epilogue font-semibold text-[18px] text-white uppercase",
                      children: "Donators",
                    }),
                    de.jsx("div", {
                      className: "mt-[20px] flex flex-col gap-4",
                      children:
                        d.length > 0
                          ? d.map((I, b) =>
                              de.jsxs(
                                "div",
                                {
                                  className:
                                    "flex justify-between items-center gap-4",
                                  children: [
                                    de.jsxs("p", {
                                      className:
                                        "font-epilogue font-normal text-[16px] text-[#b2b3bd] leading-[26px] break-ll",
                                      children: [b + 1, ". ", I.donator],
                                    }),
                                    de.jsx("p", {
                                      className:
                                        "font-epilogue font-normal text-[16px] text-[#808191] leading-[26px] break-ll",
                                      children: I.donation,
                                    }),
                                  ],
                                },
                                `${I.donator}-${b}`
                              )
                            )
                          : de.jsx("p", {
                              className:
                                "font-epilogue font-normal text-[16px] text-[#808191] leading-[26px] text-justify",
                              children: "No donators yet. Be the first one!",
                            }),
                    }),
                  ],
                }),
              ],
            }),
            de.jsxs("div", {
              className: "flex-1",
              children: [
                de.jsx("h4", {
                  className:
                    "font-epilogue font-semibold text-[18px] text-white uppercase",
                  children: "Fund",
                }),
                de.jsxs("div", {
                  className:
                    "mt-[20px] flex flex-col p-4 bg-[#1c1c24] rounded-[10px]",
                  children: [
                    de.jsx("p", {
                      className:
                        "font-epilogue fount-medium text-[20px] leading-[30px] text-center text-[#808191]",
                      children: "Fund the campaign",
                    }),
                    de.jsxs("div", {
                      className: "mt-[30px]",
                      children: [
                        de.jsx("input", {
                          type: "number",
                          placeholder: "ETH 0.1",
                          step: "0.01",
                          className:
                            "w-full py-[10px] sm:px-[20px] px-[15px] outline-none border-[1px] border-[#3a3a43] bg-transparent font-epilogue text-white text-[18px] leading-[30px] placeholder:text-[#4b5264] rounded-[10px]",
                          value: c,
                          onChange: (I) => u(I.target.value),
                        }),
                        de.jsxs("div", {
                          className:
                            "my-[20px] p-4 bg-[#13131a] rounded-[10px]",
                          children: [
                            de.jsx("h4", {
                              className:
                                "font-epilogue font-semibold text-[14px] leading-[22px] text-white",
                              children: "Back it because you believe in it.",
                            }),
                            de.jsx("p", {
                              className:
                                "mt-[20px] font-epilogue font-normal leading-[22px] text-[#808191]",
                              children:
                                "Support the project for no reward, just because it speaks to you.",
                            }),
                          ],
                        }),
                        de.jsx(Cb, {
                          btnType: "button",
                          title: "Fund Campaign",
                          styles: "w-full bg-[#8c6dfd]",
                          handleClick: A,
                        }),
                      ],
                    }),
                  ],
                }),
              ],
            }),
          ],
        }),
      ],
    });
  },
  oke = () =>
    de.jsxs("div", {
      className: "relative sm:-8 p-4 bg-[#13131a] min-h-screen flex flex-row",
      children: [
        de.jsx("div", {
          className: "sm:flex hidden mr-10 relative",
          children: de.jsx(xG, {}),
        }),
        de.jsxs("div", {
          className: "flex-1 max-sm:w-full max-w-[1280px] mx-auto sm:pr-5",
          children: [
            de.jsx(XAe, {}),
            de.jsxs(YK, {
              children: [
                de.jsx(yh, {
                  path: "/",
                  element: de.jsx(nke, {}),
                }),
                de.jsx(yh, {
                  path: "/profile",
                  element: de.jsx(ike, {}),
                }),
                de.jsx(yh, {
                  path: "/create-campaign",
                  element: de.jsx(ake, {}),
                }),
                de.jsx(yh, {
                  path: "/campaign-details/:id",
                  element: de.jsx(ske, {}),
                }),
              ],
            }),
          ],
        }),
      ],
    });
var cke = {};
console.log("11155111");
EN(document.getElementById("root")).render(
  de.jsx(QCe, {
    chainId: cke.CHAIN_ID,
    children: de.jsx(aG, {
      children: de.jsx(YAe, {
        children: de.jsx(oke, {}),
      }),
    }),
  })
);
export {
  sL as $,
  Gt as A,
  ae as B,
  Gn as C,
  $0e as D,
  pde as E,
  hs as F,
  Pv as G,
  Iv as H,
  yde as I,
  Yt as J,
  yv as K,
  gke as L,
  kv as M,
  Td as N,
  Sv as O,
  yn as P,
  ti as Q,
  ku as R,
  zm as S,
  ze as T,
  nl as U,
  wke as V,
  bke as W,
  da as X,
  yke as Y,
  G3 as Z,
  $L as _,
  Q0 as a,
  d2 as a0,
  Hh as a1,
  et as a2,
  $2 as a3,
  U2 as a4,
  W2 as a5,
  Qe as a6,
  gde as a7,
  vde as a8,
  wde as a9,
  G0e as aA,
  $de as aB,
  Nde as aC,
  Q0e as aD,
  Ufe as aE,
  ofe as aF,
  ui as aG,
  CD as aH,
  ls as aI,
  Ude as aa,
  Ode as ab,
  qE as ac,
  efe as ad,
  ide as ae,
  WE as af,
  RL as ag,
  CL as ah,
  b2 as ai,
  Lde as aj,
  j7 as ak,
  z0e as al,
  ne as am,
  uv as an,
  Tn as ao,
  Ev as ap,
  ble as aq,
  mke as ar,
  Ri as as,
  jfe as at,
  Gi as au,
  wr as av,
  mde as aw,
  Ve as ax,
  ade as ay,
  Fde as az,
  t9 as b,
  Efe as c,
  Tfe as d,
  Cfe as e,
  Bfe as f,
  Df as g,
  Sr as h,
  _de as i,
  de as j,
  Rv as k,
  Cde as l,
  ah as m,
  Ft as n,
  be as o,
  nfe as p,
  Je as q,
  ud as r,
  Se as s,
  xke as t,
  ab as u,
  vke as v,
  pi as w,
  Z_ as x,
  mo as y,
  al as z,
};
